import warnings
import pandas as pd
import six
import inspect
from functools import wraps, lru_cache

import rqdatac

try:
    from collections.abc import Iterable
except ImportError:
    from collections import Iterable


def hk_to_unique_id(ids):
    from rqdatac.services.basic import hk_all_unique_id_to_order_book_id

    all_unique_ids = hk_all_unique_id_to_order_book_id()
    reverse_map = {}
    if isinstance(ids, six.string_types):
        if ids not in all_unique_ids:
            insts = rqdatac.instruments(ids, market="hk")
            if insts is not None:
                reverse_map[insts.unique_id] = insts.order_book_id
                return insts.unique_id, reverse_map
            else:
                return ids, reverse_map
        else:
            return ids, reverse_map
    elif isinstance(ids, Iterable):
        result = []
        for i in ids:
            if i not in all_unique_ids:
                insts = rqdatac.instruments(i, market="hk")
                if insts is not None:
                    reverse_map[insts.unique_id] = insts.order_book_id
                    result.append(insts.unique_id)
                else:
                    # We can almost make sure that the input id `i` is not valid
                    # but we still append it to result, because the upper level decorator
                    # should not eat any passing parameters.
                    result.append(i)
            else:
                result.append(i)
        return result, reverse_map
    else:
        raise ValueError("ids should be str or iterator")


def _convert_multi_index_dataframe(result, reverse_map):
    for level_index, level_name in enumerate(result.index.names):
        if level_name == "order_book_id":
            result.index = result.index.set_levels(
                [reverse_map.get(i, i) for i in result.index.levels[level_index]],
                level=level_index,
            )
            break
    return result


def _convert_dataframe(result, reverse_map):
    if result.empty:
        return result
    if "order_book_id" in result.columns:
        result["order_book_id"] = [
            reverse_map.get(i, i) for i in result["order_book_id"]
        ]
    elif result.index.name == "order_book_id":
        result.index = [reverse_map.get(i, i) for i in result.index]
        result.index.name = "order_book_id"
    elif isinstance(result.columns[0], str):  # check if columns are order_book_ids.
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            first_column = result.columns[0]
            first_column = reverse_map.get(first_column, first_column)
            insts = rqdatac.instruments(first_column, market="hk")
            if insts is not None:
                name = result.colunms.name
                result.columns = [reverse_map.get(i, i) for i in result.columns]
                result.columns.name = name
    return result


def _convert_series(result, reverse_map):
    if result.index.name == "order_book_id":
        result.index = [reverse_map.get(i, i) for i in result.index]
        result.index.name = "order_book_id"
    return result


def mapping_back_to_order_book_id(result, reverse_map):
    """Converts order_book_id fields in `reuslt`.  The result are generated by rqdatac calls"""
    # the result of rqdatac call can be the following:
    # 1. DataFrame, which have `order_book_id` as index
    # 2. Series, which have `order_book_id` as index
    # 3. List of order_book_ids
    # 4. List of instruments
    # 5. something that doesn't include id info.
    if isinstance(result, (pd.DataFrame, pd.Series)) and isinstance(
        result.index, pd.MultiIndex
    ):
        return _convert_multi_index_dataframe(result, reverse_map)
    elif isinstance(result, pd.DataFrame):
        return _convert_dataframe(result, reverse_map)
    elif isinstance(result, pd.Series):
        return _convert_series(result, reverse_map)
    elif isinstance(result, list):
        return [reverse_map.get(i, i) for i in result]
    return result


@lru_cache(None)
def get_signature(func):
    wrapped_f = func
    while True:
        new_wrapped = getattr(wrapped_f, "__wrapped__", None)
        if new_wrapped is not None and new_wrapped != wrapped_f:
            wrapped_f = new_wrapped
        else:
            break
    return inspect.signature(func)


def support_hk_order_book_id(f):
    """main decorator to make rqdatac function supports hk order book id as input."""

    @wraps(f)
    def wrapped(*args, **kwargs):
        # get order_book_id argument
        sig = get_signature(f)
        call_info = sig.bind(*args, **kwargs)
        call_info.apply_defaults()
        # after `apply_defaults`, all arg information are available through `call_info.arguments`
        # as a dict.
        arguments: dict = call_info.arguments
        # if there is something in kwargs, should flatten it into arguments.
        if "kwargs" in arguments:
            for k, v in arguments.pop("kwargs").items():
                arguments[k] = v
        # A fast call if user doesn't call for `hk` data.
        if arguments.get("market", None) != "hk":
            return f(*args, **kwargs)

        reverse_map = {}
        for k in ("order_book_id", "order_book_ids", "indexes"):
            if k in arguments:
                arguments[k], reverse_map = hk_to_unique_id(arguments[k])
                break
        result = f(**arguments)
        if reverse_map and f.__name__ != "get_trading_hours":
            return mapping_back_to_order_book_id(result, reverse_map)
        else:
            return result

    return wrapped
