<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Class and Function Documentation</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
    }
    .toc {
      margin-bottom: 30px;
      padding: 10px;
      background-color: #f2f2f2;
      border: 1px solid #ccc;
    }
    .toc h2 {
      margin-top: 0;
    }
    .toc-table {
      width: 100%;
      border-collapse: collapse;
    }
    .toc-table th, .toc-table td {
      padding: 5px;
      text-align: left;
      vertical-align: top;
      border-bottom: 1px solid #ddd;
    }
    .toc-table th {
      font-weight: bold;
      background-color: #e5e5e5;
    }
    .toc-package {
      font-weight: bold;
      font-size: 1.2em;
      background-color: #f0f0f0;
      padding: 6px 3px;
    }
    .toc-name {
      width: 25%;
    }
    .toc-talkpipe {
      width: 25%;
      color: #0056b3;
      font-style: italic;
    }
    .toc-description {
      width: 50%;
    }
    .package-header {
      margin-top: 40px;
      margin-bottom: 10px;
      padding: 5px 0;
      border-bottom: 2px solid #aaa;
      font-size: 1.4em;
      font-weight: bold;
      color: #444;
    }
    .class, .function {
      margin: 20px 0;
      padding: 10px;
      border: 1px solid #ddd;
      background-color: #f9f9f9;
    }
    .function {
      background-color: #f9f9f9;
    }
    h2 {
      color: #333;
      margin-bottom: 5px;
    }
    .talkpipe-name {
      font-weight: bold;
      color: #007bff;
    }
    .param-list {
      margin: 5px 0;
      padding-left: 20px;
    }
    .param-list li {
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Class and Function Documentation</h1>
    <div class="toc">
      <h2>Table of Contents</h2>
      <table class="toc-table">
        <thead>
          <tr>
            <th class="toc-name">Name</th>
            <th class="toc-talkpipe">Chatterlang Name</th>
            <th class="toc-description">Description</th>
          </tr>
        </thead>
        <tbody>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-app-chatterlang_serve">talkpipe.app.chatterlang_serve</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-app-chatterlang_serve-ChatterlangServerSegment">ChatterlangServerSegment</a></td>
  <td class="toc-talkpipe">chatterlangServer</td>
  <td class="toc-description">Segment for receiving JSON data via FastAPI with configurable form</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-chatterlang-compiler">talkpipe.chatterlang.compiler</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-chatterlang-compiler-Accum">Accum</a></td>
  <td class="toc-talkpipe">accum</td>
  <td class="toc-description">Accumulates items from the input stream both in an internal buffer and in the specified variable.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-chatterlang-compiler-Snippet">Snippet</a></td>
  <td class="toc-talkpipe">snippet</td>
  <td class="toc-description">A segment that loads a chatterlang script from a file and compiles it, after which it</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-data-email">talkpipe.data.email</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-email-readEmail">readEmail</a></td>
  <td class="toc-talkpipe">readEmail</td>
  <td class="toc-description">A source that monitors an email inbox and yields new unread emails.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-email-sendEmail">sendEmail</a></td>
  <td class="toc-talkpipe">sendEmail</td>
  <td class="toc-description">Send emails for each item in the input iterable using SMTP.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-data-extraction">talkpipe.data.extraction</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-extraction-FileExtractor">FileExtractor</a></td>
  <td class="toc-talkpipe">extract</td>
  <td class="toc-description">A class for extracting text content from different file types.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-extraction-listFiles">listFiles</a></td>
  <td class="toc-talkpipe">listFiles</td>
  <td class="toc-description">Lists files matching given patterns (potentially with wildcards) and yields their paths.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-extraction-readdocx">readdocx</a></td>
  <td class="toc-talkpipe">readdocx</td>
  <td class="toc-description">Read and extract text from Microsoft Word (.docx) files.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-extraction-readtxt">readtxt</a></td>
  <td class="toc-talkpipe">readtxt</td>
  <td class="toc-description">Reads text files from given file paths or directories and yields their contents.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-data-html">talkpipe.data.html</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-html-downloadURLSegment">downloadURLSegment</a></td>
  <td class="toc-talkpipe">downloadURL</td>
  <td class="toc-description">Download a URL segment and return its content.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-html-htmlToTextSegment">htmlToTextSegment</a></td>
  <td class="toc-talkpipe">htmlToText</td>
  <td class="toc-description">Converts HTML content to text segment.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-data-mongo">talkpipe.data.mongo</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-mongo-MongoInsert">MongoInsert</a></td>
  <td class="toc-talkpipe">mongoInsert</td>
  <td class="toc-description">Insert items from the input stream into a MongoDB collection.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-mongo-MongoSearch">MongoSearch</a></td>
  <td class="toc-talkpipe">mongoSearch</td>
  <td class="toc-description">Search a MongoDB collection and yield results.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-data-rss">talkpipe.data.rss</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-data-rss-rss_source">rss_source</a></td>
  <td class="toc-talkpipe">rss</td>
  <td class="toc-description">Generator function that monitors and yields new entries from an RSS feed.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-llm-chat">talkpipe.llm.chat</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-llm-chat-LlmExtractTerms">LlmExtractTerms</a></td>
  <td class="toc-talkpipe">llmExtractTerms</td>
  <td class="toc-description">For each piece of text read from the input stream, extract terms from the text.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-llm-chat-LLMPrompt">LLMPrompt</a></td>
  <td class="toc-talkpipe">llmPrompt</td>
  <td class="toc-description">Interactive, optionally multi-turn, chat with an llm.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-llm-chat-LlmScore">LlmScore</a></td>
  <td class="toc-talkpipe">llmScore</td>
  <td class="toc-description">For each piece of text read from the input stream, compute a score and an explanation for that score.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-llm-embedding">talkpipe.llm.embedding</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-llm-embedding-LLMEmbed">LLMEmbed</a></td>
  <td class="toc-talkpipe">llmEmbed</td>
  <td class="toc-description">Read strings from the input stream and emit an embedding for each string using a language model.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-operations-filtering">talkpipe.operations.filtering</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-operations-filtering-distinctBloomFilter">distinctBloomFilter</a></td>
  <td class="toc-talkpipe">distinctBloomFilter</td>
  <td class="toc-description">Filter items using a Bloom Filter to yield only distinct elements based on specified fields.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-operations-matrices">talkpipe.operations.matrices</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-operations-matrices-ReduceTSNE">ReduceTSNE</a></td>
  <td class="toc-talkpipe">reduceTSNE</td>
  <td class="toc-description">Use t-SNE to reduce dimensionality of provided matrix.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-operations-matrices-ReduceUMAP">ReduceUMAP</a></td>
  <td class="toc-talkpipe">reduceUMAP</td>
  <td class="toc-description">Use UMAP to reduce dimensionality of provided matrix.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-operations-signatures">talkpipe.operations.signatures</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-operations-signatures-SignSegment">SignSegment</a></td>
  <td class="toc-talkpipe">sign</td>
  <td class="toc-description">Sign items using a private key.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-operations-signatures-VerifySegment">VerifySegment</a></td>
  <td class="toc-talkpipe">verify</td>
  <td class="toc-description">Verify signatures on items using a public key.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-operations-thread_ops">talkpipe.operations.thread_ops</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-operations-thread_ops-threadedSegment">threadedSegment</a></td>
  <td class="toc-talkpipe">threaded</td>
  <td class="toc-description">Links the input stream to a threaded queue system.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-operations-transforms">talkpipe.operations.transforms</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-operations-transforms-fill_null">fill_null</a></td>
  <td class="toc-talkpipe">fillNull</td>
  <td class="toc-description">Fills null (None) values in a sequence of dictionaries with specified defaults.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-operations-transforms-MakeLists">MakeLists</a></td>
  <td class="toc-talkpipe">makeLists</td>
  <td class="toc-description"></td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-operations-transforms-regex_replace">regex_replace</a></td>
  <td class="toc-talkpipe">regexReplace</td>
  <td class="toc-description">Transform items by applying regex pattern replacement.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-pipe-basic">talkpipe.pipe.basic</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-appendAs">appendAs</a></td>
  <td class="toc-talkpipe">appendAs</td>
  <td class="toc-description">Appends the specified fields to the input item.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-Cast">Cast</a></td>
  <td class="toc-talkpipe">cast</td>
  <td class="toc-description">Casts the input data to a specified type.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-concat">concat</a></td>
  <td class="toc-talkpipe">concat</td>
  <td class="toc-description">Concatenates specified fields from each item with a delimiter.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-ConfigureLogger">ConfigureLogger</a></td>
  <td class="toc-talkpipe">configureLogger</td>
  <td class="toc-description">Configures loggers based on the provided logger levels and files.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-copy_segment">copy_segment</a></td>
  <td class="toc-talkpipe">copy</td>
  <td class="toc-description">A segment that creates a shallow copy of each item in the input iterable.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-deep_copy_segment">deep_copy_segment</a></td>
  <td class="toc-talkpipe">deepCopy</td>
  <td class="toc-description">A segment that creates a deep copy of each item in the input iterable.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-DescribeData">DescribeData</a></td>
  <td class="toc-talkpipe">describe</td>
  <td class="toc-description">Returns a dictionary of all attributes of the input data.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-EvalExpression">EvalExpression</a></td>
  <td class="toc-talkpipe">lambda</td>
  <td class="toc-description">Evaluate a Python expression on each item in the input stream.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-everyN">everyN</a></td>
  <td class="toc-talkpipe">everyN</td>
  <td class="toc-description">Yields every nth item from the input stream.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-exec">exec</a></td>
  <td class="toc-talkpipe">exec</td>
  <td class="toc-description">Execute a shell command and yield each line from stdout as a data item.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-fillTemplate">fillTemplate</a></td>
  <td class="toc-talkpipe">fillTemplate</td>
  <td class="toc-description">Fill a template string with values from the input item.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-FilterExpression">FilterExpression</a></td>
  <td class="toc-talkpipe">lambdaFilter</td>
  <td class="toc-description">Filter items from the input stream based on a Python expression.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-firstN">firstN</a></td>
  <td class="toc-talkpipe">firstN</td>
  <td class="toc-description">Yields the first n items from the input stream.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-flatten">flatten</a></td>
  <td class="toc-talkpipe">flatten</td>
  <td class="toc-description">Flattens a nested list of items.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-FormattedItem">FormattedItem</a></td>
  <td class="toc-talkpipe">formatItem</td>
  <td class="toc-description">Generate formatted output for specified fields in &quot;Property: Value&quot; format.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-Hash">Hash</a></td>
  <td class="toc-talkpipe">hash</td>
  <td class="toc-description">Hashes the input data using the specified algorithm.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-isIn">isIn</a></td>
  <td class="toc-talkpipe">isIn</td>
  <td class="toc-description">Filters items based on whether a field contains a specified value.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-isNotIn">isNotIn</a></td>
  <td class="toc-talkpipe">isNotIn</td>
  <td class="toc-description">Filters items based on whether a field does not contain a specified value.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-longestStr">longestStr</a></td>
  <td class="toc-talkpipe">longestStr</td>
  <td class="toc-description">Finds the longest string among specified fields in the input item.  If</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-progressTicks">progressTicks</a></td>
  <td class="toc-talkpipe">progressTicks</td>
  <td class="toc-description">Display progress indicators while processing items in the pipeline.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-sleep">sleep</a></td>
  <td class="toc-talkpipe">sleep</td>
  <td class="toc-description">Sleep for a specified number of seconds between processing each item.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-slice">slice</a></td>
  <td class="toc-talkpipe">slice</td>
  <td class="toc-description">Slices a sequence using start and end indices.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-ToDataFrame">ToDataFrame</a></td>
  <td class="toc-talkpipe">toDataFrame</td>
  <td class="toc-description">Drain all items from the input stream and emit a single DataFrame.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-ToDict">ToDict</a></td>
  <td class="toc-talkpipe">toDict</td>
  <td class="toc-description">Creates a dictionary from the input data.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-basic-ToList">ToList</a></td>
  <td class="toc-talkpipe">toList</td>
  <td class="toc-description">Drains the input stream and emits a list of all items.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-pipe-io">talkpipe.pipe.io</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-io-dumpsJsonl">dumpsJsonl</a></td>
  <td class="toc-talkpipe">dumpsJsonl</td>
  <td class="toc-description">Drains the input stream and dumps each item as a jsonl string.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-io-echo">echo</a></td>
  <td class="toc-talkpipe">echo</td>
  <td class="toc-description">A source that generates input from a string.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-io-loadsJsonl">loadsJsonl</a></td>
  <td class="toc-talkpipe">loadsJsonl</td>
  <td class="toc-description">Reads each item from the input stream, interpreting it as a jsonl string.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-io-Log">Log</a></td>
  <td class="toc-talkpipe">log</td>
  <td class="toc-description">An operation that logs each item from the input stream.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-io-Print">Print</a></td>
  <td class="toc-talkpipe">print</td>
  <td class="toc-description">An operation prints and passes on each item from the input stream.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-io-Prompt">Prompt</a></td>
  <td class="toc-talkpipe">prompt</td>
  <td class="toc-description">A source that generates input from a prompt.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-io-readJsonl">readJsonl</a></td>
  <td class="toc-talkpipe">readJsonl</td>
  <td class="toc-description">Reads each item from the input stream as a path to a jsonl file. Loads each line of</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-io-writePickle">writePickle</a></td>
  <td class="toc-talkpipe">writePickle</td>
  <td class="toc-description">Writes each item into a pickle file. If first_only is True, only the first item is written.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-io-writeString">writeString</a></td>
  <td class="toc-talkpipe">writeString</td>
  <td class="toc-description">Writes each item into a files after casting it to a string.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-pipe-math">talkpipe.pipe.math</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-math-arange">arange</a></td>
  <td class="toc-talkpipe">range</td>
  <td class="toc-description">Generate a range of integers between lower (inclusive) and upper (exclusive)</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-math-eq">eq</a></td>
  <td class="toc-talkpipe">eq</td>
  <td class="toc-description">Filter items where a specified field&#x27;s value equals a number.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-math-gt">gt</a></td>
  <td class="toc-talkpipe">gt</td>
  <td class="toc-description">Filter items where a specified field&#x27;s value is greater than a number.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-math-gte">gte</a></td>
  <td class="toc-talkpipe">gte</td>
  <td class="toc-description">Filter items where a specified field&#x27;s value is greater than or equal to a number.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-math-lt">lt</a></td>
  <td class="toc-talkpipe">lt</td>
  <td class="toc-description">Filters items based on a field value being less than a specified number.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-math-lte">lte</a></td>
  <td class="toc-talkpipe">lte</td>
  <td class="toc-description">Filter items where a specified field&#x27;s value is less than or equal to a number.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-math-neq">neq</a></td>
  <td class="toc-talkpipe">neq</td>
  <td class="toc-description">Filter items where a specified field&#x27;s value does not equal a number.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-math-randomInts">randomInts</a></td>
  <td class="toc-talkpipe">randomInts</td>
  <td class="toc-description">Generate n random integers between lower and upper.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-pipe-math-scale">scale</a></td>
  <td class="toc-talkpipe">scale</td>
  <td class="toc-description">Scale each item in the input stream by the multiplier.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-search-simplevectordb">talkpipe.search.simplevectordb</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-search-simplevectordb-add_vector">add_vector</a></td>
  <td class="toc-talkpipe">addVector</td>
  <td class="toc-description">Segment to add a vector to the SimpleVectorDB.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-search-simplevectordb-search_vector">search_vector</a></td>
  <td class="toc-talkpipe">searchVector</td>
  <td class="toc-description">Segment to search for similar vectors in the SimpleVectorDB.</td>
</tr>
<tr><td class="toc-package" colspan="3"><a href="#talkpipe-search-whoosh">talkpipe.search.whoosh</a></td></tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-search-whoosh-indexWhoosh">indexWhoosh</a></td>
  <td class="toc-talkpipe">indexWhoosh</td>
  <td class="toc-description">Index documents using Whoosh full-text indexing.</td>
</tr>
<tr>
  <td class="toc-name"><a href="#talkpipe-search-whoosh-searchWhoosh">searchWhoosh</a></td>
  <td class="toc-talkpipe">searchWhoosh</td>
  <td class="toc-description">Search documents using Whoosh full-text indexing.</td>
</tr>
        </tbody>
      </table>
    </div>
<div class="package-header" id="talkpipe-app-chatterlang_serve">talkpipe.app.chatterlang_serve</div>
<div class="class" id="talkpipe-app-chatterlang_serve-ChatterlangServerSegment">
  <h2>Source Class: ChatterlangServerSegment</h2>
  <p class="talkpipe-name">Chatterlang Name: chatterlangServer</p>
  <div><pre>Segment for receiving JSON data via FastAPI with configurable form</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>port: Union[int, str] = 9999</li>
    <li>host: str = &#x27;0.0.0.0&#x27;</li>
    <li>api_key: str = None</li>
    <li>require_auth: bool = False</li>
    <li>form_config: Union[str, Dict[str, Any]] = None</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSource</p>
</div>
<div class="package-header" id="talkpipe-chatterlang-compiler">talkpipe.chatterlang.compiler</div>
<div class="class" id="talkpipe-chatterlang-compiler-Accum">
  <h2>Segment Class: Accum</h2>
  <p class="talkpipe-name">Chatterlang Name: accum</p>
  <div><pre>Accumulates items from the input stream both in an internal buffer and in the specified variable.  
This is useful for accumulating the results of running the pipeline multiple times.     

Args:
    variable (Union[VariableName, str], optional): The name of the variable to store the accumulated data in. Defaults to None.
    reset (bool, optional): Whether to reset the accumulator each time the segment is run. Defaults to True.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>variable: Union[VariableName, str] = None</li>
    <li>reset: bool = True</li>
  </ul>
  <p><strong>Base Classes:</strong> io.AbstractSegment</p>
</div>
<div class="class" id="talkpipe-chatterlang-compiler-Snippet">
  <h2>Segment Class: Snippet</h2>
  <p class="talkpipe-name">Chatterlang Name: snippet</p>
  <div><pre>A segment that loads a chatterlang script from a file and compiles it, after which it
functions as a normal segment that can be integrated into a pipeline.

Args:
    file (str): The path to the chatterlang script file.
    runtime (RuntimeComponent, optional): The runtime component to use. Defaults to None.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>script_source: str</li>
  </ul>
  <p><strong>Base Classes:</strong> io.AbstractSegment</p>
</div>
<div class="package-header" id="talkpipe-data-email">talkpipe.data.email</div>
<div class="function" id="talkpipe-data-email-readEmail">
  <h2>Source Function: readEmail</h2>
  <p class="talkpipe-name">Chatterlang Name: readEmail</p>
  <div><pre>A source that monitors an email inbox and yields new unread emails.

This source periodically checks for new unread emails, marks them as read,
and yields their content and metadata. It connects using IMAP and can be
configured to poll at specific intervals.

Args:
    poll_interval_minutes (int, optional): Minutes between email checks. Defaults to 10.
    folder (str, optional): Mailbox folder to check. Defaults to 'INBOX'.
    mark_as_read (bool, optional): Whether to mark emails as read. Defaults to True.
    limit (int, optional): Maximum number of emails to fetch per check. Defaults to 100. 
        if -1, fetch all.
    imap_server (str, optional): IMAP server address. If None, uses config.
    email_address (str, optional): Email address. If None, uses config.
    password (str, optional): Password. If None, uses config.
    
Yields:
    dict: Email metadata and content including:
        - message_id: Unique message ID
        - subject: Email subject
        - from: Sender address
        - to: Recipient address(es)
        - cc: CC address(es)
        - date: Datetime object of when email was sent
        - date_str: Date string from email header
        - plain_text: Plain text content if available
        - html_content: HTML content if available
        - headers: Dictionary of all email headers
        - raw_email: Full raw email content</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>poll_interval_minutes = 10</li>
    <li>folder = &#x27;INBOX&#x27;</li>
    <li>mark_as_read = True</li>
    <li>limit = 100</li>
    <li>unseen_only = True</li>
    <li>imap_server = None</li>
    <li>email_address = None</li>
    <li>password = None</li>
  </ul>
</div>
<div class="function" id="talkpipe-data-email-sendEmail">
  <h2>Segment Function: sendEmail</h2>
  <p class="talkpipe-name">Chatterlang Name: sendEmail</p>
  <div><pre>Send emails for each item in the input iterable using SMTP.

This function processes a list of items and sends an email for each one, using the specified
fields for subject and body content. It supports both HTML and plain text email formats.

Args:
    subject_field (str): Field name in the item to use as email subject
    body_fields (list[str]): List of field names to include in email body
    sender_email (str, optional): Sender's email address. If None, uses config value
    recipient_email (str, optional): Recipient's email address. If None, uses config value
    smtp_server (str, optional): SMTP server address. Defaults to 'smtp.gmail.com'
    port (int, optional): SMTP server port. Defaults to 587

Yields:
    item: Returns each processed item after sending its corresponding email

Raises:
    AssertionError: If subject_field or body_fields are None
    ValueError: If required fields are missing in items

Example:
    >>> items = [{'title': 'Hello', 'content': 'World'}]
    >>> for item in sendEmail(items, 'title', ['content'], 'sender@email.com', 'recipient@email.com'):
    ...     print(f"Processed {item}")

Notes:
    - Requires valid SMTP credentials in config
    - Supports HTML formatting in email body
    - Uses TLS encryption for email transmission</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>body_fields</li>
    <li>sender_email</li>
    <li>recipient_email</li>
    <li>smtp_server = None</li>
    <li>port = 587</li>
  </ul>
</div>
<div class="package-header" id="talkpipe-data-extraction">talkpipe.data.extraction</div>
<div class="class" id="talkpipe-data-extraction-FileExtractor">
  <h2>Segment Class: FileExtractor</h2>
  <p class="talkpipe-name">Chatterlang Name: extract</p>
  <div><pre>A class for extracting text content from different file types.

This class implements the AbstractSegment interface and provides functionality to extract
text content from various file formats using registered extractors. It supports multiple
file formats and can be extended with additional extractors.

Attributes:
    _extractors (dict): A dictionary mapping file extensions to their corresponding extractor functions.

Methods:
    register_extractor(file_extension: str, extractor): Register a new file extractor for a specific extension.
    extract(file_path: Union[str, PosixPath]): Extract content from a single file.
    transform(input_iter): Transform an iterator of file paths into an iterator of their contents.

Example:
    >>> extractor = FileExtractor()
    >>> content = extractor.extract("document.txt")
    >>> for text in extractor.transform(["file1.txt", "file2.docx"]):
    ...     print(text)

Raises:
    Exception: When trying to extract content from a file with an unsupported extension.</pre></div>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="function" id="talkpipe-data-extraction-listFiles">
  <h2>Segment Function: listFiles</h2>
  <p class="talkpipe-name">Chatterlang Name: listFiles</p>
  <div><pre>Lists files matching given patterns (potentially with wildcards) and yields their paths.

Args:
    patterns (Iterable[str]): Iterable of file patterns or paths (supports wildcards like *, ?, []).
    full_path (bool): Whether to yield full absolute paths or just filenames.
    files_only (bool): Whether to include only files (excluding directories).

Yields:
    str: File paths (absolute if full_path=True, filenames if full_path=False).


Raises:
    None: This function does not raise exceptions for non-matching patterns.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>full_path: bool = True</li>
    <li>files_only: bool = False</li>
  </ul>
</div>
<div class="function" id="talkpipe-data-extraction-readdocx">
  <h2>Segment Function: readdocx</h2>
  <p class="talkpipe-name">Chatterlang Name: readdocx</p>
  <div><pre>Read and extract text from Microsoft Word (.docx) files.

If an item is a directory, it will scan the directory (recursively by default)
and read all .docx files.

Args:
    items (Iterable[str]): Iterable of file or directory paths.
    recursive (bool): Whether to scan directories recursively for .docx files.

Yields:
    str: The full text content of each document with paragraphs joined by spaces

Raises:
    FileNotFoundError: If a path does not exist.
    IOError: If there is an error reading any of the files.</pre></div>
</div>
<div class="function" id="talkpipe-data-extraction-readtxt">
  <h2>Segment Function: readtxt</h2>
  <p class="talkpipe-name">Chatterlang Name: readtxt</p>
  <div><pre>Reads text files from given file paths or directories and yields their contents.

If an item is a directory, it will scan the directory (recursively by default)
and read all .txt files.

Args:
    items (Iterable[str]): Iterable of file or directory paths.
    recursive (bool): Whether to scan directories recursively for .txt files.

Yields:
    str: The contents of each text file.

Raises:
    FileNotFoundError: If a path does not exist.
    IOError: If there is an error reading any of the files.</pre></div>
</div>
<div class="package-header" id="talkpipe-data-html">talkpipe.data.html</div>
<div class="function" id="talkpipe-data-html-downloadURLSegment">
  <h2>Segment Function: downloadURLSegment</h2>
  <p class="talkpipe-name">Chatterlang Name: downloadURL</p>
  <div><pre>Download a URL segment and return its content.

This function is a wrapper around downloadURL that specifically handles URL segments.
It attempts to download content from the specified URL with configurable error handling
and timeout settings.

Args:
    fail_on_error (bool, optional): If True, raises exceptions on download errors.
        If False, returns None on errors. Defaults to True.
    timeout (int, optional): The timeout in seconds for the download request. 
        Defaults to 10 seconds.

Returns:
    bytes|None: The downloaded content as bytes if successful, None if fail_on_error
        is False and an error occurs.

Raises:
    Various exceptions from downloadURL function when fail_on_error is True and
    an error occurs during download.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>timeout = 10</li>
    <li>user_agent = None</li>
  </ul>
</div>
<div class="function" id="talkpipe-data-html-htmlToTextSegment">
  <h2>Segment Function: htmlToTextSegment</h2>
  <p class="talkpipe-name">Chatterlang Name: htmlToText</p>
  <div><pre>Converts HTML content to text segment.

This function takes HTML content and converts it to plain text format.
If cleanText is enabled, the resulting text will also be cleaned so it 
tries to retain only the main body content.

Args:
    raw (str): The raw HTML content to be converted
    cleanText (bool, optional): Whether to clean and normalize the output text. Defaults to True.
    field (str): The field name to be used for the segment. If None, assuming the incoming item is html.
    append_as (str): The name of the field to append the text to.  If None, just pass on the cleaned text.

Returns:
    str: The extracted text content from the HTML

See Also:
    htmlToText: The underlying function used for HTML to text conversion</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>cleanText = True</li>
  </ul>
</div>
<div class="package-header" id="talkpipe-data-mongo">talkpipe.data.mongo</div>
<div class="class" id="talkpipe-data-mongo-MongoInsert">
  <h2>Segment Class: MongoInsert</h2>
  <p class="talkpipe-name">Chatterlang Name: mongoInsert</p>
  <div><pre>Insert items from the input stream into a MongoDB collection.

For each item received, this segment inserts it into the specified MongoDB collection
and then yields the item back to the pipeline. This allows for both persisting data
and continuing to process it in subsequent pipeline stages.

Args:
    connection_string (str, optional): MongoDB connection string. If not provided,
        will attempt to get from config using the key "mongo_connection_string".
    database (str): Name of the MongoDB database to use.
    collection (str): Name of the MongoDB collection to use.
    field (str, optional): Field to extract from each item for insertion. 
        If not provided, inserts the entire item. Default is "_".
    fields (str, optional): Comma-separated list of fields to extract and include in the 
        document, in the format "field1:name1,field2:name2". If provided, this creates a 
        new document with the specified fields. Cannot be used with 'field' parameter.
    append_as (str, optional): If provided, adds the MongoDB insertion result
        to the item using this field name. Default is None.
    create_index (str, optional): If provided, creates an index on this field.
        Default is None.
    unique_index (bool, optional): If True and create_index is provided, 
        creates a unique index. Default is False.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>connection_string: Optional[str] = None</li>
    <li>database: Optional[str] = None</li>
    <li>collection: Optional[str] = None</li>
    <li>field: str = &#x27;_&#x27;</li>
    <li>fields: Optional[str] = None</li>
    <li>append_as: Optional[str] = None</li>
    <li>create_index: Optional[str] = None</li>
    <li>unique_index: bool = False</li>
  </ul>
  <p><strong>Base Classes:</strong> core.AbstractSegment</p>
</div>
<div class="class" id="talkpipe-data-mongo-MongoSearch">
  <h2>Segment Class: MongoSearch</h2>
  <p class="talkpipe-name">Chatterlang Name: mongoSearch</p>
  <div><pre>Search a MongoDB collection and yield results.

This segment performs a query against a MongoDB collection and yields
the matching documents one by one as they are returned from the database.

Args:
    field(str): the field in the incoming item to use as a query.  Defaults is "_"
    connection_string (str, optional): MongoDB connection string. If not provided,
        will attempt to get from config using the key "mongo_connection_string".
    database (str): Name of the MongoDB database to use.
    collection (str): Name of the MongoDB collection to use.
    project (str, optional): JSON string defining the projection for returned documents.
        Default is None (returns all fields).
    sort (str, optional): JSON string defining the sort order. Default is None.
    limit (int, optional): Maximum number of results to return per query. Default is 0 (no limit).
    skip (int, optional): Number of documents to skip. Default is 0.
    append_as (str, optional): If provided, adds the MongoDB results to the incoming item
        using this field name. If not provided, the results themselves are yielded.
    as_list (bool, optional): If True and append_as is provided, all results are collected
        into a list and appended to the incoming item. Default is False.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>field: str = &#x27;_&#x27;</li>
    <li>connection_string: Optional[str] = None</li>
    <li>database: Optional[str] = None</li>
    <li>collection: Optional[str] = None</li>
    <li>project: Optional[str] = None</li>
    <li>sort: Optional[str] = None</li>
    <li>limit: int = 0</li>
    <li>skip: int = 0</li>
    <li>append_as: Optional[str] = None</li>
  </ul>
  <p><strong>Base Classes:</strong> core.AbstractSegment</p>
</div>
<div class="package-header" id="talkpipe-data-rss">talkpipe.data.rss</div>
<div class="function" id="talkpipe-data-rss-rss_source">
  <h2>Source Function: rss_source</h2>
  <p class="talkpipe-name">Chatterlang Name: rss</p>
  <div><pre>Generator function that monitors and yields new entries from an RSS feed.

This function continuously monitors an RSS feed at the specified URL and yields new entries
as they become available. It uses a SQLite database to keep track of previously seen entries
to avoid duplicates.

Args:
    url (str): The URL of the RSS feed to monitor.  If None, the URL is read from the config using
        the key "RSS_URL"
    db_path (str, optional): Path to the SQLite database file for storing entry history.
        Defaults to ':memory:' for an in-memory database.
    poll_interval_minutes (int, optional): Number of minutes to wait between polling
        the RSS feed for updates. Defaults to 10 minutes.

Yields:
    dict: New entries from the RSS feed, containing feed item data.

Example:
    >>> for entry in rss_source("http://example.com/feed.xml"):
    ...     print(entry["title"])</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>url: str</li>
    <li>db_path: str = &#x27;:memory:&#x27;</li>
    <li>poll_interval_minutes: int = 10</li>
  </ul>
</div>
<div class="package-header" id="talkpipe-llm-chat">talkpipe.llm.chat</div>
<div class="class" id="talkpipe-llm-chat-LlmExtractTerms">
  <h2>Segment Class: LlmExtractTerms</h2>
  <p class="talkpipe-name">Chatterlang Name: llmExtractTerms</p>
  <div><pre>For each piece of text read from the input stream, extract terms from the text.

The system prompt must be provided and should explain the nature of the terms. For 
example, a system_prompt might be:

<pre>Extract keywords from the following text.</pre>

See the LLMPrompt segment for more information on the other arguments.</pre></div>
  <p><strong>Base Classes:</strong> AbstractLLMGuidedGeneration</p>
</div>
<div class="class" id="talkpipe-llm-chat-LLMPrompt">
  <h2>Segment Class: LLMPrompt</h2>
  <p class="talkpipe-name">Chatterlang Name: llmPrompt</p>
  <div><pre>Interactive, optionally multi-turn, chat with an llm.

Reads prompts from the input stream and emits responses from the llm.
The model name and source can be specified in three different ways.  If
explicitly included in the constructor, those values will be used.  If not,
the values will be loaded from environment variables (TALKPIPE_default_model_name
and TALKPIPE_default_source).  If those are not set, the values will be loaded
from the configuration file (~/.talkpipe.toml).  If none of those are set, an 
error will be raised.

Args:
    model (str, optional): The name of the model to chat with. Defaults to None.
    source (ModelSource, optional): The source of the model. Defaults to None. Valid values are "openai" and "ollama."
    system_prompt (str, optional): The system prompt for the model. Defaults to "You are a helpful assistant.".
    multi_turn (bool, optional): Whether the chat is multi-turn. Defaults to True.
    pass_prompts (bool, optional): Whether to pass the prompts through to the output. Defaults to False.
    field (str, optional): The field in the input item containing the prompt. Defaults to None.
    append_as (str, optional): The field to append the response to. Defaults to None.
    temperature (float, optional): The temperature to use for the model. If not specified, no temperature parameter will be passed to the model.
    output_format (BaseModel, optional): A class used for guided generation. Defaults to None.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>model: str = None</li>
    <li>source: str = None</li>
    <li>system_prompt: str = &#x27;You are a helpful assistant.&#x27;</li>
    <li>multi_turn: bool = True</li>
    <li>pass_prompts: bool = False</li>
    <li>field: Optional[str] = None</li>
    <li>append_as: Optional[str] = None</li>
    <li>temperature: float = None</li>
    <li>output_format: BaseModel = None</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="class" id="talkpipe-llm-chat-LlmScore">
  <h2>Segment Class: LlmScore</h2>
  <p class="talkpipe-name">Chatterlang Name: llmScore</p>
  <div><pre>For each piece of text read from the input stream, compute a score and an explanation for that score.

The system prompt must be provided and should explain the range of the score (which must be 
a range of integers) and the meaning of the score. For example, a system_prompt might be:

<pre>Score the following text according to how relevant it is to canines, where 0 mean unrelated and 10 
means highly related.</pre>

See the LLMPrompt segment for more information on the other arguments.</pre></div>
  <p><strong>Base Classes:</strong> AbstractLLMGuidedGeneration</p>
</div>
<div class="package-header" id="talkpipe-llm-embedding">talkpipe.llm.embedding</div>
<div class="class" id="talkpipe-llm-embedding-LLMEmbed">
  <h2>Segment Class: LLMEmbed</h2>
  <p class="talkpipe-name">Chatterlang Name: llmEmbed</p>
  <div><pre>Read strings from the input stream and emit an embedding for each string using a language model.

This segment creates vector embeddings from text using the specified embedding model.
It can extract text from a specific field in structured data or process the input directly.

Attributes:
    embedder: The embedding adapter instance that performs the actual embedding.
    field: Optional field name to extract text from structured input.
    append_as: Optional field name to append embeddings to the original item.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>model: str = None</li>
    <li>source: str = None</li>
    <li>field: Optional[str] = None</li>
    <li>append_as: Optional[str] = None</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="package-header" id="talkpipe-operations-filtering">talkpipe.operations.filtering</div>
<div class="function" id="talkpipe-operations-filtering-distinctBloomFilter">
  <h2>Segment Function: distinctBloomFilter</h2>
  <p class="talkpipe-name">Chatterlang Name: distinctBloomFilter</p>
  <div><pre>Filter items using a Bloom Filter to yield only distinct elements based on specified fields.

A Bloom Filter is a space-efficient probabilistic data structure used to test whether 
an element is a member of a set. False positive matches are possible, but false 
negatives are not.

Args:
    items (iterable): Input items to filter.
    capacity (int): Expected number of items to be added to the Bloom Filter.
    error_rate (float): Acceptable false positive probability (between 0 and 1).
    field_list (str, optional): Dot-separated string of nested fields to use for 
        distinctness check. Defaults to "_" which uses the entire item.

Yields:
    item: Items that have not been seen before according to the Bloom Filter.

Example:
    >>> items = [{"id": 1, "name": "John"}, {"id": 2, "name": "John"}]
    >>> list(distinctBloomFilter(items, 1000, 0.01, "name"))
    [{'id': 1, 'name': 'John'}]  # Only first item with name "John" is yielded

Note:
    Due to the probabilistic nature of Bloom Filters, there is a small chance
    of false positives (items incorrectly identified as duplicates) based on
    the specified error_rate.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>error_rate</li>
    <li>field_list = &#x27;_&#x27;</li>
  </ul>
</div>
<div class="package-header" id="talkpipe-operations-matrices">talkpipe.operations.matrices</div>
<div class="class" id="talkpipe-operations-matrices-ReduceTSNE">
  <h2>Segment Class: ReduceTSNE</h2>
  <p class="talkpipe-name">Chatterlang Name: reduceTSNE</p>
  <div><pre>Use t-SNE to reduce dimensionality of provided matrix.

This segment reduces the dimensionality of the provided matrix using t-SNE 
(t-Distributed Stochastic Neighbor Embedding).

Parameters:
    n_components: The dimension of the space to embed into. Default is 2.
    perplexity: The perplexity is related to the number of nearest neighbors used
        in other manifold learning algorithms. Larger datasets usually require a
        larger perplexity. Default is 30.
    early_exaggeration: Controls how tight natural clusters in the original 
        space are in the embedded space. Default is 12.0.
    learning_rate: The learning rate for t-SNE. Default is 200.0.
    max_iter: Maximum number of iterations for the optimization. Default is 1000.
    metric: Distance metric for t-SNE. Default is 'euclidean'.
    random_state: Random state for reproducibility.
    **tsne_kwargs: Additional keyword arguments to pass to TSNE.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>n_components: Optional[int] = 2</li>
    <li>perplexity: float = 30.0</li>
    <li>early_exaggeration: float = 12.0</li>
    <li>learning_rate: float = 200.0</li>
    <li>max_iter: int = 1000</li>
    <li>metric: str = &#x27;euclidean&#x27;</li>
    <li>random_state: Optional[int] = None</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="class" id="talkpipe-operations-matrices-ReduceUMAP">
  <h2>Segment Class: ReduceUMAP</h2>
  <p class="talkpipe-name">Chatterlang Name: reduceUMAP</p>
  <div><pre>Use UMAP to reduce dimensionality of provided matrix.

This segment reduces the dimensionality of the provided matrix using UMAP.

Parameters:
    n_components: The dimension of the space to embed into. Default is 2.
    n_neighbors: Size of local neighborhood. Default is 15.
    min_dist: Minimum distance between embedded points. Default is 0.1.
    metric: Distance metric for UMAP. Default is 'euclidean'.
    random_state: Random state for reproducibility.
    **umap_kwargs: Additional keyword arguments to pass to UMAP.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>n_components: Optional[int] = 2</li>
    <li>n_neighbors: int = 15</li>
    <li>min_dist: float = 0.1</li>
    <li>metric: str = &#x27;euclidean&#x27;</li>
    <li>random_state: Optional[int] = None</li>
    <li>n_epochs: int = None</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="package-header" id="talkpipe-operations-signatures">talkpipe.operations.signatures</div>
<div class="class" id="talkpipe-operations-signatures-SignSegment">
  <h2>Segment Class: SignSegment</h2>
  <p class="talkpipe-name">Chatterlang Name: sign</p>
  <div><pre>Sign items using a private key.

This segment signs each item in the input stream using RSA-PSS with SHA-256.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>private_key</li>
    <li>message_field = &#x27;_&#x27;</li>
    <li>password = None</li>
    <li>append_as = None</li>
    <li>encode_signature = True</li>
  </ul>
  <p><strong>Base Classes:</strong> core.AbstractSegment</p>
</div>
<div class="class" id="talkpipe-operations-signatures-VerifySegment">
  <h2>Segment Class: VerifySegment</h2>
  <p class="talkpipe-name">Chatterlang Name: verify</p>
  <div><pre>Verify signatures on items using a public key.

This segment verifies the signature on each item in the input stream using RSA-PSS with SHA-256.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>public_key</li>
    <li>message_field = &#x27;_&#x27;</li>
    <li>signature_field = &#x27;signature&#x27;</li>
    <li>append_as = None</li>
  </ul>
  <p><strong>Base Classes:</strong> core.AbstractSegment</p>
</div>
<div class="package-header" id="talkpipe-operations-thread_ops">talkpipe.operations.thread_ops</div>
<div class="function" id="talkpipe-operations-thread_ops-threadedSegment">
  <h2>Segment Function: threadedSegment</h2>
  <p class="talkpipe-name">Chatterlang Name: threaded</p>
  <div><pre>Links the input stream to a threaded queue system.

This segment takes an input stream and links it to a threaded queue system.
It starts the queue system and then starts yielding from the queue.  That way
the upstream units don't have to wait for the downstream segments to draw 
from them.</pre></div>
</div>
<div class="package-header" id="talkpipe-operations-transforms">talkpipe.operations.transforms</div>
<div class="function" id="talkpipe-operations-transforms-fill_null">
  <h2>Segment Function: fill_null</h2>
  <p class="talkpipe-name">Chatterlang Name: fillNull</p>
  <div><pre>Fills null (None) values in a sequence of dictionaries with specified defaults.

This generator function processes dictionaries by replacing None values with either
a general default value or specific values for named fields.

Args:
    items: An iterable of dictionaries to process.
    default (str, optional): The default value to use for any None values not 
        specified in kwargs. Defaults to ''.
    **kwargs: Field-specific default values. Each keyword argument specifies a
        field name and the default value to use for that field.

Yields:
    dict: The processed dictionary with None values replaced by defaults.

Raises:
    AssertionError: If any item in the input is not a dictionary.
    TypeError: If any item doesn't support item assignment using square brackets.

Examples:
    >>> data = [{'a': None, 'b': 1}, {'a': 2, 'b': None}]
    >>> list(fill_null(data, default='N/A'))
    [{'a': 'N/A', 'b': 1}, {'a': 2, 'b': 'N/A'}]
    
    >>> list(fill_null(data, b='EMPTY'))
    [{'a': None, 'b': 1}, {'a': 2, 'b': 'EMPTY'}]</pre></div>
</div>
<div class="class" id="talkpipe-operations-transforms-MakeLists">
  <h2>Segment Class: MakeLists</h2>
  <p class="talkpipe-name">Chatterlang Name: makeLists</p>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>num_items: Optional[int] = None</li>
    <li>cumulative: bool = False</li>
    <li>field: str = &#x27;_&#x27;</li>
    <li>ignoreNone: bool = False</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="function" id="talkpipe-operations-transforms-regex_replace">
  <h2>Segment Function: regex_replace</h2>
  <p class="talkpipe-name">Chatterlang Name: regexReplace</p>
  <div><pre>Transform items by applying regex pattern replacement.

This segment transforms items by applying a regex pattern replacement to either
the entire item (if field="_") or a specific field of the item.

Args:
    items (Iterable): Input items to transform.
    pattern (str): Regular expression pattern to match.
    replacement (str): Replacement string for matched patterns.
    field (str, optional): Field to apply transformation to. Use "_" for entire item. Defaults to "_".

Yields:
    Union[str, dict]: Transformed items. Returns string if field="_", otherwise returns modified item dict.

Raises:
    TypeError: If extracted value is not a string or if item is not subscriptable when field != "_".

Examples:
    >>> list(regex_replace(["hello world"], r"world", "everyone"))
    ['hello everyone']
    
    >>> list(regex_replace([{"text": "hello world"}], r"world", "everyone", field="text"))
    [{'text': 'hello everyone'}]</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>replacement</li>
    <li>field = &#x27;_&#x27;</li>
  </ul>
</div>
<div class="package-header" id="talkpipe-pipe-basic">talkpipe.pipe.basic</div>
<div class="function" id="talkpipe-pipe-basic-appendAs">
  <h2>Segment Function: appendAs</h2>
  <p class="talkpipe-name">Chatterlang Name: appendAs</p>
  <div><pre>Appends the specified fields to the input item.

Equivalent to toDict except that that item is modified with the new key/value pairs 
rather than a new dictionary returned.

Assumes that the input item can has items assigned using bracket notation ([]).</pre></div>
</div>
<div class="class" id="talkpipe-pipe-basic-Cast">
  <h2>Segment Class: Cast</h2>
  <p class="talkpipe-name">Chatterlang Name: cast</p>
  <div><pre>Casts the input data to a specified type.

The type can be specified by passing a type object or a string representation of the type.
The cast will optionally fail silently if the data cannot be cast to the specified type.
This lets this segment also be used as a filter to remove data that cannot be cast.
The cast occurs by calling the type object on the data.  </pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>cast_type: Union[type, str]</li>
    <li>fail_silently: bool = True</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="function" id="talkpipe-pipe-basic-concat">
  <h2>Segment Function: concat</h2>
  <p class="talkpipe-name">Chatterlang Name: concat</p>
  <div><pre>Concatenates specified fields from each item with a delimiter.

    Args:
        items: Iterable of input items to process
        fields: String specifying fields to extract and concatenate
        delimiter (str, optional): String to insert between concatenated fields. Defaults to "

"
        append_as (str, optional): If specified, adds concatenated result as new field with this name. 
                                Defaults to None.

    Yields:
        If append_as is specified, yields the original item with concatenated result added as new field.
        Otherwise, yields just the concatenated string.
    </pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>delimiter = &#x27;\n\n&#x27;</li>
    <li>append_as = None</li>
  </ul>
</div>
<div class="class" id="talkpipe-pipe-basic-ConfigureLogger">
  <h2>Segment Class: ConfigureLogger</h2>
  <p class="talkpipe-name">Chatterlang Name: configureLogger</p>
  <div><pre>Configures loggers based on the provided logger levels and files.

This segment configures loggers based on the provided logger levels and files.
The logger levels are specified as a string in the format "logger:level,logger:level,...".
The logger files are specified as a string in the format "logger:file,logger:file,...".

It configures when the script is compiled or the object is instantiated and never again 
after that.  It passes the input data through unchanged.

Args:
    logger_levels (str): Logger levels in format 'logger:level,logger:level,...'
    logger_files (str): Logger files in format 'logger:file,logger:file,...'</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>logger_levels: Optional[str] = None</li>
    <li>logger_files: Optional[str] = None</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="function" id="talkpipe-pipe-basic-copy_segment">
  <h2>Segment Function: copy_segment</h2>
  <p class="talkpipe-name">Chatterlang Name: copy</p>
  <div><pre>A segment that creates a shallow copy of each item in the input iterable.

This can be used to create a defensive copy of items in the pipline, ensuring that modifications
to the items do not affect the original items in the input stream.  

Args:
    items (Iterable): An iterable of items to copy.</pre></div>
</div>
<div class="function" id="talkpipe-pipe-basic-deep_copy_segment">
  <h2>Segment Function: deep_copy_segment</h2>
  <p class="talkpipe-name">Chatterlang Name: deepCopy</p>
  <div><pre>A segment that creates a deep copy of each item in the input iterable.

This can be used to create a defensive copy of items in the pipeline, ensuring that modifications
to the items do not affect the original items in the input stream.
Args:
    items (Iterable): An iterable of items to copy.</pre></div>
</div>
<div class="class" id="talkpipe-pipe-basic-DescribeData">
  <h2>Segment Class: DescribeData</h2>
  <p class="talkpipe-name">Chatterlang Name: describe</p>
  <div><pre>Returns a dictionary of all attributes of the input data.

This is useful mostly for debugging and understanding the 
structure of the data.</pre></div>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="class" id="talkpipe-pipe-basic-EvalExpression">
  <h2>Segment Class: EvalExpression</h2>
  <p class="talkpipe-name">Chatterlang Name: lambda</p>
  <div><pre>Evaluate a Python expression on each item in the input stream.

This segment pre-compiles the expression during initialization for efficiency 
and then applies it to each item during transformation. Expressions are evaluated
in a restricted environment for security.

The item is available in expressions as 'item'. If the item is a dictionary,
its fields can be accessed directly as variables in the expression.

Args:
    expression: The Python expression to evaluate
    field: If provided, extract this field from each item before evaluating
    append_as: If provided, append the result to each item under this field name
    fail_on_error: If True, raises exceptions when evaluation fails. If False, logs errors and returns None</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>expression: str</li>
    <li>field: Optional[str] = &#x27;_&#x27;</li>
    <li>append_as: Optional[str] = None</li>
    <li>fail_on_error: bool = True</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="function" id="talkpipe-pipe-basic-everyN">
  <h2>Segment Function: everyN</h2>
  <p class="talkpipe-name">Chatterlang Name: everyN</p>
  <div><pre>Yields every nth item from the input stream.

Args:
    items: Iterable of items to process
    n: Number of items to skip between each yield

Yields:
    Every nth item from the input stream.</pre></div>
</div>
<div class="function" id="talkpipe-pipe-basic-exec">
  <h2>Source Function: exec</h2>
  <p class="talkpipe-name">Chatterlang Name: exec</p>
  <div><pre>Execute a shell command and yield each line from stdout as a data item.

This source allows you to integrate shell commands into TalkPipe pipelines,
streaming the output line by line for further processing.

ChatterLang Usage:
    input exec[command="ls -la"]
    input exec[command="find /path -name '*.txt'"]
    
Args:
    command (str): The shell command to execute.
    
Yields:
    str: Each line from the command's stdout output.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>command: str</li>
  </ul>
</div>
<div class="function" id="talkpipe-pipe-basic-fillTemplate">
  <h2>Segment Function: fillTemplate</h2>
  <p class="talkpipe-name">Chatterlang Name: fillTemplate</p>
  <div><pre>Fill a template string with values from the input item.

Args:
    item: The input item containing values to fill the template
    template (str): The template string with placeholders for values

Returns:
    str: The filled template string</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>fail_on_missing: bool = True</li>
    <li>default: Optional[Any] = &#x27;&#x27;</li>
  </ul>
</div>
<div class="class" id="talkpipe-pipe-basic-FilterExpression">
  <h2>Segment Class: FilterExpression</h2>
  <p class="talkpipe-name">Chatterlang Name: lambdaFilter</p>
  <div><pre>Filter items from the input stream based on a Python expression.

This segment pre-compiles the expression during initialization for efficiency 
and then applies it to each item during transformation. Expressions are evaluated
in a restricted environment for security.

The item is available in expressions as 'item'. If the item is a dictionary,
its fields can be accessed directly as variables in the expression.

Args:
    expression: The Python expression to evaluate
    field: If provided, extract this field from each item before evaluating
    fail_on_error: If True, raises exceptions when evaluation fails. If False, logs errors and returns None</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>expression: str</li>
    <li>field: Optional[str] = &#x27;_&#x27;</li>
    <li>fail_on_error: bool = True</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="function" id="talkpipe-pipe-basic-firstN">
  <h2>Segment Function: firstN</h2>
  <p class="talkpipe-name">Chatterlang Name: firstN</p>
  <div><pre>Yields the first n items from the input stream.

Useful for sampling data, testing pipelines with limited data, or implementing
pagination-like functionality.

ChatterLang Usage:
    firstN[n=5]
    
Args:
    items (Iterable): An iterable of items to process.
    n (int): The number of items to yield. Defaults to 1.
    
Yields:
    Any: The first n items from the input stream.</pre></div>
</div>
<div class="function" id="talkpipe-pipe-basic-flatten">
  <h2>Segment Function: flatten</h2>
  <p class="talkpipe-name">Chatterlang Name: flatten</p>
  <div><pre>Flattens a nested list of items.

Args:
    items: Iterable of items to flatten

Yields:
    Flattened list of items</pre></div>
</div>
<div class="class" id="talkpipe-pipe-basic-FormattedItem">
  <h2>Segment Class: FormattedItem</h2>
  <p class="talkpipe-name">Chatterlang Name: formatItem</p>
  <div><pre>    Generate formatted output for specified fields in "Property: Value" format.
    
    This segment takes each input item and generates one formatted string output 
    containing all specified fields. Each field is in the format "Label: Value".
    
    Args:
        field_list (str): Comma-separated list of field:label pairs. 
                         Format: "field1:Label1,field2:Label2" or just "field1,field2"
        format_type (str): Type of formatting to apply ("auto", "text", "json", "clean")
        wrap_width (int): Width for text wrapping (default: 80)
        fail_on_missing (bool): Whether to fail if a field is missing (default: False)
        separator (str): Separator between property and value (default: ": ")
        field_separator (str): Separator between different fields (default: "
")
    
    Yields:
        str: One formatted string per input item containing all fields
    </pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>field_list: str</li>
    <li>wrap_width: int = 80</li>
    <li>fail_on_missing: bool = False</li>
    <li>field_name_separator: str = &#x27;: &#x27;</li>
    <li>field_separator: str = &#x27;\n&#x27;</li>
    <li>item_suffix: str = &#x27;&#x27;</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="class" id="talkpipe-pipe-basic-Hash">
  <h2>Segment Class: Hash</h2>
  <p class="talkpipe-name">Chatterlang Name: hash</p>
  <div><pre>Hashes the input data using the specified algorithm.

This segment hashes the input data using the specified algorithm.
Strings will be encoded and hashed.  All other datatypes wil be hashed using either pickle or repr().

Args:
    algorithm (str): Hash algorithm to use.  Options include SHA1, SHA224, SHA256, SHA384, SHA512, SHA-3, and MD5.
    use_repr (bool): If True, the repr() version of the input data is hashed.  If False, the input data is hashed via 
        pickling.  Using repr() will handle all object, even those that can't be pickled and won't be subject to
        changes in pickling formats.  But the pickled version will include more state and generally be more reliable.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>algorithm: str = &#x27;MD5&#x27;</li>
    <li>use_repr = False</li>
    <li>field_list: str = &#x27;_&#x27;</li>
    <li>append_as = None</li>
    <li>fail_on_missing: bool = True</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="function" id="talkpipe-pipe-basic-isIn">
  <h2>Segment Function: isIn</h2>
  <p class="talkpipe-name">Chatterlang Name: isIn</p>
  <div><pre>Filters items based on whether a field contains a specified value.

Args:
    items: Iterable of items to filter
    field: Field name to check for value
    value: Value to check for in the field

Yields:
    Items where the specified field contains the specified value.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>value</li>
  </ul>
</div>
<div class="function" id="talkpipe-pipe-basic-isNotIn">
  <h2>Segment Function: isNotIn</h2>
  <p class="talkpipe-name">Chatterlang Name: isNotIn</p>
  <div><pre>Filters items based on whether a field does not contain a specified value.

Args:
    field: Field name to check for value
    value: Value to check for in the field

Yields:
    Items where the specified field does not contain the specified value.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>value</li>
  </ul>
</div>
<div class="function" id="talkpipe-pipe-basic-longestStr">
  <h2>Segment Function: longestStr</h2>
  <p class="talkpipe-name">Chatterlang Name: longestStr</p>
  <div><pre>Finds the longest string among specified fields in the input item.  If 
a field is not present or is not a string, it is ignored.  If two or more
fields have the same length, the first one encountered is returned.  If
none of the specified fields are present, and emptry string is yielded.
Args:
    items: The input items
    field_list (str): Comma-separated list of fields to check for longest string
Yields:
    The longest string found in the specified fields of the input items.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>append_as = None</li>
  </ul>
</div>
<div class="function" id="talkpipe-pipe-basic-progressTicks">
  <h2>Segment Function: progressTicks</h2>
  <p class="talkpipe-name">Chatterlang Name: progressTicks</p>
  <div><pre>Display progress indicators while processing items in the pipeline.

Prints tick marks to stderr to visualize processing progress without interfering 
with the main data stream. Useful for monitoring long-running pipelines.

ChatterLang Usage:
    progressTicks[tick="*", tick_count=100, eol_count=10, print_count=true]
    
Args:
    items (Iterable): An iterable of items to process.
    tick (str): The character to print as a tick mark. Defaults to '.'.
    tick_count (int): Number of items to process before printing a tick mark. Defaults to 10.
    eol_count (Optional[int]): Number of tick marks before starting a new line. 
                              If None, no new line is printed. Defaults to 10.
    print_count (bool): If True, prints the count of items processed at line ends.
    
Yields:
    Any: The original items from the input iterable, unchanged.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>tick_count: int = 10</li>
    <li>eol_count: Optional[int] = 10</li>
    <li>print_count: bool = False</li>
  </ul>
</div>
<div class="function" id="talkpipe-pipe-basic-sleep">
  <h2>Segment Function: sleep</h2>
  <p class="talkpipe-name">Chatterlang Name: sleep</p>
  <div><pre>Sleep for a specified number of seconds between processing each item.

This segment introduces a delay between processing each item in the pipeline.
Useful for rate limiting, testing timing-sensitive code, or simulating slow operations.

ChatterLang Usage:
    sleep[seconds=1]
    
Args:
    items (Iterable): An iterable of items to process.
    seconds (int): The number of seconds to sleep after processing each item.

Yields:
    Any: Each input item unchanged after the sleep delay.</pre></div>
</div>
<div class="function" id="talkpipe-pipe-basic-slice">
  <h2>Segment Function: slice</h2>
  <p class="talkpipe-name">Chatterlang Name: slice</p>
  <div><pre>Slices a sequence using start and end indices.

This function takes a sequence and a range string in the format "start:end" to slice the sequence.
Both start and end indices are optional.

Args:
    item: Any sequence that supports slicing (e.g., list, string, tuple)
    range (str, optional): String in format "start:end" where both start and end are optional.
        For example: "2:5", ":3", "4:", ":" are all valid. Defaults to None.

Returns:
    The sliced sequence containing elements from start to end index.
    If range is None, returns a full copy of the sequence.

Examples:
    >>> slice([1,2,3,4,5], "1:3")
    [2, 3]
    >>> slice("hello", ":3")
    "hel"
    >>> slice([1,2,3,4,5], "2:")
    [3, 4, 5]</pre></div>
</div>
<div class="class" id="talkpipe-pipe-basic-ToDataFrame">
  <h2>Segment Class: ToDataFrame</h2>
  <p class="talkpipe-name">Chatterlang Name: toDataFrame</p>
  <div><pre>Drain all items from the input stream and emit a single DataFrame.

The input data stream should be composed of dictionaries, where each 
dictionary represents a row in the DataFrame.</pre></div>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="class" id="talkpipe-pipe-basic-ToDict">
  <h2>Segment Class: ToDict</h2>
  <p class="talkpipe-name">Chatterlang Name: toDict</p>
  <div><pre>Creates a dictionary from the input data.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>field_list: str = &#x27;_&#x27;</li>
    <li>fail_on_missing: bool = True</li>
    <li>default: Optional[Any] = None</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="class" id="talkpipe-pipe-basic-ToList">
  <h2>Segment Class: ToList</h2>
  <p class="talkpipe-name">Chatterlang Name: toList</p>
  <div><pre>Drains the input stream and emits a list of all items.</pre></div>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="package-header" id="talkpipe-pipe-io">talkpipe.pipe.io</div>
<div class="function" id="talkpipe-pipe-io-dumpsJsonl">
  <h2>Segment Function: dumpsJsonl</h2>
  <p class="talkpipe-name">Chatterlang Name: dumpsJsonl</p>
  <div><pre>Drains the input stream and dumps each item as a jsonl string.
    </pre></div>
</div>
<div class="function" id="talkpipe-pipe-io-echo">
  <h2>Source Function: echo</h2>
  <p class="talkpipe-name">Chatterlang Name: echo</p>
  <div><pre>A source that generates input from a string.

This source will generate input from a string, splitting it on a delimiter.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>data</li>
    <li>delimiter</li>
  </ul>
</div>
<div class="function" id="talkpipe-pipe-io-loadsJsonl">
  <h2>Segment Function: loadsJsonl</h2>
  <p class="talkpipe-name">Chatterlang Name: loadsJsonl</p>
  <div><pre>Reads each item from the input stream, interpreting it as a jsonl string. 
    
    </pre></div>
</div>
<div class="class" id="talkpipe-pipe-io-Log">
  <h2>Segment Class: Log</h2>
  <p class="talkpipe-name">Chatterlang Name: log</p>
  <div><pre>An operation that logs each item from the input stream.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>level: Optional[str] = &#x27;INFO&#x27;</li>
    <li>field_list: Optional[str] = None</li>
    <li>log_name: Optional[str] = None</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="class" id="talkpipe-pipe-io-Print">
  <h2>Segment Class: Print</h2>
  <p class="talkpipe-name">Chatterlang Name: print</p>
  <div><pre>An operation prints and passes on each item from the input stream.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>pprint: Optional[bool] = False</li>
    <li>field_list: Optional[str] = None</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractSegment</p>
</div>
<div class="class" id="talkpipe-pipe-io-Prompt">
  <h2>Source Class: Prompt</h2>
  <p class="talkpipe-name">Chatterlang Name: prompt</p>
  <div><pre>A source that generates input from a prompt.

This source will generate input from a prompt until the user enters an EOF.
It is for creating interactive pipelines.  It uses prompt_toolkit under the
hood to provide a nice prompt experience.</pre></div>
  <p><strong>Base Classes:</strong> AbstractSource</p>
</div>
<div class="function" id="talkpipe-pipe-io-readJsonl">
  <h2>Segment Function: readJsonl</h2>
  <p class="talkpipe-name">Chatterlang Name: readJsonl</p>
  <div><pre>Reads each item from the input stream as a path to a jsonl file. Loads each line of
each file as a json object and yields each individually.</pre></div>
</div>
<div class="function" id="talkpipe-pipe-io-writePickle">
  <h2>Segment Function: writePickle</h2>
  <p class="talkpipe-name">Chatterlang Name: writePickle</p>
  <div><pre>Writes each item into a pickle file. If first_only is True, only the first item is written.
In any event, all items are yielded.

Args:
    fname (str): The name of the file to write.
    first_only (bool): If True, only the first item in the input stream is written.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>fname: str</li>
    <li>field: Optional[str] = None</li>
    <li>first_only: bool = False</li>
  </ul>
</div>
<div class="function" id="talkpipe-pipe-io-writeString">
  <h2>Segment Function: writeString</h2>
  <p class="talkpipe-name">Chatterlang Name: writeString</p>
  <div><pre>Writes each item into a files after casting it to a string.

Args:
    fname (str): The name of the file to write.
    new_line (bool): If True, a new line will be written after each item.
    first_only (bool): If True, the segment will write only the first item in the input stream.
        In any event, all items will be yielded.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>fname: str</li>
    <li>field: Optional[str] = None</li>
    <li>new_line = True</li>
    <li>first_only: bool = False</li>
  </ul>
</div>
<div class="package-header" id="talkpipe-pipe-math">talkpipe.pipe.math</div>
<div class="function" id="talkpipe-pipe-math-arange">
  <h2>Source Function: arange</h2>
  <p class="talkpipe-name">Chatterlang Name: range</p>
  <div><pre>Generate a range of integers between lower (inclusive) and upper (exclusive)

This segment wraps the built-in range function, allowing you to specify
the lower and upper bounds of the range. The range is inclusive of the
lower bound and exclusive of the upper bound.

Args:
    lower (int): Lower bound of the range (inclusive)
    upper (int): Upper bound of the range (exclusive)</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>lower</li>
    <li>upper</li>
  </ul>
</div>
<div class="class" id="talkpipe-pipe-math-eq">
  <h2>Segment Class: eq</h2>
  <p class="talkpipe-name">Chatterlang Name: eq</p>
  <div><pre>Filter items where a specified field's value equals a number.

For each item passed in, this segment yields only those where the value of the specified field
is equal to the given number n.  

Args:
    items: Iterable of items to filter
    field: String representing the field/property to compare.  Note that
      an underscore "_" can be used to refer to the item itself.
    n: Item to compare against

Yields:
    Items where the specified field's value equals n

Raises:
    AttributeError: If the specified field is missing from any item</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>field: str</li>
    <li>n: Any</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractComparisonFilter</p>
</div>
<div class="class" id="talkpipe-pipe-math-gt">
  <h2>Segment Class: gt</h2>
  <p class="talkpipe-name">Chatterlang Name: gt</p>
  <div><pre>Filter items where a specified field's value is greater than a number.

For each item passed in, this segment yields only those where the value of the specified field
is greater than the given number n.

Args:
    items: Iterable of items to filter
    field: String representing the field/property to compare.  Note that
      an underscore "_" can be used to refer to the item itself.
    n: Number to compare against

Yields:
    Items where the specified field's value is greater than n

Raises:
    AttributeError: If the specified field is missing from any item</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>field: str</li>
    <li>n: Any</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractComparisonFilter</p>
</div>
<div class="class" id="talkpipe-pipe-math-gte">
  <h2>Segment Class: gte</h2>
  <p class="talkpipe-name">Chatterlang Name: gte</p>
  <div><pre>Filter items where a specified field's value is greater than or equal to a number.

For each item passed in, this segment yields only those where the value of the specified field
is greater than or equal to the given number n.

Args:
    items: Iterable of items to filter
    field: String representing the field/property to compare.  Note that
      an underscore "_" can be used to refer to the item itself.
    n: Number to compare against

Yields:
    Items where the specified field's value is greater than or equal to n

Raises:
    AttributeError: If the specified field is missing from any item</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>field: str</li>
    <li>n: Any</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractComparisonFilter</p>
</div>
<div class="class" id="talkpipe-pipe-math-lt">
  <h2>Segment Class: lt</h2>
  <p class="talkpipe-name">Chatterlang Name: lt</p>
  <div><pre>Filters items based on a field value being less than a specified number.

For each item passed in, this segment yields items where the 
specified field value is less than the given number n.

Args:
    items (iterable): An iterable of items to filter
    field: String representing the field/property to compare.  Note that
      an underscore "_" can be used to refer to the item itself.
    n (numeric): The number to compare against

Yields:
    item: Items where the specified field value is less than n

Raises:
    AttributeError: If the specified field does not exist on an item (due to fail_on_missing=True)</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>field: str</li>
    <li>n: Any</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractComparisonFilter</p>
</div>
<div class="class" id="talkpipe-pipe-math-lte">
  <h2>Segment Class: lte</h2>
  <p class="talkpipe-name">Chatterlang Name: lte</p>
  <div><pre>Filter items where a specified field's value is less than or equal to a number.

For each item passed in, this segment yields only those where the value of the specified field
is less than or equal to the given number n.

Args:
    items: Iterable of items to filter
    field: String representing the field/property to compare.  Note that
      an underscore "_" can be used to refer to the item itself.
    n: Number to compare against

Yields:
    Items where the specified field's value is less than or equal to n

Raises:
    AttributeError: If the specified field is missing from any item</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>field: str</li>
    <li>n: Any</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractComparisonFilter</p>
</div>
<div class="class" id="talkpipe-pipe-math-neq">
  <h2>Segment Class: neq</h2>
  <p class="talkpipe-name">Chatterlang Name: neq</p>
  <div><pre>Filter items where a specified field's value does not equal a number.

For each item passed in, this segment yields only those where the value of the specified field
is not equal to the given number n.

Args:
    items: Iterable of items to filter
    field: String representing the field/property to compare.  Note that
      an underscore "_" can be used to refer to the item itself.
    n: Item to compare against

Yields:
    Items where the specified field's value does not equal n

Raises:
    AttributeError: If the specified field is missing from any item</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>field: str</li>
    <li>n: Any</li>
  </ul>
  <p><strong>Base Classes:</strong> AbstractComparisonFilter</p>
</div>
<div class="function" id="talkpipe-pipe-math-randomInts">
  <h2>Source Function: randomInts</h2>
  <p class="talkpipe-name">Chatterlang Name: randomInts</p>
  <div><pre>Generate n random integers between lower and upper.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>n: int</li>
    <li>lower</li>
    <li>upper</li>
  </ul>
</div>
<div class="function" id="talkpipe-pipe-math-scale">
  <h2>Segment Function: scale</h2>
  <p class="talkpipe-name">Chatterlang Name: scale</p>
  <div><pre>Scale each item in the input stream by the multiplier.</pre></div>
</div>
<div class="package-header" id="talkpipe-search-simplevectordb">talkpipe.search.simplevectordb</div>
<div class="function" id="talkpipe-search-simplevectordb-add_vector">
  <h2>Segment Function: add_vector</h2>
  <p class="talkpipe-name">Chatterlang Name: addVector</p>
  <div><pre>Segment to add a vector to the SimpleVectorDB.

Args:
    item: The item containing the vector data.
    vector_field: The field containing the vector data.
    vector_id: Optional custom ID for the vector.
    metadata_field_list: Optional metadata field list.
    dimension: Expected dimension of the vector (optional).

Returns:
    The ID of the added vector.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>vector_field: str = &#x27;_&#x27;</li>
    <li>vector_id: Optional[str] = None</li>
    <li>metadata_field_list: Optional[str] = None</li>
    <li>overwrite: bool = False</li>
  </ul>
</div>
<div class="function" id="talkpipe-search-simplevectordb-search_vector">
  <h2>Segment Function: search_vector</h2>
  <p class="talkpipe-name">Chatterlang Name: searchVector</p>
  <div><pre>Segment to search for similar vectors in the SimpleVectorDB.
Args:
    vector_field: The field containing the vector data.
    top_k: Number of top results to return.
    search_metric: Similarity metric ("cosine" or "euclidean").
    search_method: Search method ("brute-force", "brute-force-heap", or "k-means").
    path: Optional path to a saved vector database.
Yields:
    List of SearchResult objects.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>vector_field = &#x27;_&#x27;</li>
    <li>top_k: int = 5</li>
    <li>all_results_at_once: bool = False</li>
    <li>append_as: Optional[str] = None</li>
    <li>continue_on_error: bool = True</li>
    <li>search_metric: str = &#x27;cosine&#x27;</li>
    <li>search_method: str = &#x27;brute-force&#x27;</li>
  </ul>
</div>
<div class="package-header" id="talkpipe-search-whoosh">talkpipe.search.whoosh</div>
<div class="function" id="talkpipe-search-whoosh-indexWhoosh">
  <h2>Segment Function: indexWhoosh</h2>
  <p class="talkpipe-name">Chatterlang Name: indexWhoosh</p>
  <div><pre>Index documents using Whoosh full-text indexing.

Args:
    items: Iterator of items to index
    index_path (str): Path to the Whoosh index directory.
    field_list (list[str]): List of fields to index.
    yield_doc (bool): If True, yield each indexed document. Otherwise yield the original item.
    continue_on_error (bool): If True, continue processing other documents when one fails.
    overwrite (bool): If True, clear existing index before indexing.
    commit_seconds (int): If > 0, commit changes if it has been this many seconds since the last commit.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>field_list: list[str] = [&#x27;_:content&#x27;]</li>
    <li>yield_doc = False</li>
    <li>continue_on_error = True</li>
    <li>overwrite = False</li>
    <li>commit_seconds: int = -1</li>
  </ul>
</div>
<div class="function" id="talkpipe-search-whoosh-searchWhoosh">
  <h2>Segment Function: searchWhoosh</h2>
  <p class="talkpipe-name">Chatterlang Name: searchWhoosh</p>
  <div><pre>Search documents using Whoosh full-text indexing.

Args:
    queries: Iterator of query strings
    index_path (str): Path to the Whoosh index directory.
    limit (int): Maximum number of results to return for each query. Defaults to 100.
    all_results_at_once (bool): If True, yield all results at once. Otherwise, yield one result at a time.
    continue_on_error (bool): If True, continue with next query when one fails.
    reload_seconds (int): If > 0, reload the index if the last search was at least this many seconds ago.</pre></div>
  <h3>Parameters:</h3>
  <ul class="param-list">
    <li>index_path: str</li>
    <li>limit: int = 100</li>
    <li>all_results_at_once: bool = False</li>
    <li>continue_on_error = True</li>
    <li>reload_seconds: int = 60</li>
    <li>field: str = &#x27;_&#x27;</li>
    <li>append_as: Optional[str] = None</li>
  </ul>
</div>
  </div>
</body>
</html>
