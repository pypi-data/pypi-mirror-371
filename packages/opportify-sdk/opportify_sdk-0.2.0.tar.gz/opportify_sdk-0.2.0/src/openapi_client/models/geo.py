# coding: utf-8

"""
    Opportify Insights API

    ## Overview  The **Opportify Insights API** provides access to a powerful and up-to-date platform. With advanced data warehousing and AI-driven capabilities, this API is designed to empower your business to make informed, data-driven decisions and effectively assess potential risks.  ### Base URL Use the following base URL for all API requests:  ```plaintext https://api.opportify.ai/insights/v1/<service>/<endpoint> ```  ### Features - [**Email Insights:**](/docs/api/api-reference/email-insights)   - Validate email syntax.   - Identify email types (free, disposable, private or unknown).   - Real time verifications:     - Reachable: Confirms if the email domain has valid MX DNS records using DNS lookup.     - Deliverable: Simulates an SMTP handshake to check if the email address exists and is deliverable.     - Catch-All: Detects if the domain accepts all emails (catch-all configuration).   - Intelligent Error Correction: Automatically corrects well-known misspelled email addresses.   - Risk Report: Provides an AI-driven normalized score (200-1000) to evaluate email risk, using predefined thresholds.      [Access Documentation >>](/docs/api/api-reference/email-insights)  - [**IP Insights:**](/docs/api/api-reference/ip-insights)   - Connection types: Detects connection types such as `wired`, `mobile`, `enterprise`, `satellite`, `VPN`, `cloud-provider`, `open-proxy`, or `Tor`.   - Geo location: Delivers detailed insights such as country, city, timezone, language preferences, and additional location-based information to enhance regional understanding.   - WHOIS: Provides main details including RIR, ASN, organization, and abuse/admin/technical contacts.   - Trusted Provider Recognition: Identifies if the IP is part of a known trusted provider (e.g., ZTNA - Zero Trust Network Access).   - Blocklist Reports: Retrieves up-to-date blocklist statuses, active reports, and the latest detections.   - Risk Report: Delivers an AI-driven normalized score (200-1000) to evaluate IP risk, supported by predefined thresholds.    [Access Documentation >>](/docs/api/api-reference/ip-insights)  ### Authentication & Security - **API Key:** Access to the API requires an API key, which must be included in the request headers. Businesses can generate unlimited API keys directly from their account, offering flexibility and ease of use.  - **ACL Rules:** Enhance security with Access Control Lists (ACL), allowing you to restrict API access from specific IP addresses or ranges. This feature provides an additional layer of protection by ensuring only authorized IPs can interact with the API. - **No Query Parameters:** As a precautionary measure, our API avoids the use of query parameters for all operations, including authentication and handling Personally Identifiable Information (PII). This approach minimizes security risks by preventing sensitive data from being exposed in access logs, browser history, cached URLs, debugging tools, or inadvertently shared URLs. All sensitive information is securely transmitted through headers or the request body. 

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing import Optional, Set
from typing_extensions import Self

class Geo(BaseModel):
    """
    ### Geolocation Determination & Confidence Levels Geolocation details are derived by analyzing the provided IP address using data aggregated from a wide range of sources, both official and unofficial (such as user-generated data, open-source, or crowdsourced). This data is meticulously evaluated and ranked using a proprietary weighted reliability score that is tailored to the specific characteristics and trustworthiness of each data source.  ---  #### Confidence Levels  The geolocation process assigns a confidence level to each level of granularity. These levels reflect the probability of accuracy based on the reliability of the data and analysis:  - **Continent-Level (99%)**: The determination of the continent is highly reliable, with a near-certain accuracy rate of 99%. - **Country-Level (98%)**: Locating the specific country has a very high accuracy of 98%, reflecting reliable cross-verification. - **Region-Level (70–90%)**: Identifying regions (such as states or provinces) has moderate to high accuracy, depending on the data quality and density for the given area. - **City-Level (50–70%)**: Pinpointing the specific city is moderately accurate, influenced by factors such as ISP data resolution and urban vs. rural settings. - **Specific Area/Point (5–40%)**: Pinpointing a highly specific area (e.g., a neighborhood or street) has a significantly lower confidence level due to inherent limitations in IP-based geolocation technology.  ---  #### Key Features  - **Alphabetical Object Sorting**:     The keys in the returned geolocation object are consistently sorted alphabetically, ensuring a predictable structure for easier integration and parsing.  ---  ### Response Elements 
    """ # noqa: E501
    continent: Optional[StrictStr] = Field(default=None, description="Name of the continent. Normalized as \"Title Case\".")
    country_code: Optional[StrictStr] = Field(default=None, description="ISO 3166-1 alpha-2 country code.", alias="countryCode")
    country_name: Optional[StrictStr] = Field(default=None, description="Full name of the country. Normalized as \"Title Case\".", alias="countryName")
    country_short_name: Optional[StrictStr] = Field(default=None, description="ISO 3166-1 English short version. Normalized as \"Title Case\".", alias="countryShortName")
    city: Optional[StrictStr] = Field(default=None, description="Name of the city. Normalized as \"Title Case\".")
    currency_code: Optional[StrictStr] = Field(default=None, description="ISO 4217 currency code.", alias="currencyCode")
    domain_extension: Optional[StrictStr] = Field(default=None, description="Top-level domain (TLD) for the country. 63 characters limit. IANA / ICANN defined.", alias="domainExtension")
    languages: Optional[StrictStr] = Field(default=None, description="List of languages spoken in the country separated by commas. (BCP 47 (Best Current Practice 47))")
    latitude: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Latitude coordinate.")
    longitude: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Longitude coordinate.")
    postal_code: Optional[StrictStr] = Field(default=None, description="Postal code. Normalized to all capital letters when applicable.", alias="postalCode")
    phone_int_code: Optional[StrictStr] = Field(default=None, description="International dialing code.", alias="phoneIntCode")
    region: Optional[StrictStr] = Field(default=None, description="Name of the region, province, or state. Normalized as \"Title Case\".")
    timezone: Optional[StrictStr] = Field(default=None, description="Timezone in IANA format.")
    __properties: ClassVar[List[str]] = ["continent", "countryCode", "countryName", "countryShortName", "city", "currencyCode", "domainExtension", "languages", "latitude", "longitude", "postalCode", "phoneIntCode", "region", "timezone"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Geo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Geo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "continent": obj.get("continent"),
            "countryCode": obj.get("countryCode"),
            "countryName": obj.get("countryName"),
            "countryShortName": obj.get("countryShortName"),
            "city": obj.get("city"),
            "currencyCode": obj.get("currencyCode"),
            "domainExtension": obj.get("domainExtension"),
            "languages": obj.get("languages"),
            "latitude": obj.get("latitude"),
            "longitude": obj.get("longitude"),
            "postalCode": obj.get("postalCode"),
            "phoneIntCode": obj.get("phoneIntCode"),
            "region": obj.get("region"),
            "timezone": obj.get("timezone")
        })
        return _obj


