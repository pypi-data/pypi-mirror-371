# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.request_timeout_error import RequestTimeoutError
from ..errors.too_many_requests_error import TooManyRequestsError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.countries import Countries
from ..types.error import Error
from ..types.from_rank import FromRank
from ..types.include_additional_info import IncludeAdditionalInfo
from ..types.is_news_domain import IsNewsDomain
from ..types.lang import Lang
from ..types.news_domain_type import NewsDomainType
from ..types.news_type import NewsType
from ..types.predefined_sources import PredefinedSources
from ..types.source_name import SourceName
from ..types.source_url import SourceUrl
from ..types.sources_response_dto import SourcesResponseDto
from ..types.to_rank import ToRank
from .types.sources_get_request_news_domain_type import SourcesGetRequestNewsDomainType

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawSourcesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def get(
        self,
        *,
        lang: typing.Optional[str] = None,
        countries: typing.Optional[str] = None,
        predefined_sources: typing.Optional[str] = None,
        source_name: typing.Optional[str] = None,
        source_url: typing.Optional[str] = None,
        include_additional_info: typing.Optional[bool] = None,
        is_news_domain: typing.Optional[bool] = None,
        news_domain_type: typing.Optional[SourcesGetRequestNewsDomainType] = None,
        news_type: typing.Optional[str] = None,
        from_rank: typing.Optional[int] = None,
        to_rank: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SourcesResponseDto]:
        """
        Retrieves a list of sources based on specified criteria such as language, country, rank, and more.

        Parameters
        ----------
        lang : typing.Optional[str]
            The language(s) of the search. The only accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code. To select multiple languages, use a comma-separated string.

            Example: `"en, es"`

            To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).

        countries : typing.Optional[str]
            The countries where the news publisher is located. The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code. To select multiple countries, use a comma-separated string.

            Example: `"US, CA"`

            To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).

        predefined_sources : typing.Optional[str]
            Predefined top news sources per country.

            Format: start with the word `top`, followed by the number of desired sources, and then the two-letter country code [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). Multiple countries with the number of top sources can be specified as a comma-separated string.

            Examples:
            - `"top 100 US"`
            - `"top 33 AT"`
            - `"top 50 US, top 20 GB"`
            - `"top 33 AT, top 50 IT"`

        source_name : typing.Optional[str]
            Word or phrase to search within the source names. To specify multiple values, use a comma-separated string.

            Example: `"sport, tech"`

            **Note**: The search doesn't require an exact match and returns sources containing the specified terms in their names. You can use any word or phrase, like `"sport"` or `"new york times"`. For example, `"sport"` returns sources such as `"Motorsport"`, `"Dot Esport"`, and `"Tuttosport"`.

        source_url : typing.Optional[str]
            The domain(s) of the news publication to search for.

            **Caution**:  When specifying the `source_url` parameter,
            you can only use `include_additional_info` as an extra parameter.

        include_additional_info : typing.Optional[bool]
            If true, returns the following additional datapoints about each news source:
            - `nb_articles_for_7d`: The number of articles published by the source in the last week.
            - `country`: Source country of origin.
            - `rank`: SEO rank.
            - `is_news_domain`: Boolean indicating if the source is a news domain.
            - `news_domain_type`: Type of news domain (e.g., "Original Content").
            - `news_type`: Category of news (e.g., "General News Outlets").

        is_news_domain : typing.Optional[bool]
            If true, filters results to include only news domains.

        news_domain_type : typing.Optional[SourcesGetRequestNewsDomainType]
            Filters results based on the news domain type. Possible values are:
            - `Original Content`: Sources that produce their own content.
            - `Aggregator`: Sources that collect content from various other sources.
            - `Press Releases`: Sources primarily publishing press releases.
            - `Republisher`: Sources that republish content from other sources.
            - `Other`: Sources that don't fit into main categories.

        news_type : typing.Optional[str]
            Filters results based on the news type. Multiple types can be specified using a comma-separated string.

            Example: `"General News Outlets,Tech News and Updates"`

            For a complete list of available news types, see [Enumerated parameters > News type](/docs/v3/api-reference/overview/enumerated-parameters#news-type-news-type).

        from_rank : typing.Optional[int]
            The lowest boundary of the rank of a news website to filter by. A lower rank indicates a more popular source.

        to_rank : typing.Optional[int]
            The highest boundary of the rank of a news website to filter by. A lower rank indicates a more popular source.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SourcesResponseDto]
            A successful response containing a list of news sources that match the specified criteria.
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/sources",
            method="GET",
            params={
                "lang": lang,
                "countries": countries,
                "predefined_sources": predefined_sources,
                "source_name": source_name,
                "source_url": source_url,
                "include_additional_info": include_additional_info,
                "is_news_domain": is_news_domain,
                "news_domain_type": news_domain_type,
                "news_type": news_type,
                "from_rank": from_rank,
                "to_rank": to_rank,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourcesResponseDto,
                    parse_obj_as(
                        type_=SourcesResponseDto,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 408:
                raise RequestTimeoutError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def post(
        self,
        *,
        lang: typing.Optional[Lang] = OMIT,
        countries: typing.Optional[Countries] = OMIT,
        predefined_sources: typing.Optional[PredefinedSources] = OMIT,
        source_name: typing.Optional[SourceName] = OMIT,
        source_url: typing.Optional[SourceUrl] = OMIT,
        include_additional_info: typing.Optional[IncludeAdditionalInfo] = OMIT,
        is_news_domain: typing.Optional[IsNewsDomain] = OMIT,
        news_domain_type: typing.Optional[NewsDomainType] = OMIT,
        news_type: typing.Optional[NewsType] = OMIT,
        from_rank: typing.Optional[FromRank] = OMIT,
        to_rank: typing.Optional[ToRank] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[SourcesResponseDto]:
        """
        Retrieves the list of sources available in the database. You can filter the sources by language, country, and more.

        Parameters
        ----------
        lang : typing.Optional[Lang]

        countries : typing.Optional[Countries]

        predefined_sources : typing.Optional[PredefinedSources]

        source_name : typing.Optional[SourceName]

        source_url : typing.Optional[SourceUrl]

        include_additional_info : typing.Optional[IncludeAdditionalInfo]

        is_news_domain : typing.Optional[IsNewsDomain]

        news_domain_type : typing.Optional[NewsDomainType]

        news_type : typing.Optional[NewsType]

        from_rank : typing.Optional[FromRank]

        to_rank : typing.Optional[ToRank]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[SourcesResponseDto]
            A successful response containing a list of news sources that match the specified criteria.
        """
        _response = self._client_wrapper.httpx_client.request(
            "api/sources",
            method="POST",
            json={
                "lang": convert_and_respect_annotation_metadata(object_=lang, annotation=Lang, direction="write"),
                "countries": convert_and_respect_annotation_metadata(
                    object_=countries, annotation=Countries, direction="write"
                ),
                "predefined_sources": convert_and_respect_annotation_metadata(
                    object_=predefined_sources, annotation=PredefinedSources, direction="write"
                ),
                "source_name": convert_and_respect_annotation_metadata(
                    object_=source_name, annotation=SourceName, direction="write"
                ),
                "source_url": convert_and_respect_annotation_metadata(
                    object_=source_url, annotation=SourceUrl, direction="write"
                ),
                "include_additional_info": include_additional_info,
                "is_news_domain": is_news_domain,
                "news_domain_type": news_domain_type,
                "news_type": convert_and_respect_annotation_metadata(
                    object_=news_type, annotation=NewsType, direction="write"
                ),
                "from_rank": from_rank,
                "to_rank": to_rank,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourcesResponseDto,
                    parse_obj_as(
                        type_=SourcesResponseDto,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 408:
                raise RequestTimeoutError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawSourcesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def get(
        self,
        *,
        lang: typing.Optional[str] = None,
        countries: typing.Optional[str] = None,
        predefined_sources: typing.Optional[str] = None,
        source_name: typing.Optional[str] = None,
        source_url: typing.Optional[str] = None,
        include_additional_info: typing.Optional[bool] = None,
        is_news_domain: typing.Optional[bool] = None,
        news_domain_type: typing.Optional[SourcesGetRequestNewsDomainType] = None,
        news_type: typing.Optional[str] = None,
        from_rank: typing.Optional[int] = None,
        to_rank: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SourcesResponseDto]:
        """
        Retrieves a list of sources based on specified criteria such as language, country, rank, and more.

        Parameters
        ----------
        lang : typing.Optional[str]
            The language(s) of the search. The only accepted format is the two-letter [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) code. To select multiple languages, use a comma-separated string.

            Example: `"en, es"`

            To learn more, see [Enumerated parameters > Language](/docs/v3/api-reference/overview/enumerated-parameters#language-lang-and-not-lang).

        countries : typing.Optional[str]
            The countries where the news publisher is located. The accepted format is the two-letter [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) code. To select multiple countries, use a comma-separated string.

            Example: `"US, CA"`

            To learn more, see [Enumerated parameters > Country](/docs/v3/api-reference/overview/enumerated-parameters#country-country-and-not-country).

        predefined_sources : typing.Optional[str]
            Predefined top news sources per country.

            Format: start with the word `top`, followed by the number of desired sources, and then the two-letter country code [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). Multiple countries with the number of top sources can be specified as a comma-separated string.

            Examples:
            - `"top 100 US"`
            - `"top 33 AT"`
            - `"top 50 US, top 20 GB"`
            - `"top 33 AT, top 50 IT"`

        source_name : typing.Optional[str]
            Word or phrase to search within the source names. To specify multiple values, use a comma-separated string.

            Example: `"sport, tech"`

            **Note**: The search doesn't require an exact match and returns sources containing the specified terms in their names. You can use any word or phrase, like `"sport"` or `"new york times"`. For example, `"sport"` returns sources such as `"Motorsport"`, `"Dot Esport"`, and `"Tuttosport"`.

        source_url : typing.Optional[str]
            The domain(s) of the news publication to search for.

            **Caution**:  When specifying the `source_url` parameter,
            you can only use `include_additional_info` as an extra parameter.

        include_additional_info : typing.Optional[bool]
            If true, returns the following additional datapoints about each news source:
            - `nb_articles_for_7d`: The number of articles published by the source in the last week.
            - `country`: Source country of origin.
            - `rank`: SEO rank.
            - `is_news_domain`: Boolean indicating if the source is a news domain.
            - `news_domain_type`: Type of news domain (e.g., "Original Content").
            - `news_type`: Category of news (e.g., "General News Outlets").

        is_news_domain : typing.Optional[bool]
            If true, filters results to include only news domains.

        news_domain_type : typing.Optional[SourcesGetRequestNewsDomainType]
            Filters results based on the news domain type. Possible values are:
            - `Original Content`: Sources that produce their own content.
            - `Aggregator`: Sources that collect content from various other sources.
            - `Press Releases`: Sources primarily publishing press releases.
            - `Republisher`: Sources that republish content from other sources.
            - `Other`: Sources that don't fit into main categories.

        news_type : typing.Optional[str]
            Filters results based on the news type. Multiple types can be specified using a comma-separated string.

            Example: `"General News Outlets,Tech News and Updates"`

            For a complete list of available news types, see [Enumerated parameters > News type](/docs/v3/api-reference/overview/enumerated-parameters#news-type-news-type).

        from_rank : typing.Optional[int]
            The lowest boundary of the rank of a news website to filter by. A lower rank indicates a more popular source.

        to_rank : typing.Optional[int]
            The highest boundary of the rank of a news website to filter by. A lower rank indicates a more popular source.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SourcesResponseDto]
            A successful response containing a list of news sources that match the specified criteria.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/sources",
            method="GET",
            params={
                "lang": lang,
                "countries": countries,
                "predefined_sources": predefined_sources,
                "source_name": source_name,
                "source_url": source_url,
                "include_additional_info": include_additional_info,
                "is_news_domain": is_news_domain,
                "news_domain_type": news_domain_type,
                "news_type": news_type,
                "from_rank": from_rank,
                "to_rank": to_rank,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourcesResponseDto,
                    parse_obj_as(
                        type_=SourcesResponseDto,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 408:
                raise RequestTimeoutError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def post(
        self,
        *,
        lang: typing.Optional[Lang] = OMIT,
        countries: typing.Optional[Countries] = OMIT,
        predefined_sources: typing.Optional[PredefinedSources] = OMIT,
        source_name: typing.Optional[SourceName] = OMIT,
        source_url: typing.Optional[SourceUrl] = OMIT,
        include_additional_info: typing.Optional[IncludeAdditionalInfo] = OMIT,
        is_news_domain: typing.Optional[IsNewsDomain] = OMIT,
        news_domain_type: typing.Optional[NewsDomainType] = OMIT,
        news_type: typing.Optional[NewsType] = OMIT,
        from_rank: typing.Optional[FromRank] = OMIT,
        to_rank: typing.Optional[ToRank] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[SourcesResponseDto]:
        """
        Retrieves the list of sources available in the database. You can filter the sources by language, country, and more.

        Parameters
        ----------
        lang : typing.Optional[Lang]

        countries : typing.Optional[Countries]

        predefined_sources : typing.Optional[PredefinedSources]

        source_name : typing.Optional[SourceName]

        source_url : typing.Optional[SourceUrl]

        include_additional_info : typing.Optional[IncludeAdditionalInfo]

        is_news_domain : typing.Optional[IsNewsDomain]

        news_domain_type : typing.Optional[NewsDomainType]

        news_type : typing.Optional[NewsType]

        from_rank : typing.Optional[FromRank]

        to_rank : typing.Optional[ToRank]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[SourcesResponseDto]
            A successful response containing a list of news sources that match the specified criteria.
        """
        _response = await self._client_wrapper.httpx_client.request(
            "api/sources",
            method="POST",
            json={
                "lang": convert_and_respect_annotation_metadata(object_=lang, annotation=Lang, direction="write"),
                "countries": convert_and_respect_annotation_metadata(
                    object_=countries, annotation=Countries, direction="write"
                ),
                "predefined_sources": convert_and_respect_annotation_metadata(
                    object_=predefined_sources, annotation=PredefinedSources, direction="write"
                ),
                "source_name": convert_and_respect_annotation_metadata(
                    object_=source_name, annotation=SourceName, direction="write"
                ),
                "source_url": convert_and_respect_annotation_metadata(
                    object_=source_url, annotation=SourceUrl, direction="write"
                ),
                "include_additional_info": include_additional_info,
                "is_news_domain": is_news_domain,
                "news_domain_type": news_domain_type,
                "news_type": convert_and_respect_annotation_metadata(
                    object_=news_type, annotation=NewsType, direction="write"
                ),
                "from_rank": from_rank,
                "to_rank": to_rank,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    SourcesResponseDto,
                    parse_obj_as(
                        type_=SourcesResponseDto,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 408:
                raise RequestTimeoutError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        str,
                        parse_obj_as(
                            type_=str,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
