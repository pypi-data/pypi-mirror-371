r'''
# cdk-library-cloudwatch-alarms

WIP - Library to provide constructs, aspects, and construct extensions to more easily set up alarms for AWS resources in CDK code based on AWS recommended alarms list. This project is still in early development so YMMV.

## Usage

This library is flexible in its approach and there are multiple paths to configuring alarms depending on how you'd like to work with the recommended alarms.

## Feature Availability

Intended feature list as of Aug 2024

* [x] Aspects to apply recommended alarms to a wide scope such as a whole CDK app

  * [x] Ability to exclude specific alarms
  * [x] Ability to define a default set of alarm actions
  * [x] Ability to modify the configuration of each alarm type
  * [ ] Ability to exclude specific resources
* [x] Constructs to ease alarm configuration for individual resources at a granular scope

  * [x] Constructs for each available alarm according to the coverage table
  * [x] Constructs for applying all recommended alarms to a specific resource
  * [x] Ability to exclude specific alarms from the all recommended alarms construct
* [x] Extended versions of resource constructs with alarm helper methods

## Resource Coverage

If it's not shown it hasn't been worked on.

| Service   | Status | Notes |
| --- | --- | --- |
| S3  | - [x] 4xxErrors<br>- [x] 5xxErrors<br>- [ ] OperationsFailedReplication | Replication errors are difficult to set up in CDK at the moment due to rule properties being IResolvables and replication rules not being available on the L2 Bucket construct |
| SQS | - [x] ApproximateAgeOfOldestMessage<br>- [x] ApproximateNumberOfMessagesNotVisible<br>- [x] ApproximateNumberOfMessagesVisible<br>- [x] NumberOfMessagesSent |- All alarms with the exception of number of messages sent require a user defined threshold because its very use-case specific.<br>- The Aspect only assigns DLQs the `ApproximateNumberOfMessagesVisible` alarm with a default threshold of 0, unless `dlqsGetFullRecommendedAlarms` is `true`, in which case they get the same alarms as other queues. DLQs that belong to a main queue which isn't in the same scope as the Aspect is added to won't be detected as DLQs and they will be treated as normal queues. |
| SNS | - [x] NumberOfMessagesPublished<br>- [x] NumberOfNotificationsDelivered<br>- [x] NumberOfNotificationsFailed<br>- [x] NumberOfNotificationsFilteredOut-InvalidAttributes<br>- [x] NumberOfNotificationsFilteredOut-InvalidMessageBody<br>- [x] NumberOfNotificationsRedrivenToDlq<br>- [x] NumberOfNotificationsFailedToRedriveToDlq<br>- [ ] SMSMonthToDateSpentUSD<br>- [ ] SMSSuccessRate | Some alarms require a threshold to be defined. SMS alarms are not implememented. |
| Lambda | - [ ] ClaimedAccountConcurrency<br>- [x] Errors<br>- [x] Throttles<br>- [x] Duration<br>- [x] ConcurrentExecutions | ClaimedAccountConcurrency is account wide and one time so not covered by this library at this time |
| RDS | **For database & cluster instances**<br>- [x] CPUUtilization<br>- [x] DatabaseConnections<br>- [x] FreeableMemory<br>- [x] FreeLocalStorage<br>- [x] FreeStorageSpace<br>- [x] ReadLatency<br>- [x] WriteLatency<br>- [x] DBLoad<br><br>**For clusters**<br>- [x] AuroraVolumeBytesLeftTotal<br>- [x] AuroraBinlogReplicaLag | Some alarms require a `threshold` to be defined. `AuroraVolumeBytesLeftTotal` and `AuroraBinlogReplicaLag` alarms are created only for Aurora MySQL clusters. |
| ECS | - [x] CPUUtilization<br>- [x] MemoryUtilization<br>- [x] EphemeralStorageUtilized<br>- [x] RunningTaskCount | The alarms are applied to `FargateService` constructs only. `EphemeralStorageUtilized` requires a `threshold` to be defined. |
| EFS | - [x] PercentIOLimit<br>- [x] BurstCreditBalance | The alarms are applied to `FileSystem` constructs. |
| ApiGateway | - [x] 4XXError<br>- [x] 5XXError<br>- [x] Latency | The alarms are applied to `RestApi` constructs only. Alarms are automatically created using the `ApiName` and `Stage` dimensions. To create Latency alarms using the `Resource` and `Method` dimensions, the corresponding properties must be explicitly specified. |
| CloudFront | - [x] 5xxErrorRate<br>- [x] OriginLatency<br>- [x] FunctionValidationErrors<br>- [x] FunctionExecutionErrors<br>- [x] FunctionThrottles | The alarms are applied to `Distribution` constructs only. Both `5xxErrorRate` and `OriginLatency` require a `threshold` to be defined. To create `Function` level alarms using the `FunctionName` dimension, the corresponding properties must be explicitly specified. |
| DynamoDB | **Mandatory alarms**<br>- [x] ReadThrottleEvents<br>- [x] SystemErrors<br>- [x] WriteThrottleEvents<br><br>**Replication alarms (optional)**<br>- [x] AgeOfOldestUnreplicatedRecord<br>- [x] FailedToReplicateRecordCount<br>- [x] ThrottledPutRecordCount | The alarms are applied to `Table` constructs only. All the mandatory alarms require a `threshold` to be defined.<br>Replication alarms are created only if the corresponding configuration is specified. Each replication alarm has a default `DelegatedOperation` dimension value:<br>- AgeOfOldestUnreplicatedRecord: `StreamRecords`<br>- FailedToReplicateRecordCount: `StreamRecords`<br>- ThrottledPutRecordCount: `PutItem` |
| EC2 | <br>- [x] CPUUtilization<br>- [x] StatusCheckFailed<br><br> | The alarms are applied to `Instance` constructs. |
| AutoScaling | <br>- [x] GroupInServiceCapacity<br><br> | The alarms are applied to `AutoScalingGroup` constructs. The alarm requires a `threshold` to be defined and the `AutoScalingGroup` should have this metric explicitly enabled. |
| ElastiCache | <br>- [x] DatabaseMemoryUsagePercentage<br>- [x] EngineCPUUtilization<br>- [x] ReplicationLag<br> | The alarms are applied to `CfnCacheCluster` and `CfnReplicationGroup` constructs. `DatabaseMemoryUsagePercentage` and `ReplicationLag` require a `threshold` to be defined.|
| PrivateLink | **Endpoints**<br>- [x] PacketsDropped<br><br>**Endpoint Services**<br>- [x] RstPacketsSent<br> | The alarms are applied to `InterfaceVpcEndpoint` and `VpcEndpointService` constructs. Because these objects do not expose the attributes required by alarms, they cannot be implemented using the `Aspect`. In all cases, the `threshold` must be defined. |
| VPN | <br>- [x] TunnelState<br><br> | The alarms are applied to `CfnVPNConnection` constructs. |
| ELBv2 | **For ApplicationLoadBalancer**<br>- [x] RejectedConnectionCount<br>- [x] HTTPCode_ELB_4XX_Count<br>- [x] HTTPCode_ELB_5XX_Count<br>- [x] HTTPCode_Target_5XX_Count<br><br>**For ApplicationTargetGroup**<br>- [x] HealthyHostCount<br>- [x] UnHealthyHostCount<br><br>**For NetworkLoadBalancer**<br>- [x] TCP_ELB_Reset_Count<br>- [x] TCP_Target_Reset_Count<br><br>**For NetworkTargetGroup**<br>- [x] HealthyHostCount<br>- [x] UnHealthyHostCount |- For target groups, `HealthyHostCount` alarm triggers when count falls below threshold (default: 1) and `UnHealthyHostCount` alarm triggers when count exceeds threshold (default: 0). For load balancers, all alarms trigger when count exceeds threshold (default: 0).<br>- The `HTTPCode_ELB_4XX_Count` and `HTTPCode_ELB_5XX_Count` alarms are defined as anomaly detection alarms instead of flat counts, because there is normally a constant background of such errors. |
| DMS | **For ReplicationInstances**<br>- [x] CPUUtilization<br>- [x] FreeableMemory<br>- [x] FreeStorageSpace<br>- [x] WriteIOPS<br>- [x] SwapUsage<br><br>**For Replication Tasks**<br>- [x] CDCLatencySource<br>- [x] CDCLatencyTarget | The alarms are applied to `CfnReplicationInstance` and `CfnReplicationTask` constructs. Extended versions `ReplicationInstance` and `ReplicationTask` are also available with alarm helper methods.<br><br>**Replication Instance Notes:**<br>- `FreeableMemory` and `FreeStorageSpace` alarms require a `threshold` to be defined.<br>- `SwapUsage` alarm uses anomaly detection with a fixed 5-minute period (as required by AWS CloudWatch) to detect high swap usage that may indicate memory pressure or performance issues. By default, it triggers when swap usage exceeds the upper threshold of the anomaly detection band, but the `comparisonOperator` can be configured to detect other patterns.<br><br>**Replication Task Notes:**<br>- Alarms are created and validated based on the `migrationType` of the ReplicationTask. CDC-related alarms can only be created for `cdc` or `full-load-and-cdc` migration types.<br>- CDC latency alarms (`CDCLatencySource` and `CDCLatencyTarget`) default to detecting high latency issues (threshold: 300 seconds, comparison: GREATER_THAN_THRESHOLD) which can indicate replication lag or database performance problems.<br>- The `CDCLatencySource` alarm monitors the gap between the last event captured from the source endpoint and current system time, while `CDCLatencyTarget` monitors the gap between a change committed to the source and the same change committed to the target. |

### Aspects

Below is an example of configuring the Lambda aspect. You must configure non-defaults for alarms which is most cases is only a `threshold`. Since the aspect is applied at the `app` level it applies to both the `TestStack` and `TestStack2` lambda functions and will create all available recommended alarms for those functions. See references for additional details on Aspects which can be applied to the app, stack, or individual constructs depending on your use case.

```python
import { App, Stack, Aspects, aws_lambda as lambda } from 'aws-cdk-lib';
import * as recommendedalarms from '@renovosolutions/cdk-library-cloudwatch-alarms';

const app = new App();
const stack = new Stack(app, 'TestStack', {
  env: {
    account: '123456789012',
    region: 'us-east-1',
  },
});

const stack2 = new Stack(app, 'TestStack2', {
  env: {
    account: '123456789012',
    region: 'us-east-1',
  },
});

const appAspects = Aspects.of(app);

appAspects.add(
  new recommendedalarms.LambdaRecommendedAlarmsAspect({
    configDurationAlarm: {
      threshold: 15,
    },
    configErrorsAlarm: {
      threshold: 1,
    },
    configThrottlesAlarm: {
      threshold: 0,
    },
  }),
);

new lambda.Function(stack, 'Lambda', {
  runtime: lambda.Runtime.NODEJS_20_X,
  handler: 'index.handler',
  code: lambda.Code.fromInline('exports.handler = async (event) => { console.log(event); }'),
});

new lambda.Function(stack2, 'Lambda2', {
  runtime: lambda.Runtime.NODEJS_20_X,
  handler: 'index.handler',
  code: lambda.Code.fromInline('exports.handler = async (event) => { console.log(event); }'),
});
```

### Recommended Alarm Constructs

You can also apply alarms to a specific resource using the recommended alarm construct for a given resource type. For example if you have an S3 Bucket you might do something like below. None of the S3 alarms require configuration so no config props are needed in this case:

```python
import { App, Stack, Aspects, aws_s3 as s3 } from 'aws-cdk-lib';
import * as recommendedalarms from '@renovosolutions/cdk-library-cloudwatch-alarms';

const app = new App();
const stack = new Stack(app, 'TestStack', {
  env: {
    account: '123456789012',
    region: 'us-east-1',
  },
});

const bucket = new s3.Bucket(stack, 'Bucket', {});

new recommendedalarms.S3RecommendedAlarms(stack, 'RecommendedAlarms', {
  bucket,
});
```

### Individual Constructs

You can also apply specific alarms from their individual constructs:

```python
import { App, Stack, Aspects, aws_s3 as s3 } from 'aws-cdk-lib';
import * as recommendedalarms from '@renovosolutions/cdk-library-cloudwatch-alarms';

const app = new App();
const stack = new Stack(app, 'TestStack', {
  env: {
    account: '123456789012',
    region: 'us-east-1',
  },
});

const bucket = new s3.Bucket(stack, 'Bucket', {});

new recommendedalarms.S3Bucket5xxErrorsAlarm(stack, 'RecommendedAlarms', {
  bucket,
  threshold: 0.10,
});
```

### Construct Extensions

You can use extended versions of the constructs you are familiar with to expose helper methods for alarms if you'd like to keep alarms more tightly coupled to specific resources.

```python
import { App, Stack, Aspects, aws_s3 as s3 } from 'aws-cdk-lib';
import * as recommendedalarms from '@renovosolutions/cdk-library-cloudwatch-alarms';

const app = new App();
const stack = new Stack(app, 'TestStack', {
  env: {
    account: '123456789012',
    region: 'us-east-1',
  },
});

  const bucket = new recommendedalarms.Bucket(stack, 'Bucket', {});

  bucket.applyRecommendedAlarms();
```

### Alarm Actions

You can apply alarm actions using the default actions on an aspect or all recommended alarms construct or you can apply individual alarm actions for helper methods of individual constructs. See below where default actions are set but an override is set for a specific alarm for the alarm action to use a different SNS topic.

```python
import { App, Stack, Aspects, aws_lambda as lambda } from 'aws-cdk-lib';
import * as recommendedalarms from '@renovosolutions/cdk-library-cloudwatch-alarms';

const app = new App();
const stack = new Stack(app, 'TestStack', {
  env: {
    account: '123456789012',
    region: 'us-east-1',
  },
});

const stack2 = new Stack(app, 'TestStack2', {
  env: {
    account: '123456789012',
    region: 'us-east-1',
  },
});

const alarmTopic = new sns.Topic(stack, 'Topic');
const topicAction =  new cloudwatch_actions.SnsAction(alarmTopic)

const alarmTopic2 = new sns.Topic(stack, 'Topic');
const topicAction2 =  new cloudwatch_actions.SnsAction(alarmTopic2)

const appAspects = Aspects.of(app);

appAspects.add(
  new recommendedalarms.LambdaRecommendedAlarmsAspect({
    defaultAlarmAction: topicAction,
    defaultOkAction: topicAction,
    defaultInsufficientDataAction: topicAction,
    configDurationAlarm: {
      threshold: 15,
      alarmAction: topicAction2,
    },
    configErrorsAlarm: {
      threshold: 1,
    },
    configThrottlesAlarm: {
      threshold: 0,
    },

  }),
);

new lambda.Function(stack, 'Lambda', {
  runtime: lambda.Runtime.NODEJS_20_X,
  handler: 'index.handler',
  code: lambda.Code.fromInline('exports.handler = async (event) => { console.log(event); }'),
});

new lambda.Function(stack2, 'Lambda2', {
  runtime: lambda.Runtime.NODEJS_20_X,
  handler: 'index.handler',
  code: lambda.Code.fromInline('exports.handler = async (event) => { console.log(event); }'),
});
```

### Exclusions

You can exclude specific alarms or specific resources. Alarms use the available metrics enums and resources use the string used for a resources id. For example below Lambda1 will not have alarms created and there will be no alarm for the Duration metric for either lambda function.

```python
import { App, Stack, Aspects, aws_lambda as lambda } from 'aws-cdk-lib';
import * as recommendedalarms from '@renovosolutions/cdk-library-cloudwatch-alarms';

const app = new App();
const stack = new Stack(app, 'TestStack', {
  env: {
    account: '123456789012', // not a real account
    region: 'us-east-1',
  },
});

const appAspects = Aspects.of(app);

appAspects.add(
  new recommendedalarms.LambdaRecommendedAlarmsAspect({
    excludeResources: ['Lambda1'],
    excludeAlarms: [recommendedalarms.LambdaRecommendedAlarmsMetrics.DURATION],
    configDurationAlarm: {
      threshold: 15,
    },
    configErrorsAlarm: {
      threshold: 1,
    },
    configThrottlesAlarm: {
      threshold: 0,
    },
  }),
);

new lambda.Function(stack, 'Lambda1', {
  runtime: lambda.Runtime.NODEJS_20_X,
  handler: 'index.handler',
  code: lambda.Code.fromInline('exports.handler = async (event) => { console.log(event); }'),
});

new lambda.Function(stack, 'Lambda2', {
  runtime: lambda.Runtime.NODEJS_20_X,
  handler: 'index.handler',
  code: lambda.Code.fromInline('exports.handler = async (event) => { console.log(event); }'),
});
```

## References

* [AWS Recommended Alarms](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html)
* [Aspects and the AWS CDK](https://docs.aws.amazon.com/cdk/v2/guide/aspects.html)
'''
from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

import typeguard
from importlib.metadata import version as _metadata_package_version
TYPEGUARD_MAJOR_VERSION = int(_metadata_package_version('typeguard').split('.')[0])

def check_type(argname: str, value: object, expected_type: typing.Any) -> typing.Any:
    if TYPEGUARD_MAJOR_VERSION <= 2:
        return typeguard.check_type(argname=argname, value=value, expected_type=expected_type) # type:ignore
    else:
        if isinstance(value, jsii._reference_map.InterfaceDynamicProxy): # pyright: ignore [reportAttributeAccessIssue]
           pass
        else:
            if TYPEGUARD_MAJOR_VERSION == 3:
                typeguard.config.collection_check_strategy = typeguard.CollectionCheckStrategy.ALL_ITEMS # type:ignore
                typeguard.check_type(value=value, expected_type=expected_type) # type:ignore
            else:
                typeguard.check_type(value=value, expected_type=expected_type, collection_check_strategy=typeguard.CollectionCheckStrategy.ALL_ITEMS) # type:ignore

from ._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.aws_apigateway as _aws_cdk_aws_apigateway_ceddda9d
import aws_cdk.aws_autoscaling as _aws_cdk_aws_autoscaling_ceddda9d
import aws_cdk.aws_certificatemanager as _aws_cdk_aws_certificatemanager_ceddda9d
import aws_cdk.aws_cloudfront as _aws_cdk_aws_cloudfront_ceddda9d
import aws_cdk.aws_cloudwatch as _aws_cdk_aws_cloudwatch_ceddda9d
import aws_cdk.aws_codeguruprofiler as _aws_cdk_aws_codeguruprofiler_ceddda9d
import aws_cdk.aws_dms as _aws_cdk_aws_dms_ceddda9d
import aws_cdk.aws_dynamodb as _aws_cdk_aws_dynamodb_ceddda9d
import aws_cdk.aws_ec2 as _aws_cdk_aws_ec2_ceddda9d
import aws_cdk.aws_ecs as _aws_cdk_aws_ecs_ceddda9d
import aws_cdk.aws_efs as _aws_cdk_aws_efs_ceddda9d
import aws_cdk.aws_elasticache as _aws_cdk_aws_elasticache_ceddda9d
import aws_cdk.aws_elasticloadbalancingv2 as _aws_cdk_aws_elasticloadbalancingv2_ceddda9d
import aws_cdk.aws_iam as _aws_cdk_aws_iam_ceddda9d
import aws_cdk.aws_kinesis as _aws_cdk_aws_kinesis_ceddda9d
import aws_cdk.aws_kms as _aws_cdk_aws_kms_ceddda9d
import aws_cdk.aws_lambda as _aws_cdk_aws_lambda_ceddda9d
import aws_cdk.aws_logs as _aws_cdk_aws_logs_ceddda9d
import aws_cdk.aws_rds as _aws_cdk_aws_rds_ceddda9d
import aws_cdk.aws_s3 as _aws_cdk_aws_s3_ceddda9d
import aws_cdk.aws_sns as _aws_cdk_aws_sns_ceddda9d
import aws_cdk.aws_sqs as _aws_cdk_aws_sqs_ceddda9d
import aws_cdk.aws_stepfunctions as _aws_cdk_aws_stepfunctions_ceddda9d
import constructs as _constructs_77d1e7e8


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AlarmBaseProps",
    jsii_struct_bases=[],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
    },
)
class AlarmBaseProps:
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''The base properties for an alarm where default values are consistent across all alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc8826645a1e265ceca74e67c468d47f270a951fd40c4c3bcf8922d80e34f685)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AlarmBaseProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class ApiGatewayAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e54942d9ca84322e711834f10d9871f12b5b1db8f6c7ba78a04be36a6ef964d3)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayDetailedAlarmConfig",
    jsii_struct_bases=[],
    name_mapping={"alias": "alias", "method": "method", "resource": "resource"},
)
class ApiGatewayDetailedAlarmConfig:
    def __init__(
        self,
        *,
        alias: builtins.str,
        method: builtins.str,
        resource: builtins.str,
    ) -> None:
        '''The common properties for the ApiGateway alarms when monitoring resource and method dimensions.

        :param alias: The alias of the resource to monitor, used as a discriminator in the alarm name.
        :param method: The method to monitor.
        :param resource: The resource to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b738b8ed888082c8147d9927f30bb1527cd7d2adae3d35bc55db2497661cb734)
            check_type(argname="argument alias", value=alias, expected_type=type_hints["alias"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "alias": alias,
            "method": method,
            "resource": resource,
        }

    @builtins.property
    def alias(self) -> builtins.str:
        '''The alias of the resource to monitor, used as a discriminator in the alarm name.'''
        result = self._values.get("alias")
        assert result is not None, "Required property 'alias' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def method(self) -> builtins.str:
        '''The method to monitor.'''
        result = self._values.get("method")
        assert result is not None, "Required property 'method' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource(self) -> builtins.str:
        '''The resource to monitor.'''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayDetailedAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayLatencyAlarmConfig",
    jsii_struct_bases=[ApiGatewayAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ApiGatewayLatencyAlarmConfig(ApiGatewayAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the Latency alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        :param alarm_name: The alarm name. Default: - apiName + ' - Latency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in milliseconds against which the specified statistic is compared. The suggested threshold value does not work for all API workloads. However, you can use it as a starting point for the threshold. You can then choose different threshold values based on the workload and acceptable latency, performance, and SLA requirements for the API. If it is acceptable for the API to have a higher latency in general, you can set a higher threshold value to make the alarm less sensitive. However, if the API is expected to provide near real-time responses, set a lower threshold value. You can also analyze historical data to determine what the expected baseline latency is for the application workload and then tune the threshold value accordingly. Default: 2500
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af66f83026ae14035872eb925fb9762936db50a2d9af5223e9a1999fef40b564)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - apiName + ' - Latency'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value in milliseconds against which the specified statistic is compared.

        The suggested threshold value does not work for all API workloads. However, you can
        use it as a starting point for the threshold. You can then choose different threshold
        values based on the workload and acceptable latency, performance, and SLA requirements
        for the API. If it is acceptable for the API to have a higher latency in general, you
        can set a higher threshold value to make the alarm less sensitive. However, if the API
        is expected to provide near real-time responses, set a lower threshold value. You can
        also analyze historical data to determine what the expected baseline latency is for the
        application workload and then tune the threshold value accordingly.

        :default: 2500
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayLatencyAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class ApiGatewayRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an ApiGateway api.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ApiGateway
    '''

    def __init__(
        self,
        *,
        config4_xx_error_alarm: typing.Union["ApiGateway4XXErrorAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config5_xx_error_alarm: typing.Union["ApiGateway5XXErrorAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_detailed_latency_alarm_list: typing.Optional[typing.Sequence[typing.Union["ApiGatewayRestApiDetailedLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_latency_alarm: typing.Optional[typing.Union[ApiGatewayLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ApiGatewayRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config4_xx_error_alarm: The configuration for the 4XXError alarm.
        :param config5_xx_error_alarm: The configuration for the 5XXError alarm.
        :param config_detailed_latency_alarm_list: The configuration list for the detailed Latency alarm.
        :param config_latency_alarm: The configuration for the Latency alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApiGatewayRestApiRecommendedAlarmsConfig(
            config4_xx_error_alarm=config4_xx_error_alarm,
            config5_xx_error_alarm=config5_xx_error_alarm,
            config_detailed_latency_alarm_list=config_detailed_latency_alarm_list,
            config_latency_alarm=config_latency_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e62e04f8ba2a25d8da7c4c62dc069c586365c7f82dc177931df4e3c001a96bc)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRecommendedAlarmsMetrics"
)
class ApiGatewayRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for ApiGateway alarms.'''

    ERROR_4XX = "ERROR_4XX"
    '''The number of client-side errors captured in a given period.'''
    ERROR_5XX = "ERROR_5XX"
    '''The number of server-side errors captured in a given period.'''
    LATENCY = "LATENCY"
    '''The time (milliseconds) between when API Gateway receives a request from a client and when it returns a response to the client.

    The latency includes the integration latency
    and other API Gateway overhead.
    '''


class ApiGatewayRestApi4XXErrorAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApi4XXErrorAlarm",
):
    '''This alarm detects a high number of client-side errors.

    This can indicate an issue in the authorization or client request parameters. It could also mean that a resource was
    removed or a client is requesting one that doesn't exist. Consider enabling CloudWatch Logs and checking for any errors
    that may be causing the 4XX errors. Moreover, consider enabling detailed CloudWatch metrics to view this metric per
    resource and method and narrow down the source of the errors. Errors could also be caused by exceeding the configured
    throttling limit.

    The alarm is triggered when number of client-errors exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param api: The ApiGateway api to monitor.
        :param threshold: The threshold value against which the specified statistic is compared.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect high rates of client-side errors for the API Gateway requests.
        :param alarm_name: The alarm name. Default: - apiName + ' - 4XXError'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. The unit is an absolute count of errors, not a percentage. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70d8eae524a7a121a49e99ed70fd871aeaf2f0e077a7ce674545b16491c88c70)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApiGatewayRestApi4XXErrorAlarmProps(
            api=api,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class ApiGatewayRestApi5XXErrorAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApi5XXErrorAlarm",
):
    '''This alarm detects a high number of server-side errors.

    This can indicate that there is something wrong on the API backend, the network,
    or the integration between the API gateway and the backend API.

    The alarm is triggered when number of server-errors exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param api: The ApiGateway api to monitor.
        :param threshold: The threshold value against which the specified statistic is compared.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect high rates of server-side errors for the API Gateway requests.
        :param alarm_name: The alarm name. Default: - apiName + ' - 5XXError'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. The unit is an absolute count of errors, not a percentage. Default: 3
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31e0f1eee097369efcdc8a765f803822803c1eab334220d1367cd756cb2b0f90)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApiGatewayRestApi5XXErrorAlarmProps(
            api=api,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApiAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"api": "api"},
)
class ApiGatewayRestApiAlarmProps:
    def __init__(self, *, api: _aws_cdk_aws_apigateway_ceddda9d.RestApi) -> None:
        '''The common properties for the ApiGateway RestApi alarms.

        :param api: The ApiGateway api to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f45987f7120127b2029405a7439b3c1968587a38de51a9ddff363c437b24af70)
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api": api,
        }

    @builtins.property
    def api(self) -> _aws_cdk_aws_apigateway_ceddda9d.RestApi:
        '''The ApiGateway api to monitor.'''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(_aws_cdk_aws_apigateway_ceddda9d.RestApi, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayRestApiAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApiGatewayRestApiDetailedLatencyAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApiDetailedLatencyAlarm",
):
    '''This alarm detects high latency for a resource and method in a stage.

    Find the IntegrationLatency metric value to check the API backend latency. If the two
    metrics are mostly aligned, the API backend is the source of higher latency and you should
    investigate there for performance issues. Consider also enabling CloudWatch Logs and checking
    for any errors that might be causing the high latency.

    The alarm is triggered when time in milliseconds exceeds or equals the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alias: builtins.str,
        method: builtins.str,
        resource: builtins.str,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param api: The ApiGateway api to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        :param alarm_name: The alarm name. Default: - apiName + ' - Latency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in milliseconds against which the specified statistic is compared. The suggested threshold value does not work for all API workloads. However, you can use it as a starting point for the threshold. You can then choose different threshold values based on the workload and acceptable latency, performance, and SLA requirements for the API. If it is acceptable for the API to have a higher latency in general, you can set a higher threshold value to make the alarm less sensitive. However, if the API is expected to provide near real-time responses, set a lower threshold value. You can also analyze historical data to determine what the expected baseline latency is for the application workload and then tune the threshold value accordingly. Default: 2500
        :param alias: The alias of the resource to monitor, used as a discriminator in the alarm name.
        :param method: The method to monitor.
        :param resource: The resource to monitor.
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__907876ec7b8663cb34d1f68a7f0cfab1c1fbf1d076e9607bc6c75ee71476dff9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApiGatewayRestApiDetailedLatencyAlarmProps(
            api=api,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            alias=alias,
            method=method,
            resource=resource,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApiDetailedLatencyAlarmConfig",
    jsii_struct_bases=[ApiGatewayLatencyAlarmConfig, ApiGatewayDetailedAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "alias": "alias",
        "method": "method",
        "resource": "resource",
    },
)
class ApiGatewayRestApiDetailedLatencyAlarmConfig(
    ApiGatewayLatencyAlarmConfig,
    ApiGatewayDetailedAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alias: builtins.str,
        method: builtins.str,
        resource: builtins.str,
    ) -> None:
        '''Configuration for the Latency alarm when monitoring resource and method dimensions.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        :param alarm_name: The alarm name. Default: - apiName + ' - Latency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in milliseconds against which the specified statistic is compared. The suggested threshold value does not work for all API workloads. However, you can use it as a starting point for the threshold. You can then choose different threshold values based on the workload and acceptable latency, performance, and SLA requirements for the API. If it is acceptable for the API to have a higher latency in general, you can set a higher threshold value to make the alarm less sensitive. However, if the API is expected to provide near real-time responses, set a lower threshold value. You can also analyze historical data to determine what the expected baseline latency is for the application workload and then tune the threshold value accordingly. Default: 2500
        :param alias: The alias of the resource to monitor, used as a discriminator in the alarm name.
        :param method: The method to monitor.
        :param resource: The resource to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__272a823eefdc7c57c3297274c586f57a5195c082b12c99716ece42fdd6dfd594)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alias", value=alias, expected_type=type_hints["alias"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "alias": alias,
            "method": method,
            "resource": resource,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - apiName + ' - Latency'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value in milliseconds against which the specified statistic is compared.

        The suggested threshold value does not work for all API workloads. However, you can
        use it as a starting point for the threshold. You can then choose different threshold
        values based on the workload and acceptable latency, performance, and SLA requirements
        for the API. If it is acceptable for the API to have a higher latency in general, you
        can set a higher threshold value to make the alarm less sensitive. However, if the API
        is expected to provide near real-time responses, set a lower threshold value. You can
        also analyze historical data to determine what the expected baseline latency is for the
        application workload and then tune the threshold value accordingly.

        :default: 2500
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def alias(self) -> builtins.str:
        '''The alias of the resource to monitor, used as a discriminator in the alarm name.'''
        result = self._values.get("alias")
        assert result is not None, "Required property 'alias' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def method(self) -> builtins.str:
        '''The method to monitor.'''
        result = self._values.get("method")
        assert result is not None, "Required property 'method' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource(self) -> builtins.str:
        '''The resource to monitor.'''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayRestApiDetailedLatencyAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApiDetailedLatencyAlarmProps",
    jsii_struct_bases=[
        ApiGatewayRestApiAlarmProps,
        ApiGatewayLatencyAlarmConfig,
        ApiGatewayDetailedAlarmConfig,
    ],
    name_mapping={
        "api": "api",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "alias": "alias",
        "method": "method",
        "resource": "resource",
    },
)
class ApiGatewayRestApiDetailedLatencyAlarmProps(
    ApiGatewayRestApiAlarmProps,
    ApiGatewayLatencyAlarmConfig,
    ApiGatewayDetailedAlarmConfig,
):
    def __init__(
        self,
        *,
        api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alias: builtins.str,
        method: builtins.str,
        resource: builtins.str,
    ) -> None:
        '''The properties for the ApiGatewayRestApiDetailedLatencyAlarm construct.

        :param api: The ApiGateway api to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        :param alarm_name: The alarm name. Default: - apiName + ' - Latency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in milliseconds against which the specified statistic is compared. The suggested threshold value does not work for all API workloads. However, you can use it as a starting point for the threshold. You can then choose different threshold values based on the workload and acceptable latency, performance, and SLA requirements for the API. If it is acceptable for the API to have a higher latency in general, you can set a higher threshold value to make the alarm less sensitive. However, if the API is expected to provide near real-time responses, set a lower threshold value. You can also analyze historical data to determine what the expected baseline latency is for the application workload and then tune the threshold value accordingly. Default: 2500
        :param alias: The alias of the resource to monitor, used as a discriminator in the alarm name.
        :param method: The method to monitor.
        :param resource: The resource to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__989b217b8af1ca5f08f13aa258cacc5cd6766752e60e13096e54cad84dcf6f63)
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alias", value=alias, expected_type=type_hints["alias"])
            check_type(argname="argument method", value=method, expected_type=type_hints["method"])
            check_type(argname="argument resource", value=resource, expected_type=type_hints["resource"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api": api,
            "alias": alias,
            "method": method,
            "resource": resource,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def api(self) -> _aws_cdk_aws_apigateway_ceddda9d.RestApi:
        '''The ApiGateway api to monitor.'''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(_aws_cdk_aws_apigateway_ceddda9d.RestApi, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - apiName + ' - Latency'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value in milliseconds against which the specified statistic is compared.

        The suggested threshold value does not work for all API workloads. However, you can
        use it as a starting point for the threshold. You can then choose different threshold
        values based on the workload and acceptable latency, performance, and SLA requirements
        for the API. If it is acceptable for the API to have a higher latency in general, you
        can set a higher threshold value to make the alarm less sensitive. However, if the API
        is expected to provide near real-time responses, set a lower threshold value. You can
        also analyze historical data to determine what the expected baseline latency is for the
        application workload and then tune the threshold value accordingly.

        :default: 2500
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def alias(self) -> builtins.str:
        '''The alias of the resource to monitor, used as a discriminator in the alarm name.'''
        result = self._values.get("alias")
        assert result is not None, "Required property 'alias' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def method(self) -> builtins.str:
        '''The method to monitor.'''
        result = self._values.get("method")
        assert result is not None, "Required property 'method' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def resource(self) -> builtins.str:
        '''The resource to monitor.'''
        result = self._values.get("resource")
        assert result is not None, "Required property 'resource' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayRestApiDetailedLatencyAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApiGatewayRestApiLatencyAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApiLatencyAlarm",
):
    '''This alarm can detect when the API Gateway requests in a stage have high latency.

    If you have detailed CloudWatch metrics enabled and you have different latency performance
    requirements for each method and resource, we recommend that you create alternative alarms to
    have more fine-grained monitoring of the latency for each resource and method.

    The alarm is triggered when time in milliseconds exceeds or equals the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param api: The ApiGateway api to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        :param alarm_name: The alarm name. Default: - apiName + ' - Latency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in milliseconds against which the specified statistic is compared. The suggested threshold value does not work for all API workloads. However, you can use it as a starting point for the threshold. You can then choose different threshold values based on the workload and acceptable latency, performance, and SLA requirements for the API. If it is acceptable for the API to have a higher latency in general, you can set a higher threshold value to make the alarm less sensitive. However, if the API is expected to provide near real-time responses, set a lower threshold value. You can also analyze historical data to determine what the expected baseline latency is for the application workload and then tune the threshold value accordingly. Default: 2500
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__de91c2b09391ec79296065ae871d152b40ed0f28d13a8fcf6419f3d8e1ddf5b3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApiGatewayRestApiLatencyAlarmProps(
            api=api,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApiLatencyAlarmProps",
    jsii_struct_bases=[ApiGatewayRestApiAlarmProps, ApiGatewayLatencyAlarmConfig],
    name_mapping={
        "api": "api",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ApiGatewayRestApiLatencyAlarmProps(
    ApiGatewayRestApiAlarmProps,
    ApiGatewayLatencyAlarmConfig,
):
    def __init__(
        self,
        *,
        api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ApiGatewayRestApiLatencyAlarm construct.

        :param api: The ApiGateway api to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        :param alarm_name: The alarm name. Default: - apiName + ' - Latency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in milliseconds against which the specified statistic is compared. The suggested threshold value does not work for all API workloads. However, you can use it as a starting point for the threshold. You can then choose different threshold values based on the workload and acceptable latency, performance, and SLA requirements for the API. If it is acceptable for the API to have a higher latency in general, you can set a higher threshold value to make the alarm less sensitive. However, if the API is expected to provide near real-time responses, set a lower threshold value. You can also analyze historical data to determine what the expected baseline latency is for the application workload and then tune the threshold value accordingly. Default: 2500
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9ee1d1edb07c07944b7c95bd346b97adda30b8cd0384bb14eac0166e5eab7f7b)
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api": api,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def api(self) -> _aws_cdk_aws_apigateway_ceddda9d.RestApi:
        '''The ApiGateway api to monitor.'''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(_aws_cdk_aws_apigateway_ceddda9d.RestApi, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - apiName + ' - Latency'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value in milliseconds against which the specified statistic is compared.

        The suggested threshold value does not work for all API workloads. However, you can
        use it as a starting point for the threshold. You can then choose different threshold
        values based on the workload and acceptable latency, performance, and SLA requirements
        for the API. If it is acceptable for the API to have a higher latency in general, you
        can set a higher threshold value to make the alarm less sensitive. However, if the API
        is expected to provide near real-time responses, set a lower threshold value. You can
        also analyze historical data to determine what the expected baseline latency is for the
        application workload and then tune the threshold value accordingly.

        :default: 2500
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayRestApiLatencyAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApiGatewayRestApiRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApiRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an ApiGateway api.

    The recommended alarms created by default for the ApiName and Stage are:

    - 4XXError alarm
    - 5XXError alarm
    - Latency alarm

    In order to create the Latency alarms for the Resource and Method dimensions the
    configDetailedLatencyAlarmList must be specified.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ApiGateway
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
        config4_xx_error_alarm: typing.Union["ApiGateway4XXErrorAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config5_xx_error_alarm: typing.Union["ApiGateway5XXErrorAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_detailed_latency_alarm_list: typing.Optional[typing.Sequence[typing.Union[ApiGatewayRestApiDetailedLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
        config_latency_alarm: typing.Optional[typing.Union[ApiGatewayLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[ApiGatewayRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param api: The ApiGateway api to monitor.
        :param config4_xx_error_alarm: The configuration for the 4XXError alarm.
        :param config5_xx_error_alarm: The configuration for the 5XXError alarm.
        :param config_detailed_latency_alarm_list: The configuration list for the detailed Latency alarm.
        :param config_latency_alarm: The configuration for the Latency alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28abc7e5840007e0028c59fe29eea994ec8b37de9da1462a8e2d5c99313a1f2b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApiGatewayRestApiRecommendedAlarmsProps(
            api=api,
            config4_xx_error_alarm=config4_xx_error_alarm,
            config5_xx_error_alarm=config5_xx_error_alarm,
            config_detailed_latency_alarm_list=config_detailed_latency_alarm_list,
            config_latency_alarm=config_latency_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarm4XXError")
    def alarm4_xx_error(self) -> typing.Optional[ApiGatewayRestApi4XXErrorAlarm]:
        '''The 4XXError alarm.'''
        return typing.cast(typing.Optional[ApiGatewayRestApi4XXErrorAlarm], jsii.get(self, "alarm4XXError"))

    @builtins.property
    @jsii.member(jsii_name="alarm5XXError")
    def alarm5_xx_error(self) -> typing.Optional[ApiGatewayRestApi5XXErrorAlarm]:
        '''The 5XXError alarm.'''
        return typing.cast(typing.Optional[ApiGatewayRestApi5XXErrorAlarm], jsii.get(self, "alarm5XXError"))

    @builtins.property
    @jsii.member(jsii_name="alarmLatency")
    def alarm_latency(self) -> typing.Optional[ApiGatewayRestApiLatencyAlarm]:
        '''The Latency alarm.'''
        return typing.cast(typing.Optional[ApiGatewayRestApiLatencyAlarm], jsii.get(self, "alarmLatency"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApiRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config4_xx_error_alarm": "config4XXErrorAlarm",
        "config5_xx_error_alarm": "config5XXErrorAlarm",
        "config_detailed_latency_alarm_list": "configDetailedLatencyAlarmList",
        "config_latency_alarm": "configLatencyAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class ApiGatewayRestApiRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config4_xx_error_alarm: typing.Union["ApiGateway4XXErrorAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config5_xx_error_alarm: typing.Union["ApiGateway5XXErrorAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_detailed_latency_alarm_list: typing.Optional[typing.Sequence[typing.Union[ApiGatewayRestApiDetailedLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
        config_latency_alarm: typing.Optional[typing.Union[ApiGatewayLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[ApiGatewayRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an ApiGateway RestApi.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config4_xx_error_alarm: The configuration for the 4XXError alarm.
        :param config5_xx_error_alarm: The configuration for the 5XXError alarm.
        :param config_detailed_latency_alarm_list: The configuration list for the detailed Latency alarm.
        :param config_latency_alarm: The configuration for the Latency alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config4_xx_error_alarm, dict):
            config4_xx_error_alarm = ApiGateway4XXErrorAlarmConfig(**config4_xx_error_alarm)
        if isinstance(config5_xx_error_alarm, dict):
            config5_xx_error_alarm = ApiGateway5XXErrorAlarmConfig(**config5_xx_error_alarm)
        if isinstance(config_latency_alarm, dict):
            config_latency_alarm = ApiGatewayLatencyAlarmConfig(**config_latency_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c4d62c1f7e7796148ba2e669b7af3d31843b5b65a3fa414ab506df073a7fb84)
            check_type(argname="argument config4_xx_error_alarm", value=config4_xx_error_alarm, expected_type=type_hints["config4_xx_error_alarm"])
            check_type(argname="argument config5_xx_error_alarm", value=config5_xx_error_alarm, expected_type=type_hints["config5_xx_error_alarm"])
            check_type(argname="argument config_detailed_latency_alarm_list", value=config_detailed_latency_alarm_list, expected_type=type_hints["config_detailed_latency_alarm_list"])
            check_type(argname="argument config_latency_alarm", value=config_latency_alarm, expected_type=type_hints["config_latency_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config4_xx_error_alarm": config4_xx_error_alarm,
            "config5_xx_error_alarm": config5_xx_error_alarm,
        }
        if config_detailed_latency_alarm_list is not None:
            self._values["config_detailed_latency_alarm_list"] = config_detailed_latency_alarm_list
        if config_latency_alarm is not None:
            self._values["config_latency_alarm"] = config_latency_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config4_xx_error_alarm(self) -> "ApiGateway4XXErrorAlarmConfig":
        '''The configuration for the 4XXError alarm.'''
        result = self._values.get("config4_xx_error_alarm")
        assert result is not None, "Required property 'config4_xx_error_alarm' is missing"
        return typing.cast("ApiGateway4XXErrorAlarmConfig", result)

    @builtins.property
    def config5_xx_error_alarm(self) -> "ApiGateway5XXErrorAlarmConfig":
        '''The configuration for the 5XXError alarm.'''
        result = self._values.get("config5_xx_error_alarm")
        assert result is not None, "Required property 'config5_xx_error_alarm' is missing"
        return typing.cast("ApiGateway5XXErrorAlarmConfig", result)

    @builtins.property
    def config_detailed_latency_alarm_list(
        self,
    ) -> typing.Optional[typing.List[ApiGatewayRestApiDetailedLatencyAlarmConfig]]:
        '''The configuration list for the detailed Latency alarm.'''
        result = self._values.get("config_detailed_latency_alarm_list")
        return typing.cast(typing.Optional[typing.List[ApiGatewayRestApiDetailedLatencyAlarmConfig]], result)

    @builtins.property
    def config_latency_alarm(self) -> typing.Optional[ApiGatewayLatencyAlarmConfig]:
        '''The configuration for the Latency alarm.'''
        result = self._values.get("config_latency_alarm")
        return typing.cast(typing.Optional[ApiGatewayLatencyAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[ApiGatewayRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[ApiGatewayRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayRestApiRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApiRecommendedAlarmsProps",
    jsii_struct_bases=[ApiGatewayRestApiRecommendedAlarmsConfig],
    name_mapping={
        "config4_xx_error_alarm": "config4XXErrorAlarm",
        "config5_xx_error_alarm": "config5XXErrorAlarm",
        "config_detailed_latency_alarm_list": "configDetailedLatencyAlarmList",
        "config_latency_alarm": "configLatencyAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "api": "api",
    },
)
class ApiGatewayRestApiRecommendedAlarmsProps(ApiGatewayRestApiRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config4_xx_error_alarm: typing.Union["ApiGateway4XXErrorAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config5_xx_error_alarm: typing.Union["ApiGateway5XXErrorAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_detailed_latency_alarm_list: typing.Optional[typing.Sequence[typing.Union[ApiGatewayRestApiDetailedLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
        config_latency_alarm: typing.Optional[typing.Union[ApiGatewayLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[ApiGatewayRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    ) -> None:
        '''Properties for the ApiGatewayRestApiRecommendedAlarms construct.

        :param config4_xx_error_alarm: The configuration for the 4XXError alarm.
        :param config5_xx_error_alarm: The configuration for the 5XXError alarm.
        :param config_detailed_latency_alarm_list: The configuration list for the detailed Latency alarm.
        :param config_latency_alarm: The configuration for the Latency alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param api: The ApiGateway api to monitor.
        '''
        if isinstance(config4_xx_error_alarm, dict):
            config4_xx_error_alarm = ApiGateway4XXErrorAlarmConfig(**config4_xx_error_alarm)
        if isinstance(config5_xx_error_alarm, dict):
            config5_xx_error_alarm = ApiGateway5XXErrorAlarmConfig(**config5_xx_error_alarm)
        if isinstance(config_latency_alarm, dict):
            config_latency_alarm = ApiGatewayLatencyAlarmConfig(**config_latency_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5779ec01c7efa4bf90b664d5da8a5ef4a05d633f7ab3e6f2005ca6a1b1eb6db)
            check_type(argname="argument config4_xx_error_alarm", value=config4_xx_error_alarm, expected_type=type_hints["config4_xx_error_alarm"])
            check_type(argname="argument config5_xx_error_alarm", value=config5_xx_error_alarm, expected_type=type_hints["config5_xx_error_alarm"])
            check_type(argname="argument config_detailed_latency_alarm_list", value=config_detailed_latency_alarm_list, expected_type=type_hints["config_detailed_latency_alarm_list"])
            check_type(argname="argument config_latency_alarm", value=config_latency_alarm, expected_type=type_hints["config_latency_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config4_xx_error_alarm": config4_xx_error_alarm,
            "config5_xx_error_alarm": config5_xx_error_alarm,
            "api": api,
        }
        if config_detailed_latency_alarm_list is not None:
            self._values["config_detailed_latency_alarm_list"] = config_detailed_latency_alarm_list
        if config_latency_alarm is not None:
            self._values["config_latency_alarm"] = config_latency_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config4_xx_error_alarm(self) -> "ApiGateway4XXErrorAlarmConfig":
        '''The configuration for the 4XXError alarm.'''
        result = self._values.get("config4_xx_error_alarm")
        assert result is not None, "Required property 'config4_xx_error_alarm' is missing"
        return typing.cast("ApiGateway4XXErrorAlarmConfig", result)

    @builtins.property
    def config5_xx_error_alarm(self) -> "ApiGateway5XXErrorAlarmConfig":
        '''The configuration for the 5XXError alarm.'''
        result = self._values.get("config5_xx_error_alarm")
        assert result is not None, "Required property 'config5_xx_error_alarm' is missing"
        return typing.cast("ApiGateway5XXErrorAlarmConfig", result)

    @builtins.property
    def config_detailed_latency_alarm_list(
        self,
    ) -> typing.Optional[typing.List[ApiGatewayRestApiDetailedLatencyAlarmConfig]]:
        '''The configuration list for the detailed Latency alarm.'''
        result = self._values.get("config_detailed_latency_alarm_list")
        return typing.cast(typing.Optional[typing.List[ApiGatewayRestApiDetailedLatencyAlarmConfig]], result)

    @builtins.property
    def config_latency_alarm(self) -> typing.Optional[ApiGatewayLatencyAlarmConfig]:
        '''The configuration for the Latency alarm.'''
        result = self._values.get("config_latency_alarm")
        return typing.cast(typing.Optional[ApiGatewayLatencyAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[ApiGatewayRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[ApiGatewayRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def api(self) -> _aws_cdk_aws_apigateway_ceddda9d.RestApi:
        '''The ApiGateway api to monitor.'''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(_aws_cdk_aws_apigateway_ceddda9d.RestApi, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayRestApiRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApplicationLoadBalancer(
    _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancer",
):
    '''An extension for the ApplicationLoadBalancer construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        client_keep_alive: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        desync_mitigation_mode: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.DesyncMitigationMode] = None,
        drop_invalid_header_fields: typing.Optional[builtins.bool] = None,
        http2_enabled: typing.Optional[builtins.bool] = None,
        idle_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        ip_address_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.IpAddressType] = None,
        preserve_host_header: typing.Optional[builtins.bool] = None,
        preserve_xff_client_port: typing.Optional[builtins.bool] = None,
        security_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup] = None,
        waf_fail_open: typing.Optional[builtins.bool] = None,
        x_amzn_tls_version_and_cipher_suite_headers: typing.Optional[builtins.bool] = None,
        xff_header_processing_mode: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.XffHeaderProcessingMode] = None,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
        cross_zone_enabled: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        deny_all_igw_traffic: typing.Optional[builtins.bool] = None,
        internet_facing: typing.Optional[builtins.bool] = None,
        load_balancer_name: typing.Optional[builtins.str] = None,
        minimum_capacity_unit: typing.Optional[jsii.Number] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param client_keep_alive: The client keep alive duration. The valid range is 60 to 604800 seconds (1 minute to 7 days). Default: - Duration.seconds(3600)
        :param desync_mitigation_mode: Determines how the load balancer handles requests that might pose a security risk to your application. Default: DesyncMitigationMode.DEFENSIVE
        :param drop_invalid_header_fields: Indicates whether HTTP headers with invalid header fields are removed by the load balancer (true) or routed to targets (false). Default: false
        :param http2_enabled: Indicates whether HTTP/2 is enabled. Default: true
        :param idle_timeout: The load balancer idle timeout, in seconds. Default: 60
        :param ip_address_type: The type of IP addresses to use. Default: IpAddressType.IPV4
        :param preserve_host_header: Indicates whether the Application Load Balancer should preserve the host header in the HTTP request and send it to the target without any change. Default: false
        :param preserve_xff_client_port: Indicates whether the X-Forwarded-For header should preserve the source port that the client used to connect to the load balancer. Default: false
        :param security_group: Security group to associate with this load balancer. Default: A security group is created
        :param waf_fail_open: Indicates whether to allow a WAF-enabled load balancer to route requests to targets if it is unable to forward the request to AWS WAF. Default: false
        :param x_amzn_tls_version_and_cipher_suite_headers: Indicates whether the two headers (x-amzn-tls-version and x-amzn-tls-cipher-suite), which contain information about the negotiated TLS version and cipher suite, are added to the client request before sending it to the target. The x-amzn-tls-version header has information about the TLS protocol version negotiated with the client, and the x-amzn-tls-cipher-suite header has information about the cipher suite negotiated with the client. Both headers are in OpenSSL format. Default: false
        :param xff_header_processing_mode: Enables you to modify, preserve, or remove the X-Forwarded-For header in the HTTP request before the Application Load Balancer sends the request to the target. Default: XffHeaderProcessingMode.APPEND
        :param vpc: The VPC network to place the load balancer in.
        :param cross_zone_enabled: Indicates whether cross-zone load balancing is enabled. Default: - false for Network Load Balancers and true for Application Load Balancers. This can not be ``false`` for Application Load Balancers.
        :param deletion_protection: Indicates whether deletion protection is enabled. Default: false
        :param deny_all_igw_traffic: Indicates whether the load balancer blocks traffic through the Internet Gateway (IGW). Default: - false for internet-facing load balancers and true for internal load balancers
        :param internet_facing: Whether the load balancer has an internet-routable address. Default: false
        :param load_balancer_name: Name of the load balancer. Default: - Automatically generated name.
        :param minimum_capacity_unit: The minimum capacity (LCU) for a load balancer. Default: undefined - ELB default is 0 LCU
        :param vpc_subnets: Which subnets place the load balancer in. Default: - the Vpc default strategy.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bb7d32e109b42c486f3ef83c0712866c58faa867e12169172cdc53eb75347920)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancerProps(
            client_keep_alive=client_keep_alive,
            desync_mitigation_mode=desync_mitigation_mode,
            drop_invalid_header_fields=drop_invalid_header_fields,
            http2_enabled=http2_enabled,
            idle_timeout=idle_timeout,
            ip_address_type=ip_address_type,
            preserve_host_header=preserve_host_header,
            preserve_xff_client_port=preserve_xff_client_port,
            security_group=security_group,
            waf_fail_open=waf_fail_open,
            x_amzn_tls_version_and_cipher_suite_headers=x_amzn_tls_version_and_cipher_suite_headers,
            xff_header_processing_mode=xff_header_processing_mode,
            vpc=vpc,
            cross_zone_enabled=cross_zone_enabled,
            deletion_protection=deletion_protection,
            deny_all_igw_traffic=deny_all_igw_traffic,
            internet_facing=internet_facing,
            load_balancer_name=load_balancer_name,
            minimum_capacity_unit=minimum_capacity_unit,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmHttpCode4xxCount")
    def alarm_http_code4xx_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        std_devs: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ApplicationLoadBalancerHttpCode4xxCountAlarm":
        '''Creates an alarm that monitors the HTTP 4XX error count for the ApplicationLoadBalancer.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is generating 4XX errors. A high number of 4XX errors can indicate client-side issues or misconfigured requests.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_ELB_4XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApplicationLoadBalancerHttpCode4xxCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            std_devs=std_devs,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ApplicationLoadBalancerHttpCode4xxCountAlarm", jsii.invoke(self, "alarmHttpCode4xxCount", [props]))

    @jsii.member(jsii_name="alarmHttpCode5xxCount")
    def alarm_http_code5xx_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        std_devs: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ApplicationLoadBalancerHttpCode5xxCountAlarm":
        '''Creates an alarm that monitors the HTTP 5XX error count for the ApplicationLoadBalancer.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is generating 5XX errors. A high number of 5XX errors can indicate issues with the load balancer itself.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_ELB_5XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApplicationLoadBalancerHttpCode5xxCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            std_devs=std_devs,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ApplicationLoadBalancerHttpCode5xxCountAlarm", jsii.invoke(self, "alarmHttpCode5xxCount", [props]))

    @jsii.member(jsii_name="alarmHttpCodeTarget5xxCount")
    def alarm_http_code_target5xx_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ApplicationLoadBalancerHttpCodeTarget5xxCountAlarm":
        '''Creates an alarm that monitors the HTTP 5XX error count from targets for the ApplicationLoadBalancer.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the targets are generating 5XX errors. A high number of 5XX errors can indicate issues with the application or backend services.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_Target_5XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of 5XX errors from targets. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ApplicationLoadBalancerHttpCodeTarget5xxCountAlarm", jsii.invoke(self, "alarmHttpCodeTarget5xxCount", [props]))

    @jsii.member(jsii_name="alarmRejectedConnectionCount")
    def alarm_rejected_connection_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ApplicationLoadBalancerRejectedConnectionCountAlarm":
        '''Creates an alarm that monitors the rejected connection count for the ApplicationLoadBalancer.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is rejecting connections. Rejected connections can indicate that the load balancer has reached its maximum connection limit.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - RejectedConnectionCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of rejected connections. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApplicationLoadBalancerRejectedConnectionCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ApplicationLoadBalancerRejectedConnectionCountAlarm", jsii.invoke(self, "alarmRejectedConnectionCount", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_http_code4xx_count_alarm: typing.Optional[typing.Union["ApplicationLoadBalancerHttpCode4xxCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_http_code5xx_count_alarm: typing.Optional[typing.Union["ApplicationLoadBalancerHttpCode5xxCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_http_code_target5xx_count_alarm: typing.Optional[typing.Union["ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_rejected_connection_count_alarm: typing.Optional[typing.Union["ApplicationLoadBalancerRejectedConnectionCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ApplicationLoadBalancerRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ApplicationLoadBalancerRecommendedAlarms":
        '''Creates the recommended alarms for the ApplicationLoadBalancer.

        :param config_http_code4xx_count_alarm: The configuration for the HTTPCode_ELB_4XX_Count alarm.
        :param config_http_code5xx_count_alarm: The configuration for the HTTPCode_ELB_5XX_Count alarm.
        :param config_http_code_target5xx_count_alarm: The configuration for the HTTPCode_Target_5XX_Count alarm.
        :param config_rejected_connection_count_alarm: The configuration for the RejectedConnectionCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
        '''
        props = ApplicationLoadBalancerRecommendedAlarmsConfig(
            config_http_code4xx_count_alarm=config_http_code4xx_count_alarm,
            config_http_code5xx_count_alarm=config_http_code5xx_count_alarm,
            config_http_code_target5xx_count_alarm=config_http_code_target5xx_count_alarm,
            config_rejected_connection_count_alarm=config_rejected_connection_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ApplicationLoadBalancerRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class ApplicationLoadBalancerAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9687e512c69ae656e4df83643578f02b457562ac8547996d9527380e3d9121a6)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"load_balancer": "loadBalancer"},
)
class ApplicationLoadBalancerAlarmProps:
    def __init__(
        self,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    ) -> None:
        '''The common properties for the ApplicationLoadBalancer alarms.

        :param load_balancer: The ApplicationLoadBalancer to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e290157996a57817cddd93930fef0cef7299d9a971b296117131d4c9dda29a73)
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer": load_balancer,
        }

    @builtins.property
    def load_balancer(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer:
        '''The ApplicationLoadBalancer to monitor.'''
        result = self._values.get("load_balancer")
        assert result is not None, "Required property 'load_balancer' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApplicationLoadBalancerHttpCode4xxCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.AnomalyDetectionAlarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerHttpCode4xxCountAlarm",
):
    '''This anomaly detection alarm is used to detect when the load balancer is generating unusually many 4XX errors.

    A high number of 4XX errors can indicate client-side issues or misconfigured requests.

    The alarm is triggered when the number of 4XX errors is outside the upper threshold
    of the anomaly detection band.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        std_devs: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param load_balancer: The ApplicationLoadBalancer to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is generating 4XX errors. A high number of 4XX errors can indicate client-side issues or misconfigured requests.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_ELB_4XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__822d378f2f32d60c71821d64d091d71130e9a6ed9a7d704ccd11e1551e00d940)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApplicationLoadBalancerHttpCode4xxCountAlarmProps(
            load_balancer=load_balancer,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            std_devs=std_devs,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerHttpCode4xxCountAlarmConfig",
    jsii_struct_bases=[ApplicationLoadBalancerAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "std_devs": "stdDevs",
    },
)
class ApplicationLoadBalancerHttpCode4xxCountAlarmConfig(
    ApplicationLoadBalancerAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        std_devs: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the HTTPCode_ELB_4XX_Count alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is generating 4XX errors. A high number of 4XX errors can indicate client-side issues or misconfigured requests.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_ELB_4XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d03cb57980316a63b6ac7fc8b7dba63532dc8dd451679a6549f835449df23c6e)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument std_devs", value=std_devs, expected_type=type_hints["std_devs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if std_devs is not None:
            self._values["std_devs"] = std_devs

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the load balancer is generating 4XX errors.
        A high number of 4XX errors can indicate client-side issues or misconfigured requests.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - HTTPCode_ELB_4XX_Count'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def std_devs(self) -> typing.Optional[jsii.Number]:
        '''The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean.

        :default: 8
        '''
        result = self._values.get("std_devs")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerHttpCode4xxCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerHttpCode4xxCountAlarmProps",
    jsii_struct_bases=[
        ApplicationLoadBalancerAlarmProps,
        ApplicationLoadBalancerHttpCode4xxCountAlarmConfig,
    ],
    name_mapping={
        "load_balancer": "loadBalancer",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "std_devs": "stdDevs",
    },
)
class ApplicationLoadBalancerHttpCode4xxCountAlarmProps(
    ApplicationLoadBalancerAlarmProps,
    ApplicationLoadBalancerHttpCode4xxCountAlarmConfig,
):
    def __init__(
        self,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        std_devs: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ApplicationLoadBalancerHttpCode4xxCountAlarm construct.

        :param load_balancer: The ApplicationLoadBalancer to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is generating 4XX errors. A high number of 4XX errors can indicate client-side issues or misconfigured requests.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_ELB_4XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__464de1eb804f7b141dc388b1e4ba9ca853a85e61bc0940fe9c1fd6d3106ebb6b)
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument std_devs", value=std_devs, expected_type=type_hints["std_devs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer": load_balancer,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if std_devs is not None:
            self._values["std_devs"] = std_devs

    @builtins.property
    def load_balancer(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer:
        '''The ApplicationLoadBalancer to monitor.'''
        result = self._values.get("load_balancer")
        assert result is not None, "Required property 'load_balancer' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the load balancer is generating 4XX errors.
        A high number of 4XX errors can indicate client-side issues or misconfigured requests.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - HTTPCode_ELB_4XX_Count'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def std_devs(self) -> typing.Optional[jsii.Number]:
        '''The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean.

        :default: 8
        '''
        result = self._values.get("std_devs")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerHttpCode4xxCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApplicationLoadBalancerHttpCode5xxCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.AnomalyDetectionAlarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerHttpCode5xxCountAlarm",
):
    '''This anomaly detection alarm is used to detect when the load balancer is generating unusually many 5XX errors.

    A high number of 5XX errors can indicate issues with the load balancer itself.

    The alarm is triggered when the number of 5XX errors is outside the upper threshold
    of the anomaly detection band.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        std_devs: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param load_balancer: The ApplicationLoadBalancer to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is generating 5XX errors. A high number of 5XX errors can indicate issues with the load balancer itself.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_ELB_5XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__539fa0a4f6542e80a2748ff50b5bee1a585895bf9d509c5e6e7b97aff4d5eec8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApplicationLoadBalancerHttpCode5xxCountAlarmProps(
            load_balancer=load_balancer,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            std_devs=std_devs,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerHttpCode5xxCountAlarmConfig",
    jsii_struct_bases=[ApplicationLoadBalancerAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "std_devs": "stdDevs",
    },
)
class ApplicationLoadBalancerHttpCode5xxCountAlarmConfig(
    ApplicationLoadBalancerAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        std_devs: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the HTTPCode_ELB_5XX_Count alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is generating 5XX errors. A high number of 5XX errors can indicate issues with the load balancer itself.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_ELB_5XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c45483444643a3edd3a6c4c13c0d66965f5e3f8468612892ed9385561e5a6d3)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument std_devs", value=std_devs, expected_type=type_hints["std_devs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if std_devs is not None:
            self._values["std_devs"] = std_devs

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the load balancer is generating 5XX errors.
        A high number of 5XX errors can indicate issues with the load balancer itself.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - HTTPCode_ELB_5XX_Count'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def std_devs(self) -> typing.Optional[jsii.Number]:
        '''The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean.

        :default: 8
        '''
        result = self._values.get("std_devs")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerHttpCode5xxCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerHttpCode5xxCountAlarmProps",
    jsii_struct_bases=[
        ApplicationLoadBalancerAlarmProps,
        ApplicationLoadBalancerHttpCode5xxCountAlarmConfig,
    ],
    name_mapping={
        "load_balancer": "loadBalancer",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "std_devs": "stdDevs",
    },
)
class ApplicationLoadBalancerHttpCode5xxCountAlarmProps(
    ApplicationLoadBalancerAlarmProps,
    ApplicationLoadBalancerHttpCode5xxCountAlarmConfig,
):
    def __init__(
        self,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        std_devs: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ApplicationLoadBalancerHttpCode5xxCountAlarm construct.

        :param load_balancer: The ApplicationLoadBalancer to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is generating 5XX errors. A high number of 5XX errors can indicate issues with the load balancer itself.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_ELB_5XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61478244c4c6feac26804e8ad2e4b1c2021243a952f35be4f4eff05c4b9a1a57)
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument std_devs", value=std_devs, expected_type=type_hints["std_devs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer": load_balancer,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if std_devs is not None:
            self._values["std_devs"] = std_devs

    @builtins.property
    def load_balancer(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer:
        '''The ApplicationLoadBalancer to monitor.'''
        result = self._values.get("load_balancer")
        assert result is not None, "Required property 'load_balancer' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the load balancer is generating 5XX errors.
        A high number of 5XX errors can indicate issues with the load balancer itself.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - HTTPCode_ELB_5XX_Count'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def std_devs(self) -> typing.Optional[jsii.Number]:
        '''The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean.

        :default: 8
        '''
        result = self._values.get("std_devs")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerHttpCode5xxCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApplicationLoadBalancerHttpCodeTarget5xxCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerHttpCodeTarget5xxCountAlarm",
):
    '''This alarm is used to detect when the targets are generating 5XX errors.

    A high number of 5XX errors can indicate issues with the application or backend services.

    The alarm is triggered when the number of 5XX errors from targets is greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param load_balancer: The ApplicationLoadBalancer to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the targets are generating 5XX errors. A high number of 5XX errors can indicate issues with the application or backend services.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_Target_5XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of 5XX errors from targets. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9947ded5c5ff7799a6316aaf3ad4e40ae5d86fa92b2d0e87d68b940d4ff3aadf)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmProps(
            load_balancer=load_balancer,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig",
    jsii_struct_bases=[ApplicationLoadBalancerAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig(
    ApplicationLoadBalancerAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the HTTPCode_Target_5XX_Count alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the targets are generating 5XX errors. A high number of 5XX errors can indicate issues with the application or backend services.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_Target_5XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of 5XX errors from targets. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__600b32b293eaf13ac79f172206fc4f481abdb37ad28dd637d48be434fef52395)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the targets are generating 5XX errors.
        A high number of 5XX errors can indicate issues with the application or backend services.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - HTTPCode_Target_5XX_Count'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the acceptable number of 5XX errors from targets.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmProps",
    jsii_struct_bases=[
        ApplicationLoadBalancerAlarmProps,
        ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig,
    ],
    name_mapping={
        "load_balancer": "loadBalancer",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmProps(
    ApplicationLoadBalancerAlarmProps,
    ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig,
):
    def __init__(
        self,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ApplicationLoadBalancerHttpCodeTarget5xxCountAlarm construct.

        :param load_balancer: The ApplicationLoadBalancer to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the targets are generating 5XX errors. A high number of 5XX errors can indicate issues with the application or backend services.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - HTTPCode_Target_5XX_Count'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of 5XX errors from targets. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5433b6c5b813275d50a52163cc053ff6fd48aac190c6d3689baf812154a62c9d)
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer": load_balancer,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def load_balancer(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer:
        '''The ApplicationLoadBalancer to monitor.'''
        result = self._values.get("load_balancer")
        assert result is not None, "Required property 'load_balancer' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the targets are generating 5XX errors.
        A high number of 5XX errors can indicate issues with the application or backend services.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - HTTPCode_Target_5XX_Count'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the acceptable number of 5XX errors from targets.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApplicationLoadBalancerRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an ApplicationLoadBalancer.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
        config_http_code4xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_http_code5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_http_code_target5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_rejected_connection_count_alarm: typing.Optional[typing.Union["ApplicationLoadBalancerRejectedConnectionCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ApplicationLoadBalancerRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param load_balancer: The ApplicationLoadBalancer to monitor.
        :param config_http_code4xx_count_alarm: The configuration for the HTTPCode_ELB_4XX_Count alarm.
        :param config_http_code5xx_count_alarm: The configuration for the HTTPCode_ELB_5XX_Count alarm.
        :param config_http_code_target5xx_count_alarm: The configuration for the HTTPCode_Target_5XX_Count alarm.
        :param config_rejected_connection_count_alarm: The configuration for the RejectedConnectionCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2bd76af47259143adccda326390737cfd73e26621fa6fcd8d22aba8c782be402)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApplicationLoadBalancerRecommendedAlarmsProps(
            load_balancer=load_balancer,
            config_http_code4xx_count_alarm=config_http_code4xx_count_alarm,
            config_http_code5xx_count_alarm=config_http_code5xx_count_alarm,
            config_http_code_target5xx_count_alarm=config_http_code_target5xx_count_alarm,
            config_rejected_connection_count_alarm=config_rejected_connection_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmHttpCode4xxCount")
    def alarm_http_code4xx_count(
        self,
    ) -> typing.Optional[ApplicationLoadBalancerHttpCode4xxCountAlarm]:
        '''The HTTPCode_ELB_4XX_Count alarm.'''
        return typing.cast(typing.Optional[ApplicationLoadBalancerHttpCode4xxCountAlarm], jsii.get(self, "alarmHttpCode4xxCount"))

    @builtins.property
    @jsii.member(jsii_name="alarmHttpCode5xxCount")
    def alarm_http_code5xx_count(
        self,
    ) -> typing.Optional[ApplicationLoadBalancerHttpCode5xxCountAlarm]:
        '''The HTTPCode_ELB_5XX_Count alarm.'''
        return typing.cast(typing.Optional[ApplicationLoadBalancerHttpCode5xxCountAlarm], jsii.get(self, "alarmHttpCode5xxCount"))

    @builtins.property
    @jsii.member(jsii_name="alarmHttpCodeTarget5xxCount")
    def alarm_http_code_target5xx_count(
        self,
    ) -> typing.Optional[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarm]:
        '''The HTTPCode_Target_5XX_Count alarm.'''
        return typing.cast(typing.Optional[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarm], jsii.get(self, "alarmHttpCodeTarget5xxCount"))

    @builtins.property
    @jsii.member(jsii_name="alarmRejectedConnectionCount")
    def alarm_rejected_connection_count(
        self,
    ) -> typing.Optional["ApplicationLoadBalancerRejectedConnectionCountAlarm"]:
        '''The RejectedConnectionCount alarm.'''
        return typing.cast(typing.Optional["ApplicationLoadBalancerRejectedConnectionCountAlarm"], jsii.get(self, "alarmRejectedConnectionCount"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class ApplicationLoadBalancerRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an ApplicationLoadBalancer.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
    '''

    def __init__(
        self,
        *,
        config_http_code4xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_http_code5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_http_code_target5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_rejected_connection_count_alarm: typing.Optional[typing.Union["ApplicationLoadBalancerRejectedConnectionCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ApplicationLoadBalancerRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_http_code4xx_count_alarm: The configuration for the HTTPCode_ELB_4XX_Count alarm.
        :param config_http_code5xx_count_alarm: The configuration for the HTTPCode_ELB_5XX_Count alarm.
        :param config_http_code_target5xx_count_alarm: The configuration for the HTTPCode_Target_5XX_Count alarm.
        :param config_rejected_connection_count_alarm: The configuration for the RejectedConnectionCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApplicationLoadBalancerRecommendedAlarmsConfig(
            config_http_code4xx_count_alarm=config_http_code4xx_count_alarm,
            config_http_code5xx_count_alarm=config_http_code5xx_count_alarm,
            config_http_code_target5xx_count_alarm=config_http_code_target5xx_count_alarm,
            config_rejected_connection_count_alarm=config_rejected_connection_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4986286dd81c90bee7785aecf315b49e7ad3e8aa350d3cdb0507f78aa3eb5d79)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_http_code4xx_count_alarm": "configHttpCode4xxCountAlarm",
        "config_http_code5xx_count_alarm": "configHttpCode5xxCountAlarm",
        "config_http_code_target5xx_count_alarm": "configHttpCodeTarget5xxCountAlarm",
        "config_rejected_connection_count_alarm": "configRejectedConnectionCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class ApplicationLoadBalancerRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_http_code4xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_http_code5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_http_code_target5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_rejected_connection_count_alarm: typing.Optional[typing.Union["ApplicationLoadBalancerRejectedConnectionCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ApplicationLoadBalancerRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an ApplicationLoadBalancer.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_http_code4xx_count_alarm: The configuration for the HTTPCode_ELB_4XX_Count alarm.
        :param config_http_code5xx_count_alarm: The configuration for the HTTPCode_ELB_5XX_Count alarm.
        :param config_http_code_target5xx_count_alarm: The configuration for the HTTPCode_Target_5XX_Count alarm.
        :param config_rejected_connection_count_alarm: The configuration for the RejectedConnectionCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_http_code4xx_count_alarm, dict):
            config_http_code4xx_count_alarm = ApplicationLoadBalancerHttpCode4xxCountAlarmConfig(**config_http_code4xx_count_alarm)
        if isinstance(config_http_code5xx_count_alarm, dict):
            config_http_code5xx_count_alarm = ApplicationLoadBalancerHttpCode5xxCountAlarmConfig(**config_http_code5xx_count_alarm)
        if isinstance(config_http_code_target5xx_count_alarm, dict):
            config_http_code_target5xx_count_alarm = ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig(**config_http_code_target5xx_count_alarm)
        if isinstance(config_rejected_connection_count_alarm, dict):
            config_rejected_connection_count_alarm = ApplicationLoadBalancerRejectedConnectionCountAlarmConfig(**config_rejected_connection_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ccd26b3dd9354de62dc9a0658a8bbd649deff69499b0846cdb71b724c7ad68c9)
            check_type(argname="argument config_http_code4xx_count_alarm", value=config_http_code4xx_count_alarm, expected_type=type_hints["config_http_code4xx_count_alarm"])
            check_type(argname="argument config_http_code5xx_count_alarm", value=config_http_code5xx_count_alarm, expected_type=type_hints["config_http_code5xx_count_alarm"])
            check_type(argname="argument config_http_code_target5xx_count_alarm", value=config_http_code_target5xx_count_alarm, expected_type=type_hints["config_http_code_target5xx_count_alarm"])
            check_type(argname="argument config_rejected_connection_count_alarm", value=config_rejected_connection_count_alarm, expected_type=type_hints["config_rejected_connection_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_http_code4xx_count_alarm is not None:
            self._values["config_http_code4xx_count_alarm"] = config_http_code4xx_count_alarm
        if config_http_code5xx_count_alarm is not None:
            self._values["config_http_code5xx_count_alarm"] = config_http_code5xx_count_alarm
        if config_http_code_target5xx_count_alarm is not None:
            self._values["config_http_code_target5xx_count_alarm"] = config_http_code_target5xx_count_alarm
        if config_rejected_connection_count_alarm is not None:
            self._values["config_rejected_connection_count_alarm"] = config_rejected_connection_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_http_code4xx_count_alarm(
        self,
    ) -> typing.Optional[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig]:
        '''The configuration for the HTTPCode_ELB_4XX_Count alarm.'''
        result = self._values.get("config_http_code4xx_count_alarm")
        return typing.cast(typing.Optional[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig], result)

    @builtins.property
    def config_http_code5xx_count_alarm(
        self,
    ) -> typing.Optional[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig]:
        '''The configuration for the HTTPCode_ELB_5XX_Count alarm.'''
        result = self._values.get("config_http_code5xx_count_alarm")
        return typing.cast(typing.Optional[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig], result)

    @builtins.property
    def config_http_code_target5xx_count_alarm(
        self,
    ) -> typing.Optional[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig]:
        '''The configuration for the HTTPCode_Target_5XX_Count alarm.'''
        result = self._values.get("config_http_code_target5xx_count_alarm")
        return typing.cast(typing.Optional[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig], result)

    @builtins.property
    def config_rejected_connection_count_alarm(
        self,
    ) -> typing.Optional["ApplicationLoadBalancerRejectedConnectionCountAlarmConfig"]:
        '''The configuration for the RejectedConnectionCount alarm.'''
        result = self._values.get("config_rejected_connection_count_alarm")
        return typing.cast(typing.Optional["ApplicationLoadBalancerRejectedConnectionCountAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["ApplicationLoadBalancerRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["ApplicationLoadBalancerRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerRecommendedAlarmsMetrics"
)
class ApplicationLoadBalancerRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for ApplicationLoadBalancer alarms.'''

    REJECTED_CONNECTION_COUNT = "REJECTED_CONNECTION_COUNT"
    '''The number of connection requests that were rejected because the load balancer had reached its maximum connections.'''
    HTTP_CODE_ELB_4XX_COUNT = "HTTP_CODE_ELB_4XX_COUNT"
    '''The number of HTTP 4XX client error codes generated by the load balancer.'''
    HTTP_CODE_ELB_5XX_COUNT = "HTTP_CODE_ELB_5XX_COUNT"
    '''The number of HTTP 5XX server error codes generated by the load balancer.'''
    HTTP_CODE_TARGET_5XX_COUNT = "HTTP_CODE_TARGET_5XX_COUNT"
    '''The number of HTTP 5XX server error codes generated by the targets.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerRecommendedAlarmsProps",
    jsii_struct_bases=[ApplicationLoadBalancerRecommendedAlarmsConfig],
    name_mapping={
        "config_http_code4xx_count_alarm": "configHttpCode4xxCountAlarm",
        "config_http_code5xx_count_alarm": "configHttpCode5xxCountAlarm",
        "config_http_code_target5xx_count_alarm": "configHttpCodeTarget5xxCountAlarm",
        "config_rejected_connection_count_alarm": "configRejectedConnectionCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "load_balancer": "loadBalancer",
    },
)
class ApplicationLoadBalancerRecommendedAlarmsProps(
    ApplicationLoadBalancerRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config_http_code4xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_http_code5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_http_code_target5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_rejected_connection_count_alarm: typing.Optional[typing.Union["ApplicationLoadBalancerRejectedConnectionCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[ApplicationLoadBalancerRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    ) -> None:
        '''Properties for the ApplicationLoadBalancerRecommendedAlarms construct.

        :param config_http_code4xx_count_alarm: The configuration for the HTTPCode_ELB_4XX_Count alarm.
        :param config_http_code5xx_count_alarm: The configuration for the HTTPCode_ELB_5XX_Count alarm.
        :param config_http_code_target5xx_count_alarm: The configuration for the HTTPCode_Target_5XX_Count alarm.
        :param config_rejected_connection_count_alarm: The configuration for the RejectedConnectionCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param load_balancer: The ApplicationLoadBalancer to monitor.
        '''
        if isinstance(config_http_code4xx_count_alarm, dict):
            config_http_code4xx_count_alarm = ApplicationLoadBalancerHttpCode4xxCountAlarmConfig(**config_http_code4xx_count_alarm)
        if isinstance(config_http_code5xx_count_alarm, dict):
            config_http_code5xx_count_alarm = ApplicationLoadBalancerHttpCode5xxCountAlarmConfig(**config_http_code5xx_count_alarm)
        if isinstance(config_http_code_target5xx_count_alarm, dict):
            config_http_code_target5xx_count_alarm = ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig(**config_http_code_target5xx_count_alarm)
        if isinstance(config_rejected_connection_count_alarm, dict):
            config_rejected_connection_count_alarm = ApplicationLoadBalancerRejectedConnectionCountAlarmConfig(**config_rejected_connection_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a86126a95d1bc9b5b7451f38fbfa9538cc1af9bfa6ba3790aad3d6a0846c23f)
            check_type(argname="argument config_http_code4xx_count_alarm", value=config_http_code4xx_count_alarm, expected_type=type_hints["config_http_code4xx_count_alarm"])
            check_type(argname="argument config_http_code5xx_count_alarm", value=config_http_code5xx_count_alarm, expected_type=type_hints["config_http_code5xx_count_alarm"])
            check_type(argname="argument config_http_code_target5xx_count_alarm", value=config_http_code_target5xx_count_alarm, expected_type=type_hints["config_http_code_target5xx_count_alarm"])
            check_type(argname="argument config_rejected_connection_count_alarm", value=config_rejected_connection_count_alarm, expected_type=type_hints["config_rejected_connection_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer": load_balancer,
        }
        if config_http_code4xx_count_alarm is not None:
            self._values["config_http_code4xx_count_alarm"] = config_http_code4xx_count_alarm
        if config_http_code5xx_count_alarm is not None:
            self._values["config_http_code5xx_count_alarm"] = config_http_code5xx_count_alarm
        if config_http_code_target5xx_count_alarm is not None:
            self._values["config_http_code_target5xx_count_alarm"] = config_http_code_target5xx_count_alarm
        if config_rejected_connection_count_alarm is not None:
            self._values["config_rejected_connection_count_alarm"] = config_rejected_connection_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_http_code4xx_count_alarm(
        self,
    ) -> typing.Optional[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig]:
        '''The configuration for the HTTPCode_ELB_4XX_Count alarm.'''
        result = self._values.get("config_http_code4xx_count_alarm")
        return typing.cast(typing.Optional[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig], result)

    @builtins.property
    def config_http_code5xx_count_alarm(
        self,
    ) -> typing.Optional[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig]:
        '''The configuration for the HTTPCode_ELB_5XX_Count alarm.'''
        result = self._values.get("config_http_code5xx_count_alarm")
        return typing.cast(typing.Optional[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig], result)

    @builtins.property
    def config_http_code_target5xx_count_alarm(
        self,
    ) -> typing.Optional[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig]:
        '''The configuration for the HTTPCode_Target_5XX_Count alarm.'''
        result = self._values.get("config_http_code_target5xx_count_alarm")
        return typing.cast(typing.Optional[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig], result)

    @builtins.property
    def config_rejected_connection_count_alarm(
        self,
    ) -> typing.Optional["ApplicationLoadBalancerRejectedConnectionCountAlarmConfig"]:
        '''The configuration for the RejectedConnectionCount alarm.'''
        result = self._values.get("config_rejected_connection_count_alarm")
        return typing.cast(typing.Optional["ApplicationLoadBalancerRejectedConnectionCountAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[ApplicationLoadBalancerRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[ApplicationLoadBalancerRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def load_balancer(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer:
        '''The ApplicationLoadBalancer to monitor.'''
        result = self._values.get("load_balancer")
        assert result is not None, "Required property 'load_balancer' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApplicationLoadBalancerRejectedConnectionCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerRejectedConnectionCountAlarm",
):
    '''This alarm is used to detect when the load balancer is rejecting connections.

    Rejected connections can indicate that the load balancer has reached its maximum connection limit.

    The alarm is triggered when the number of rejected connections is greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param load_balancer: The ApplicationLoadBalancer to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is rejecting connections. Rejected connections can indicate that the load balancer has reached its maximum connection limit.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - RejectedConnectionCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of rejected connections. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2d5fdc80258b5a62ee1a301c5d95dc15e6aca58479cd9536348b6ed6e1c8780c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApplicationLoadBalancerRejectedConnectionCountAlarmProps(
            load_balancer=load_balancer,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerRejectedConnectionCountAlarmConfig",
    jsii_struct_bases=[ApplicationLoadBalancerAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ApplicationLoadBalancerRejectedConnectionCountAlarmConfig(
    ApplicationLoadBalancerAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the RejectedConnectionCount alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is rejecting connections. Rejected connections can indicate that the load balancer has reached its maximum connection limit.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - RejectedConnectionCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of rejected connections. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__01fa76713b0249fdf3b75f594722ff34e8a7e97acbf487ce20d4da5f9f25e8ee)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the load balancer is rejecting connections.
        Rejected connections can indicate that the load balancer has reached its maximum connection limit.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - RejectedConnectionCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the acceptable number of rejected connections.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerRejectedConnectionCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationLoadBalancerRejectedConnectionCountAlarmProps",
    jsii_struct_bases=[
        ApplicationLoadBalancerAlarmProps,
        ApplicationLoadBalancerRejectedConnectionCountAlarmConfig,
    ],
    name_mapping={
        "load_balancer": "loadBalancer",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ApplicationLoadBalancerRejectedConnectionCountAlarmProps(
    ApplicationLoadBalancerAlarmProps,
    ApplicationLoadBalancerRejectedConnectionCountAlarmConfig,
):
    def __init__(
        self,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ApplicationLoadBalancerRejectedConnectionCountAlarm construct.

        :param load_balancer: The ApplicationLoadBalancer to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is rejecting connections. Rejected connections can indicate that the load balancer has reached its maximum connection limit.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - RejectedConnectionCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of rejected connections. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8cac3a3f4883bfdd18150e81d9b44d5ee7b7a13e4586f6c11daad970477d3a6f)
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer": load_balancer,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def load_balancer(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer:
        '''The ApplicationLoadBalancer to monitor.'''
        result = self._values.get("load_balancer")
        assert result is not None, "Required property 'load_balancer' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the load balancer is rejecting connections.
        Rejected connections can indicate that the load balancer has reached its maximum connection limit.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - RejectedConnectionCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the acceptable number of rejected connections.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationLoadBalancerRejectedConnectionCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApplicationTargetGroup(
    _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroup",
):
    '''An extension for the ApplicationTargetGroup construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        enable_anomaly_mitigation: typing.Optional[builtins.bool] = None,
        load_balancing_algorithm_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.TargetGroupLoadBalancingAlgorithmType] = None,
        multi_value_headers_enabled: typing.Optional[builtins.bool] = None,
        port: typing.Optional[jsii.Number] = None,
        protocol: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationProtocol] = None,
        protocol_version: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationProtocolVersion] = None,
        slow_start: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        stickiness_cookie_duration: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        stickiness_cookie_name: typing.Optional[builtins.str] = None,
        targets: typing.Optional[typing.Sequence[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.IApplicationLoadBalancerTarget]] = None,
        cross_zone_enabled: typing.Optional[builtins.bool] = None,
        deregistration_delay: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        health_check: typing.Optional[typing.Union[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.HealthCheck, typing.Dict[builtins.str, typing.Any]]] = None,
        ip_address_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.TargetGroupIpAddressType] = None,
        target_group_name: typing.Optional[builtins.str] = None,
        target_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.TargetType] = None,
        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param enable_anomaly_mitigation: Indicates whether anomaly mitigation is enabled. Only available when ``loadBalancingAlgorithmType`` is ``TargetGroupLoadBalancingAlgorithmType.WEIGHTED_RANDOM`` Default: false
        :param load_balancing_algorithm_type: The load balancing algorithm to select targets for routing requests. Default: TargetGroupLoadBalancingAlgorithmType.ROUND_ROBIN
        :param multi_value_headers_enabled: Indicates whether the target group supports multi-value headers. If the value is true, the request and response headers exchanged between the load balancer and the Lambda function include arrays of values or strings. Only applicable for Lambda targets. Default: false
        :param port: The port on which the target receives traffic. This is not applicable for Lambda targets. Default: - Determined from protocol if known
        :param protocol: The protocol used for communication with the target. This is not applicable for Lambda targets. Default: - Determined from port if known
        :param protocol_version: The protocol version to use. Default: ApplicationProtocolVersion.HTTP1
        :param slow_start: The time period during which the load balancer sends a newly registered target a linearly increasing share of the traffic to the target group. The range is 30-900 seconds (15 minutes). Default: 0
        :param stickiness_cookie_duration: The stickiness cookie expiration period. Setting this value enables load balancer stickiness. After this period, the cookie is considered stale. The minimum value is 1 second and the maximum value is 7 days (604800 seconds). Default: - Stickiness is disabled
        :param stickiness_cookie_name: The name of an application-based stickiness cookie. Names that start with the following prefixes are not allowed: AWSALB, AWSALBAPP, and AWSALBTG; they're reserved for use by the load balancer. Note: ``stickinessCookieName`` parameter depends on the presence of ``stickinessCookieDuration`` parameter. If ``stickinessCookieDuration`` is not set, ``stickinessCookieName`` will be omitted. Default: - If ``stickinessCookieDuration`` is set, a load-balancer generated cookie is used. Otherwise, no stickiness is defined.
        :param targets: The targets to add to this target group. Can be ``Instance``, ``IPAddress``, or any self-registering load balancing target. If you use either ``Instance`` or ``IPAddress`` as targets, all target must be of the same type. Default: - No targets.
        :param cross_zone_enabled: Indicates whether cross zone load balancing is enabled. Default: - use load balancer configuration
        :param deregistration_delay: The amount of time for Elastic Load Balancing to wait before deregistering a target. The range is 0-3600 seconds. Default: 300
        :param health_check: Health check configuration. Default: - The default value for each property in this configuration varies depending on the target.
        :param ip_address_type: The type of IP addresses of the targets registered with the target group. Default: undefined - ELB defaults to IPv4
        :param target_group_name: The name of the target group. This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen. Default: - Automatically generated.
        :param target_type: The type of targets registered to this TargetGroup, either IP or Instance. All targets registered into the group must be of this type. If you register targets to the TargetGroup in the CDK app, the TargetType is determined automatically. Default: - Determined automatically.
        :param vpc: The virtual private cloud (VPC). only if ``TargetType`` is ``Ip`` or ``InstanceId`` Default: - undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f3eca73e09d126f9757cb84b797321f327ba4a1f68cd373ba6fb9aa90ea61db3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroupProps(
            enable_anomaly_mitigation=enable_anomaly_mitigation,
            load_balancing_algorithm_type=load_balancing_algorithm_type,
            multi_value_headers_enabled=multi_value_headers_enabled,
            port=port,
            protocol=protocol,
            protocol_version=protocol_version,
            slow_start=slow_start,
            stickiness_cookie_duration=stickiness_cookie_duration,
            stickiness_cookie_name=stickiness_cookie_name,
            targets=targets,
            cross_zone_enabled=cross_zone_enabled,
            deregistration_delay=deregistration_delay,
            health_check=health_check,
            ip_address_type=ip_address_type,
            target_group_name=target_group_name,
            target_type=target_type,
            vpc=vpc,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmHealthyHostCount")
    def alarm_healthy_host_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ApplicationTargetGroupHealthyHostCountAlarm":
        '''Creates an alarm that monitors the healthy host count for the ApplicationTargetGroup.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of healthy hosts in the target group falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - HealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the minimum number of healthy hosts required for your application to function properly. Default: 1
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApplicationTargetGroupHealthyHostCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ApplicationTargetGroupHealthyHostCountAlarm", jsii.invoke(self, "alarmHealthyHostCount", [props]))

    @jsii.member(jsii_name="alarmUnHealthyHostCount")
    def alarm_un_healthy_host_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ApplicationTargetGroupUnHealthyHostCountAlarm":
        '''Creates an alarm that monitors the unhealthy host count for the ApplicationTargetGroup.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of unhealthy hosts in the target group exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - UnHealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the maximum number of unhealthy hosts that your application can tolerate before service is impacted. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApplicationTargetGroupUnHealthyHostCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ApplicationTargetGroupUnHealthyHostCountAlarm", jsii.invoke(self, "alarmUnHealthyHostCount", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_healthy_host_count_alarm: typing.Optional[typing.Union["ApplicationTargetGroupHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_un_healthy_host_count_alarm: typing.Optional[typing.Union["ApplicationTargetGroupUnHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ApplicationTargetGroupRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ApplicationTargetGroupRecommendedAlarms":
        '''Creates the recommended alarms for the ApplicationTargetGroup.

        :param config_healthy_host_count_alarm: The configuration for the HealthyHostCount alarm.
        :param config_un_healthy_host_count_alarm: The configuration for the UnHealthyHostCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
        '''
        props = ApplicationTargetGroupRecommendedAlarmsConfig(
            config_healthy_host_count_alarm=config_healthy_host_count_alarm,
            config_un_healthy_host_count_alarm=config_un_healthy_host_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ApplicationTargetGroupRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class ApplicationTargetGroupAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e5082ab129e09581e8efe5b3ae12c541bdc4c541519c9c8348f706704aeee7a5)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationTargetGroupAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"target_group": "targetGroup"},
)
class ApplicationTargetGroupAlarmProps:
    def __init__(
        self,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
    ) -> None:
        '''The common properties for the ApplicationTargetGroup alarms.

        :param target_group: The ApplicationTargetGroup to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9dfe5b7537402019ae5b587e15d8f9cdd15e8e3232f5aa11bbb9815b195150c1)
            check_type(argname="argument target_group", value=target_group, expected_type=type_hints["target_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "target_group": target_group,
        }

    @builtins.property
    def target_group(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup:
        '''The ApplicationTargetGroup to monitor.'''
        result = self._values.get("target_group")
        assert result is not None, "Required property 'target_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationTargetGroupAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApplicationTargetGroupHealthyHostCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupHealthyHostCountAlarm",
):
    '''This alarm is used to detect when the number of healthy hosts in the target group falls below the threshold.

    A low number of healthy hosts can indicate service availability issues.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param target_group: The ApplicationTargetGroup to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of healthy hosts in the target group falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - HealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the minimum number of healthy hosts required for your application to function properly. Default: 1
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__61a37400bbff0bb7de91c4ddaaf39b5e5d9fec89268a65f7863af18503c5d7a7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApplicationTargetGroupHealthyHostCountAlarmProps(
            target_group=target_group,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupHealthyHostCountAlarmConfig",
    jsii_struct_bases=[ApplicationTargetGroupAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ApplicationTargetGroupHealthyHostCountAlarmConfig(
    ApplicationTargetGroupAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the HealthyHostCount alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of healthy hosts in the target group falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - HealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the minimum number of healthy hosts required for your application to function properly. Default: 1
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__05a032d5319017b28e4b24064604ea6011288674f9ddeaf551819c2930a6006e)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the number of healthy hosts in the target group
        falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - targetGroupName + ' - HealthyHostCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the minimum number of healthy hosts
        required for your application to function properly.

        :default: 1
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationTargetGroupHealthyHostCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupHealthyHostCountAlarmProps",
    jsii_struct_bases=[
        ApplicationTargetGroupAlarmProps,
        ApplicationTargetGroupHealthyHostCountAlarmConfig,
    ],
    name_mapping={
        "target_group": "targetGroup",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ApplicationTargetGroupHealthyHostCountAlarmProps(
    ApplicationTargetGroupAlarmProps,
    ApplicationTargetGroupHealthyHostCountAlarmConfig,
):
    def __init__(
        self,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ApplicationTargetGroupHealthyHostCountAlarm construct.

        :param target_group: The ApplicationTargetGroup to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of healthy hosts in the target group falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - HealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the minimum number of healthy hosts required for your application to function properly. Default: 1
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9d196b9cf1035270d6184672d9b100db5dd0d35a5878c8cf83f2d14464a24e4c)
            check_type(argname="argument target_group", value=target_group, expected_type=type_hints["target_group"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "target_group": target_group,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def target_group(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup:
        '''The ApplicationTargetGroup to monitor.'''
        result = self._values.get("target_group")
        assert result is not None, "Required property 'target_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the number of healthy hosts in the target group
        falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - targetGroupName + ' - HealthyHostCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the minimum number of healthy hosts
        required for your application to function properly.

        :default: 1
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationTargetGroupHealthyHostCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApplicationTargetGroupRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an ApplicationTargetGroup.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
        config_healthy_host_count_alarm: typing.Optional[typing.Union[ApplicationTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_un_healthy_host_count_alarm: typing.Optional[typing.Union["ApplicationTargetGroupUnHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ApplicationTargetGroupRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param target_group: The ApplicationTargetGroup to monitor.
        :param config_healthy_host_count_alarm: The configuration for the HealthyHostCount alarm.
        :param config_un_healthy_host_count_alarm: The configuration for the UnHealthyHostCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd3ad36e370a1ce87d25da23a20bfbea01f361ef5e21acaced912dd8f79d679e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApplicationTargetGroupRecommendedAlarmsProps(
            target_group=target_group,
            config_healthy_host_count_alarm=config_healthy_host_count_alarm,
            config_un_healthy_host_count_alarm=config_un_healthy_host_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmHealthyHostCount")
    def alarm_healthy_host_count(
        self,
    ) -> typing.Optional[ApplicationTargetGroupHealthyHostCountAlarm]:
        '''The HealthyHostCount alarm.'''
        return typing.cast(typing.Optional[ApplicationTargetGroupHealthyHostCountAlarm], jsii.get(self, "alarmHealthyHostCount"))

    @builtins.property
    @jsii.member(jsii_name="alarmUnHealthyHostCount")
    def alarm_un_healthy_host_count(
        self,
    ) -> typing.Optional["ApplicationTargetGroupUnHealthyHostCountAlarm"]:
        '''The UnHealthyHostCount alarm.'''
        return typing.cast(typing.Optional["ApplicationTargetGroupUnHealthyHostCountAlarm"], jsii.get(self, "alarmUnHealthyHostCount"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class ApplicationTargetGroupRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an ApplicationTargetGroup.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
    '''

    def __init__(
        self,
        *,
        config_healthy_host_count_alarm: typing.Optional[typing.Union[ApplicationTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_un_healthy_host_count_alarm: typing.Optional[typing.Union["ApplicationTargetGroupUnHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ApplicationTargetGroupRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_healthy_host_count_alarm: The configuration for the HealthyHostCount alarm.
        :param config_un_healthy_host_count_alarm: The configuration for the UnHealthyHostCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApplicationTargetGroupRecommendedAlarmsConfig(
            config_healthy_host_count_alarm=config_healthy_host_count_alarm,
            config_un_healthy_host_count_alarm=config_un_healthy_host_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2eff6bb57c5b310692d6d2f5590d32c005a5ff9057fb2202f17de4fab2b1af5)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_healthy_host_count_alarm": "configHealthyHostCountAlarm",
        "config_un_healthy_host_count_alarm": "configUnHealthyHostCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class ApplicationTargetGroupRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_healthy_host_count_alarm: typing.Optional[typing.Union[ApplicationTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_un_healthy_host_count_alarm: typing.Optional[typing.Union["ApplicationTargetGroupUnHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ApplicationTargetGroupRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an ApplicationTargetGroup.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_healthy_host_count_alarm: The configuration for the HealthyHostCount alarm.
        :param config_un_healthy_host_count_alarm: The configuration for the UnHealthyHostCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_healthy_host_count_alarm, dict):
            config_healthy_host_count_alarm = ApplicationTargetGroupHealthyHostCountAlarmConfig(**config_healthy_host_count_alarm)
        if isinstance(config_un_healthy_host_count_alarm, dict):
            config_un_healthy_host_count_alarm = ApplicationTargetGroupUnHealthyHostCountAlarmConfig(**config_un_healthy_host_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f49c01378c4b63c1b79b66061b3fa87cec8315abb87bc054045fd2698100ae3)
            check_type(argname="argument config_healthy_host_count_alarm", value=config_healthy_host_count_alarm, expected_type=type_hints["config_healthy_host_count_alarm"])
            check_type(argname="argument config_un_healthy_host_count_alarm", value=config_un_healthy_host_count_alarm, expected_type=type_hints["config_un_healthy_host_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_healthy_host_count_alarm is not None:
            self._values["config_healthy_host_count_alarm"] = config_healthy_host_count_alarm
        if config_un_healthy_host_count_alarm is not None:
            self._values["config_un_healthy_host_count_alarm"] = config_un_healthy_host_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_healthy_host_count_alarm(
        self,
    ) -> typing.Optional[ApplicationTargetGroupHealthyHostCountAlarmConfig]:
        '''The configuration for the HealthyHostCount alarm.'''
        result = self._values.get("config_healthy_host_count_alarm")
        return typing.cast(typing.Optional[ApplicationTargetGroupHealthyHostCountAlarmConfig], result)

    @builtins.property
    def config_un_healthy_host_count_alarm(
        self,
    ) -> typing.Optional["ApplicationTargetGroupUnHealthyHostCountAlarmConfig"]:
        '''The configuration for the UnHealthyHostCount alarm.'''
        result = self._values.get("config_un_healthy_host_count_alarm")
        return typing.cast(typing.Optional["ApplicationTargetGroupUnHealthyHostCountAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["ApplicationTargetGroupRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["ApplicationTargetGroupRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationTargetGroupRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupRecommendedAlarmsMetrics"
)
class ApplicationTargetGroupRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for ApplicationTargetGroup alarms.'''

    HEALTHY_HOST_COUNT = "HEALTHY_HOST_COUNT"
    '''The number of healthy targets in the target group.'''
    UNHEALTHY_HOST_COUNT = "UNHEALTHY_HOST_COUNT"
    '''The number of unhealthy targets in the target group.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupRecommendedAlarmsProps",
    jsii_struct_bases=[ApplicationTargetGroupRecommendedAlarmsConfig],
    name_mapping={
        "config_healthy_host_count_alarm": "configHealthyHostCountAlarm",
        "config_un_healthy_host_count_alarm": "configUnHealthyHostCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "target_group": "targetGroup",
    },
)
class ApplicationTargetGroupRecommendedAlarmsProps(
    ApplicationTargetGroupRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config_healthy_host_count_alarm: typing.Optional[typing.Union[ApplicationTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_un_healthy_host_count_alarm: typing.Optional[typing.Union["ApplicationTargetGroupUnHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[ApplicationTargetGroupRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
    ) -> None:
        '''Properties for the ApplicationTargetGroupRecommendedAlarms construct.

        :param config_healthy_host_count_alarm: The configuration for the HealthyHostCount alarm.
        :param config_un_healthy_host_count_alarm: The configuration for the UnHealthyHostCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param target_group: The ApplicationTargetGroup to monitor.
        '''
        if isinstance(config_healthy_host_count_alarm, dict):
            config_healthy_host_count_alarm = ApplicationTargetGroupHealthyHostCountAlarmConfig(**config_healthy_host_count_alarm)
        if isinstance(config_un_healthy_host_count_alarm, dict):
            config_un_healthy_host_count_alarm = ApplicationTargetGroupUnHealthyHostCountAlarmConfig(**config_un_healthy_host_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f69da420612f08b947e19d377b1ad5e60721379e53434b957d61153604c36e1)
            check_type(argname="argument config_healthy_host_count_alarm", value=config_healthy_host_count_alarm, expected_type=type_hints["config_healthy_host_count_alarm"])
            check_type(argname="argument config_un_healthy_host_count_alarm", value=config_un_healthy_host_count_alarm, expected_type=type_hints["config_un_healthy_host_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument target_group", value=target_group, expected_type=type_hints["target_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "target_group": target_group,
        }
        if config_healthy_host_count_alarm is not None:
            self._values["config_healthy_host_count_alarm"] = config_healthy_host_count_alarm
        if config_un_healthy_host_count_alarm is not None:
            self._values["config_un_healthy_host_count_alarm"] = config_un_healthy_host_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_healthy_host_count_alarm(
        self,
    ) -> typing.Optional[ApplicationTargetGroupHealthyHostCountAlarmConfig]:
        '''The configuration for the HealthyHostCount alarm.'''
        result = self._values.get("config_healthy_host_count_alarm")
        return typing.cast(typing.Optional[ApplicationTargetGroupHealthyHostCountAlarmConfig], result)

    @builtins.property
    def config_un_healthy_host_count_alarm(
        self,
    ) -> typing.Optional["ApplicationTargetGroupUnHealthyHostCountAlarmConfig"]:
        '''The configuration for the UnHealthyHostCount alarm.'''
        result = self._values.get("config_un_healthy_host_count_alarm")
        return typing.cast(typing.Optional["ApplicationTargetGroupUnHealthyHostCountAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[ApplicationTargetGroupRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[ApplicationTargetGroupRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def target_group(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup:
        '''The ApplicationTargetGroup to monitor.'''
        result = self._values.get("target_group")
        assert result is not None, "Required property 'target_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationTargetGroupRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ApplicationTargetGroupUnHealthyHostCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupUnHealthyHostCountAlarm",
):
    '''This alarm is used to detect when the number of unhealthy hosts in the target group exceeds the threshold.

    A high number of unhealthy hosts can indicate service health issues.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param target_group: The ApplicationTargetGroup to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of unhealthy hosts in the target group exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - UnHealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the maximum number of unhealthy hosts that your application can tolerate before service is impacted. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f430a7a39a1f1b915f5b663d4636e2c739a435c15ad3c59786229d1d238d93c6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ApplicationTargetGroupUnHealthyHostCountAlarmProps(
            target_group=target_group,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupUnHealthyHostCountAlarmConfig",
    jsii_struct_bases=[ApplicationTargetGroupAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ApplicationTargetGroupUnHealthyHostCountAlarmConfig(
    ApplicationTargetGroupAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the UnHealthyHostCount alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of unhealthy hosts in the target group exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - UnHealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the maximum number of unhealthy hosts that your application can tolerate before service is impacted. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__95557f03b14db822ef98d677e96577b75ce44a0efad5ac3c0be58f621379de2f)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the number of unhealthy hosts in the target group
        exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - targetGroupName + ' - UnHealthyHostCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the maximum number of unhealthy hosts
        that your application can tolerate before service is impacted.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationTargetGroupUnHealthyHostCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApplicationTargetGroupUnHealthyHostCountAlarmProps",
    jsii_struct_bases=[
        ApplicationTargetGroupAlarmProps,
        ApplicationTargetGroupUnHealthyHostCountAlarmConfig,
    ],
    name_mapping={
        "target_group": "targetGroup",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ApplicationTargetGroupUnHealthyHostCountAlarmProps(
    ApplicationTargetGroupAlarmProps,
    ApplicationTargetGroupUnHealthyHostCountAlarmConfig,
):
    def __init__(
        self,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ApplicationTargetGroupUnHealthyHostCountAlarm construct.

        :param target_group: The ApplicationTargetGroup to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of unhealthy hosts in the target group exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - UnHealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the maximum number of unhealthy hosts that your application can tolerate before service is impacted. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f6f05d2de207f9b375204838e135337da9e5b314006480a2437ff6c7607cd5f)
            check_type(argname="argument target_group", value=target_group, expected_type=type_hints["target_group"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "target_group": target_group,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def target_group(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup:
        '''The ApplicationTargetGroup to monitor.'''
        result = self._values.get("target_group")
        assert result is not None, "Required property 'target_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the number of unhealthy hosts in the target group
        exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - targetGroupName + ' - UnHealthyHostCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the maximum number of unhealthy hosts
        that your application can tolerate before service is impacted.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApplicationTargetGroupUnHealthyHostCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class AutoScalingAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f34c8bf92bc1f68db1fc43c47b2bed623d3e4e5b74fcabdf46f1b6be3adb19fb)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoScalingAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AutoScalingGroup(
    _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingGroup",
):
    '''An extension for the AutoScalingGroup construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
        init: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.CloudFormationInit] = None,
        init_options: typing.Optional[typing.Union[_aws_cdk_aws_autoscaling_ceddda9d.ApplyCloudFormationInitOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        instance_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.InstanceType] = None,
        launch_template: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ILaunchTemplate] = None,
        machine_image: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IMachineImage] = None,
        max_healthy_percentage: typing.Optional[jsii.Number] = None,
        min_healthy_percentage: typing.Optional[jsii.Number] = None,
        mixed_instances_policy: typing.Optional[typing.Union[_aws_cdk_aws_autoscaling_ceddda9d.MixedInstancesPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
        require_imdsv2: typing.Optional[builtins.bool] = None,
        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        security_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup] = None,
        user_data: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.UserData] = None,
        allow_all_outbound: typing.Optional[builtins.bool] = None,
        associate_public_ip_address: typing.Optional[builtins.bool] = None,
        auto_scaling_group_name: typing.Optional[builtins.str] = None,
        az_capacity_distribution_strategy: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.CapacityDistributionStrategy] = None,
        block_devices: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_autoscaling_ceddda9d.BlockDevice, typing.Dict[builtins.str, typing.Any]]]] = None,
        capacity_rebalance: typing.Optional[builtins.bool] = None,
        cooldown: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        default_instance_warmup: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        desired_capacity: typing.Optional[jsii.Number] = None,
        group_metrics: typing.Optional[typing.Sequence[_aws_cdk_aws_autoscaling_ceddda9d.GroupMetrics]] = None,
        health_check: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.HealthCheck] = None,
        health_checks: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.HealthChecks] = None,
        ignore_unmodified_size_properties: typing.Optional[builtins.bool] = None,
        instance_monitoring: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.Monitoring] = None,
        key_name: typing.Optional[builtins.str] = None,
        key_pair: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IKeyPair] = None,
        max_capacity: typing.Optional[jsii.Number] = None,
        max_instance_lifetime: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        min_capacity: typing.Optional[jsii.Number] = None,
        new_instances_protected_from_scale_in: typing.Optional[builtins.bool] = None,
        notifications: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_autoscaling_ceddda9d.NotificationConfiguration, typing.Dict[builtins.str, typing.Any]]]] = None,
        signals: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.Signals] = None,
        spot_price: typing.Optional[builtins.str] = None,
        ssm_session_permissions: typing.Optional[builtins.bool] = None,
        termination_policies: typing.Optional[typing.Sequence[_aws_cdk_aws_autoscaling_ceddda9d.TerminationPolicy]] = None,
        termination_policy_custom_lambda_function_arn: typing.Optional[builtins.str] = None,
        update_policy: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.UpdatePolicy] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc: VPC to launch these instances in.
        :param init: Apply the given CloudFormation Init configuration to the instances in the AutoScalingGroup at startup. If you specify ``init``, you must also specify ``signals`` to configure the number of instances to wait for and the timeout for waiting for the init process. Default: - no CloudFormation init
        :param init_options: Use the given options for applying CloudFormation Init. Describes the configsets to use and the timeout to wait Default: - default options
        :param instance_type: Type of instance to launch. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Do not provide any instance type
        :param launch_template: Launch template to use. Launch configuration related settings and MixedInstancesPolicy must not be specified when a launch template is specified. Default: - Do not provide any launch template
        :param machine_image: AMI to launch. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Do not provide any machine image
        :param max_healthy_percentage: Specifies the upper threshold as a percentage of the desired capacity of the Auto Scaling group. It represents the maximum percentage of the group that can be in service and healthy, or pending, to support your workload when replacing instances. Value range is 0 to 100. After it's set, both ``minHealthyPercentage`` and ``maxHealthyPercentage`` to -1 will clear the previously set value. Both or neither of ``minHealthyPercentage`` and ``maxHealthyPercentage`` must be specified, and the difference between them cannot be greater than 100. A large range increases the number of instances that can be replaced at the same time. Default: - No instance maintenance policy.
        :param min_healthy_percentage: Specifies the lower threshold as a percentage of the desired capacity of the Auto Scaling group. It represents the minimum percentage of the group to keep in service, healthy, and ready to use to support your workload when replacing instances. Value range is 0 to 100. After it's set, both ``minHealthyPercentage`` and ``maxHealthyPercentage`` to -1 will clear the previously set value. Both or neither of ``minHealthyPercentage`` and ``maxHealthyPercentage`` must be specified, and the difference between them cannot be greater than 100. A large range increases the number of instances that can be replaced at the same time. Default: - No instance maintenance policy.
        :param mixed_instances_policy: Mixed Instances Policy to use. Launch configuration related settings and Launch Template must not be specified when a MixedInstancesPolicy is specified. Default: - Do not provide any MixedInstancesPolicy
        :param require_imdsv2: Whether IMDSv2 should be required on launched instances. Default: false
        :param role: An IAM role to associate with the instance profile assigned to this Auto Scaling Group. The role must be assumable by the service principal ``ec2.amazonaws.com``: ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: A role will automatically be created, it can be accessed via the ``role`` property
        :param security_group: Security group to launch the instances in. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - A SecurityGroup will be created if none is specified.
        :param user_data: Specific UserData to use. The UserData may still be mutated after creation. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - A UserData object appropriate for the MachineImage's Operating System is created.
        :param allow_all_outbound: Whether the instances can initiate connections to anywhere by default. Default: true
        :param associate_public_ip_address: Whether instances in the Auto Scaling Group should have public IP addresses associated with them. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Use subnet setting.
        :param auto_scaling_group_name: The name of the Auto Scaling group. This name must be unique per Region per account. Default: - Auto generated by CloudFormation
        :param az_capacity_distribution_strategy: The strategy for distributing instances across Availability Zones. Default: None
        :param block_devices: Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Uses the block device mapping of the AMI
        :param capacity_rebalance: Indicates whether Capacity Rebalancing is enabled. When you turn on Capacity Rebalancing, Amazon EC2 Auto Scaling attempts to launch a Spot Instance whenever Amazon EC2 notifies that a Spot Instance is at an elevated risk of interruption. After launching a new instance, it then terminates an old instance. Default: false
        :param cooldown: Default scaling cooldown for this AutoScalingGroup. Default: Duration.minutes(5)
        :param default_instance_warmup: The amount of time, in seconds, until a newly launched instance can contribute to the Amazon CloudWatch metrics. This delay lets an instance finish initializing before Amazon EC2 Auto Scaling aggregates instance metrics, resulting in more reliable usage data. Set this value equal to the amount of time that it takes for resource consumption to become stable after an instance reaches the InService state. To optimize the performance of scaling policies that scale continuously, such as target tracking and step scaling policies, we strongly recommend that you enable the default instance warmup, even if its value is set to 0 seconds Default instance warmup will not be added if no value is specified Default: None
        :param desired_capacity: Initial amount of instances in the fleet. If this is set to a number, every deployment will reset the amount of instances to this number. It is recommended to leave this value blank. Default: minCapacity, and leave unchanged during deployment
        :param group_metrics: Enable monitoring for group metrics, these metrics describe the group rather than any of its instances. To report all group metrics use ``GroupMetrics.all()`` Group metrics are reported in a granularity of 1 minute at no additional charge. Default: - no group metrics will be reported
        :param health_check: (deprecated) Configuration for health checks. Default: - HealthCheck.ec2 with no grace period
        :param health_checks: Configuration for EC2 or additional health checks. Even when using ``HealthChecks.withAdditionalChecks()``, the EC2 type is implicitly included. Default: - EC2 type with no grace period
        :param ignore_unmodified_size_properties: If the ASG has scheduled actions, don't reset unchanged group sizes. Only used if the ASG has scheduled actions (which may scale your ASG up or down regardless of cdk deployments). If true, the size of the group will only be reset if it has been changed in the CDK app. If false, the sizes will always be changed back to what they were in the CDK app on deployment. Default: true
        :param instance_monitoring: Controls whether instances in this group are launched with detailed or basic monitoring. When detailed monitoring is enabled, Amazon CloudWatch generates metrics every minute and your account is charged a fee. When you disable detailed monitoring, CloudWatch generates metrics every 5 minutes. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: - Monitoring.DETAILED
        :param key_name: (deprecated) Name of SSH keypair to grant access to instances. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified You can either specify ``keyPair`` or ``keyName``, not both. Default: - No SSH access will be possible.
        :param key_pair: The SSH keypair to grant access to the instance. Feature flag ``AUTOSCALING_GENERATE_LAUNCH_TEMPLATE`` must be enabled to use this property. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified. You can either specify ``keyPair`` or ``keyName``, not both. Default: - No SSH access will be possible.
        :param max_capacity: Maximum number of instances in the fleet. Default: desiredCapacity
        :param max_instance_lifetime: The maximum amount of time that an instance can be in service. The maximum duration applies to all current and future instances in the group. As an instance approaches its maximum duration, it is terminated and replaced, and cannot be used again. You must specify a value of at least 604,800 seconds (7 days). To clear a previously set value, leave this property undefined. Default: none
        :param min_capacity: Minimum number of instances in the fleet. Default: 1
        :param new_instances_protected_from_scale_in: Whether newly-launched instances are protected from termination by Amazon EC2 Auto Scaling when scaling in. By default, Auto Scaling can terminate an instance at any time after launch when scaling in an Auto Scaling Group, subject to the group's termination policy. However, you may wish to protect newly-launched instances from being scaled in if they are going to run critical applications that should not be prematurely terminated. This flag must be enabled if the Auto Scaling Group will be associated with an ECS Capacity Provider with managed termination protection. Default: false
        :param notifications: Configure autoscaling group to send notifications about fleet changes to an SNS topic(s). Default: - No fleet change notifications will be sent.
        :param signals: Configure waiting for signals during deployment. Use this to pause the CloudFormation deployment to wait for the instances in the AutoScalingGroup to report successful startup during creation and updates. The UserData script needs to invoke ``cfn-signal`` with a success or failure code after it is done setting up the instance. Without waiting for signals, the CloudFormation deployment will proceed as soon as the AutoScalingGroup has been created or updated but before the instances in the group have been started. For example, to have instances wait for an Elastic Load Balancing health check before they signal success, add a health-check verification by using the cfn-init helper script. For an example, see the verify_instance_health command in the Auto Scaling rolling updates sample template: https://github.com/awslabs/aws-cloudformation-templates/blob/master/aws/services/AutoScaling/AutoScalingRollingUpdates.yaml Default: - Do not wait for signals
        :param spot_price: The maximum hourly price (in USD) to be paid for any Spot Instance launched to fulfill the request. Spot Instances are launched when the price you specify exceeds the current Spot market price. ``launchTemplate`` and ``mixedInstancesPolicy`` must not be specified when this property is specified Default: none
        :param ssm_session_permissions: Add SSM session permissions to the instance role. Setting this to ``true`` adds the necessary permissions to connect to the instance using SSM Session Manager. You can do this from the AWS Console. NOTE: Setting this flag to ``true`` may not be enough by itself. You must also use an AMI that comes with the SSM Agent, or install the SSM Agent yourself. See `Working with SSM Agent <https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent.html>`_ in the SSM Developer Guide. Default: false
        :param termination_policies: A policy or a list of policies that are used to select the instances to terminate. The policies are executed in the order that you list them. Default: - ``TerminationPolicy.DEFAULT``
        :param termination_policy_custom_lambda_function_arn: A lambda function Arn that can be used as a custom termination policy to select the instances to terminate. This property must be specified if the TerminationPolicy.CUSTOM_LAMBDA_FUNCTION is used. Default: - No lambda function Arn will be supplied
        :param update_policy: What to do when an AutoScalingGroup's instance configuration is changed. This is applied when any of the settings on the ASG are changed that affect how the instances should be created (VPC, instance type, startup scripts, etc.). It indicates how the existing instances should be replaced with new instances matching the new config. By default, nothing is done and only new instances are launched with the new config. Default: - ``UpdatePolicy.rollingUpdate()`` if using ``init``, ``UpdatePolicy.none()`` otherwise
        :param vpc_subnets: Where to place instances within the VPC. Default: - All Private subnets.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0e9f80bdc24a7bb9bf530d5b966c33921cf9260ef5f57056e14dfc2d48ea0a97)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroupProps(
            vpc=vpc,
            init=init,
            init_options=init_options,
            instance_type=instance_type,
            launch_template=launch_template,
            machine_image=machine_image,
            max_healthy_percentage=max_healthy_percentage,
            min_healthy_percentage=min_healthy_percentage,
            mixed_instances_policy=mixed_instances_policy,
            require_imdsv2=require_imdsv2,
            role=role,
            security_group=security_group,
            user_data=user_data,
            allow_all_outbound=allow_all_outbound,
            associate_public_ip_address=associate_public_ip_address,
            auto_scaling_group_name=auto_scaling_group_name,
            az_capacity_distribution_strategy=az_capacity_distribution_strategy,
            block_devices=block_devices,
            capacity_rebalance=capacity_rebalance,
            cooldown=cooldown,
            default_instance_warmup=default_instance_warmup,
            desired_capacity=desired_capacity,
            group_metrics=group_metrics,
            health_check=health_check,
            health_checks=health_checks,
            ignore_unmodified_size_properties=ignore_unmodified_size_properties,
            instance_monitoring=instance_monitoring,
            key_name=key_name,
            key_pair=key_pair,
            max_capacity=max_capacity,
            max_instance_lifetime=max_instance_lifetime,
            min_capacity=min_capacity,
            new_instances_protected_from_scale_in=new_instances_protected_from_scale_in,
            notifications=notifications,
            signals=signals,
            spot_price=spot_price,
            ssm_session_permissions=ssm_session_permissions,
            termination_policies=termination_policies,
            termination_policy_custom_lambda_function_arn=termination_policy_custom_lambda_function_arn,
            update_policy=update_policy,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmGroupInServiceCapacity")
    def alarm_group_in_service_capacity(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "AutoScalingGroupGroupInServiceCapacityAlarm":
        '''Creates an alarm that monitors the GroupInServiceCapacity for the EC2 autoScalingGroup.

        :param threshold: The threshold value should be the minimum capacity required to run your workload. In most cases, you can set this to match the GroupDesiredCapacity metric.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect a low availability in your auto scaling group because of launch failures or suspended launches.
        :param alarm_name: The alarm name. Default: - autoScalingGroupName + ' - GroupInServiceCapacity'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = AutoScalingGroupInServiceCapacityAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("AutoScalingGroupGroupInServiceCapacityAlarm", jsii.invoke(self, "alarmGroupInServiceCapacity", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_group_in_service_capacity_alarm: typing.Union["AutoScalingGroupInServiceCapacityAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["AutoScalingRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "AutoScalingGroupRecommendedAlarms":
        '''Creates the recommended alarms for the EC2 AutoScalingGroup.

        :param config_group_in_service_capacity_alarm: The configuration for the GroupInServiceCapacity alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#AutoScaling
        '''
        props = AutoScalingGroupRecommendedAlarmsConfig(
            config_group_in_service_capacity_alarm=config_group_in_service_capacity_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("AutoScalingGroupRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingGroupAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"auto_scaling_group": "autoScalingGroup"},
)
class AutoScalingGroupAlarmProps:
    def __init__(
        self,
        *,
        auto_scaling_group: _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
    ) -> None:
        '''The common properties for the EC2 AutoScalingGroup alarms.

        :param auto_scaling_group: The EC2 AutoScalingGroup to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d94d15da6ab5f02c6243b356d97c9d728043a324aca631806c5ea86e4b8e01ca)
            check_type(argname="argument auto_scaling_group", value=auto_scaling_group, expected_type=type_hints["auto_scaling_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auto_scaling_group": auto_scaling_group,
        }

    @builtins.property
    def auto_scaling_group(self) -> _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup:
        '''The EC2 AutoScalingGroup to monitor.'''
        result = self._values.get("auto_scaling_group")
        assert result is not None, "Required property 'auto_scaling_group' is missing"
        return typing.cast(_aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoScalingGroupAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AutoScalingGroupGroupInServiceCapacityAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingGroupGroupInServiceCapacityAlarm",
):
    '''This alarm helps to detect when the capacity in the group is below the desired capacity required for your workload.

    To troubleshoot, check your scaling activities for launch failures and confirm that your desired capacity configuration
    is correct.

    The alarm is triggered when the capacity in the group is less than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        auto_scaling_group: _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param auto_scaling_group: The EC2 AutoScalingGroup to monitor.
        :param threshold: The threshold value should be the minimum capacity required to run your workload. In most cases, you can set this to match the GroupDesiredCapacity metric.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect a low availability in your auto scaling group because of launch failures or suspended launches.
        :param alarm_name: The alarm name. Default: - autoScalingGroupName + ' - GroupInServiceCapacity'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__207504a11eca1048ab0f0cb0cd46ef472eab4a027cdc22dcb06b46c4d9380190)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AutoScalingGroupGroupInServiceCapacityAlarmProps(
            auto_scaling_group=auto_scaling_group,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingGroupInServiceCapacityAlarmConfig",
    jsii_struct_bases=[AutoScalingAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class AutoScalingGroupInServiceCapacityAlarmConfig(AutoScalingAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the GroupInServiceCapacity alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The threshold value should be the minimum capacity required to run your workload. In most cases, you can set this to match the GroupDesiredCapacity metric.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect a low availability in your auto scaling group because of launch failures or suspended launches.
        :param alarm_name: The alarm name. Default: - autoScalingGroupName + ' - GroupInServiceCapacity'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8bc12a9c6366827286d8a2eed3f9e658ad400eb435e198c1d19335addf45ed9f)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The threshold value should be the minimum capacity required to run your workload.

        In most cases,
        you can set this to match the GroupDesiredCapacity metric.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect a low availability in your auto scaling group because of launch failures
        or suspended launches.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - autoScalingGroupName + ' - GroupInServiceCapacity'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 10
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 10
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoScalingGroupInServiceCapacityAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class AutoScalingGroupRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingGroupRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an EC2 AutoScalingGroup.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#AutoScaling
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        auto_scaling_group: _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
        config_group_in_service_capacity_alarm: typing.Union[AutoScalingGroupInServiceCapacityAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["AutoScalingRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param auto_scaling_group: The EC2 AutoScalingGroup to monitor.
        :param config_group_in_service_capacity_alarm: The configuration for the GroupInServiceCapacity alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__80d1e0bb39d93b7b99e53b929044820b4b7ed6d9c2e028b1ca724e83ab38616d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = AutoScalingGroupRecommendedAlarmsProps(
            auto_scaling_group=auto_scaling_group,
            config_group_in_service_capacity_alarm=config_group_in_service_capacity_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmGroupInServiceCapacity")
    def alarm_group_in_service_capacity(
        self,
    ) -> typing.Optional[AutoScalingGroupGroupInServiceCapacityAlarm]:
        '''The GroupInServiceCapacity alarm.'''
        return typing.cast(typing.Optional[AutoScalingGroupGroupInServiceCapacityAlarm], jsii.get(self, "alarmGroupInServiceCapacity"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingGroupRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_group_in_service_capacity_alarm": "configGroupInServiceCapacityAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class AutoScalingGroupRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_group_in_service_capacity_alarm: typing.Union[AutoScalingGroupInServiceCapacityAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["AutoScalingRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an EC2 AutoScalingGroup.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_group_in_service_capacity_alarm: The configuration for the GroupInServiceCapacity alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_group_in_service_capacity_alarm, dict):
            config_group_in_service_capacity_alarm = AutoScalingGroupInServiceCapacityAlarmConfig(**config_group_in_service_capacity_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4eae16a88118a3a8b0f1e59758c25173fff964ec13d5833aa7199f039077fc97)
            check_type(argname="argument config_group_in_service_capacity_alarm", value=config_group_in_service_capacity_alarm, expected_type=type_hints["config_group_in_service_capacity_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_group_in_service_capacity_alarm": config_group_in_service_capacity_alarm,
        }
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_group_in_service_capacity_alarm(
        self,
    ) -> AutoScalingGroupInServiceCapacityAlarmConfig:
        '''The configuration for the GroupInServiceCapacity alarm.'''
        result = self._values.get("config_group_in_service_capacity_alarm")
        assert result is not None, "Required property 'config_group_in_service_capacity_alarm' is missing"
        return typing.cast(AutoScalingGroupInServiceCapacityAlarmConfig, result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["AutoScalingRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["AutoScalingRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoScalingGroupRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingGroupRecommendedAlarmsProps",
    jsii_struct_bases=[AutoScalingGroupRecommendedAlarmsConfig],
    name_mapping={
        "config_group_in_service_capacity_alarm": "configGroupInServiceCapacityAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "auto_scaling_group": "autoScalingGroup",
    },
)
class AutoScalingGroupRecommendedAlarmsProps(AutoScalingGroupRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config_group_in_service_capacity_alarm: typing.Union[AutoScalingGroupInServiceCapacityAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["AutoScalingRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        auto_scaling_group: _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
    ) -> None:
        '''Properties for the AutoScalingGroupRecommendedAlarms construct.

        :param config_group_in_service_capacity_alarm: The configuration for the GroupInServiceCapacity alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param auto_scaling_group: The EC2 AutoScalingGroup to monitor.
        '''
        if isinstance(config_group_in_service_capacity_alarm, dict):
            config_group_in_service_capacity_alarm = AutoScalingGroupInServiceCapacityAlarmConfig(**config_group_in_service_capacity_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__84f107eb6b9771648539a36155991f106e101c6f46985039a5e3ccb99826234e)
            check_type(argname="argument config_group_in_service_capacity_alarm", value=config_group_in_service_capacity_alarm, expected_type=type_hints["config_group_in_service_capacity_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument auto_scaling_group", value=auto_scaling_group, expected_type=type_hints["auto_scaling_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_group_in_service_capacity_alarm": config_group_in_service_capacity_alarm,
            "auto_scaling_group": auto_scaling_group,
        }
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_group_in_service_capacity_alarm(
        self,
    ) -> AutoScalingGroupInServiceCapacityAlarmConfig:
        '''The configuration for the GroupInServiceCapacity alarm.'''
        result = self._values.get("config_group_in_service_capacity_alarm")
        assert result is not None, "Required property 'config_group_in_service_capacity_alarm' is missing"
        return typing.cast(AutoScalingGroupInServiceCapacityAlarmConfig, result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["AutoScalingRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["AutoScalingRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def auto_scaling_group(self) -> _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup:
        '''The EC2 AutoScalingGroup to monitor.'''
        result = self._values.get("auto_scaling_group")
        assert result is not None, "Required property 'auto_scaling_group' is missing"
        return typing.cast(_aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoScalingGroupRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class AutoScalingRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an EC2 AutoScalingGroup.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#AutoScaling
    '''

    def __init__(
        self,
        *,
        config_group_in_service_capacity_alarm: typing.Union[AutoScalingGroupInServiceCapacityAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["AutoScalingRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_group_in_service_capacity_alarm: The configuration for the GroupInServiceCapacity alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = AutoScalingGroupRecommendedAlarmsConfig(
            config_group_in_service_capacity_alarm=config_group_in_service_capacity_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c76a791474124f52989c8eac7d582ed82be8d4a1aa8c88ec8952367d68aab818)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingRecommendedAlarmsMetrics"
)
class AutoScalingRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for EC2 AutoScaling alarms.'''

    GROUP_IN_SERVICE_CAPACITY = "GROUP_IN_SERVICE_CAPACITY"
    '''The number of capacity units that are running as part of the Auto Scaling group.'''


class Bucket(
    _aws_cdk_aws_s3_ceddda9d.Bucket,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Bucket",
):
    '''An extension for the S3 Bucket construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        access_control: typing.Optional[_aws_cdk_aws_s3_ceddda9d.BucketAccessControl] = None,
        auto_delete_objects: typing.Optional[builtins.bool] = None,
        block_public_access: typing.Optional[_aws_cdk_aws_s3_ceddda9d.BlockPublicAccess] = None,
        bucket_key_enabled: typing.Optional[builtins.bool] = None,
        bucket_name: typing.Optional[builtins.str] = None,
        cors: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.CorsRule, typing.Dict[builtins.str, typing.Any]]]] = None,
        encryption: typing.Optional[_aws_cdk_aws_s3_ceddda9d.BucketEncryption] = None,
        encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        enforce_ssl: typing.Optional[builtins.bool] = None,
        event_bridge_enabled: typing.Optional[builtins.bool] = None,
        intelligent_tiering_configurations: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.IntelligentTieringConfiguration, typing.Dict[builtins.str, typing.Any]]]] = None,
        inventories: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.Inventory, typing.Dict[builtins.str, typing.Any]]]] = None,
        lifecycle_rules: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.LifecycleRule, typing.Dict[builtins.str, typing.Any]]]] = None,
        metrics: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.BucketMetrics, typing.Dict[builtins.str, typing.Any]]]] = None,
        minimum_tls_version: typing.Optional[jsii.Number] = None,
        notifications_handler_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        notifications_skip_destination_validation: typing.Optional[builtins.bool] = None,
        object_lock_default_retention: typing.Optional[_aws_cdk_aws_s3_ceddda9d.ObjectLockRetention] = None,
        object_lock_enabled: typing.Optional[builtins.bool] = None,
        object_ownership: typing.Optional[_aws_cdk_aws_s3_ceddda9d.ObjectOwnership] = None,
        public_read_access: typing.Optional[builtins.bool] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        replication_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        replication_rules: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.ReplicationRule, typing.Dict[builtins.str, typing.Any]]]] = None,
        server_access_logs_bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
        server_access_logs_prefix: typing.Optional[builtins.str] = None,
        target_object_key_format: typing.Optional[_aws_cdk_aws_s3_ceddda9d.TargetObjectKeyFormat] = None,
        transfer_acceleration: typing.Optional[builtins.bool] = None,
        transition_default_minimum_object_size: typing.Optional[_aws_cdk_aws_s3_ceddda9d.TransitionDefaultMinimumObjectSize] = None,
        versioned: typing.Optional[builtins.bool] = None,
        website_error_document: typing.Optional[builtins.str] = None,
        website_index_document: typing.Optional[builtins.str] = None,
        website_redirect: typing.Optional[typing.Union[_aws_cdk_aws_s3_ceddda9d.RedirectTarget, typing.Dict[builtins.str, typing.Any]]] = None,
        website_routing_rules: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.RoutingRule, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param access_control: Specifies a canned ACL that grants predefined permissions to the bucket. Default: BucketAccessControl.PRIVATE
        :param auto_delete_objects: Whether all objects should be automatically deleted when the bucket is removed from the stack or when the stack is deleted. Requires the ``removalPolicy`` to be set to ``RemovalPolicy.DESTROY``. **Warning** if you have deployed a bucket with ``autoDeleteObjects: true``, switching this to ``false`` in a CDK version *before* ``1.126.0`` will lead to all objects in the bucket being deleted. Be sure to update your bucket resources by deploying with CDK version ``1.126.0`` or later **before** switching this value to ``false``. Setting ``autoDeleteObjects`` to true on a bucket will add ``s3:PutBucketPolicy`` to the bucket policy. This is because during bucket deletion, the custom resource provider needs to update the bucket policy by adding a deny policy for ``s3:PutObject`` to prevent race conditions with external bucket writers. Default: false
        :param block_public_access: The block public access configuration of this bucket. Default: - CloudFormation defaults will apply. New buckets and objects don't allow public access, but users can modify bucket policies or object permissions to allow public access
        :param bucket_key_enabled: Whether Amazon S3 should use its own intermediary key to generate data keys. Only relevant when using KMS for encryption. - If not enabled, every object GET and PUT will cause an API call to KMS (with the attendant cost implications of that). - If enabled, S3 will use its own time-limited key instead. Only relevant, when Encryption is not set to ``BucketEncryption.UNENCRYPTED``. Default: - false
        :param bucket_name: Physical name of this bucket. Default: - Assigned by CloudFormation (recommended).
        :param cors: The CORS configuration of this bucket. Default: - No CORS configuration.
        :param encryption: The kind of server-side encryption to apply to this bucket. If you choose KMS, you can specify a KMS key via ``encryptionKey``. If encryption key is not specified, a key will automatically be created. Default: - ``KMS`` if ``encryptionKey`` is specified, or ``S3_MANAGED`` otherwise.
        :param encryption_key: External KMS key to use for bucket encryption. The ``encryption`` property must be either not specified or set to ``KMS`` or ``DSSE``. An error will be emitted if ``encryption`` is set to ``UNENCRYPTED`` or ``S3_MANAGED``. Default: - If ``encryption`` is set to ``KMS`` and this property is undefined, a new KMS key will be created and associated with this bucket.
        :param enforce_ssl: Enforces SSL for requests. S3.5 of the AWS Foundational Security Best Practices Regarding S3. Default: false
        :param event_bridge_enabled: Whether this bucket should send notifications to Amazon EventBridge or not. Default: false
        :param intelligent_tiering_configurations: Intelligent Tiering Configurations. Default: No Intelligent Tiiering Configurations.
        :param inventories: The inventory configuration of the bucket. Default: - No inventory configuration
        :param lifecycle_rules: Rules that define how Amazon S3 manages objects during their lifetime. Default: - No lifecycle rules.
        :param metrics: The metrics configuration of this bucket. Default: - No metrics configuration.
        :param minimum_tls_version: Enforces minimum TLS version for requests. Requires ``enforceSSL`` to be enabled. Default: No minimum TLS version is enforced.
        :param notifications_handler_role: The role to be used by the notifications handler. Default: - a new role will be created.
        :param notifications_skip_destination_validation: Skips notification validation of Amazon SQS, Amazon SNS, and Lambda destinations. Default: false
        :param object_lock_default_retention: The default retention mode and rules for S3 Object Lock. Default retention can be configured after a bucket is created if the bucket already has object lock enabled. Enabling object lock for existing buckets is not supported. Default: no default retention period
        :param object_lock_enabled: Enable object lock on the bucket. Enabling object lock for existing buckets is not supported. Object lock must be enabled when the bucket is created. Default: false, unless objectLockDefaultRetention is set (then, true)
        :param object_ownership: The objectOwnership of the bucket. Default: - No ObjectOwnership configuration. By default, Amazon S3 sets Object Ownership to ``Bucket owner enforced``. This means ACLs are disabled and the bucket owner will own every object.
        :param public_read_access: Grants public read access to all objects in the bucket. Similar to calling ``bucket.grantPublicAccess()`` Default: false
        :param removal_policy: Policy to apply when the bucket is removed from this stack. Default: - The bucket will be orphaned.
        :param replication_role: The role to be used by the replication. When setting this property, you must also set ``replicationRules``. Default: - a new role will be created.
        :param replication_rules: A container for one or more replication rules. Default: - No replication
        :param server_access_logs_bucket: Destination bucket for the server access logs. Default: - If "serverAccessLogsPrefix" undefined - access logs disabled, otherwise - log to current bucket.
        :param server_access_logs_prefix: Optional log file prefix to use for the bucket's access logs. If defined without "serverAccessLogsBucket", enables access logs to current bucket with this prefix. Default: - No log file prefix
        :param target_object_key_format: Optional key format for log objects. Default: - the default key format is: [DestinationPrefix][YYYY]-[MM]-[DD]-[hh]-[mm]-[ss]-[UniqueString]
        :param transfer_acceleration: Whether this bucket should have transfer acceleration turned on or not. Default: false
        :param transition_default_minimum_object_size: Indicates which default minimum object size behavior is applied to the lifecycle configuration. To customize the minimum object size for any transition you can add a filter that specifies a custom ``objectSizeGreaterThan`` or ``objectSizeLessThan`` for ``lifecycleRules`` property. Custom filters always take precedence over the default transition behavior. Default: - TransitionDefaultMinimumObjectSize.VARIES_BY_STORAGE_CLASS before September 2024, otherwise TransitionDefaultMinimumObjectSize.ALL_STORAGE_CLASSES_128_K.
        :param versioned: Whether this bucket should have versioning turned on or not. Default: false (unless object lock is enabled, then true)
        :param website_error_document: The name of the error document (e.g. "404.html") for the website. ``websiteIndexDocument`` must also be set if this is set. Default: - No error document.
        :param website_index_document: The name of the index document (e.g. "index.html") for the website. Enables static website hosting for this bucket. Default: - No index document.
        :param website_redirect: Specifies the redirect behavior of all requests to a website endpoint of a bucket. If you specify this property, you can't specify "websiteIndexDocument", "websiteErrorDocument" nor , "websiteRoutingRules". Default: - No redirection.
        :param website_routing_rules: Rules that define when a redirect is applied and the redirect behavior. Default: - No redirection rules.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__997fd23e9dec2f8580d4a0f3905a7216624c6b51043d6491f7523aa123af316d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_s3_ceddda9d.BucketProps(
            access_control=access_control,
            auto_delete_objects=auto_delete_objects,
            block_public_access=block_public_access,
            bucket_key_enabled=bucket_key_enabled,
            bucket_name=bucket_name,
            cors=cors,
            encryption=encryption,
            encryption_key=encryption_key,
            enforce_ssl=enforce_ssl,
            event_bridge_enabled=event_bridge_enabled,
            intelligent_tiering_configurations=intelligent_tiering_configurations,
            inventories=inventories,
            lifecycle_rules=lifecycle_rules,
            metrics=metrics,
            minimum_tls_version=minimum_tls_version,
            notifications_handler_role=notifications_handler_role,
            notifications_skip_destination_validation=notifications_skip_destination_validation,
            object_lock_default_retention=object_lock_default_retention,
            object_lock_enabled=object_lock_enabled,
            object_ownership=object_ownership,
            public_read_access=public_read_access,
            removal_policy=removal_policy,
            replication_role=replication_role,
            replication_rules=replication_rules,
            server_access_logs_bucket=server_access_logs_bucket,
            server_access_logs_prefix=server_access_logs_prefix,
            target_object_key_format=target_object_key_format,
            transfer_acceleration=transfer_acceleration,
            transition_default_minimum_object_size=transition_default_minimum_object_size,
            versioned=versioned,
            website_error_document=website_error_document,
            website_index_document=website_index_document,
            website_redirect=website_redirect,
            website_routing_rules=website_routing_rules,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarm4xxErrors")
    def alarm4xx_errors(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "S3Bucket4xxErrorsAlarm":
        '''Creates an alarm that monitors the 4xx errors for the S3 bucket.

        :param alarm_description: The alarm description. Default: - This alarm helps us report the total number of 4xx error status codes that are made in response to client requests. 403 error codes might indicate an incorrect IAM policy, and 404 error codes might indicate mis-behaving client application, for example. Enabling S3 server access logging on a temporary basis will help you to pinpoint the issue's origin using the fields HTTP status and Error Code. To understand more about the error code, see Error Responses (https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html).
        :param alarm_name: The alarm name. Default: - bucket.bucketName + ' - 4xxErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. Default: 0.05
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = S3Bucket4xxErrorsAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            threshold=threshold,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("S3Bucket4xxErrorsAlarm", jsii.invoke(self, "alarm4xxErrors", [props]))

    @jsii.member(jsii_name="alarm5xxErrors")
    def alarm5xx_errors(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "S3Bucket5xxErrorsAlarm":
        '''Creates an alarm that monitors the 5xx errors for the S3 bucket.

        :param alarm_description: The alarm description. Default: - This alarm helps you detect a high number of server-side errors. These errors indicate that a client made a request that the server couldnt complete. This can help you correlate the issue your application is facing because of S3. For more information to help you efficiently handle or reduce errors, see Optimizing performance design patterns (https://docs.aws.amazon.com/AmazonS3/latest/userguide/optimizing-performance-design-patterns.html#optimizing-performance-timeouts-retries). Errors might also be caused by an the issue with S3, check AWS service health dashboard for the status of Amazon S3 in your Region.
        :param alarm_name: The alarm name. Default: - bucket.bucketName + ' - 5xxErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. Default: 0.05
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = S3Bucket5xxErrorsAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            threshold=threshold,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("S3Bucket5xxErrorsAlarm", jsii.invoke(self, "alarm5xxErrors", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config4xx_errors_alarm: typing.Optional[typing.Union["S3Bucket4xxErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config5xx_errors_alarm: typing.Optional[typing.Union["S3Bucket5xxErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["S3RecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "S3RecommendedAlarms":
        '''Creates the recommended alarms for the S3 bucket.

        :param config4xx_errors_alarm: The configuration for the 4xx errors alarm.
        :param config5xx_errors_alarm: The configuration for the 5xx errors alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#S3
        '''
        props = S3RecommendedAlarmsConfig(
            config4xx_errors_alarm=config4xx_errors_alarm,
            config5xx_errors_alarm=config5xx_errors_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("S3RecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


class CfnCacheCluster(
    _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CfnCacheCluster",
):
    '''An extension for the CfnCacheCluster construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cache_node_type: builtins.str,
        engine: builtins.str,
        num_cache_nodes: jsii.Number,
        auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        az_mode: typing.Optional[builtins.str] = None,
        cache_parameter_group_name: typing.Optional[builtins.str] = None,
        cache_security_group_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        cache_subnet_group_name: typing.Optional[builtins.str] = None,
        cluster_name: typing.Optional[builtins.str] = None,
        engine_version: typing.Optional[builtins.str] = None,
        ip_discovery: typing.Optional[builtins.str] = None,
        log_delivery_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster.LogDeliveryConfigurationRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        network_type: typing.Optional[builtins.str] = None,
        notification_topic_arn: typing.Optional[builtins.str] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_availability_zone: typing.Optional[builtins.str] = None,
        preferred_availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        snapshot_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        snapshot_name: typing.Optional[builtins.str] = None,
        snapshot_retention_limit: typing.Optional[jsii.Number] = None,
        snapshot_window: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_encryption_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cache_node_type: The compute and memory capacity of the nodes in the node group (shard). The following node types are supported by ElastiCache. Generally speaking, the current generation types provide more memory and computational power at lower cost when compared to their equivalent previous generation counterparts. Changing the CacheNodeType of a Memcached instance is currently not supported. If you need to scale using Memcached, we recommend forcing a replacement update by changing the ``LogicalResourceId`` of the resource. - General purpose: - Current generation: *M6g node types:* ``cache.m6g.large`` , ``cache.m6g.xlarge`` , ``cache.m6g.2xlarge`` , ``cache.m6g.4xlarge`` , ``cache.m6g.8xlarge`` , ``cache.m6g.12xlarge`` , ``cache.m6g.16xlarge`` , ``cache.m6g.24xlarge`` *M5 node types:* ``cache.m5.large`` , ``cache.m5.xlarge`` , ``cache.m5.2xlarge`` , ``cache.m5.4xlarge`` , ``cache.m5.12xlarge`` , ``cache.m5.24xlarge`` *M4 node types:* ``cache.m4.large`` , ``cache.m4.xlarge`` , ``cache.m4.2xlarge`` , ``cache.m4.4xlarge`` , ``cache.m4.10xlarge`` *T4g node types:* ``cache.t4g.micro`` , ``cache.t4g.small`` , ``cache.t4g.medium`` *T3 node types:* ``cache.t3.micro`` , ``cache.t3.small`` , ``cache.t3.medium`` *T2 node types:* ``cache.t2.micro`` , ``cache.t2.small`` , ``cache.t2.medium`` - Previous generation: (not recommended) *T1 node types:* ``cache.t1.micro`` *M1 node types:* ``cache.m1.small`` , ``cache.m1.medium`` , ``cache.m1.large`` , ``cache.m1.xlarge`` *M3 node types:* ``cache.m3.medium`` , ``cache.m3.large`` , ``cache.m3.xlarge`` , ``cache.m3.2xlarge`` - Compute optimized: - Previous generation: (not recommended) *C1 node types:* ``cache.c1.xlarge`` - Memory optimized: - Current generation: *R6gd node types:* ``cache.r6gd.xlarge`` , ``cache.r6gd.2xlarge`` , ``cache.r6gd.4xlarge`` , ``cache.r6gd.8xlarge`` , ``cache.r6gd.12xlarge`` , ``cache.r6gd.16xlarge`` .. epigraph:: The ``r6gd`` family is available in the following regions: ``us-east-2`` , ``us-east-1`` , ``us-west-2`` , ``us-west-1`` , ``eu-west-1`` , ``eu-central-1`` , ``ap-northeast-1`` , ``ap-southeast-1`` , ``ap-southeast-2`` . *R6g node types:* ``cache.r6g.large`` , ``cache.r6g.xlarge`` , ``cache.r6g.2xlarge`` , ``cache.r6g.4xlarge`` , ``cache.r6g.8xlarge`` , ``cache.r6g.12xlarge`` , ``cache.r6g.16xlarge`` , ``cache.r6g.24xlarge`` *R5 node types:* ``cache.r5.large`` , ``cache.r5.xlarge`` , ``cache.r5.2xlarge`` , ``cache.r5.4xlarge`` , ``cache.r5.12xlarge`` , ``cache.r5.24xlarge`` *R4 node types:* ``cache.r4.large`` , ``cache.r4.xlarge`` , ``cache.r4.2xlarge`` , ``cache.r4.4xlarge`` , ``cache.r4.8xlarge`` , ``cache.r4.16xlarge`` - Previous generation: (not recommended) *M2 node types:* ``cache.m2.xlarge`` , ``cache.m2.2xlarge`` , ``cache.m2.4xlarge`` *R3 node types:* ``cache.r3.large`` , ``cache.r3.xlarge`` , ``cache.r3.2xlarge`` , ``cache.r3.4xlarge`` , ``cache.r3.8xlarge`` For region availability, see `Supported Node Types by Region <https://docs.aws.amazon.com/AmazonElastiCache/latest/dg/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion>`_ *Additional node type info* - All current generation instance types are created in Amazon VPC by default. - Valkey and Redis OSS append-only files (AOF) are not supported for T1 or T2 instances. - Valkey and Redis OSS Multi-AZ with automatic failover is not supported on T1 instances. - Redis OSS configuration variables ``appendonly`` and ``appendfsync`` are not supported on Redis OSS version 2.8.22 and later.
        :param engine: The name of the cache engine to be used for this cluster. Valid values for this parameter are: ``memcached`` | valkey | ``redis``
        :param num_cache_nodes: The number of cache nodes that the cache cluster should have. .. epigraph:: However, if the ``PreferredAvailabilityZone`` and ``PreferredAvailabilityZones`` properties were not previously specified and you don't specify any new values, an update requires `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
        :param auto_minor_version_upgrade: If you are running Valkey 7.2 or later, or Redis OSS engine version 6.0 or later, set this parameter to yes if you want to opt-in to the next minor version upgrade campaign. This parameter is disabled for previous versions.
        :param az_mode: Specifies whether the nodes in this Memcached cluster are created in a single Availability Zone or created across multiple Availability Zones in the cluster's region. This parameter is only supported for Memcached clusters. If the ``AZMode`` and ``PreferredAvailabilityZones`` are not specified, ElastiCache assumes ``single-az`` mode.
        :param cache_parameter_group_name: The name of the parameter group to associate with this cluster. If this argument is omitted, the default parameter group for the specified engine is used. You cannot use any parameter group which has ``cluster-enabled='yes'`` when creating a cluster.
        :param cache_security_group_names: A list of security group names to associate with this cluster. Use this parameter only when you are creating a cluster outside of an Amazon Virtual Private Cloud (Amazon VPC).
        :param cache_subnet_group_name: The name of the subnet group to be used for the cluster. Use this parameter only when you are creating a cluster in an Amazon Virtual Private Cloud (Amazon VPC). .. epigraph:: If you're going to launch your cluster in an Amazon VPC, you need to create a subnet group before you start creating a cluster. For more information, see ``[AWS::ElastiCache::SubnetGroup](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticache-subnetgroup.html) .``
        :param cluster_name: A name for the cache cluster. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the cache cluster. For more information, see `Name Type <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html>`_ . The name must contain 1 to 50 alphanumeric characters or hyphens. The name must start with a letter and cannot end with a hyphen or contain two consecutive hyphens.
        :param engine_version: The version number of the cache engine to be used for this cluster. To view the supported cache engine versions, use the DescribeCacheEngineVersions operation. *Important:* You can upgrade to a newer engine version (see `Selecting a Cache Engine and Version <https://docs.aws.amazon.com/AmazonElastiCache/latest/dg/SelectEngine.html#VersionManagement>`_ ), but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing cluster or replication group and create it anew with the earlier engine version.
        :param ip_discovery: The network type you choose when modifying a cluster, either ``ipv4`` | ``ipv6`` . IPv6 is supported for workloads using Valkey 7.2 and above, Redis OSS engine version 6.2 to 7.1 and Memcached engine version 1.6.6 and above on all instances built on the `Nitro system <https://docs.aws.amazon.com/ec2/nitro/>`_ .
        :param log_delivery_configurations: Specifies the destination, format and type of the logs.
        :param network_type: Must be either ``ipv4`` | ``ipv6`` | ``dual_stack`` . IPv6 is supported for workloads using Valkey 7.2 and above, Redis OSS engine version 6.2 to 7.1 and Memcached engine version 1.6.6 and above on all instances built on the `Nitro system <https://docs.aws.amazon.com/ec2/nitro/>`_ .
        :param notification_topic_arn: The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent. .. epigraph:: The Amazon SNS topic owner must be the same as the cluster owner.
        :param port: The port number on which each of the cache nodes accepts connections.
        :param preferred_availability_zone: The EC2 Availability Zone in which the cluster is created. All nodes belonging to this cluster are placed in the preferred Availability Zone. If you want to create your nodes across multiple Availability Zones, use ``PreferredAvailabilityZones`` . Default: System chosen Availability Zone.
        :param preferred_availability_zones: A list of the Availability Zones in which cache nodes are created. The order of the zones in the list is not important. This option is only supported on Memcached. .. epigraph:: If you are creating your cluster in an Amazon VPC (recommended) you can only locate nodes in Availability Zones that are associated with the subnets in the selected subnet group. The number of Availability Zones listed must equal the value of ``NumCacheNodes`` . If you want all the nodes in the same Availability Zone, use ``PreferredAvailabilityZone`` instead, or repeat the Availability Zone multiple times in the list. Default: System chosen Availability Zones.
        :param preferred_maintenance_window: Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ``ddd`` are: - ``sun`` - ``mon`` - ``tue`` - ``wed`` - ``thu`` - ``fri`` - ``sat`` Example: ``sun:23:00-mon:01:30``
        :param snapshot_arns: A single-element string list containing an Amazon Resource Name (ARN) that uniquely identifies a Valkey or Redis OSS RDB snapshot file stored in Amazon S3. The snapshot file is used to populate the node group (shard). The Amazon S3 object name in the ARN cannot contain any commas. .. epigraph:: This parameter is only valid if the ``Engine`` parameter is ``redis`` . Example of an Amazon S3 ARN: ``arn:aws:s3:::my_bucket/snapshot1.rdb``
        :param snapshot_name: The name of a Valkey or Redis OSS snapshot from which to restore data into the new node group (shard). The snapshot status changes to ``restoring`` while the new node group (shard) is being created. .. epigraph:: This parameter is only valid if the ``Engine`` parameter is ``redis`` .
        :param snapshot_retention_limit: The number of days for which ElastiCache retains automatic snapshots before deleting them. For example, if you set ``SnapshotRetentionLimit`` to 5, a snapshot taken today is retained for 5 days before being deleted. .. epigraph:: This parameter is only valid if the ``Engine`` parameter is ``redis`` . Default: 0 (i.e., automatic backups are disabled for this cache cluster).
        :param snapshot_window: The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your node group (shard). Example: ``05:00-09:00`` If you do not specify this parameter, ElastiCache automatically chooses an appropriate time range. .. epigraph:: This parameter is only valid if the ``Engine`` parameter is ``redis`` .
        :param tags: A list of tags to be added to this resource.
        :param transit_encryption_enabled: A flag that enables in-transit encryption when set to true.
        :param vpc_security_group_ids: One or more VPC security groups associated with the cluster. Use this parameter only when you are creating a cluster in an Amazon Virtual Private Cloud (Amazon VPC).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86037cd53a11220db21e2416eb05b1fd5d54e13a1577d12e916d181d78bd28e4)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_elasticache_ceddda9d.CfnCacheClusterProps(
            cache_node_type=cache_node_type,
            engine=engine,
            num_cache_nodes=num_cache_nodes,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            az_mode=az_mode,
            cache_parameter_group_name=cache_parameter_group_name,
            cache_security_group_names=cache_security_group_names,
            cache_subnet_group_name=cache_subnet_group_name,
            cluster_name=cluster_name,
            engine_version=engine_version,
            ip_discovery=ip_discovery,
            log_delivery_configurations=log_delivery_configurations,
            network_type=network_type,
            notification_topic_arn=notification_topic_arn,
            port=port,
            preferred_availability_zone=preferred_availability_zone,
            preferred_availability_zones=preferred_availability_zones,
            preferred_maintenance_window=preferred_maintenance_window,
            snapshot_arns=snapshot_arns,
            snapshot_name=snapshot_name,
            snapshot_retention_limit=snapshot_retention_limit,
            snapshot_window=snapshot_window,
            tags=tags,
            transit_encryption_enabled=transit_encryption_enabled,
            vpc_security_group_ids=vpc_security_group_ids,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmDatabaseMemoryUsagePercentage")
    def alarm_database_memory_usage_percentage(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ElastiCacheClusterDatabaseMemoryUsagePercentageAlarm":
        '''Creates an alarm that monitors the DatabaseMemoryUsagePercentage for the ElastiCache cacheCluster.

        :param threshold: Depending on your application's memory requirements and the memory capacity of your ElastiCache cluster, you should set the threshold to the percentage that reflects the critical level of memory usage of the cluster. You can use historical memory usage data as reference for acceptable memory usage threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization of your cluster so that you can avoid failures when writing to your cluster. It is useful to know when you will need to scale up your cluster if your application does not expect to experience evictions.
        :param alarm_name: The alarm name. Default: - logicalId + ' - DatabaseMemoryUsagePercentage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ElastiCacheClusterDatabaseMemoryUsagePercentageAlarm", jsii.invoke(self, "alarmDatabaseMemoryUsagePercentage", [props]))

    @jsii.member(jsii_name="alarmEngineCpuUtilization")
    def alarm_engine_cpu_utilization(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ElastiCacheClusterEngineCpuUtilizationAlarm":
        '''Creates an alarm that monitors the EngineCpuUtilization for the ElastiCache cacheCluster.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization of the Redis OSS engine thread. It is useful if you want to monitor the CPU usage of the database engine itself.
        :param alarm_name: The alarm name. Default: - logicalId + ' - EngineCPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: Set the threshold to a percentage that reflects the critical engine CPU utilization level for your application. You can benchmark your cluster using your application and expected workload to correlate EngineCPUUtilization and performance as a reference, and then set the threshold accordingly. In most cases, you can set the threshold to about 90% of your available CPU. Default: 90
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ElastiCacheEngineCpuUtilizationAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ElastiCacheClusterEngineCpuUtilizationAlarm", jsii.invoke(self, "alarmEngineCpuUtilization", [props]))

    @jsii.member(jsii_name="alarmReplicationLag")
    def alarm_replication_lag(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ElastiCacheClusterReplicationLagAlarm":
        '''Creates an alarm that monitors the ReplicationLag for the ElastiCache cacheCluster.

        :param threshold: Set the threshold according to your application's requirements and the potential impact of replication lag. You should consider your application's expected write rates and network conditions for the acceptable replication lag.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a delay between data updates on the primary node and their synchronization to replica node. It helps to ensure data consistency of a read replica cluster node.
        :param alarm_name: The alarm name. Default: - logicalId + ' - ReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ElastiCacheReplicationLagAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ElastiCacheClusterReplicationLagAlarm", jsii.invoke(self, "alarmReplicationLag", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_database_memory_usage_percentage_alarm: typing.Union["ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_replication_lag_alarm: typing.Union["ElastiCacheReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_engine_cpu_utilization_alarm: typing.Optional[typing.Union["ElastiCacheEngineCpuUtilizationAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ElastiCacheRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ElastiCacheClusterRecommendedAlarms":
        '''Creates the recommended alarms for the ElastiCache CfnCacheCluster.

        :param config_database_memory_usage_percentage_alarm: The configuration for the DatabaseMemoryUsagePercentage alarm.
        :param config_replication_lag_alarm: The configuration for the ReplicationLag alarm.
        :param config_engine_cpu_utilization_alarm: The configuration for the EngineCpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ElastiCache
        '''
        props = ElastiCacheClusterRecommendedAlarmsConfig(
            config_database_memory_usage_percentage_alarm=config_database_memory_usage_percentage_alarm,
            config_replication_lag_alarm=config_replication_lag_alarm,
            config_engine_cpu_utilization_alarm=config_engine_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ElastiCacheClusterRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


class CfnReplicationGroup(
    _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CfnReplicationGroup",
):
    '''An extension for the CfnReplicationGroup construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        replication_group_description: builtins.str,
        at_rest_encryption_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        auth_token: typing.Optional[builtins.str] = None,
        automatic_failover_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        cache_node_type: typing.Optional[builtins.str] = None,
        cache_parameter_group_name: typing.Optional[builtins.str] = None,
        cache_security_group_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        cache_subnet_group_name: typing.Optional[builtins.str] = None,
        cluster_mode: typing.Optional[builtins.str] = None,
        data_tiering_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        engine: typing.Optional[builtins.str] = None,
        engine_version: typing.Optional[builtins.str] = None,
        global_replication_group_id: typing.Optional[builtins.str] = None,
        ip_discovery: typing.Optional[builtins.str] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        log_delivery_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup.LogDeliveryConfigurationRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        multi_az_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        network_type: typing.Optional[builtins.str] = None,
        node_group_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup.NodeGroupConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
        notification_topic_arn: typing.Optional[builtins.str] = None,
        num_cache_clusters: typing.Optional[jsii.Number] = None,
        num_node_groups: typing.Optional[jsii.Number] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_cache_cluster_a_zs: typing.Optional[typing.Sequence[builtins.str]] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        primary_cluster_id: typing.Optional[builtins.str] = None,
        replicas_per_node_group: typing.Optional[jsii.Number] = None,
        replication_group_id: typing.Optional[builtins.str] = None,
        security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
        snapshot_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
        snapshot_name: typing.Optional[builtins.str] = None,
        snapshot_retention_limit: typing.Optional[jsii.Number] = None,
        snapshotting_cluster_id: typing.Optional[builtins.str] = None,
        snapshot_window: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_encryption_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        transit_encryption_mode: typing.Optional[builtins.str] = None,
        user_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_group_description: A user-created description for the replication group.
        :param at_rest_encryption_enabled: A flag that enables encryption at rest when set to ``true`` . *Required:* Only available when creating a replication group in an Amazon VPC using Redis OSS version ``3.2.6`` or ``4.x`` onward. Default: ``false``
        :param auth_token: *Reserved parameter.* The password used to access a password protected server. ``AuthToken`` can be specified only on replication groups where ``TransitEncryptionEnabled`` is ``true`` . For more information, see `Authenticating Valkey or Redis OSS users with the AUTH Command <https://docs.aws.amazon.com/AmazonElastiCache/latest/dg/auth.html>`_ . .. epigraph:: For HIPAA compliance, you must specify ``TransitEncryptionEnabled`` as ``true`` , an ``AuthToken`` , and a ``CacheSubnetGroup`` . Password constraints: - Must be only printable ASCII characters. - Must be at least 16 characters and no more than 128 characters in length. - Nonalphanumeric characters are restricted to (!, &, #, $, ^, <, >, -, ). For more information, see `AUTH password <https://docs.aws.amazon.com/http://redis.io/commands/AUTH>`_ at http://redis.io/commands/AUTH. .. epigraph:: If ADDING the AuthToken, update requires `Replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
        :param automatic_failover_enabled: Specifies whether a read-only replica is automatically promoted to read/write primary if the existing primary fails. ``AutomaticFailoverEnabled`` must be enabled for Valkey or Redis OSS (cluster mode enabled) replication groups. Default: false
        :param auto_minor_version_upgrade: If you are running Valkey 7.2 or later, or Redis OSS 6.0 or later, set this parameter to yes if you want to opt-in to the next minor version upgrade campaign. This parameter is disabled for previous versions.
        :param cache_node_type: The compute and memory capacity of the nodes in the node group (shard). The following node types are supported by ElastiCache. Generally speaking, the current generation types provide more memory and computational power at lower cost when compared to their equivalent previous generation counterparts. - General purpose: - Current generation: *M6g node types:* ``cache.m6g.large`` , ``cache.m6g.xlarge`` , ``cache.m6g.2xlarge`` , ``cache.m6g.4xlarge`` , ``cache.m6g.12xlarge`` , ``cache.m6g.24xlarge`` *M5 node types:* ``cache.m5.large`` , ``cache.m5.xlarge`` , ``cache.m5.2xlarge`` , ``cache.m5.4xlarge`` , ``cache.m5.12xlarge`` , ``cache.m5.24xlarge`` *M4 node types:* ``cache.m4.large`` , ``cache.m4.xlarge`` , ``cache.m4.2xlarge`` , ``cache.m4.4xlarge`` , ``cache.m4.10xlarge`` *T4g node types:* ``cache.t4g.micro`` , ``cache.t4g.small`` , ``cache.t4g.medium`` *T3 node types:* ``cache.t3.micro`` , ``cache.t3.small`` , ``cache.t3.medium`` *T2 node types:* ``cache.t2.micro`` , ``cache.t2.small`` , ``cache.t2.medium`` - Previous generation: (not recommended) *T1 node types:* ``cache.t1.micro`` *M1 node types:* ``cache.m1.small`` , ``cache.m1.medium`` , ``cache.m1.large`` , ``cache.m1.xlarge`` *M3 node types:* ``cache.m3.medium`` , ``cache.m3.large`` , ``cache.m3.xlarge`` , ``cache.m3.2xlarge`` - Compute optimized: - Previous generation: (not recommended) *C1 node types:* ``cache.c1.xlarge`` - Memory optimized: - Current generation: *R6gd node types:* ``cache.r6gd.xlarge`` , ``cache.r6gd.2xlarge`` , ``cache.r6gd.4xlarge`` , ``cache.r6gd.8xlarge`` , ``cache.r6gd.12xlarge`` , ``cache.r6gd.16xlarge`` .. epigraph:: The ``r6gd`` family is available in the following regions: ``us-east-2`` , ``us-east-1`` , ``us-west-2`` , ``us-west-1`` , ``eu-west-1`` , ``eu-central-1`` , ``ap-northeast-1`` , ``ap-southeast-1`` , ``ap-southeast-2`` . *R6g node types:* ``cache.r6g.large`` , ``cache.r6g.xlarge`` , ``cache.r6g.2xlarge`` , ``cache.r6g.4xlarge`` , ``cache.r6g.12xlarge`` , ``cache.r6g.24xlarge`` *R5 node types:* ``cache.r5.large`` , ``cache.r5.xlarge`` , ``cache.r5.2xlarge`` , ``cache.r5.4xlarge`` , ``cache.r5.12xlarge`` , ``cache.r5.24xlarge`` *R4 node types:* ``cache.r4.large`` , ``cache.r4.xlarge`` , ``cache.r4.2xlarge`` , ``cache.r4.4xlarge`` , ``cache.r4.8xlarge`` , ``cache.r4.16xlarge`` - Previous generation: (not recommended) *M2 node types:* ``cache.m2.xlarge`` , ``cache.m2.2xlarge`` , ``cache.m2.4xlarge`` *R3 node types:* ``cache.r3.large`` , ``cache.r3.xlarge`` , ``cache.r3.2xlarge`` , ``cache.r3.4xlarge`` , ``cache.r3.8xlarge`` For region availability, see `Supported Node Types by Amazon Region <https://docs.aws.amazon.com/AmazonElastiCache/latest/dg/CacheNodes.SupportedTypes.html#CacheNodes.SupportedTypesByRegion>`_
        :param cache_parameter_group_name: The name of the parameter group to associate with this replication group. If this argument is omitted, the default cache parameter group for the specified engine is used. If you are running Valkey or Redis OSS version 3.2.4 or later, only one node group (shard), and want to use a default parameter group, we recommend that you specify the parameter group by name. - To create a Valkey or Redis OSS (cluster mode disabled) replication group, use ``CacheParameterGroupName=default.redis3.2`` . - To create a Valkey or Redis OSS (cluster mode enabled) replication group, use ``CacheParameterGroupName=default.redis3.2.cluster.on`` .
        :param cache_security_group_names: A list of cache security group names to associate with this replication group.
        :param cache_subnet_group_name: The name of the cache subnet group to be used for the replication group. .. epigraph:: If you're going to launch your cluster in an Amazon VPC, you need to create a subnet group before you start creating a cluster. For more information, see `AWS::ElastiCache::SubnetGroup <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-elasticache-subnetgroup.html>`_ .
        :param cluster_mode: The mode can be enabled or disabled. To change the cluster mode from disabled to enabled, you must first set the cluster mode to compatible. The compatible mode allows your Valkey or Redis OSS clients to connect using both cluster mode enabled and cluster mode disabled. After you migrate all Valkey or Redis OSS clients to use cluster mode enabled, you can then complete cluster mode configuration and set the cluster mode to enabled. For more information, see `Modify cluster mode <https://docs.aws.amazon.com/AmazonElastiCache/latest/dg/modify-cluster-mode.html>`_ .
        :param data_tiering_enabled: Enables data tiering. Data tiering is only supported for replication groups using the r6gd node type. This parameter must be set to true when using r6gd nodes. For more information, see `Data tiering <https://docs.aws.amazon.com/AmazonElastiCache/latest/dg/data-tiering.html>`_ .
        :param engine: The name of the cache engine to be used for the clusters in this replication group. The value must be set to ``valkey`` or ``redis`` . .. epigraph:: Upgrading an existing engine from redis to valkey is done through in-place migration, and requires a parameter group.
        :param engine_version: The version number of the cache engine to be used for the clusters in this replication group. To view the supported cache engine versions, use the ``DescribeCacheEngineVersions`` operation. *Important:* You can upgrade to a newer engine version (see `Selecting a Cache Engine and Version <https://docs.aws.amazon.com/AmazonElastiCache/latest/dg/SelectEngine.html#VersionManagement>`_ ) in the *ElastiCache User Guide* , but you cannot downgrade to an earlier engine version. If you want to use an earlier engine version, you must delete the existing cluster or replication group and create it anew with the earlier engine version.
        :param global_replication_group_id: The name of the Global datastore.
        :param ip_discovery: The network type you choose when creating a replication group, either ``ipv4`` | ``ipv6`` . IPv6 is supported for workloads using Valkey 7.2 and above, Redis OSS engine version 6.2 to 7.1 or Memcached engine version 1.6.6 and above on all instances built on the `Nitro system <https://docs.aws.amazon.com/ec2/nitro/>`_ .
        :param kms_key_id: The ID of the KMS key used to encrypt the disk on the cluster.
        :param log_delivery_configurations: Specifies the destination, format and type of the logs.
        :param multi_az_enabled: A flag indicating if you have Multi-AZ enabled to enhance fault tolerance. For more information, see `Minimizing Downtime: Multi-AZ <https://docs.aws.amazon.com/AmazonElastiCache/latest/dg/AutoFailover.html>`_ .
        :param network_type: Must be either ``ipv4`` | ``ipv6`` | ``dual_stack`` . IPv6 is supported for workloads using Valkey 7.2 and above, Redis OSS engine version 6.2 to 7.1 and Memcached engine version 1.6.6 and above on all instances built on the `Nitro system <https://docs.aws.amazon.com/ec2/nitro/>`_ .
        :param node_group_configuration: ``NodeGroupConfiguration`` is a property of the ``AWS::ElastiCache::ReplicationGroup`` resource that configures an Amazon ElastiCache (ElastiCache) Valkey or Redis OSS cluster node group. If you set `UseOnlineResharding <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatepolicy.html#cfn-attributes-updatepolicy-useonlineresharding>`_ to ``true`` , you can update ``NodeGroupConfiguration`` without interruption. When ``UseOnlineResharding`` is set to ``false`` , or is not specified, updating ``NodeGroupConfiguration`` results in `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ .
        :param notification_topic_arn: The Amazon Resource Name (ARN) of the Amazon Simple Notification Service (SNS) topic to which notifications are sent. .. epigraph:: The Amazon SNS topic owner must be the same as the cluster owner.
        :param num_cache_clusters: The number of clusters this replication group initially has. This parameter is not used if there is more than one node group (shard). You should use ``ReplicasPerNodeGroup`` instead. If ``AutomaticFailoverEnabled`` is ``true`` , the value of this parameter must be at least 2. If ``AutomaticFailoverEnabled`` is ``false`` you can omit this parameter (it will default to 1), or you can explicitly set it to a value between 2 and 6. The maximum permitted value for ``NumCacheClusters`` is 6 (1 primary plus 5 replicas).
        :param num_node_groups: An optional parameter that specifies the number of node groups (shards) for this Valkey or Redis OSS (cluster mode enabled) replication group. For Valkey or Redis OSS (cluster mode disabled) either omit this parameter or set it to 1. If you set `UseOnlineResharding <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-attribute-updatepolicy.html#cfn-attributes-updatepolicy-useonlineresharding>`_ to ``true`` , you can update ``NumNodeGroups`` without interruption. When ``UseOnlineResharding`` is set to ``false`` , or is not specified, updating ``NumNodeGroups`` results in `replacement <https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html#update-replacement>`_ . Default: 1
        :param port: The port number on which each member of the replication group accepts connections.
        :param preferred_cache_cluster_a_zs: A list of EC2 Availability Zones in which the replication group's clusters are created. The order of the Availability Zones in the list is the order in which clusters are allocated. The primary cluster is created in the first AZ in the list. This parameter is not used if there is more than one node group (shard). You should use ``NodeGroupConfiguration`` instead. .. epigraph:: If you are creating your replication group in an Amazon VPC (recommended), you can only locate clusters in Availability Zones associated with the subnets in the selected subnet group. The number of Availability Zones listed must equal the value of ``NumCacheClusters`` . Default: system chosen Availability Zones.
        :param preferred_maintenance_window: Specifies the weekly time range during which maintenance on the cluster is performed. It is specified as a range in the format ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). The minimum maintenance window is a 60 minute period. Valid values for ``ddd`` are: - ``sun`` - ``mon`` - ``tue`` - ``wed`` - ``thu`` - ``fri`` - ``sat`` Example: ``sun:23:00-mon:01:30``
        :param primary_cluster_id: The identifier of the cluster that serves as the primary for this replication group. This cluster must already exist and have a status of ``available`` . This parameter is not required if ``NumCacheClusters`` , ``NumNodeGroups`` , or ``ReplicasPerNodeGroup`` is specified.
        :param replicas_per_node_group: An optional parameter that specifies the number of replica nodes in each node group (shard). Valid values are 0 to 5.
        :param replication_group_id: The replication group identifier. This parameter is stored as a lowercase string. Constraints: - A name must contain from 1 to 40 alphanumeric characters or hyphens. - The first character must be a letter. - A name cannot end with a hyphen or contain two consecutive hyphens.
        :param security_group_ids: One or more Amazon VPC security groups associated with this replication group. Use this parameter only when you are creating a replication group in an Amazon Virtual Private Cloud (Amazon VPC).
        :param snapshot_arns: A list of Amazon Resource Names (ARN) that uniquely identify the Valkey or Redis OSS RDB snapshot files stored in Amazon S3. The snapshot files are used to populate the new replication group. The Amazon S3 object name in the ARN cannot contain any commas. The new replication group will have the number of node groups (console: shards) specified by the parameter *NumNodeGroups* or the number of node groups configured by *NodeGroupConfiguration* regardless of the number of ARNs specified here. Example of an Amazon S3 ARN: ``arn:aws:s3:::my_bucket/snapshot1.rdb``
        :param snapshot_name: The name of a snapshot from which to restore data into the new replication group. The snapshot status changes to ``restoring`` while the new replication group is being created.
        :param snapshot_retention_limit: The number of days for which ElastiCache retains automatic snapshots before deleting them. For example, if you set ``SnapshotRetentionLimit`` to 5, a snapshot that was taken today is retained for 5 days before being deleted. Default: 0 (i.e., automatic backups are disabled for this cluster).
        :param snapshotting_cluster_id: The cluster ID that is used as the daily snapshot source for the replication group. This parameter cannot be set for Valkey or Redis OSS (cluster mode enabled) replication groups.
        :param snapshot_window: The daily time range (in UTC) during which ElastiCache begins taking a daily snapshot of your node group (shard). Example: ``05:00-09:00`` If you do not specify this parameter, ElastiCache automatically chooses an appropriate time range.
        :param tags: A list of tags to be added to this resource. Tags are comma-separated key,value pairs (e.g. Key= ``myKey`` , Value= ``myKeyValue`` . You can include multiple tags as shown following: Key= ``myKey`` , Value= ``myKeyValue`` Key= ``mySecondKey`` , Value= ``mySecondKeyValue`` . Tags on replication groups will be replicated to all nodes.
        :param transit_encryption_enabled: A flag that enables in-transit encryption when set to ``true`` . This parameter is only available when creating a replication group in an Amazon VPC using Valkey version ``7.2`` and above, Redis OSS version ``3.2.6`` , or Redis OSS version ``4.x`` and above, and the cluster is being created in an Amazon VPC. If you enable in-transit encryption, you must also specify a value for ``CacheSubnetGroup`` . .. epigraph:: TransitEncryptionEnabled is required when creating a new valkey replication group. Default: ``false`` .. epigraph:: For HIPAA compliance, you must specify ``TransitEncryptionEnabled`` as ``true`` , an ``AuthToken`` , and a ``CacheSubnetGroup`` .
        :param transit_encryption_mode: A setting that allows you to migrate your clients to use in-transit encryption, with no downtime. When setting ``TransitEncryptionEnabled`` to ``true`` , you can set your ``TransitEncryptionMode`` to ``preferred`` in the same request, to allow both encrypted and unencrypted connections at the same time. Once you migrate all your Valkey or Redis OSS clients to use encrypted connections you can modify the value to ``required`` to allow encrypted connections only. Setting ``TransitEncryptionMode`` to ``required`` is a two-step process that requires you to first set the ``TransitEncryptionMode`` to ``preferred`` , after that you can set ``TransitEncryptionMode`` to ``required`` . This process will not trigger the replacement of the replication group.
        :param user_group_ids: The ID of user group to associate with the replication group.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a7ccdbca841d390836aded81d1175e953552ca0c93e888187601d7071b0a809e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroupProps(
            replication_group_description=replication_group_description,
            at_rest_encryption_enabled=at_rest_encryption_enabled,
            auth_token=auth_token,
            automatic_failover_enabled=automatic_failover_enabled,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            cache_node_type=cache_node_type,
            cache_parameter_group_name=cache_parameter_group_name,
            cache_security_group_names=cache_security_group_names,
            cache_subnet_group_name=cache_subnet_group_name,
            cluster_mode=cluster_mode,
            data_tiering_enabled=data_tiering_enabled,
            engine=engine,
            engine_version=engine_version,
            global_replication_group_id=global_replication_group_id,
            ip_discovery=ip_discovery,
            kms_key_id=kms_key_id,
            log_delivery_configurations=log_delivery_configurations,
            multi_az_enabled=multi_az_enabled,
            network_type=network_type,
            node_group_configuration=node_group_configuration,
            notification_topic_arn=notification_topic_arn,
            num_cache_clusters=num_cache_clusters,
            num_node_groups=num_node_groups,
            port=port,
            preferred_cache_cluster_a_zs=preferred_cache_cluster_a_zs,
            preferred_maintenance_window=preferred_maintenance_window,
            primary_cluster_id=primary_cluster_id,
            replicas_per_node_group=replicas_per_node_group,
            replication_group_id=replication_group_id,
            security_group_ids=security_group_ids,
            snapshot_arns=snapshot_arns,
            snapshot_name=snapshot_name,
            snapshot_retention_limit=snapshot_retention_limit,
            snapshotting_cluster_id=snapshotting_cluster_id,
            snapshot_window=snapshot_window,
            tags=tags,
            transit_encryption_enabled=transit_encryption_enabled,
            transit_encryption_mode=transit_encryption_mode,
            user_group_ids=user_group_ids,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmDatabaseMemoryUsagePercentage")
    def alarm_database_memory_usage_percentage(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarm":
        '''Creates an alarm that monitors the DatabaseMemoryUsagePercentage for the ElastiCache cacheReplicationGroup.

        :param threshold: Depending on your application's memory requirements and the memory capacity of your ElastiCache cluster, you should set the threshold to the percentage that reflects the critical level of memory usage of the cluster. You can use historical memory usage data as reference for acceptable memory usage threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization of your cluster so that you can avoid failures when writing to your cluster. It is useful to know when you will need to scale up your cluster if your application does not expect to experience evictions.
        :param alarm_name: The alarm name. Default: - logicalId + ' - DatabaseMemoryUsagePercentage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarm", jsii.invoke(self, "alarmDatabaseMemoryUsagePercentage", [props]))

    @jsii.member(jsii_name="alarmEngineCpuUtilization")
    def alarm_engine_cpu_utilization(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ElastiCacheReplicationGroupEngineCpuUtilizationAlarm":
        '''Creates an alarm that monitors the EngineCpuUtilization for the ElastiCache cacheReplicationGroup.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization of the Redis OSS engine thread. It is useful if you want to monitor the CPU usage of the database engine itself.
        :param alarm_name: The alarm name. Default: - logicalId + ' - EngineCPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: Set the threshold to a percentage that reflects the critical engine CPU utilization level for your application. You can benchmark your cluster using your application and expected workload to correlate EngineCPUUtilization and performance as a reference, and then set the threshold accordingly. In most cases, you can set the threshold to about 90% of your available CPU. Default: 90
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ElastiCacheEngineCpuUtilizationAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ElastiCacheReplicationGroupEngineCpuUtilizationAlarm", jsii.invoke(self, "alarmEngineCpuUtilization", [props]))

    @jsii.member(jsii_name="alarmReplicationLag")
    def alarm_replication_lag(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ElastiCacheReplicationGroupReplicationLagAlarm":
        '''Creates an alarm that monitors the ReplicationLag for the ElastiCache cacheReplicationGroup.

        :param threshold: Set the threshold according to your application's requirements and the potential impact of replication lag. You should consider your application's expected write rates and network conditions for the acceptable replication lag.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a delay between data updates on the primary node and their synchronization to replica node. It helps to ensure data consistency of a read replica cluster node.
        :param alarm_name: The alarm name. Default: - logicalId + ' - ReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ElastiCacheReplicationLagAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ElastiCacheReplicationGroupReplicationLagAlarm", jsii.invoke(self, "alarmReplicationLag", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_database_memory_usage_percentage_alarm: typing.Union["ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_replication_lag_alarm: typing.Union["ElastiCacheReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_engine_cpu_utilization_alarm: typing.Optional[typing.Union["ElastiCacheEngineCpuUtilizationAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ElastiCacheRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "ElastiCacheReplicationGroupRecommendedAlarms":
        '''Creates the recommended alarms for the ElastiCache CfnReplicationGroup.

        :param config_database_memory_usage_percentage_alarm: The configuration for the DatabaseMemoryUsagePercentage alarm.
        :param config_replication_lag_alarm: The configuration for the ReplicationLag alarm.
        :param config_engine_cpu_utilization_alarm: The configuration for the EngineCPUUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ElastiCache
        '''
        props = ElastiCacheReplicationGroupRecommendedAlarmsConfig(
            config_database_memory_usage_percentage_alarm=config_database_memory_usage_percentage_alarm,
            config_replication_lag_alarm=config_replication_lag_alarm,
            config_engine_cpu_utilization_alarm=config_engine_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("ElastiCacheReplicationGroupRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class CloudFrontAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3820b7882a7674f411cc15dedf79c6768e809ba39552ae7ab5cc589063637c14)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDetailedAlarmConfig",
    jsii_struct_bases=[],
    name_mapping={"function_name": "functionName"},
)
class CloudFrontDetailedAlarmConfig:
    def __init__(self, *, function_name: builtins.str) -> None:
        '''The common properties for the CloudFront alarms when monitoring resource and method dimensions.

        :param function_name: The name of the function to monitor, used as a discriminator in the alarm name.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f63190c577990aef1c72ba1290e304136a09f7029c86646278b4dcb3cf65ebec)
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "function_name": function_name,
        }

    @builtins.property
    def function_name(self) -> builtins.str:
        '''The name of the function to monitor, used as a discriminator in the alarm name.'''
        result = self._values.get("function_name")
        assert result is not None, "Required property 'function_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDetailedAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CloudFrontDistribution5xxErrorRateAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistribution5xxErrorRateAlarm",
):
    '''This alarm monitors the percentage of 5xx error responses from your origin server, to help you detect if the CloudFront service is having issues.

    See {@link https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/troubleshooting-response-errors.html Troubleshooting error responses from your origin} for information to help you understand the problems with your server.

    The alarm is triggered when the percentage exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param distribution: The CloudFront Distribution to monitor.
        :param threshold: The recommended threshold value for this alarm is highly dependent on the tolerance for 5xx responses. You can analyze historical data and trends, and then set the threshold accordingly. Because 5xx errors can be caused by transient issues, we recommend that you set the threshold to a value greater than 0 so that the alarm is not too sensitive.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect problems with serving requests from the origin server, or problems with communication between CloudFront and your origin server.
        :param alarm_name: The alarm name. Default: - distributionId + ' - 5xxErrorRate'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41d8e3486518c487fad458e8dff100b3669925844a0375ca3783b9fdf23b49ee)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CloudFrontDistribution5xxErrorRateAlarmProps(
            distribution=distribution,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"distribution": "distribution"},
)
class CloudFrontDistributionAlarmProps:
    def __init__(
        self,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    ) -> None:
        '''The common properties for the CloudFront Distribution alarms.

        :param distribution: The CloudFront Distribution to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__248fcc4e71cc9a3c4ab45ffb841c70093e82bf3af03551acf869b4ae9e35f383)
            check_type(argname="argument distribution", value=distribution, expected_type=type_hints["distribution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "distribution": distribution,
        }

    @builtins.property
    def distribution(self) -> _aws_cdk_aws_cloudfront_ceddda9d.Distribution:
        '''The CloudFront Distribution to monitor.'''
        result = self._values.get("distribution")
        assert result is not None, "Required property 'distribution' is missing"
        return typing.cast(_aws_cdk_aws_cloudfront_ceddda9d.Distribution, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class CloudFrontDistributionDetailedFunctionExecutionErrorsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionDetailedFunctionExecutionErrorsAlarm",
):
    '''This alarm helps you monitor execution errors from CloudFront functions so that you can take steps to resolve them.

    Analyze the CloudWatch function logs and look at the function code to find and resolve the root
    cause of the problem.

    The alarm is triggered when the number of execution errors is greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        function_name: builtins.str,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param distribution: The CloudFront Distribution to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect execution errors from CloudFront functions.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionExecutionErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: We recommend to set the threshold to 0 because an execution error indicates a problem with the code that occurs at runtime. Default: 0
        :param function_name: The name of the function to monitor, used as a discriminator in the alarm name.
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__227fda650b67ac25cd09047d27bf71990f1b6cfd651682942cc79a601b270b2b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmProps(
            distribution=distribution,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            function_name=function_name,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class CloudFrontDistributionDetailedFunctionThrottlesAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionDetailedFunctionThrottlesAlarm",
):
    '''This alarm helps you to monitor if your CloudFront function is throttled.

    If your function is throttled, it means that it is taking too long to execute.
    To avoid function throttles, consider optimizing the function code.

    The alarm is triggered when the number of times the function was throttled is greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        function_name: builtins.str,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param distribution: The CloudFront Distribution to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when your CloudFront function is throttled so that you can react and resolve the issue for a smooth customer experience.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionThrottles'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: We recommend setting the threshold to 0, to allow quicker resolution of the function throttles. Default: 0
        :param function_name: The name of the function to monitor, used as a discriminator in the alarm name.
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ce4e083dc5b9a2a7328c0ac78a8a293ad67fd66c60ba3b3467286362bcd55907)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CloudFrontDistributionDetailedFunctionThrottlesAlarmProps(
            distribution=distribution,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            function_name=function_name,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class CloudFrontDistributionDetailedFunctionValidationErrorsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionDetailedFunctionValidationErrorsAlarm",
):
    '''This alarm helps you monitor validation errors from CloudFront functions so that you can take steps to resolve them.

    Analyze the CloudWatch function logs and look at the function code to find and resolve the root
    cause of the problem.

    The alarm is triggered when the number of validation errors is greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        function_name: builtins.str,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param distribution: The CloudFront Distribution to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect validation errors from CloudFront functions.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionValidationErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: A value greater than 0 indicates a validation error. We recommend setting the threshold to 0 because validation errors imply a problem when CloudFront functions hand off back to CloudFront. For example, CloudFront needs the HTTP Host header in order to process a request. There is nothing stopping a user from deleting the Host header in their CloudFront functions code. But when CloudFront gets the response back and the Host header is missing, CloudFront throws a validation error. Default: 0
        :param function_name: The name of the function to monitor, used as a discriminator in the alarm name.
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__598f49854634f167c78a891bef6741976476f2b7fd0a00ca549f373c15ec8226)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CloudFrontDistributionDetailedFunctionValidationErrorsAlarmProps(
            distribution=distribution,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            function_name=function_name,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class CloudFrontDistributionOriginLatencyAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionOriginLatencyAlarm",
):
    '''The alarm helps to monitor if the origin server is taking too long to respond.

    If the server takes too long to respond, it might lead to a timeout.
    Refer to {@link https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/http-504-gateway-timeout.html#http-504-gateway-timeout-slow-application find and fix delayed responses from applications on your origin server}
    if you experience consistently high OriginLatency values.

    The alarm is triggered when the percentage is lower or equals the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param distribution: The CloudFront Distribution to monitor.
        :param threshold: You should calculate the value of about 80% of the origin response timeout, and use the result as the threshold value. If this metric is consistently close to the origin response timeout value, you might start experiencing 504 errors.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect problems with the origin server taking too long to respond.
        :param alarm_name: The alarm name. Default: - distributionId + ' - OriginLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af70c9a32ab9863b966d4dbfc706f9bf74bdcbbcc352049b52d7d11ef6e7884f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CloudFrontDistributionOriginLatencyAlarmProps(
            distribution=distribution,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class CloudFrontDistributionRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an CloudFront Distribution.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#CloudFront
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        config5xx_error_rate_alarm: typing.Union["CloudFront5xxErrorRateAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_origin_latency_alarm: typing.Union["CloudFrontOriginLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_detailed_function_execution_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_detailed_function_throttles_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_detailed_function_validation_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["CloudFrontRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param distribution: The CloudFront Distribution to monitor.
        :param config5xx_error_rate_alarm: The configuration for the 5xxErrorRate alarm.
        :param config_origin_latency_alarm: The configuration for the OriginLatency alarm.
        :param config_detailed_function_execution_errors_alarm_list: The configuration list for the detailed FunctionExecutionErrors alarm.
        :param config_detailed_function_throttles_alarm_list: The configuration list for the detailed FunctionThrottles alarm.
        :param config_detailed_function_validation_errors_alarm_list: The configuration list for the detailed FunctionValidationErrors alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64ee14900249018f7c68fd6171113f33480e248f41c63095f472a21485c1a2d8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = CloudFrontDistributionRecommendedAlarmsProps(
            distribution=distribution,
            config5xx_error_rate_alarm=config5xx_error_rate_alarm,
            config_origin_latency_alarm=config_origin_latency_alarm,
            config_detailed_function_execution_errors_alarm_list=config_detailed_function_execution_errors_alarm_list,
            config_detailed_function_throttles_alarm_list=config_detailed_function_throttles_alarm_list,
            config_detailed_function_validation_errors_alarm_list=config_detailed_function_validation_errors_alarm_list,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarm5xxErrorRate")
    def alarm5xx_error_rate(
        self,
    ) -> typing.Optional[CloudFrontDistribution5xxErrorRateAlarm]:
        '''The 5xxErrorRate alarm.'''
        return typing.cast(typing.Optional[CloudFrontDistribution5xxErrorRateAlarm], jsii.get(self, "alarm5xxErrorRate"))

    @builtins.property
    @jsii.member(jsii_name="alarmOriginLatency")
    def alarm_origin_latency(
        self,
    ) -> typing.Optional[CloudFrontDistributionOriginLatencyAlarm]:
        '''The OriginLatency alarm.'''
        return typing.cast(typing.Optional[CloudFrontDistributionOriginLatencyAlarm], jsii.get(self, "alarmOriginLatency"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config5xx_error_rate_alarm": "config5xxErrorRateAlarm",
        "config_origin_latency_alarm": "configOriginLatencyAlarm",
        "config_detailed_function_execution_errors_alarm_list": "configDetailedFunctionExecutionErrorsAlarmList",
        "config_detailed_function_throttles_alarm_list": "configDetailedFunctionThrottlesAlarmList",
        "config_detailed_function_validation_errors_alarm_list": "configDetailedFunctionValidationErrorsAlarmList",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class CloudFrontDistributionRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config5xx_error_rate_alarm: typing.Union["CloudFront5xxErrorRateAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_origin_latency_alarm: typing.Union["CloudFrontOriginLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_detailed_function_execution_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_detailed_function_throttles_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_detailed_function_validation_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["CloudFrontRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an CloudFront Service.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config5xx_error_rate_alarm: The configuration for the 5xxErrorRate alarm.
        :param config_origin_latency_alarm: The configuration for the OriginLatency alarm.
        :param config_detailed_function_execution_errors_alarm_list: The configuration list for the detailed FunctionExecutionErrors alarm.
        :param config_detailed_function_throttles_alarm_list: The configuration list for the detailed FunctionThrottles alarm.
        :param config_detailed_function_validation_errors_alarm_list: The configuration list for the detailed FunctionValidationErrors alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config5xx_error_rate_alarm, dict):
            config5xx_error_rate_alarm = CloudFront5xxErrorRateAlarmConfig(**config5xx_error_rate_alarm)
        if isinstance(config_origin_latency_alarm, dict):
            config_origin_latency_alarm = CloudFrontOriginLatencyAlarmConfig(**config_origin_latency_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6879266c5397224eede2bc3d511a20b2cf0cf418483da97a33948992115ccfed)
            check_type(argname="argument config5xx_error_rate_alarm", value=config5xx_error_rate_alarm, expected_type=type_hints["config5xx_error_rate_alarm"])
            check_type(argname="argument config_origin_latency_alarm", value=config_origin_latency_alarm, expected_type=type_hints["config_origin_latency_alarm"])
            check_type(argname="argument config_detailed_function_execution_errors_alarm_list", value=config_detailed_function_execution_errors_alarm_list, expected_type=type_hints["config_detailed_function_execution_errors_alarm_list"])
            check_type(argname="argument config_detailed_function_throttles_alarm_list", value=config_detailed_function_throttles_alarm_list, expected_type=type_hints["config_detailed_function_throttles_alarm_list"])
            check_type(argname="argument config_detailed_function_validation_errors_alarm_list", value=config_detailed_function_validation_errors_alarm_list, expected_type=type_hints["config_detailed_function_validation_errors_alarm_list"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config5xx_error_rate_alarm": config5xx_error_rate_alarm,
            "config_origin_latency_alarm": config_origin_latency_alarm,
        }
        if config_detailed_function_execution_errors_alarm_list is not None:
            self._values["config_detailed_function_execution_errors_alarm_list"] = config_detailed_function_execution_errors_alarm_list
        if config_detailed_function_throttles_alarm_list is not None:
            self._values["config_detailed_function_throttles_alarm_list"] = config_detailed_function_throttles_alarm_list
        if config_detailed_function_validation_errors_alarm_list is not None:
            self._values["config_detailed_function_validation_errors_alarm_list"] = config_detailed_function_validation_errors_alarm_list
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config5xx_error_rate_alarm(self) -> "CloudFront5xxErrorRateAlarmConfig":
        '''The configuration for the 5xxErrorRate alarm.'''
        result = self._values.get("config5xx_error_rate_alarm")
        assert result is not None, "Required property 'config5xx_error_rate_alarm' is missing"
        return typing.cast("CloudFront5xxErrorRateAlarmConfig", result)

    @builtins.property
    def config_origin_latency_alarm(self) -> "CloudFrontOriginLatencyAlarmConfig":
        '''The configuration for the OriginLatency alarm.'''
        result = self._values.get("config_origin_latency_alarm")
        assert result is not None, "Required property 'config_origin_latency_alarm' is missing"
        return typing.cast("CloudFrontOriginLatencyAlarmConfig", result)

    @builtins.property
    def config_detailed_function_execution_errors_alarm_list(
        self,
    ) -> typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig"]]:
        '''The configuration list for the detailed FunctionExecutionErrors alarm.'''
        result = self._values.get("config_detailed_function_execution_errors_alarm_list")
        return typing.cast(typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig"]], result)

    @builtins.property
    def config_detailed_function_throttles_alarm_list(
        self,
    ) -> typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig"]]:
        '''The configuration list for the detailed FunctionThrottles alarm.'''
        result = self._values.get("config_detailed_function_throttles_alarm_list")
        return typing.cast(typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig"]], result)

    @builtins.property
    def config_detailed_function_validation_errors_alarm_list(
        self,
    ) -> typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig"]]:
        '''The configuration list for the detailed FunctionValidationErrors alarm.'''
        result = self._values.get("config_detailed_function_validation_errors_alarm_list")
        return typing.cast(typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig"]], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["CloudFrontRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["CloudFrontRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionRecommendedAlarmsProps",
    jsii_struct_bases=[CloudFrontDistributionRecommendedAlarmsConfig],
    name_mapping={
        "config5xx_error_rate_alarm": "config5xxErrorRateAlarm",
        "config_origin_latency_alarm": "configOriginLatencyAlarm",
        "config_detailed_function_execution_errors_alarm_list": "configDetailedFunctionExecutionErrorsAlarmList",
        "config_detailed_function_throttles_alarm_list": "configDetailedFunctionThrottlesAlarmList",
        "config_detailed_function_validation_errors_alarm_list": "configDetailedFunctionValidationErrorsAlarmList",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "distribution": "distribution",
    },
)
class CloudFrontDistributionRecommendedAlarmsProps(
    CloudFrontDistributionRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config5xx_error_rate_alarm: typing.Union["CloudFront5xxErrorRateAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_origin_latency_alarm: typing.Union["CloudFrontOriginLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_detailed_function_execution_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_detailed_function_throttles_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_detailed_function_validation_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["CloudFrontRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    ) -> None:
        '''Properties for the CloudFrontDistributionRecommendedAlarms construct.

        :param config5xx_error_rate_alarm: The configuration for the 5xxErrorRate alarm.
        :param config_origin_latency_alarm: The configuration for the OriginLatency alarm.
        :param config_detailed_function_execution_errors_alarm_list: The configuration list for the detailed FunctionExecutionErrors alarm.
        :param config_detailed_function_throttles_alarm_list: The configuration list for the detailed FunctionThrottles alarm.
        :param config_detailed_function_validation_errors_alarm_list: The configuration list for the detailed FunctionValidationErrors alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param distribution: The CloudFront Distribution to monitor.
        '''
        if isinstance(config5xx_error_rate_alarm, dict):
            config5xx_error_rate_alarm = CloudFront5xxErrorRateAlarmConfig(**config5xx_error_rate_alarm)
        if isinstance(config_origin_latency_alarm, dict):
            config_origin_latency_alarm = CloudFrontOriginLatencyAlarmConfig(**config_origin_latency_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7867c21528e689be02bd1b707c76d96efac66abc09b9d6918330ab4960080286)
            check_type(argname="argument config5xx_error_rate_alarm", value=config5xx_error_rate_alarm, expected_type=type_hints["config5xx_error_rate_alarm"])
            check_type(argname="argument config_origin_latency_alarm", value=config_origin_latency_alarm, expected_type=type_hints["config_origin_latency_alarm"])
            check_type(argname="argument config_detailed_function_execution_errors_alarm_list", value=config_detailed_function_execution_errors_alarm_list, expected_type=type_hints["config_detailed_function_execution_errors_alarm_list"])
            check_type(argname="argument config_detailed_function_throttles_alarm_list", value=config_detailed_function_throttles_alarm_list, expected_type=type_hints["config_detailed_function_throttles_alarm_list"])
            check_type(argname="argument config_detailed_function_validation_errors_alarm_list", value=config_detailed_function_validation_errors_alarm_list, expected_type=type_hints["config_detailed_function_validation_errors_alarm_list"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument distribution", value=distribution, expected_type=type_hints["distribution"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config5xx_error_rate_alarm": config5xx_error_rate_alarm,
            "config_origin_latency_alarm": config_origin_latency_alarm,
            "distribution": distribution,
        }
        if config_detailed_function_execution_errors_alarm_list is not None:
            self._values["config_detailed_function_execution_errors_alarm_list"] = config_detailed_function_execution_errors_alarm_list
        if config_detailed_function_throttles_alarm_list is not None:
            self._values["config_detailed_function_throttles_alarm_list"] = config_detailed_function_throttles_alarm_list
        if config_detailed_function_validation_errors_alarm_list is not None:
            self._values["config_detailed_function_validation_errors_alarm_list"] = config_detailed_function_validation_errors_alarm_list
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config5xx_error_rate_alarm(self) -> "CloudFront5xxErrorRateAlarmConfig":
        '''The configuration for the 5xxErrorRate alarm.'''
        result = self._values.get("config5xx_error_rate_alarm")
        assert result is not None, "Required property 'config5xx_error_rate_alarm' is missing"
        return typing.cast("CloudFront5xxErrorRateAlarmConfig", result)

    @builtins.property
    def config_origin_latency_alarm(self) -> "CloudFrontOriginLatencyAlarmConfig":
        '''The configuration for the OriginLatency alarm.'''
        result = self._values.get("config_origin_latency_alarm")
        assert result is not None, "Required property 'config_origin_latency_alarm' is missing"
        return typing.cast("CloudFrontOriginLatencyAlarmConfig", result)

    @builtins.property
    def config_detailed_function_execution_errors_alarm_list(
        self,
    ) -> typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig"]]:
        '''The configuration list for the detailed FunctionExecutionErrors alarm.'''
        result = self._values.get("config_detailed_function_execution_errors_alarm_list")
        return typing.cast(typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig"]], result)

    @builtins.property
    def config_detailed_function_throttles_alarm_list(
        self,
    ) -> typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig"]]:
        '''The configuration list for the detailed FunctionThrottles alarm.'''
        result = self._values.get("config_detailed_function_throttles_alarm_list")
        return typing.cast(typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig"]], result)

    @builtins.property
    def config_detailed_function_validation_errors_alarm_list(
        self,
    ) -> typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig"]]:
        '''The configuration list for the detailed FunctionValidationErrors alarm.'''
        result = self._values.get("config_detailed_function_validation_errors_alarm_list")
        return typing.cast(typing.Optional[typing.List["CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig"]], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["CloudFrontRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["CloudFrontRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def distribution(self) -> _aws_cdk_aws_cloudfront_ceddda9d.Distribution:
        '''The CloudFront Distribution to monitor.'''
        result = self._values.get("distribution")
        assert result is not None, "Required property 'distribution' is missing"
        return typing.cast(_aws_cdk_aws_cloudfront_ceddda9d.Distribution, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontFunctionExecutionErrorsAlarmConfig",
    jsii_struct_bases=[CloudFrontAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class CloudFrontFunctionExecutionErrorsAlarmConfig(CloudFrontAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the FunctionExecutionErrors alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect execution errors from CloudFront functions.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionExecutionErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: We recommend to set the threshold to 0 because an execution error indicates a problem with the code that occurs at runtime. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__af97d207175eb2e76e4aa13c9c167a4f8d22265802b299fc480b14341738b9e7)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect execution errors from CloudFront functions.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - ' + functionName + ' - FunctionExecutionErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''We recommend to set the threshold to 0 because an execution error indicates a problem with the code that occurs at runtime.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontFunctionExecutionErrorsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontFunctionThrottlesAlarmConfig",
    jsii_struct_bases=[CloudFrontAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class CloudFrontFunctionThrottlesAlarmConfig(CloudFrontAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the FunctionThrottles alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when your CloudFront function is throttled so that you can react and resolve the issue for a smooth customer experience.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionThrottles'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: We recommend setting the threshold to 0, to allow quicker resolution of the function throttles. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c981c3d670ae2c9b1155edd6332cbda93dce2b1f3a19fc53ecb03ba1115f7d77)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect when your CloudFront function is throttled so that you can
        react and resolve the issue for a smooth customer experience.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - ' + functionName + ' - FunctionThrottles'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''We recommend setting the threshold to 0, to allow quicker resolution of the function throttles.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontFunctionThrottlesAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontFunctionValidationErrorsAlarmConfig",
    jsii_struct_bases=[CloudFrontAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class CloudFrontFunctionValidationErrorsAlarmConfig(CloudFrontAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the FunctionValidationErrors alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect validation errors from CloudFront functions.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionValidationErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: A value greater than 0 indicates a validation error. We recommend setting the threshold to 0 because validation errors imply a problem when CloudFront functions hand off back to CloudFront. For example, CloudFront needs the HTTP Host header in order to process a request. There is nothing stopping a user from deleting the Host header in their CloudFront functions code. But when CloudFront gets the response back and the Host header is missing, CloudFront throws a validation error. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b658a3f61c67bad646a4506df211681542a1cc68672350c7e515461be5d5a57)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect validation errors from CloudFront functions.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - ' + functionName + ' - FunctionValidationErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 2
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''A value greater than 0 indicates a validation error.

        We recommend setting the threshold to 0 because
        validation errors imply a problem when CloudFront functions hand off back to CloudFront. For example,
        CloudFront needs the HTTP Host header in order to process a request. There is nothing stopping a user
        from deleting the Host header in their CloudFront functions code. But when CloudFront gets the response
        back and the Host header is missing, CloudFront throws a validation error.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontFunctionValidationErrorsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontOriginLatencyAlarmConfig",
    jsii_struct_bases=[CloudFrontAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class CloudFrontOriginLatencyAlarmConfig(CloudFrontAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the OriginLatency alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: You should calculate the value of about 80% of the origin response timeout, and use the result as the threshold value. If this metric is consistently close to the origin response timeout value, you might start experiencing 504 errors.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect problems with the origin server taking too long to respond.
        :param alarm_name: The alarm name. Default: - distributionId + ' - OriginLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff483231024f29d40c2f8d88bea548c79984207f57f24c7e1680f7bdb7f71883)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''You should calculate the value of about 80% of the origin response timeout, and use the result as the threshold value.

        If this metric is consistently close to the origin response timeout value,
        you might start experiencing 504 errors.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect problems with the origin server taking too long to respond.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - OriginLatency'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontOriginLatencyAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class CloudFrontRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an CloudFront Distribution.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#CloudFront
    '''

    def __init__(
        self,
        *,
        config5xx_error_rate_alarm: typing.Union["CloudFront5xxErrorRateAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_origin_latency_alarm: typing.Union[CloudFrontOriginLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_detailed_function_execution_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_detailed_function_throttles_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_detailed_function_validation_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["CloudFrontRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config5xx_error_rate_alarm: The configuration for the 5xxErrorRate alarm.
        :param config_origin_latency_alarm: The configuration for the OriginLatency alarm.
        :param config_detailed_function_execution_errors_alarm_list: The configuration list for the detailed FunctionExecutionErrors alarm.
        :param config_detailed_function_throttles_alarm_list: The configuration list for the detailed FunctionThrottles alarm.
        :param config_detailed_function_validation_errors_alarm_list: The configuration list for the detailed FunctionValidationErrors alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = CloudFrontDistributionRecommendedAlarmsConfig(
            config5xx_error_rate_alarm=config5xx_error_rate_alarm,
            config_origin_latency_alarm=config_origin_latency_alarm,
            config_detailed_function_execution_errors_alarm_list=config_detailed_function_execution_errors_alarm_list,
            config_detailed_function_throttles_alarm_list=config_detailed_function_throttles_alarm_list,
            config_detailed_function_validation_errors_alarm_list=config_detailed_function_validation_errors_alarm_list,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4ced914fbbe40406d5305a5076e36fccb277dc46eb31a2f5f45ba8aee5f27afe)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontRecommendedAlarmsMetrics"
)
class CloudFrontRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for CloudFront alarms.'''

    ERROR_RATE_5XX = "ERROR_RATE_5XX"
    '''The percentage of all viewer requests for which the response's HTTP status code is 5xx.'''
    ORIGIN_LATENCY = "ORIGIN_LATENCY"
    '''The total time spent from when CloudFront receives a request to when it starts providing a response to the network (not the viewer), for requests that are served from the origin, not the CloudFront cache.

    This is also known as first byte latency, or time-to-first-byte.
    '''
    FUNCTION_VALIDATION_ERRORS = "FUNCTION_VALIDATION_ERRORS"
    '''The number of validation errors produced by the function in a given time period.

    Validation errors occur when the function runs successfully but returns invalid data
    (an invalid {@link https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/functions-event-structure.html event object}).
    '''
    FUNCTION_EXECUTION_ERRORS = "FUNCTION_EXECUTION_ERRORS"
    '''The number of execution errors that occurred in a given time period.

    Execution errors occur
    when the function fails to complete successfully.
    '''
    FUNCTION_THROTTLES = "FUNCTION_THROTTLES"
    '''The number of times that the function was throttled in a given time period.

    Functions can be throttled for the following reasons:

    - The function continuously exceeds the maximum time allowed for execution
    - The function results in compilation errors
    - There is an unusually high number of requests per second
    '''


class DatabaseCluster(
    _aws_cdk_aws_rds_ceddda9d.DatabaseCluster,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DatabaseCluster",
):
    '''An extension of the database cluster construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        engine: _aws_cdk_aws_rds_ceddda9d.IClusterEngine,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        backtrack_window: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        backup: typing.Optional[typing.Union[_aws_cdk_aws_rds_ceddda9d.BackupProps, typing.Dict[builtins.str, typing.Any]]] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
        cloudwatch_logs_retention_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        cluster_scailability_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.ClusterScailabilityType] = None,
        cluster_scalability_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.ClusterScalabilityType] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        credentials: typing.Optional[_aws_cdk_aws_rds_ceddda9d.Credentials] = None,
        database_insights_mode: typing.Optional[_aws_cdk_aws_rds_ceddda9d.DatabaseInsightsMode] = None,
        default_database_name: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        enable_cluster_level_enhanced_monitoring: typing.Optional[builtins.bool] = None,
        enable_data_api: typing.Optional[builtins.bool] = None,
        enable_local_write_forwarding: typing.Optional[builtins.bool] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        engine_lifecycle_support: typing.Optional[_aws_cdk_aws_rds_ceddda9d.EngineLifecycleSupport] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier_base: typing.Optional[builtins.str] = None,
        instance_props: typing.Optional[typing.Union[_aws_cdk_aws_rds_ceddda9d.InstanceProps, typing.Dict[builtins.str, typing.Any]]] = None,
        instances: typing.Optional[jsii.Number] = None,
        instance_update_behaviour: typing.Optional[_aws_cdk_aws_rds_ceddda9d.InstanceUpdateBehaviour] = None,
        monitoring_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        monitoring_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        network_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.NetworkType] = None,
        parameter_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IParameterGroup] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        performance_insight_encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        performance_insight_retention: typing.Optional[_aws_cdk_aws_rds_ceddda9d.PerformanceInsightRetention] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        readers: typing.Optional[typing.Sequence[_aws_cdk_aws_rds_ceddda9d.IClusterInstance]] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        replication_source_identifier: typing.Optional[builtins.str] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_aws_cdk_aws_s3_ceddda9d.IBucket]] = None,
        s3_export_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_aws_cdk_aws_s3_ceddda9d.IBucket]] = None,
        s3_import_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
        serverless_v2_auto_pause_duration: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        serverless_v2_max_capacity: typing.Optional[jsii.Number] = None,
        serverless_v2_min_capacity: typing.Optional[jsii.Number] = None,
        storage_encrypted: typing.Optional[builtins.bool] = None,
        storage_encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        storage_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.DBClusterStorageType] = None,
        subnet_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.ISubnetGroup] = None,
        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
        writer: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IClusterInstance] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param engine: What kind of database to start.
        :param auto_minor_version_upgrade: Specifies whether minor engine upgrades are applied automatically to the DB cluster during the maintenance window. Default: true
        :param backtrack_window: The number of seconds to set a cluster's target backtrack window to. This feature is only supported by the Aurora MySQL database engine and cannot be enabled on existing clusters. Default: 0 seconds (no backtrack)
        :param backup: Backup settings. Default: - Backup retention period for automated backups is 1 day. Backup preferred window is set to a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.
        :param cloudwatch_logs_exports: The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param cluster_identifier: An optional identifier for the cluster. Default: - A name is automatically generated.
        :param cluster_scailability_type: (deprecated) [Misspelled] Specifies the scalability mode of the Aurora DB cluster. Set LIMITLESS if you want to use a limitless database; otherwise, set it to STANDARD. Default: ClusterScailabilityType.STANDARD
        :param cluster_scalability_type: Specifies the scalability mode of the Aurora DB cluster. Set LIMITLESS if you want to use a limitless database; otherwise, set it to STANDARD. Default: ClusterScalabilityType.STANDARD
        :param copy_tags_to_snapshot: Whether to copy tags to the snapshot when a snapshot is created. Default: - true
        :param credentials: Credentials for the administrative user. Default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password
        :param database_insights_mode: The database insights mode. Default: - DatabaseInsightsMode.STANDARD when performance insights are enabled and Amazon Aurora engine is used, otherwise not set.
        :param default_database_name: Name of a database which is automatically created inside the cluster. Default: - Database is not created in cluster.
        :param deletion_protection: Indicates whether the DB cluster should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, ``undefined`` otherwise, which will not enable deletion protection. To disable deletion protection after it has been enabled, you must explicitly set this value to ``false``.
        :param domain: Directory ID for associating the DB cluster with a specific Active Directory. Necessary for enabling Kerberos authentication. If specified, the DB cluster joins the given Active Directory, enabling Kerberos authentication. If not specified, the DB cluster will not be associated with any Active Directory, and Kerberos authentication will not be enabled. Default: - DB cluster is not associated with an Active Directory; Kerberos authentication is not enabled.
        :param domain_role: The IAM role to be used when making API calls to the Directory Service. The role needs the AWS-managed policy ``AmazonRDSDirectoryServiceAccess`` or equivalent. Default: - If ``DatabaseClusterBaseProps.domain`` is specified, a role with the ``AmazonRDSDirectoryServiceAccess`` policy is automatically created.
        :param enable_cluster_level_enhanced_monitoring: Whether to enable enhanced monitoring at the cluster level. If set to true, ``monitoringInterval`` and ``monitoringRole`` are applied to not the instances, but the cluster. ``monitoringInterval`` is required to be set if ``enableClusterLevelEnhancedMonitoring`` is set to true. Default: - When the ``monitoringInterval`` is set, enhanced monitoring is enabled for each instance.
        :param enable_data_api: Whether to enable the Data API for the cluster. Default: - false
        :param enable_local_write_forwarding: Whether read replicas can forward write operations to the writer DB instance in the DB cluster. This setting can only be enabled for Aurora MySQL 3.04 or higher, and for Aurora PostgreSQL 16.4 or higher (for version 16), 15.8 or higher (for version 15), and 14.13 or higher (for version 14). Default: false
        :param enable_performance_insights: Whether to enable Performance Insights for the DB cluster. Default: - false, unless ``performanceInsightRetention`` or ``performanceInsightEncryptionKey`` is set, or ``databaseInsightsMode`` is set to ``DatabaseInsightsMode.ADVANCED``.
        :param engine_lifecycle_support: The life cycle type for this DB cluster. Default: undefined - AWS RDS default setting is ``EngineLifecycleSupport.OPEN_SOURCE_RDS_EXTENDED_SUPPORT``
        :param iam_authentication: Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier_base: Base identifier for instances. Every replica is named by appending the replica number to this string, 1-based. Default: - clusterIdentifier is used with the word "Instance" appended. If clusterIdentifier is not provided, the identifier is automatically generated.
        :param instance_props: (deprecated) Settings for the individual instances that are launched.
        :param instances: (deprecated) How many replicas/instances to create. Has to be at least 1. Default: 2
        :param instance_update_behaviour: The ordering of updates for instances. Default: InstanceUpdateBehaviour.BULK
        :param monitoring_interval: The interval between points when Amazon RDS collects enhanced monitoring metrics. If you enable ``enableClusterLevelEnhancedMonitoring``, this property is applied to the cluster, otherwise it is applied to the instances. Default: - no enhanced monitoring
        :param monitoring_role: Role that will be used to manage DB monitoring. If you enable ``enableClusterLevelEnhancedMonitoring``, this property is applied to the cluster, otherwise it is applied to the instances. Default: - A role is automatically created for you
        :param network_type: The network type of the DB instance. Default: - IPV4
        :param parameter_group: Additional parameters to pass to the database engine. Default: - No parameter group.
        :param parameters: The parameters in the DBClusterParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBClusterParameterGroup. Default: - None
        :param performance_insight_encryption_key: The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: The amount of time, in days, to retain Performance Insights data. If you set ``databaseInsightsMode`` to ``DatabaseInsightsMode.ADVANCED``, you must set this property to ``PerformanceInsightRetention.MONTHS_15``. Default: - 7
        :param port: What port to listen on. Default: - The default for the engine is used.
        :param preferred_maintenance_window: A preferred maintenance window day/time range. Should be specified as a range ddd:hh24:mi-ddd:hh24:mi (24H Clock UTC). Example: 'Sun:23:45-Mon:00:15' Default: - 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week.
        :param readers: A list of instances to create as cluster reader instances. Default: - no readers are created. The cluster will have a single writer/reader
        :param removal_policy: The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        :param replication_source_identifier: The Amazon Resource Name (ARN) of the source DB instance or DB cluster if this DB cluster is created as a read replica. Cannot be used with credentials. Default: - This DB Cluster is not a read replica
        :param s3_export_buckets: S3 buckets that you want to load data into. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ExportRole`` is used. For MySQL: Default: - None
        :param s3_export_role: Role that will be associated with this DB cluster to enable S3 export. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ExportBuckets`` is used. To use this property with Aurora PostgreSQL, it must be configured with the S3 export feature enabled when creating the DatabaseClusterEngine For MySQL: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: S3 buckets that you want to load data from. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ImportRole`` is used. For MySQL: Default: - None
        :param s3_import_role: Role that will be associated with this DB cluster to enable S3 import. This feature is only supported by the Aurora database engine. This property must not be used if ``s3ImportBuckets`` is used. To use this property with Aurora PostgreSQL, it must be configured with the S3 import feature enabled when creating the DatabaseClusterEngine For MySQL: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param security_groups: Security group. Default: - a new security group is created.
        :param serverless_v2_auto_pause_duration: Specifies the duration an Aurora Serverless v2 DB instance must be idle before Aurora attempts to automatically pause it. The duration must be between 300 seconds (5 minutes) and 86,400 seconds (24 hours). Default: - The default is 300 seconds (5 minutes).
        :param serverless_v2_max_capacity: The maximum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 40, 40.5, 41, and so on. The largest value that you can use is 256. The maximum capacity must be higher than 0.5 ACUs. Default: 2
        :param serverless_v2_min_capacity: The minimum number of Aurora capacity units (ACUs) for a DB instance in an Aurora Serverless v2 cluster. You can specify ACU values in half-step increments, such as 8, 8.5, 9, and so on. The smallest value that you can use is 0. For Aurora versions that support the Aurora Serverless v2 auto-pause feature, the smallest value that you can use is 0. For versions that don't support Aurora Serverless v2 auto-pause, the smallest value that you can use is 0.5. Default: 0.5
        :param storage_encrypted: Whether to enable storage encryption. Default: - true if storageEncryptionKey is provided, false otherwise
        :param storage_encryption_key: The KMS key for storage encryption. If specified, ``storageEncrypted`` will be set to ``true``. Default: - if storageEncrypted is true then the default master key, no key otherwise
        :param storage_type: The storage type to be associated with the DB cluster. Default: - DBClusterStorageType.AURORA
        :param subnet_group: Existing subnet group for the cluster. Default: - a new subnet group will be created.
        :param vpc: What subnets to run the RDS instances in. Must be at least 2 subnets in two different AZs.
        :param vpc_subnets: Where to place the instances within the VPC. Default: - the Vpc default strategy if not specified.
        :param writer: The instance to use for the cluster writer. Default: - required if instanceProps is not provided
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae99011110f783b0444b8e6ac9226586a1665200f9ac945e68fef86d3fa756a2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_rds_ceddda9d.DatabaseClusterProps(
            engine=engine,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            backtrack_window=backtrack_window,
            backup=backup,
            cloudwatch_logs_exports=cloudwatch_logs_exports,
            cloudwatch_logs_retention=cloudwatch_logs_retention,
            cloudwatch_logs_retention_role=cloudwatch_logs_retention_role,
            cluster_identifier=cluster_identifier,
            cluster_scailability_type=cluster_scailability_type,
            cluster_scalability_type=cluster_scalability_type,
            copy_tags_to_snapshot=copy_tags_to_snapshot,
            credentials=credentials,
            database_insights_mode=database_insights_mode,
            default_database_name=default_database_name,
            deletion_protection=deletion_protection,
            domain=domain,
            domain_role=domain_role,
            enable_cluster_level_enhanced_monitoring=enable_cluster_level_enhanced_monitoring,
            enable_data_api=enable_data_api,
            enable_local_write_forwarding=enable_local_write_forwarding,
            enable_performance_insights=enable_performance_insights,
            engine_lifecycle_support=engine_lifecycle_support,
            iam_authentication=iam_authentication,
            instance_identifier_base=instance_identifier_base,
            instance_props=instance_props,
            instances=instances,
            instance_update_behaviour=instance_update_behaviour,
            monitoring_interval=monitoring_interval,
            monitoring_role=monitoring_role,
            network_type=network_type,
            parameter_group=parameter_group,
            parameters=parameters,
            performance_insight_encryption_key=performance_insight_encryption_key,
            performance_insight_retention=performance_insight_retention,
            port=port,
            preferred_maintenance_window=preferred_maintenance_window,
            readers=readers,
            removal_policy=removal_policy,
            replication_source_identifier=replication_source_identifier,
            s3_export_buckets=s3_export_buckets,
            s3_export_role=s3_export_role,
            s3_import_buckets=s3_import_buckets,
            s3_import_role=s3_import_role,
            security_groups=security_groups,
            serverless_v2_auto_pause_duration=serverless_v2_auto_pause_duration,
            serverless_v2_max_capacity=serverless_v2_max_capacity,
            serverless_v2_min_capacity=serverless_v2_min_capacity,
            storage_encrypted=storage_encrypted,
            storage_encryption_key=storage_encryption_key,
            storage_type=storage_type,
            subnet_group=subnet_group,
            vpc=vpc,
            vpc_subnets=vpc_subnets,
            writer=writer,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmAuroraBinLogReplicationLag")
    def alarm_aurora_bin_log_replication_lag(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsAuroraBinLogReplicationLagAlarm":
        '''Creates an alarm that monitors the Bin Log Replication lag.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect whether the writer instance is in an error state and cant replicate the source. This alarm is recommended only for Aurora MySQL.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - AuroraBinLogReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: The value against which the specified statistic is compared. We recommend that you use -1 as the threshold value because Aurora MySQL publishes this value if the replica is in an error state. Default: -1
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsAuroraBinLogReplicationLagAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsAuroraBinLogReplicationLagAlarm", jsii.invoke(self, "alarmAuroraBinLogReplicationLag", [props]))

    @jsii.member(jsii_name="alarmAuroraVolumeBytesLeftTotal")
    def alarm_aurora_volume_bytes_left_total(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsAuroraVolumeBytesLeftTotalAlarm":
        '''Creates an alarm that monitors the AuroraVolumeBytesLeftTotal.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the Aurora cluster is to the volume size limit. This alarm can prevent an out-of-space error that occurs when your cluster runs out of space. This alarm is recommended only for Aurora MySQL.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - AuroraVolumeBytesLeftTotal'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in bytes against which the specified statistic is compared. You should calculate 10%-20% of the actual size limit based on velocity and trend of volume usage increase, and then use that result as the threshold value to proactively take action before the volume reaches its limit.
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsAuroraVolumeBytesLeftTotalAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsAuroraVolumeBytesLeftTotalAlarm", jsii.invoke(self, "alarmAuroraVolumeBytesLeftTotal", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_aurora_bin_log_replication_lag_alarm: typing.Optional[typing.Union["RdsAuroraBinLogReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_aurora_volume_bytes_left_total_alarm: typing.Optional[typing.Union["RdsAuroraVolumeBytesLeftTotalAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_database_connections_alarm: typing.Union["RdsDatabaseConnectionsAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_db_load_alarm: typing.Union["RdsDbLoadAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_freeable_memory_alarm: typing.Union["RdsFreeableMemoryAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_free_local_storage_alarm: typing.Union["RdsFreeLocalStorageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union["RdsFreeStorageSpaceAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_read_latency_alarm: typing.Union["RdsReadLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_write_latency_alarm: typing.Union["RdsWriteLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union["RdsCpuUtilizationAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["RdsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsAuroraRecommendedAlarms":
        '''Creates recommended alarms for the database cluster.

        :param config_aurora_bin_log_replication_lag_alarm: The configuration for the AuroraBinLogReplicationLag alarm.
        :param config_aurora_volume_bytes_left_total_alarm: The configuration for the AuroraVolumeBytesLeftTotal alarm.
        :param config_database_connections_alarm: The configuration for the DatabaseConnections alarm.
        :param config_db_load_alarm: The configuration for the DbLoad alarm.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_local_storage_alarm: The configuration for the FreeLocalStorage alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_read_latency_alarm: The configuration for the ReadLatency alarm.
        :param config_write_latency_alarm: The configuration for the WriteLatency alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#RDS
        '''
        props = RdsAuroraRecommendedAlarmsConfig(
            config_aurora_bin_log_replication_lag_alarm=config_aurora_bin_log_replication_lag_alarm,
            config_aurora_volume_bytes_left_total_alarm=config_aurora_volume_bytes_left_total_alarm,
            config_database_connections_alarm=config_database_connections_alarm,
            config_db_load_alarm=config_db_load_alarm,
            config_freeable_memory_alarm=config_freeable_memory_alarm,
            config_free_local_storage_alarm=config_free_local_storage_alarm,
            config_free_storage_space_alarm=config_free_storage_space_alarm,
            config_read_latency_alarm=config_read_latency_alarm,
            config_write_latency_alarm=config_write_latency_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsAuroraRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


class DatabaseInstance(
    _aws_cdk_aws_rds_ceddda9d.DatabaseInstance,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DatabaseInstance",
):
    '''An extension of the rds instance (database or cluster instance) construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        character_set_name: typing.Optional[builtins.str] = None,
        credentials: typing.Optional[_aws_cdk_aws_rds_ceddda9d.Credentials] = None,
        storage_encrypted: typing.Optional[builtins.bool] = None,
        storage_encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        engine: _aws_cdk_aws_rds_ceddda9d.IInstanceEngine,
        allocated_storage: typing.Optional[jsii.Number] = None,
        allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
        database_name: typing.Optional[builtins.str] = None,
        instance_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.InstanceType] = None,
        license_model: typing.Optional[_aws_cdk_aws_rds_ceddda9d.LicenseModel] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        timezone: typing.Optional[builtins.str] = None,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
        apply_immediately: typing.Optional[builtins.bool] = None,
        auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        backup_retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        ca_certificate: typing.Optional[_aws_cdk_aws_rds_ceddda9d.CaCertificate] = None,
        cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
        cloudwatch_logs_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
        cloudwatch_logs_retention_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        delete_automated_backups: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        domain: typing.Optional[builtins.str] = None,
        domain_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        enable_performance_insights: typing.Optional[builtins.bool] = None,
        engine_lifecycle_support: typing.Optional[_aws_cdk_aws_rds_ceddda9d.EngineLifecycleSupport] = None,
        iam_authentication: typing.Optional[builtins.bool] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        iops: typing.Optional[jsii.Number] = None,
        max_allocated_storage: typing.Optional[jsii.Number] = None,
        monitoring_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        monitoring_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        multi_az: typing.Optional[builtins.bool] = None,
        network_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.NetworkType] = None,
        option_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IOptionGroup] = None,
        parameter_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IParameterGroup] = None,
        performance_insight_encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        performance_insight_retention: typing.Optional[_aws_cdk_aws_rds_ceddda9d.PerformanceInsightRetention] = None,
        port: typing.Optional[jsii.Number] = None,
        preferred_backup_window: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        processor_features: typing.Optional[typing.Union[_aws_cdk_aws_rds_ceddda9d.ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
        publicly_accessible: typing.Optional[builtins.bool] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        s3_export_buckets: typing.Optional[typing.Sequence[_aws_cdk_aws_s3_ceddda9d.IBucket]] = None,
        s3_export_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        s3_import_buckets: typing.Optional[typing.Sequence[_aws_cdk_aws_s3_ceddda9d.IBucket]] = None,
        s3_import_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
        storage_throughput: typing.Optional[jsii.Number] = None,
        storage_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.StorageType] = None,
        subnet_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.ISubnetGroup] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param character_set_name: For supported engines, specifies the character set to associate with the DB instance. Default: - RDS default character set name
        :param credentials: Credentials for the administrative user. Default: - A username of 'admin' (or 'postgres' for PostgreSQL) and SecretsManager-generated password
        :param storage_encrypted: Indicates whether the DB instance is encrypted. Default: - true if storageEncryptionKey has been provided, false otherwise
        :param storage_encryption_key: The KMS key that's used to encrypt the DB instance. Default: - default master key if storageEncrypted is true, no key otherwise
        :param engine: The database engine.
        :param allocated_storage: The allocated storage size, specified in gibibytes (GiB). Default: 100
        :param allow_major_version_upgrade: Whether to allow major version upgrades. Default: false
        :param database_name: The name of the database. Default: - no name
        :param instance_type: The name of the compute and memory capacity for the instance. Default: - m5.large (or, more specifically, db.m5.large)
        :param license_model: The license model. Default: - RDS default license model
        :param parameters: The parameters in the DBParameterGroup to create automatically. You can only specify parameterGroup or parameters but not both. You need to use a versioned engine to auto-generate a DBParameterGroup. Default: - None
        :param timezone: The time zone of the instance. This is currently supported only by Microsoft Sql Server. Default: - RDS default timezone
        :param vpc: The VPC network where the DB subnet group should be created.
        :param apply_immediately: Specifies whether changes to the DB instance and any pending modifications are applied immediately, regardless of the ``preferredMaintenanceWindow`` setting. If set to ``false``, changes are applied during the next maintenance window. Until RDS applies the changes, the DB instance remains in a drift state. As a result, the configuration doesn't fully reflect the requested modifications and temporarily diverges from the intended state. This property also determines whether the DB instance reboots when a static parameter is modified in the associated DB parameter group. Default: - Changes will be applied immediately
        :param auto_minor_version_upgrade: Indicates that minor engine upgrades are applied automatically to the DB instance during the maintenance window. Default: true
        :param availability_zone: The name of the Availability Zone where the DB instance will be located. Default: - no preference
        :param backup_retention: The number of days during which automatic DB snapshots are retained. Set to zero to disable backups. When creating a read replica, you must enable automatic backups on the source database instance by setting the backup retention to a value other than zero. Default: - Duration.days(1) for source instances, disabled for read replicas
        :param ca_certificate: The identifier of the CA certificate for this DB instance. Specifying or updating this property triggers a reboot. For RDS DB engines: Default: - RDS will choose a certificate authority
        :param cloudwatch_logs_exports: The list of log types that need to be enabled for exporting to CloudWatch Logs. Default: - no log exports
        :param cloudwatch_logs_retention: The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``Infinity``. Default: - logs never expire
        :param cloudwatch_logs_retention_role: The IAM role for the Lambda function associated with the custom resource that sets the retention policy. Default: - a new role is created.
        :param copy_tags_to_snapshot: Indicates whether to copy all of the user-defined tags from the DB instance to snapshots of the DB instance. Default: true
        :param delete_automated_backups: Indicates whether automated backups should be deleted or retained when you delete a DB instance. Default: true
        :param deletion_protection: Indicates whether the DB instance should have deletion protection enabled. Default: - true if ``removalPolicy`` is RETAIN, false otherwise
        :param domain: The Active Directory directory ID to create the DB instance in. Default: - Do not join domain
        :param domain_role: The IAM role to be used when making API calls to the Directory Service. The role needs the AWS-managed policy AmazonRDSDirectoryServiceAccess or equivalent. Default: - The role will be created for you if ``DatabaseInstanceNewProps#domain`` is specified
        :param enable_performance_insights: Whether to enable Performance Insights for the DB instance. Default: - false, unless ``performanceInsightRetention`` or ``performanceInsightEncryptionKey`` is set.
        :param engine_lifecycle_support: The life cycle type for this DB instance. This setting applies only to RDS for MySQL and RDS for PostgreSQL. Default: undefined - AWS RDS default setting is ``EngineLifecycleSupport.OPEN_SOURCE_RDS_EXTENDED_SUPPORT``
        :param iam_authentication: Whether to enable mapping of AWS Identity and Access Management (IAM) accounts to database accounts. Default: false
        :param instance_identifier: A name for the DB instance. If you specify a name, AWS CloudFormation converts it to lowercase. Default: - a CloudFormation generated name
        :param iops: The number of I/O operations per second (IOPS) that the database provisions. The value must be equal to or greater than 1000. Default: - no provisioned iops if storage type is not specified. For GP3: 3,000 IOPS if allocated storage is less than 400 GiB for MariaDB, MySQL, and PostgreSQL, less than 200 GiB for Oracle and less than 20 GiB for SQL Server. 12,000 IOPS otherwise (except for SQL Server where the default is always 3,000 IOPS).
        :param max_allocated_storage: Upper limit to which RDS can scale the storage in GiB(Gibibyte). Default: - No autoscaling of RDS instance
        :param monitoring_interval: The interval, in seconds, between points when Amazon RDS collects enhanced monitoring metrics for the DB instance. Default: - no enhanced monitoring
        :param monitoring_role: Role that will be used to manage DB instance monitoring. Default: - A role is automatically created for you
        :param multi_az: Specifies if the database instance is a multiple Availability Zone deployment. Default: false
        :param network_type: The network type of the DB instance. Default: - IPV4
        :param option_group: The option group to associate with the instance. Default: - no option group
        :param parameter_group: The DB parameter group to associate with the instance. Default: - no parameter group
        :param performance_insight_encryption_key: The AWS KMS key for encryption of Performance Insights data. Default: - default master key
        :param performance_insight_retention: The amount of time, in days, to retain Performance Insights data. Default: 7 this is the free tier
        :param port: The port for the instance. Default: - the default port for the chosen engine.
        :param preferred_backup_window: The daily time range during which automated backups are performed. Constraints: - Must be in the format ``hh24:mi-hh24:mi``. - Must be in Universal Coordinated Time (UTC). - Must not conflict with the preferred maintenance window. - Must be at least 30 minutes. Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_WorkingWithAutomatedBackups.html#USER_WorkingWithAutomatedBackups.BackupWindow
        :param preferred_maintenance_window: The weekly time range (in UTC) during which system maintenance can occur. Format: ``ddd:hh24:mi-ddd:hh24:mi`` Constraint: Minimum 30-minute window Default: - a 30-minute window selected at random from an 8-hour block of time for each AWS Region, occurring on a random day of the week. To see the time blocks available, see https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_UpgradeDBInstance.Maintenance.html#Concepts.DBMaintenance
        :param processor_features: The number of CPU cores and the number of threads per core. Default: - the default number of CPU cores and threads per core for the chosen instance class. See https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.DBInstanceClass.html#USER_ConfigureProcessor
        :param publicly_accessible: Indicates whether the DB instance is an internet-facing instance. If not specified, the instance's vpcSubnets will be used to determine if the instance is internet-facing or not. Default: - ``true`` if the instance's ``vpcSubnets`` is ``subnetType: SubnetType.PUBLIC``, ``false`` otherwise
        :param removal_policy: The CloudFormation policy to apply when the instance is removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the resource, but retain a snapshot of the data)
        :param s3_export_buckets: S3 buckets that you want to load data into. This property must not be used if ``s3ExportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_export_role: Role that will be associated with this DB instance to enable S3 export. This property must not be used if ``s3ExportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ExportBuckets`` is set, no role is defined otherwise
        :param s3_import_buckets: S3 buckets that you want to load data from. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportRole`` is used. For Microsoft SQL Server: Default: - None
        :param s3_import_role: Role that will be associated with this DB instance to enable S3 import. This feature is only supported by the Microsoft SQL Server, Oracle, and PostgreSQL engines. This property must not be used if ``s3ImportBuckets`` is used. For Microsoft SQL Server: Default: - New role is created if ``s3ImportBuckets`` is set, no role is defined otherwise
        :param security_groups: The security groups to assign to the DB instance. Default: - a new security group is created
        :param storage_throughput: The storage throughput, specified in mebibytes per second (MiBps). Only applicable for GP3. Default: - 125 MiBps if allocated storage is less than 400 GiB for MariaDB, MySQL, and PostgreSQL, less than 200 GiB for Oracle and less than 20 GiB for SQL Server. 500 MiBps otherwise (except for SQL Server where the default is always 125 MiBps).
        :param storage_type: The storage type. Storage types supported are gp2, io1, standard. Default: GP2
        :param subnet_group: Existing subnet group for the instance. Default: - a new subnet group will be created.
        :param vpc_subnets: The type of subnets to add to the created DB subnet group. Default: - private subnets
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9152604e11755d3937ae12655f53012564282cb097fd7057b1d03eb751e9201f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_rds_ceddda9d.DatabaseInstanceProps(
            character_set_name=character_set_name,
            credentials=credentials,
            storage_encrypted=storage_encrypted,
            storage_encryption_key=storage_encryption_key,
            engine=engine,
            allocated_storage=allocated_storage,
            allow_major_version_upgrade=allow_major_version_upgrade,
            database_name=database_name,
            instance_type=instance_type,
            license_model=license_model,
            parameters=parameters,
            timezone=timezone,
            vpc=vpc,
            apply_immediately=apply_immediately,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            availability_zone=availability_zone,
            backup_retention=backup_retention,
            ca_certificate=ca_certificate,
            cloudwatch_logs_exports=cloudwatch_logs_exports,
            cloudwatch_logs_retention=cloudwatch_logs_retention,
            cloudwatch_logs_retention_role=cloudwatch_logs_retention_role,
            copy_tags_to_snapshot=copy_tags_to_snapshot,
            delete_automated_backups=delete_automated_backups,
            deletion_protection=deletion_protection,
            domain=domain,
            domain_role=domain_role,
            enable_performance_insights=enable_performance_insights,
            engine_lifecycle_support=engine_lifecycle_support,
            iam_authentication=iam_authentication,
            instance_identifier=instance_identifier,
            iops=iops,
            max_allocated_storage=max_allocated_storage,
            monitoring_interval=monitoring_interval,
            monitoring_role=monitoring_role,
            multi_az=multi_az,
            network_type=network_type,
            option_group=option_group,
            parameter_group=parameter_group,
            performance_insight_encryption_key=performance_insight_encryption_key,
            performance_insight_retention=performance_insight_retention,
            port=port,
            preferred_backup_window=preferred_backup_window,
            preferred_maintenance_window=preferred_maintenance_window,
            processor_features=processor_features,
            publicly_accessible=publicly_accessible,
            removal_policy=removal_policy,
            s3_export_buckets=s3_export_buckets,
            s3_export_role=s3_export_role,
            s3_import_buckets=s3_import_buckets,
            s3_import_role=s3_import_role,
            security_groups=security_groups,
            storage_throughput=storage_throughput,
            storage_type=storage_type,
            subnet_group=subnet_group,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmCpuUtilization")
    def alarm_cpu_utilization(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsInstanceCpuUtilizationAlarm":
        '''Creates an alarm that monitors the CpuUtilization.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect consistent high CPU utilization in order to prevent very high response time and time-outs. If you want to check micro-bursting of CPU utilization you can set a lower alarm evaluation time.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - CpuUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. Random spikes in CPU consumption might not hamper database performance, but sustained high CPU can hinder upcoming database requests. Depending on the overall database workload, high CPU at your RDS/Aurora instance can degrade the overall performance. Default: 90
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsCpuUtilizationAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsInstanceCpuUtilizationAlarm", jsii.invoke(self, "alarmCpuUtilization", [props]))

    @jsii.member(jsii_name="alarmDatabaseConnections")
    def alarm_database_connections(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsInstanceDatabaseConnectionsAlarm":
        '''Creates an alarm that monitors the DatabaseConnections.

        :param threshold: The number of connections against which the specified statistic is compared. The number of connections allowed depends on the size of your DB instance class and database engine-specific parameters related to processes/connections. You should calculate a value between 90-95% of the maximum number of connections for your database and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent rejected connections when the maximum number of DB connections is reached. This alarm is not recommended if you frequently change DB instance class, because doing so changes the memory and default maximum number of connections.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - DatabaseConnections'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsDatabaseConnectionsAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsInstanceDatabaseConnectionsAlarm", jsii.invoke(self, "alarmDatabaseConnections", [props]))

    @jsii.member(jsii_name="alarmDbLoad")
    def alarm_db_load(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsInstanceDbLoadAlarm":
        '''Creates an alarm that monitors the DbLoad.

        :param threshold: The value against which the specified statistic is compared. The maximum vCPU value is determined by the number of vCPU (virtual CPU) cores for your DB instance. Depending on the maximum vCPU, different values for the threshold can be appropriate. Ideally, DB load should not go above vCPU line.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a high DB load. High DB load can cause performance issues in the DB instance. This alarm is not applicable to serverless DB instances.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - DBLoad'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsDbLoadAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsInstanceDbLoadAlarm", jsii.invoke(self, "alarmDbLoad", [props]))

    @jsii.member(jsii_name="alarmFreeableMemory")
    def alarm_freeable_memory(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsInstanceFreeableMemoryAlarm":
        '''Creates an alarm that monitors the FreeableMemory.

        :param threshold: The percentage value (0-100) against which the specified statistic is compared. Depending on the workload and instance class, different values for the threshold can be appropriate. Ideally, available memory should not go below 25% of total memory for prolonged periods. For Aurora, you can set the threshold close to 5%, because the metric approaching 0 means that the DB instance has scaled up as much as it can. You can analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent running out of memory which can result in rejected connections.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeableMemory'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsFreeableMemoryAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsInstanceFreeableMemoryAlarm", jsii.invoke(self, "alarmFreeableMemory", [props]))

    @jsii.member(jsii_name="alarmFreeLocalStorage")
    def alarm_free_local_storage(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsInstanceFreeLocalStorageAlarm":
        '''Creates an alarm that monitors the FreeLocalStorage.

        :param threshold: The percentage value (0-100) against which the specified statistic is compared. You should calculate about 10%-20% of the amount of storage available based on velocity and trend of volume usage, and then use that result as the threshold value to proactively take action before the volume reaches its limit.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the Aurora DB instance is to reaching the local storage limit, if you do not use Aurora Serverless v2 or higher. Local storage can reach capacity when you store non-persistent data, such as temporary table and log files, in the local storage. This alarm can prevent an out-of-space error that occurs when your DB instance runs out of local storage.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeLocalStorage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsFreeLocalStorageAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsInstanceFreeLocalStorageAlarm", jsii.invoke(self, "alarmFreeLocalStorage", [props]))

    @jsii.member(jsii_name="alarmFreeStorageSpace")
    def alarm_free_storage_space(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsInstanceFreeStorageSpaceAlarm":
        '''Creates an alarm that monitors the FreeStorageSpace.

        :param threshold: The percentage value (0-100) against which the specified statistic is compared. The threshold value will depend on the currently allocated storage space. Typically, you should calculate the value of 10 percent of the allocated storage space and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm helps prevent storage full issues. This can prevent downtime that occurs when your database instance runs out of storage. We do not recommend using this alarm if you have storage auto scaling enabled, or if you frequently change the storage capacity of the database instance.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeStorageSpace'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsFreeStorageSpaceAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsInstanceFreeStorageSpaceAlarm", jsii.invoke(self, "alarmFreeStorageSpace", [props]))

    @jsii.member(jsii_name="alarmReadLatency")
    def alarm_read_latency(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsInstanceReadLatencyAlarm":
        '''Creates an alarm that monitors the ReadLatency.

        :param threshold: The value in milliseconds against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on your use case. Read latencies higher than 20 milliseconds are likely a cause for investigation. You can also set a higher threshold if your application can have higher latency for read operations. Review the criticality and requirements of read latency and analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high read latency. Database disks normally have a low read/write latency, but they can have issues that can cause high latency operations.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - ReadLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsReadLatencyAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsInstanceReadLatencyAlarm", jsii.invoke(self, "alarmReadLatency", [props]))

    @jsii.member(jsii_name="alarmWriteLatency")
    def alarm_write_latency(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsInstanceWriteLatencyAlarm":
        '''Creates an alarm that monitors the WriteLatency.

        :param threshold: The value in milliseconds against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on your use case. Write latencies higher than 20 milliseconds are likely a cause for investigation. You can also set a higher threshold if your application can have a higher latency for write operations. Review the criticality and requirements of write latency and analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high write latency. Although database disks typically have low read/write latency, they may experience problems that cause high latency operations. Monitoring this will assure you the disk latency is as low as expected.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - WriteLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsWriteLatencyAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsInstanceWriteLatencyAlarm", jsii.invoke(self, "alarmWriteLatency", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_database_connections_alarm: typing.Union["RdsDatabaseConnectionsAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_db_load_alarm: typing.Union["RdsDbLoadAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_freeable_memory_alarm: typing.Union["RdsFreeableMemoryAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_free_local_storage_alarm: typing.Union["RdsFreeLocalStorageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union["RdsFreeStorageSpaceAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_read_latency_alarm: typing.Union["RdsReadLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_write_latency_alarm: typing.Union["RdsWriteLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union["RdsCpuUtilizationAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["RdsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "RdsInstanceRecommendedAlarms":
        '''Creates recommended alarms for the database instance.

        :param config_database_connections_alarm: The configuration for the DatabaseConnections alarm.
        :param config_db_load_alarm: The configuration for the DbLoad alarm.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_local_storage_alarm: The configuration for the FreeLocalStorage alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_read_latency_alarm: The configuration for the ReadLatency alarm.
        :param config_write_latency_alarm: The configuration for the WriteLatency alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#RDS
        '''
        props = RdsInstanceRecommendedAlarmsConfig(
            config_database_connections_alarm=config_database_connections_alarm,
            config_db_load_alarm=config_db_load_alarm,
            config_freeable_memory_alarm=config_freeable_memory_alarm,
            config_free_local_storage_alarm=config_free_local_storage_alarm,
            config_free_storage_space_alarm=config_free_storage_space_alarm,
            config_read_latency_alarm=config_read_latency_alarm,
            config_write_latency_alarm=config_write_latency_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("RdsInstanceRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


class Distribution(
    _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Distribution",
):
    '''An extension for the Distribution construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        default_behavior: typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.BehaviorOptions, typing.Dict[builtins.str, typing.Any]],
        additional_behaviors: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.BehaviorOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
        certificate: typing.Optional[_aws_cdk_aws_certificatemanager_ceddda9d.ICertificate] = None,
        comment: typing.Optional[builtins.str] = None,
        default_root_object: typing.Optional[builtins.str] = None,
        domain_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        enable_ipv6: typing.Optional[builtins.bool] = None,
        enable_logging: typing.Optional[builtins.bool] = None,
        error_responses: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.ErrorResponse, typing.Dict[builtins.str, typing.Any]]]] = None,
        geo_restriction: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.GeoRestriction] = None,
        http_version: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.HttpVersion] = None,
        log_bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
        log_file_prefix: typing.Optional[builtins.str] = None,
        log_includes_cookies: typing.Optional[builtins.bool] = None,
        minimum_protocol_version: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SecurityPolicyProtocol] = None,
        price_class: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.PriceClass] = None,
        publish_additional_metrics: typing.Optional[builtins.bool] = None,
        ssl_support_method: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SSLMethod] = None,
        web_acl_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param default_behavior: The default behavior for the distribution.
        :param additional_behaviors: Additional behaviors for the distribution, mapped by the pathPattern that specifies which requests to apply the behavior to. Default: - no additional behaviors are added.
        :param certificate: A certificate to associate with the distribution. The certificate must be located in N. Virginia (us-east-1). Default: - the CloudFront wildcard certificate (*.cloudfront.net) will be used.
        :param comment: Any comments you want to include about the distribution. Default: - no comment
        :param default_root_object: The object that you want CloudFront to request from your origin (for example, index.html) when a viewer requests the root URL for your distribution. If no default object is set, the request goes to the origin's root (e.g., example.com/). Default: - no default root object
        :param domain_names: Alternative domain names for this distribution. If you want to use your own domain name, such as www.example.com, instead of the cloudfront.net domain name, you can add an alternate domain name to your distribution. If you attach a certificate to the distribution, you should add (at least one of) the domain names of the certificate to this list. When you want to move a domain name between distributions, you can associate a certificate without specifying any domain names. For more information, see the *Moving an alternate domain name to a different distribution* section in the README. Default: - The distribution will only support the default generated name (e.g., d111111abcdef8.cloudfront.net)
        :param enabled: Enable or disable the distribution. Default: true
        :param enable_ipv6: Whether CloudFront will respond to IPv6 DNS requests with an IPv6 address. If you specify false, CloudFront responds to IPv6 DNS requests with the DNS response code NOERROR and with no IP addresses. This allows viewers to submit a second request, for an IPv4 address for your distribution. Default: true
        :param enable_logging: Enable access logging for the distribution. Default: - false, unless ``logBucket`` is specified.
        :param error_responses: How CloudFront should handle requests that are not successful (e.g., PageNotFound). Default: - No custom error responses.
        :param geo_restriction: Controls the countries in which your content is distributed. Default: - No geographic restrictions
        :param http_version: Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront. For viewers and CloudFront to use HTTP/2, viewers must support TLS 1.2 or later, and must support server name identification (SNI). Default: HttpVersion.HTTP2
        :param log_bucket: The Amazon S3 bucket to store the access logs in. Make sure to set ``objectOwnership`` to ``s3.ObjectOwnership.OBJECT_WRITER`` in your custom bucket. Default: - A bucket is created if ``enableLogging`` is true
        :param log_file_prefix: An optional string that you want CloudFront to prefix to the access log filenames for this distribution. Default: - no prefix
        :param log_includes_cookies: Specifies whether you want CloudFront to include cookies in access logs. Default: false
        :param minimum_protocol_version: The minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections. CloudFront serves your objects only to browsers or devices that support at least the SSL version that you specify. Default: - SecurityPolicyProtocol.TLS_V1_2_2021 if the '@aws-cdk/aws-cloudfront:defaultSecurityPolicyTLSv1.2_2021' feature flag is set; otherwise, SecurityPolicyProtocol.TLS_V1_2_2019.
        :param price_class: The price class that corresponds with the maximum price that you want to pay for CloudFront service. If you specify PriceClass_All, CloudFront responds to requests for your objects from all CloudFront edge locations. If you specify a price class other than PriceClass_All, CloudFront serves your objects from the CloudFront edge location that has the lowest latency among the edge locations in your price class. Default: PriceClass.PRICE_CLASS_ALL
        :param publish_additional_metrics: Whether to enable additional CloudWatch metrics. Default: false
        :param ssl_support_method: The SSL method CloudFront will use for your distribution. Server Name Indication (SNI) - is an extension to the TLS computer networking protocol by which a client indicates which hostname it is attempting to connect to at the start of the handshaking process. This allows a server to present multiple certificates on the same IP address and TCP port number and hence allows multiple secure (HTTPS) websites (or any other service over TLS) to be served by the same IP address without requiring all those sites to use the same certificate. CloudFront can use SNI to host multiple distributions on the same IP - which a large majority of clients will support. If your clients cannot support SNI however - CloudFront can use dedicated IPs for your distribution - but there is a prorated monthly charge for using this feature. By default, we use SNI - but you can optionally enable dedicated IPs (VIP). See the CloudFront SSL for more details about pricing : https://aws.amazon.com/cloudfront/custom-ssl-domains/ Default: SSLMethod.SNI
        :param web_acl_id: Unique identifier that specifies the AWS WAF web ACL to associate with this CloudFront distribution. To specify a web ACL created using the latest version of AWS WAF, use the ACL ARN, for example ``arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a``. To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example ``473e64fd-f30b-4765-81a0-62ad96dd167a``. Default: - No AWS Web Application Firewall web access control list (web ACL).
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__46f484d1d1177c5f3c3883060fbc0c874488a986b8174bf67e85d18aba3a973c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_cloudfront_ceddda9d.DistributionProps(
            default_behavior=default_behavior,
            additional_behaviors=additional_behaviors,
            certificate=certificate,
            comment=comment,
            default_root_object=default_root_object,
            domain_names=domain_names,
            enabled=enabled,
            enable_ipv6=enable_ipv6,
            enable_logging=enable_logging,
            error_responses=error_responses,
            geo_restriction=geo_restriction,
            http_version=http_version,
            log_bucket=log_bucket,
            log_file_prefix=log_file_prefix,
            log_includes_cookies=log_includes_cookies,
            minimum_protocol_version=minimum_protocol_version,
            price_class=price_class,
            publish_additional_metrics=publish_additional_metrics,
            ssl_support_method=ssl_support_method,
            web_acl_id=web_acl_id,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarm5xxErrorRate")
    def alarm5xx_error_rate(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> CloudFrontDistribution5xxErrorRateAlarm:
        '''Creates an alarm that monitors the 5xxErrorRate for the CloudFront distribution.

        :param threshold: The recommended threshold value for this alarm is highly dependent on the tolerance for 5xx responses. You can analyze historical data and trends, and then set the threshold accordingly. Because 5xx errors can be caused by transient issues, we recommend that you set the threshold to a value greater than 0 so that the alarm is not too sensitive.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect problems with serving requests from the origin server, or problems with communication between CloudFront and your origin server.
        :param alarm_name: The alarm name. Default: - distributionId + ' - 5xxErrorRate'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = CloudFront5xxErrorRateAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(CloudFrontDistribution5xxErrorRateAlarm, jsii.invoke(self, "alarm5xxErrorRate", [props]))

    @jsii.member(jsii_name="alarmDetailedFunctionExecutionErrors")
    def alarm_detailed_function_execution_errors(
        self,
        props: typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]],
    ) -> typing.List[CloudFrontDistributionDetailedFunctionExecutionErrorsAlarm]:
        '''Creates a list of alarms that monitor the total number of execution errors produced by the function in a given time period.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c33396aabc047624cd98f8b6013c529bf4c220dcb7217dc70626b10c3ee4c11)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.List[CloudFrontDistributionDetailedFunctionExecutionErrorsAlarm], jsii.invoke(self, "alarmDetailedFunctionExecutionErrors", [props]))

    @jsii.member(jsii_name="alarmDetailedFunctionThrottles")
    def alarm_detailed_function_throttles(
        self,
        props: typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]]],
    ) -> typing.List[CloudFrontDistributionDetailedFunctionThrottlesAlarm]:
        '''Creates a list of alarms that monitor the total number of times that the function was throttled in a given time period.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1dc097067f51531d62193f96de11e277083f1d5757eb83a682ada405560d0ad3)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.List[CloudFrontDistributionDetailedFunctionThrottlesAlarm], jsii.invoke(self, "alarmDetailedFunctionThrottles", [props]))

    @jsii.member(jsii_name="alarmDetailedFunctionValidationErrors")
    def alarm_detailed_function_validation_errors(
        self,
        props: typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]],
    ) -> typing.List[CloudFrontDistributionDetailedFunctionValidationErrorsAlarm]:
        '''Creates a list of alarms that monitor the total number of validation errors produced by the function in a given time period.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e179d19c9fc9edc3aa0308ed1163f6e11d82ff2723a453223538d1b623d488ed)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.List[CloudFrontDistributionDetailedFunctionValidationErrorsAlarm], jsii.invoke(self, "alarmDetailedFunctionValidationErrors", [props]))

    @jsii.member(jsii_name="alarmOriginLatency")
    def alarm_origin_latency(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> CloudFrontDistributionOriginLatencyAlarm:
        '''Creates an alarm that monitors the OriginLatency for the CloudFront distribution.

        :param threshold: You should calculate the value of about 80% of the origin response timeout, and use the result as the threshold value. If this metric is consistently close to the origin response timeout value, you might start experiencing 504 errors.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect problems with the origin server taking too long to respond.
        :param alarm_name: The alarm name. Default: - distributionId + ' - OriginLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = CloudFrontOriginLatencyAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(CloudFrontDistributionOriginLatencyAlarm, jsii.invoke(self, "alarmOriginLatency", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config5xx_error_rate_alarm: typing.Union["CloudFront5xxErrorRateAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_origin_latency_alarm: typing.Union[CloudFrontOriginLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_detailed_function_execution_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_detailed_function_throttles_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        config_detailed_function_validation_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union["CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[CloudFrontRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> CloudFrontDistributionRecommendedAlarms:
        '''Creates the recommended alarms for the CloudFront Distribution.

        :param config5xx_error_rate_alarm: The configuration for the 5xxErrorRate alarm.
        :param config_origin_latency_alarm: The configuration for the OriginLatency alarm.
        :param config_detailed_function_execution_errors_alarm_list: The configuration list for the detailed FunctionExecutionErrors alarm.
        :param config_detailed_function_throttles_alarm_list: The configuration list for the detailed FunctionThrottles alarm.
        :param config_detailed_function_validation_errors_alarm_list: The configuration list for the detailed FunctionValidationErrors alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#CloudFront
        '''
        props = CloudFrontDistributionRecommendedAlarmsConfig(
            config5xx_error_rate_alarm=config5xx_error_rate_alarm,
            config_origin_latency_alarm=config_origin_latency_alarm,
            config_detailed_function_execution_errors_alarm_list=config_detailed_function_execution_errors_alarm_list,
            config_detailed_function_throttles_alarm_list=config_detailed_function_throttles_alarm_list,
            config_detailed_function_validation_errors_alarm_list=config_detailed_function_validation_errors_alarm_list,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(CloudFrontDistributionRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class DmsAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab82a99a09f2744657ff9cbcdaac21944d1f4051e326e3dace98bfc944088fda)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsAnomalyDetectionAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "std_devs": "stdDevs",
    },
)
class DmsAnomalyDetectionAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        std_devs: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The common optional configuration for anomaly detection alarms.

        Anomaly detection alarms have a fixed period of 5 minutes as required by AWS CloudWatch,
        so the period property is not configurable.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8 (standard deviation for anomaly detection)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bcabd771bbd113e05d836ed3a76a31a745756114857fd3ddf7ca987ab1cd7b5c)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument std_devs", value=std_devs, expected_type=type_hints["std_devs"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if std_devs is not None:
            self._values["std_devs"] = std_devs

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def std_devs(self) -> typing.Optional[jsii.Number]:
        '''The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean.

        :default: 8 (standard deviation for anomaly detection)
        '''
        result = self._values.get("std_devs")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsAnomalyDetectionAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsCdcLatencySourceAlarmConfig",
    jsii_struct_bases=[DmsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "comparison_operator": "comparisonOperator",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class DmsCdcLatencySourceAlarmConfig(DmsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the CdcLatencySource alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_description: The description of the alarm. Default: - This alarm monitors CDC latency from the source database. High values may indicate replication lag or source database performance issues. This can affect data freshness in real-time applications.
        :param alarm_name: The alarm name. Default: - replicationTaskIdentifier + ' - CDCLatencySource'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        :param threshold: The latency threshold in seconds. This alarm can be used to detect: - High latency indicating replication lag or source database performance issues - Potential data freshness problems affecting real-time applications Consider your application's tolerance for data lag when setting this threshold. Default: 300 (5 minutes - for detecting high latency issues)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__299d64b2beecb87b0d236387d739b17cb049b9ac0bd6eaf48971da02c32d7d59)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if comparison_operator is not None:
            self._values["comparison_operator"] = comparison_operator
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm monitors CDC latency from the source database.
        High values may indicate replication lag or source database performance issues.
        This can affect data freshness in real-time applications.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationTaskIdentifier + ' - CDCLatencySource'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator]:
        '''The comparison operator to use for the alarm.

        :default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        '''
        result = self._values.get("comparison_operator")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2 (allow for some variance while still detecting issues)
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3 (to avoid false alarms from temporary fluctuations)
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The latency threshold in seconds.

        This alarm can be used to detect:

        - High latency indicating replication lag or source database performance issues
        - Potential data freshness problems affecting real-time applications

        Consider your application's tolerance for data lag when setting this threshold.

        :default: 300 (5 minutes - for detecting high latency issues)
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsCdcLatencySourceAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsCdcLatencyTargetAlarmConfig",
    jsii_struct_bases=[DmsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "comparison_operator": "comparisonOperator",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class DmsCdcLatencyTargetAlarmConfig(DmsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the CdcLatencyTarget alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_description: The description of the alarm. Default: - This alarm monitors CDC latency to the target database. High values may indicate replication lag or target database performance issues. This can affect data consistency in downstream applications.
        :param alarm_name: The alarm name. Default: - replicationTaskIdentifier + ' - CDCLatencyTarget'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        :param threshold: The latency threshold in seconds. This alarm can be used to detect: - High latency indicating target database performance issues or replication lag - Potential data consistency problems affecting downstream applications Consider your application's tolerance for data lag when setting this threshold. Default: 300 (5 minutes - for detecting high latency issues)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__09071285f6d7363e67a937314714d0d90fd6ca94372d1671a1b25f7df3f3a4e3)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if comparison_operator is not None:
            self._values["comparison_operator"] = comparison_operator
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm monitors CDC latency to the target database.
        High values may indicate replication lag or target database performance issues.
        This can affect data consistency in downstream applications.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationTaskIdentifier + ' - CDCLatencyTarget'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator]:
        '''The comparison operator to use for the alarm.

        :default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        '''
        result = self._values.get("comparison_operator")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2 (allow for some variance while still detecting issues)
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3 (to avoid false alarms from temporary fluctuations)
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The latency threshold in seconds.

        This alarm can be used to detect:

        - High latency indicating target database performance issues or replication lag
        - Potential data consistency problems affecting downstream applications

        Consider your application's tolerance for data lag when setting this threshold.

        :default: 300 (5 minutes - for detecting high latency issues)
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsCdcLatencyTargetAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsCpuUtilizationAlarmConfig",
    jsii_struct_bases=[DmsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class DmsCpuUtilizationAlarmConfig(DmsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the CpuUtilization alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization for the DMS Replication Instance. Consistent high CPU utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The service metrics for CPU utilization might exceed 100% utilization. However, we recommend that you monitor the metric for high CPU utilization to avoid impacting other services. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df53ca11e40a0b33719484628860336ea3eb59316fbc5077a9bd1a63cb270311)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high CPU utilization for the DMS Replication
        Instance. Consistent high CPU utilization can indicate a resource bottleneck or application
        performance problems.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationInstanceIdentifier + ' - CPUUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The percentage (0-100) value against which the specified statistic is compared.

        The service metrics for CPU utilization might exceed 100% utilization. However,
        we recommend that you monitor the metric for high CPU utilization to avoid impacting
        other services.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsCpuUtilizationAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsFreeStorageSpaceAlarmConfig",
    jsii_struct_bases=[DmsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DmsFreeStorageSpaceAlarmConfig(DmsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the FreeStorageSpace alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param threshold: The amount in bytes value against which the specified statistic is compared. The threshold value will depend on the currently allocated storage space. Typically, you should calculate the value of 10 percent of the allocated storage space and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm helps prevent storage full issues. This can prevent downtime that occurs when your replication instance runs out of storage.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - FreeStorageSpace'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6900991ff0f12bb00229010fcd6d47b85195ca93f18edde326a0c875b690a298)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The amount in bytes value against which the specified statistic is compared.

        The threshold value will depend on the currently allocated storage space. Typically,
        you should calculate the value of 10 percent of the allocated storage space and use
        that result as the threshold value.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps prevent storage full issues. This can prevent downtime
        that occurs when your replication instance runs out of storage.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationInstanceIdentifier + ' - FreeStorageSpace'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsFreeStorageSpaceAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsFreeableMemoryAlarmConfig",
    jsii_struct_bases=[DmsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DmsFreeableMemoryAlarmConfig(DmsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the FreeableMemory alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param threshold: The amount in bytes against which the specified statistic is compared. Depending on the workload and instance class, different values for the threshold can be appropriate. Ideally, available memory should not go below 25% of total memory for prolonged periods.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent running out of memory.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - FreeableMemory'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b9254e191b23fed1b7b55f7882d0ba3409d3fa5f0920b7493f0e37b9a4d810d7)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The amount in bytes against which the specified statistic is compared.

        Depending on the workload and instance class, different values for the threshold
        can be appropriate. Ideally, available memory should not go below 25% of total
        memory for prolonged periods.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to help prevent running out of memory.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationInstanceIdentifier + ' - FreeableMemory'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsFreeableMemoryAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"replication_instance": "replicationInstance"},
)
class DmsReplicationInstanceAlarmProps:
    def __init__(
        self,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    ) -> None:
        '''The common properties for the DMS Replication Instance alarms.

        :param replication_instance: The DMS Replication Instance to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf02c2a755b3f26cf82dd776eea332fad151b972f9b94eeeddf2a5eeab264e4a)
            check_type(argname="argument replication_instance", value=replication_instance, expected_type=type_hints["replication_instance"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "replication_instance": replication_instance,
        }

    @builtins.property
    def replication_instance(self) -> _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance:
        '''The DMS Replication Instance to monitor.'''
        result = self._values.get("replication_instance")
        assert result is not None, "Required property 'replication_instance' is missing"
        return typing.cast(_aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationInstanceAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DmsReplicationInstanceCpuUtilizationAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceCpuUtilizationAlarm",
):
    '''This alarm is used to detect high CPU utilization for the DMS Replication Instance.

    Consistent high CPU utilization can indicate a resource bottleneck or application
    performance problems.

    The alarm is triggered when CPU utilization exceeds % threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_instance: The DMS Replication Instance to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization for the DMS Replication Instance. Consistent high CPU utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The service metrics for CPU utilization might exceed 100% utilization. However, we recommend that you monitor the metric for high CPU utilization to avoid impacting other services. Default: 90
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__743fd8efe73419c42a8dbe71f7fad61467c32befa6db45b707bed978505b2a96)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DmsReplicationInstanceCpuUtilizationAlarmProps(
            replication_instance=replication_instance,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceCpuUtilizationAlarmProps",
    jsii_struct_bases=[DmsReplicationInstanceAlarmProps, DmsCpuUtilizationAlarmConfig],
    name_mapping={
        "replication_instance": "replicationInstance",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class DmsReplicationInstanceCpuUtilizationAlarmProps(
    DmsReplicationInstanceAlarmProps,
    DmsCpuUtilizationAlarmConfig,
):
    def __init__(
        self,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DmsReplicationInstanceCpuUtilizationAlarm construct.

        :param replication_instance: The DMS Replication Instance to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization for the DMS Replication Instance. Consistent high CPU utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The service metrics for CPU utilization might exceed 100% utilization. However, we recommend that you monitor the metric for high CPU utilization to avoid impacting other services. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3d6abb9942ee60c245bffb931dce8750868c7e969ccae01c3b2f35f57741c18c)
            check_type(argname="argument replication_instance", value=replication_instance, expected_type=type_hints["replication_instance"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "replication_instance": replication_instance,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def replication_instance(self) -> _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance:
        '''The DMS Replication Instance to monitor.'''
        result = self._values.get("replication_instance")
        assert result is not None, "Required property 'replication_instance' is missing"
        return typing.cast(_aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high CPU utilization for the DMS Replication
        Instance. Consistent high CPU utilization can indicate a resource bottleneck or application
        performance problems.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationInstanceIdentifier + ' - CPUUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The percentage (0-100) value against which the specified statistic is compared.

        The service metrics for CPU utilization might exceed 100% utilization. However,
        we recommend that you monitor the metric for high CPU utilization to avoid impacting
        other services.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationInstanceCpuUtilizationAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DmsReplicationInstanceFreeStorageSpaceAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceFreeStorageSpaceAlarm",
):
    '''An alarm that monitors the amount of available storage space for a DMS Replication Instance.

    This alarm helps prevent storage full issues. This can prevent downtime that occurs when your replication
    instance runs out of storage.

    The alarm is triggered when the amount of available storage space (bytes) is less than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_instance: The DMS Replication Instance to monitor.
        :param threshold: The amount in bytes value against which the specified statistic is compared. The threshold value will depend on the currently allocated storage space. Typically, you should calculate the value of 10 percent of the allocated storage space and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm helps prevent storage full issues. This can prevent downtime that occurs when your replication instance runs out of storage.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - FreeStorageSpace'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68acb003c1fca22c0b23584e8a3960bf291894afcd0a56987a78dc7a2ba7988f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DmsReplicationInstanceFreeStorageSpaceAlarmProps(
            replication_instance=replication_instance,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceFreeStorageSpaceAlarmProps",
    jsii_struct_bases=[
        DmsReplicationInstanceAlarmProps, DmsFreeStorageSpaceAlarmConfig
    ],
    name_mapping={
        "replication_instance": "replicationInstance",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DmsReplicationInstanceFreeStorageSpaceAlarmProps(
    DmsReplicationInstanceAlarmProps,
    DmsFreeStorageSpaceAlarmConfig,
):
    def __init__(
        self,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DmsReplicationInstanceFreeStorageSpaceAlarm construct.

        :param replication_instance: The DMS Replication Instance to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param threshold: The amount in bytes value against which the specified statistic is compared. The threshold value will depend on the currently allocated storage space. Typically, you should calculate the value of 10 percent of the allocated storage space and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm helps prevent storage full issues. This can prevent downtime that occurs when your replication instance runs out of storage.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - FreeStorageSpace'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ffaa103abf140cfbfb95e89a0b72a6f6840a090c75389d2d4554f46759923315)
            check_type(argname="argument replication_instance", value=replication_instance, expected_type=type_hints["replication_instance"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "replication_instance": replication_instance,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def replication_instance(self) -> _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance:
        '''The DMS Replication Instance to monitor.'''
        result = self._values.get("replication_instance")
        assert result is not None, "Required property 'replication_instance' is missing"
        return typing.cast(_aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The amount in bytes value against which the specified statistic is compared.

        The threshold value will depend on the currently allocated storage space. Typically,
        you should calculate the value of 10 percent of the allocated storage space and use
        that result as the threshold value.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps prevent storage full issues. This can prevent downtime
        that occurs when your replication instance runs out of storage.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationInstanceIdentifier + ' - FreeStorageSpace'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationInstanceFreeStorageSpaceAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DmsReplicationInstanceFreeableMemoryAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceFreeableMemoryAlarm",
):
    '''An alarm that monitors the amount of available memory (RAM) on the replication instance.

    This alarm is used to help prevent running out of memory.

    The alarm is triggered when the percentage of available memory is less than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_instance: The DMS Replication Instance to monitor.
        :param threshold: The amount in bytes against which the specified statistic is compared. Depending on the workload and instance class, different values for the threshold can be appropriate. Ideally, available memory should not go below 25% of total memory for prolonged periods.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent running out of memory.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - FreeableMemory'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ff0aeafda7e3930a68283d39571b85830d96c56ac4f8d76b7ccd739ae73d3442)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DmsReplicationInstanceFreeableMemoryAlarmProps(
            replication_instance=replication_instance,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceFreeableMemoryAlarmProps",
    jsii_struct_bases=[DmsReplicationInstanceAlarmProps, DmsFreeableMemoryAlarmConfig],
    name_mapping={
        "replication_instance": "replicationInstance",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DmsReplicationInstanceFreeableMemoryAlarmProps(
    DmsReplicationInstanceAlarmProps,
    DmsFreeableMemoryAlarmConfig,
):
    def __init__(
        self,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DmsReplicationInstanceFreeableMemoryAlarm construct.

        :param replication_instance: The DMS Replication Instance to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param threshold: The amount in bytes against which the specified statistic is compared. Depending on the workload and instance class, different values for the threshold can be appropriate. Ideally, available memory should not go below 25% of total memory for prolonged periods.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent running out of memory.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - FreeableMemory'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__040bd7d3582121131896de98d02516ea0a71bc776b539ed619e247d6fb11b357)
            check_type(argname="argument replication_instance", value=replication_instance, expected_type=type_hints["replication_instance"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "replication_instance": replication_instance,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def replication_instance(self) -> _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance:
        '''The DMS Replication Instance to monitor.'''
        result = self._values.get("replication_instance")
        assert result is not None, "Required property 'replication_instance' is missing"
        return typing.cast(_aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The amount in bytes against which the specified statistic is compared.

        Depending on the workload and instance class, different values for the threshold
        can be appropriate. Ideally, available memory should not go below 25% of total
        memory for prolonged periods.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to help prevent running out of memory.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationInstanceIdentifier + ' - FreeableMemory'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationInstanceFreeableMemoryAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DmsReplicationInstanceRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for a DMS Replication Instance.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        config_freeable_memory_alarm: typing.Union[DmsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[DmsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[DmsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_swap_usage_alarm: typing.Optional[typing.Union["DmsSwapUsageAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_write_iops_alarm: typing.Optional[typing.Union["DmsWriteIopsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["DmsReplicationInstanceRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_instance: The DMS Replication Instance to monitor.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_swap_usage_alarm: The configuration for the SwapUsage alarm.
        :param config_write_iops_alarm: The configuration for the WriteIops alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fff739d06f4bfe93d2a25f0febaa8495e0d1604317581feda15604b1d98a87d8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DmsReplicationInstanceRecommendedAlarmsProps(
            replication_instance=replication_instance,
            config_freeable_memory_alarm=config_freeable_memory_alarm,
            config_free_storage_space_alarm=config_free_storage_space_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            config_swap_usage_alarm=config_swap_usage_alarm,
            config_write_iops_alarm=config_write_iops_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmCpuUtilization")
    def alarm_cpu_utilization(
        self,
    ) -> typing.Optional[DmsReplicationInstanceCpuUtilizationAlarm]:
        '''The CpuUtilization alarm.'''
        return typing.cast(typing.Optional[DmsReplicationInstanceCpuUtilizationAlarm], jsii.get(self, "alarmCpuUtilization"))

    @builtins.property
    @jsii.member(jsii_name="alarmFreeableMemory")
    def alarm_freeable_memory(
        self,
    ) -> typing.Optional[DmsReplicationInstanceFreeableMemoryAlarm]:
        '''The FreeableMemory alarm.'''
        return typing.cast(typing.Optional[DmsReplicationInstanceFreeableMemoryAlarm], jsii.get(self, "alarmFreeableMemory"))

    @builtins.property
    @jsii.member(jsii_name="alarmFreeStorageSpace")
    def alarm_free_storage_space(
        self,
    ) -> typing.Optional[DmsReplicationInstanceFreeStorageSpaceAlarm]:
        '''The FreeStorageSpace alarm.'''
        return typing.cast(typing.Optional[DmsReplicationInstanceFreeStorageSpaceAlarm], jsii.get(self, "alarmFreeStorageSpace"))

    @builtins.property
    @jsii.member(jsii_name="alarmSwapUsage")
    def alarm_swap_usage(
        self,
    ) -> typing.Optional["DmsReplicationInstanceSwapUsageAlarm"]:
        '''The SwapUsage alarm.'''
        return typing.cast(typing.Optional["DmsReplicationInstanceSwapUsageAlarm"], jsii.get(self, "alarmSwapUsage"))

    @builtins.property
    @jsii.member(jsii_name="alarmWriteIops")
    def alarm_write_iops(
        self,
    ) -> typing.Optional["DmsReplicationInstanceWriteIopsAlarm"]:
        '''The WriteIops alarm.'''
        return typing.cast(typing.Optional["DmsReplicationInstanceWriteIopsAlarm"], jsii.get(self, "alarmWriteIops"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class DmsReplicationInstanceRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for a DMS Replication Instance.

    :see: https://aws.amazon.com/blogs/database/setting-up-amazon-cloudwatch-alarms-for-aws-dms-resources-using-the-aws-cli/
    '''

    def __init__(
        self,
        *,
        config_freeable_memory_alarm: typing.Union[DmsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[DmsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[DmsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_swap_usage_alarm: typing.Optional[typing.Union["DmsSwapUsageAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_write_iops_alarm: typing.Optional[typing.Union["DmsWriteIopsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["DmsReplicationInstanceRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_swap_usage_alarm: The configuration for the SwapUsage alarm.
        :param config_write_iops_alarm: The configuration for the WriteIops alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DmsReplicationInstanceRecommendedAlarmsConfig(
            config_freeable_memory_alarm=config_freeable_memory_alarm,
            config_free_storage_space_alarm=config_free_storage_space_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            config_swap_usage_alarm=config_swap_usage_alarm,
            config_write_iops_alarm=config_write_iops_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9ce743fcb197ac7f7e98a9f4cb54abe9abb9cf1267f8b11d2718c74973084b8)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_freeable_memory_alarm": "configFreeableMemoryAlarm",
        "config_free_storage_space_alarm": "configFreeStorageSpaceAlarm",
        "config_cpu_utilization_alarm": "configCpuUtilizationAlarm",
        "config_swap_usage_alarm": "configSwapUsageAlarm",
        "config_write_iops_alarm": "configWriteIopsAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class DmsReplicationInstanceRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_freeable_memory_alarm: typing.Union[DmsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[DmsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[DmsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_swap_usage_alarm: typing.Optional[typing.Union["DmsSwapUsageAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_write_iops_alarm: typing.Optional[typing.Union["DmsWriteIopsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["DmsReplicationInstanceRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for a DMS Replication Instance.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_swap_usage_alarm: The configuration for the SwapUsage alarm.
        :param config_write_iops_alarm: The configuration for the WriteIops alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_freeable_memory_alarm, dict):
            config_freeable_memory_alarm = DmsFreeableMemoryAlarmConfig(**config_freeable_memory_alarm)
        if isinstance(config_free_storage_space_alarm, dict):
            config_free_storage_space_alarm = DmsFreeStorageSpaceAlarmConfig(**config_free_storage_space_alarm)
        if isinstance(config_cpu_utilization_alarm, dict):
            config_cpu_utilization_alarm = DmsCpuUtilizationAlarmConfig(**config_cpu_utilization_alarm)
        if isinstance(config_swap_usage_alarm, dict):
            config_swap_usage_alarm = DmsSwapUsageAlarmConfig(**config_swap_usage_alarm)
        if isinstance(config_write_iops_alarm, dict):
            config_write_iops_alarm = DmsWriteIopsAlarmConfig(**config_write_iops_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c8d9847b36753cb62ae1fc2a1303a3bcc1676d195fb399398e7b2ba0de09c78)
            check_type(argname="argument config_freeable_memory_alarm", value=config_freeable_memory_alarm, expected_type=type_hints["config_freeable_memory_alarm"])
            check_type(argname="argument config_free_storage_space_alarm", value=config_free_storage_space_alarm, expected_type=type_hints["config_free_storage_space_alarm"])
            check_type(argname="argument config_cpu_utilization_alarm", value=config_cpu_utilization_alarm, expected_type=type_hints["config_cpu_utilization_alarm"])
            check_type(argname="argument config_swap_usage_alarm", value=config_swap_usage_alarm, expected_type=type_hints["config_swap_usage_alarm"])
            check_type(argname="argument config_write_iops_alarm", value=config_write_iops_alarm, expected_type=type_hints["config_write_iops_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_freeable_memory_alarm": config_freeable_memory_alarm,
            "config_free_storage_space_alarm": config_free_storage_space_alarm,
        }
        if config_cpu_utilization_alarm is not None:
            self._values["config_cpu_utilization_alarm"] = config_cpu_utilization_alarm
        if config_swap_usage_alarm is not None:
            self._values["config_swap_usage_alarm"] = config_swap_usage_alarm
        if config_write_iops_alarm is not None:
            self._values["config_write_iops_alarm"] = config_write_iops_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_freeable_memory_alarm(self) -> DmsFreeableMemoryAlarmConfig:
        '''The configuration for the FreeableMemory alarm.'''
        result = self._values.get("config_freeable_memory_alarm")
        assert result is not None, "Required property 'config_freeable_memory_alarm' is missing"
        return typing.cast(DmsFreeableMemoryAlarmConfig, result)

    @builtins.property
    def config_free_storage_space_alarm(self) -> DmsFreeStorageSpaceAlarmConfig:
        '''The configuration for the FreeStorageSpace alarm.'''
        result = self._values.get("config_free_storage_space_alarm")
        assert result is not None, "Required property 'config_free_storage_space_alarm' is missing"
        return typing.cast(DmsFreeStorageSpaceAlarmConfig, result)

    @builtins.property
    def config_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[DmsCpuUtilizationAlarmConfig]:
        '''The configuration for the CpuUtilization alarm.'''
        result = self._values.get("config_cpu_utilization_alarm")
        return typing.cast(typing.Optional[DmsCpuUtilizationAlarmConfig], result)

    @builtins.property
    def config_swap_usage_alarm(self) -> typing.Optional["DmsSwapUsageAlarmConfig"]:
        '''The configuration for the SwapUsage alarm.'''
        result = self._values.get("config_swap_usage_alarm")
        return typing.cast(typing.Optional["DmsSwapUsageAlarmConfig"], result)

    @builtins.property
    def config_write_iops_alarm(self) -> typing.Optional["DmsWriteIopsAlarmConfig"]:
        '''The configuration for the WriteIops alarm.'''
        result = self._values.get("config_write_iops_alarm")
        return typing.cast(typing.Optional["DmsWriteIopsAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["DmsReplicationInstanceRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["DmsReplicationInstanceRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationInstanceRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceRecommendedAlarmsMetrics"
)
class DmsReplicationInstanceRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for DMS Replication Instance alarms.'''

    CPU_UTILIZATION = "CPU_UTILIZATION"
    '''The percentage of allocated vCPU (virtual CPU) currently in use on the instance.'''
    FREEABLE_MEMORY = "FREEABLE_MEMORY"
    '''The amount in bytes of available random access memory.'''
    FREE_STORAGE_SPACE = "FREE_STORAGE_SPACE"
    '''The amount in bytes of available storage space.'''
    WRITE_IOPS = "WRITE_IOPS"
    '''The average number of disk write I/O operations per second.'''
    SWAP_USAGE = "SWAP_USAGE"
    '''The amount in bytes of swap space used on the replication instance.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceRecommendedAlarmsProps",
    jsii_struct_bases=[DmsReplicationInstanceRecommendedAlarmsConfig],
    name_mapping={
        "config_freeable_memory_alarm": "configFreeableMemoryAlarm",
        "config_free_storage_space_alarm": "configFreeStorageSpaceAlarm",
        "config_cpu_utilization_alarm": "configCpuUtilizationAlarm",
        "config_swap_usage_alarm": "configSwapUsageAlarm",
        "config_write_iops_alarm": "configWriteIopsAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "replication_instance": "replicationInstance",
    },
)
class DmsReplicationInstanceRecommendedAlarmsProps(
    DmsReplicationInstanceRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config_freeable_memory_alarm: typing.Union[DmsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[DmsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[DmsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_swap_usage_alarm: typing.Optional[typing.Union["DmsSwapUsageAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_write_iops_alarm: typing.Optional[typing.Union["DmsWriteIopsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[DmsReplicationInstanceRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    ) -> None:
        '''Properties for the DmsReplicationInstanceRecommendedAlarms construct.

        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_swap_usage_alarm: The configuration for the SwapUsage alarm.
        :param config_write_iops_alarm: The configuration for the WriteIops alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param replication_instance: The DMS Replication Instance to monitor.
        '''
        if isinstance(config_freeable_memory_alarm, dict):
            config_freeable_memory_alarm = DmsFreeableMemoryAlarmConfig(**config_freeable_memory_alarm)
        if isinstance(config_free_storage_space_alarm, dict):
            config_free_storage_space_alarm = DmsFreeStorageSpaceAlarmConfig(**config_free_storage_space_alarm)
        if isinstance(config_cpu_utilization_alarm, dict):
            config_cpu_utilization_alarm = DmsCpuUtilizationAlarmConfig(**config_cpu_utilization_alarm)
        if isinstance(config_swap_usage_alarm, dict):
            config_swap_usage_alarm = DmsSwapUsageAlarmConfig(**config_swap_usage_alarm)
        if isinstance(config_write_iops_alarm, dict):
            config_write_iops_alarm = DmsWriteIopsAlarmConfig(**config_write_iops_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4fbb9dc5c3afae087dde4011b8914d4255e2c1b477462ba38fd49172d3b7bdcd)
            check_type(argname="argument config_freeable_memory_alarm", value=config_freeable_memory_alarm, expected_type=type_hints["config_freeable_memory_alarm"])
            check_type(argname="argument config_free_storage_space_alarm", value=config_free_storage_space_alarm, expected_type=type_hints["config_free_storage_space_alarm"])
            check_type(argname="argument config_cpu_utilization_alarm", value=config_cpu_utilization_alarm, expected_type=type_hints["config_cpu_utilization_alarm"])
            check_type(argname="argument config_swap_usage_alarm", value=config_swap_usage_alarm, expected_type=type_hints["config_swap_usage_alarm"])
            check_type(argname="argument config_write_iops_alarm", value=config_write_iops_alarm, expected_type=type_hints["config_write_iops_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument replication_instance", value=replication_instance, expected_type=type_hints["replication_instance"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_freeable_memory_alarm": config_freeable_memory_alarm,
            "config_free_storage_space_alarm": config_free_storage_space_alarm,
            "replication_instance": replication_instance,
        }
        if config_cpu_utilization_alarm is not None:
            self._values["config_cpu_utilization_alarm"] = config_cpu_utilization_alarm
        if config_swap_usage_alarm is not None:
            self._values["config_swap_usage_alarm"] = config_swap_usage_alarm
        if config_write_iops_alarm is not None:
            self._values["config_write_iops_alarm"] = config_write_iops_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_freeable_memory_alarm(self) -> DmsFreeableMemoryAlarmConfig:
        '''The configuration for the FreeableMemory alarm.'''
        result = self._values.get("config_freeable_memory_alarm")
        assert result is not None, "Required property 'config_freeable_memory_alarm' is missing"
        return typing.cast(DmsFreeableMemoryAlarmConfig, result)

    @builtins.property
    def config_free_storage_space_alarm(self) -> DmsFreeStorageSpaceAlarmConfig:
        '''The configuration for the FreeStorageSpace alarm.'''
        result = self._values.get("config_free_storage_space_alarm")
        assert result is not None, "Required property 'config_free_storage_space_alarm' is missing"
        return typing.cast(DmsFreeStorageSpaceAlarmConfig, result)

    @builtins.property
    def config_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[DmsCpuUtilizationAlarmConfig]:
        '''The configuration for the CpuUtilization alarm.'''
        result = self._values.get("config_cpu_utilization_alarm")
        return typing.cast(typing.Optional[DmsCpuUtilizationAlarmConfig], result)

    @builtins.property
    def config_swap_usage_alarm(self) -> typing.Optional["DmsSwapUsageAlarmConfig"]:
        '''The configuration for the SwapUsage alarm.'''
        result = self._values.get("config_swap_usage_alarm")
        return typing.cast(typing.Optional["DmsSwapUsageAlarmConfig"], result)

    @builtins.property
    def config_write_iops_alarm(self) -> typing.Optional["DmsWriteIopsAlarmConfig"]:
        '''The configuration for the WriteIops alarm.'''
        result = self._values.get("config_write_iops_alarm")
        return typing.cast(typing.Optional["DmsWriteIopsAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[DmsReplicationInstanceRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[DmsReplicationInstanceRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def replication_instance(self) -> _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance:
        '''The DMS Replication Instance to monitor.'''
        result = self._values.get("replication_instance")
        assert result is not None, "Required property 'replication_instance' is missing"
        return typing.cast(_aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationInstanceRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DmsReplicationInstanceSwapUsageAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.AnomalyDetectionAlarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceSwapUsageAlarm",
):
    '''This anomaly detection alarm is used to detect high swap usage for the DMS Replication Instance.

    High swap usage can indicate memory pressure, performance issues, or resource constraints.
    This alarm uses anomaly detection to identify when swap usage exceeds normal patterns,
    which can help identify performance degradation or insufficient memory allocation.

    By default, the alarm is triggered when swap usage exceeds the upper threshold
    of the anomaly detection band, detecting unusually high swap usage that may
    indicate memory pressure or performance issues.

    Note: Anomaly detection alarms use a fixed 5-minute period as required by AWS CloudWatch.
    This period cannot be customized and is optimal for anomaly detection algorithms.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        std_devs: typing.Optional[jsii.Number] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_instance: The DMS Replication Instance to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high swap usage for the DMS Replication Instance. High swap usage can indicate memory pressure or performance issues.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - SwapUsage'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_UPPER_THRESHOLD (for detecting high swap usage indicating memory pressure)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8 (standard deviation for anomaly detection)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f556e31738cca869b9f7180f7ef9a13a9f76fc27c4561fa1c649df222b711903)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DmsReplicationInstanceSwapUsageAlarmProps(
            replication_instance=replication_instance,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            std_devs=std_devs,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class DmsReplicationInstanceWriteIopsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceWriteIopsAlarm",
):
    '''This alarm is used to detect high write IOPS for the DMS Replication Instance.

    High write IOPS can indicate heavy write activity or potential I/O bottlenecks.
    This can help identify performance issues or unexpected workload patterns.

    The alarm is triggered when write IOPS exceeds the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_instance: The DMS Replication Instance to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high write IOPS for the DMS Replication Instance. High write IOPS can indicate heavy write activity or potential I/O bottlenecks.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - WriteIOPS'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The number of write I/O operations per second against which the specified statistic is compared. High write IOPS can indicate heavy write activity or potential performance bottlenecks. Consider your normal workload patterns when setting this threshold. Default: 1000
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__283f247727ed1b733e3c1a83af7ac50f14bbb8809f6537c729d4ae3df5fbccc7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DmsReplicationInstanceWriteIopsAlarmProps(
            replication_instance=replication_instance,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"replication_task": "replicationTask"},
)
class DmsReplicationTaskAlarmProps:
    def __init__(self, *, replication_task: "ReplicationTask") -> None:
        '''The common properties for the DMS Replication Task alarms.

        :param replication_task: The DMS Replication Task to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bdb67432e90d78ce4b107fb0e0f859e6fe25040f445056dd20e82e54231290e)
            check_type(argname="argument replication_task", value=replication_task, expected_type=type_hints["replication_task"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "replication_task": replication_task,
        }

    @builtins.property
    def replication_task(self) -> "ReplicationTask":
        '''The DMS Replication Task to monitor.'''
        result = self._values.get("replication_task")
        assert result is not None, "Required property 'replication_task' is missing"
        return typing.cast("ReplicationTask", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationTaskAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DmsReplicationTaskCdcLatencySourceAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskCdcLatencySourceAlarm",
):
    '''An alarm that monitors the CDC latency (in seconds) from the source database.

    This alarm monitors the gap between the last event captured from the source endpoint
    and current system time. It can help detect:

    - Replication lag indicating source database performance issues
    - Network connectivity problems affecting CDC capture
    - Source database load affecting change capture performance
    - Data freshness issues that could impact real-time applications

    The alarm is typically configured to trigger on high latency values.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        replication_task: "ReplicationTask",
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_task: The DMS Replication Task to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm monitors CDC latency from the source database. High values may indicate replication lag or source database performance issues. This can affect data freshness in real-time applications.
        :param alarm_name: The alarm name. Default: - replicationTaskIdentifier + ' - CDCLatencySource'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        :param threshold: The latency threshold in seconds. This alarm can be used to detect: - High latency indicating replication lag or source database performance issues - Potential data freshness problems affecting real-time applications Consider your application's tolerance for data lag when setting this threshold. Default: 300 (5 minutes - for detecting high latency issues)
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6a2b5b5171013395409ade0fa68f164c0e13d8305e1a7ad17d067cafc82750d2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DmsReplicationTaskCdcLatencySourceAlarmProps(
            replication_task=replication_task,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskCdcLatencySourceAlarmProps",
    jsii_struct_bases=[DmsReplicationTaskAlarmProps, DmsCdcLatencySourceAlarmConfig],
    name_mapping={
        "replication_task": "replicationTask",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "comparison_operator": "comparisonOperator",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class DmsReplicationTaskCdcLatencySourceAlarmProps(
    DmsReplicationTaskAlarmProps,
    DmsCdcLatencySourceAlarmConfig,
):
    def __init__(
        self,
        *,
        replication_task: "ReplicationTask",
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DmsReplicationTaskCdcLatencySourceAlarm construct.

        :param replication_task: The DMS Replication Task to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_description: The description of the alarm. Default: - This alarm monitors CDC latency from the source database. High values may indicate replication lag or source database performance issues. This can affect data freshness in real-time applications.
        :param alarm_name: The alarm name. Default: - replicationTaskIdentifier + ' - CDCLatencySource'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        :param threshold: The latency threshold in seconds. This alarm can be used to detect: - High latency indicating replication lag or source database performance issues - Potential data freshness problems affecting real-time applications Consider your application's tolerance for data lag when setting this threshold. Default: 300 (5 minutes - for detecting high latency issues)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0ecdae9faa8a7cad48a1ebe9a5b9aa28a5e7170faef1718c0b047e75988e547)
            check_type(argname="argument replication_task", value=replication_task, expected_type=type_hints["replication_task"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "replication_task": replication_task,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if comparison_operator is not None:
            self._values["comparison_operator"] = comparison_operator
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def replication_task(self) -> "ReplicationTask":
        '''The DMS Replication Task to monitor.'''
        result = self._values.get("replication_task")
        assert result is not None, "Required property 'replication_task' is missing"
        return typing.cast("ReplicationTask", result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm monitors CDC latency from the source database.
        High values may indicate replication lag or source database performance issues.
        This can affect data freshness in real-time applications.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationTaskIdentifier + ' - CDCLatencySource'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator]:
        '''The comparison operator to use for the alarm.

        :default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        '''
        result = self._values.get("comparison_operator")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2 (allow for some variance while still detecting issues)
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3 (to avoid false alarms from temporary fluctuations)
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The latency threshold in seconds.

        This alarm can be used to detect:

        - High latency indicating replication lag or source database performance issues
        - Potential data freshness problems affecting real-time applications

        Consider your application's tolerance for data lag when setting this threshold.

        :default: 300 (5 minutes - for detecting high latency issues)
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationTaskCdcLatencySourceAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DmsReplicationTaskCdcLatencyTargetAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskCdcLatencyTargetAlarm",
):
    '''An alarm that monitors the CDC latency (in seconds) to the target database.

    This alarm monitors the gap between a change that was committed to the source
    and the same change committed to the target. It can help detect:

    - End-to-end replication latency affecting data consistency
    - Target database performance issues affecting write operations
    - Network connectivity problems between replication instance and target
    - Data consistency issues that could impact downstream applications

    The alarm is typically configured to trigger on high latency values.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        replication_task: "ReplicationTask",
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_task: The DMS Replication Task to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm monitors CDC latency to the target database. High values may indicate replication lag or target database performance issues. This can affect data consistency in downstream applications.
        :param alarm_name: The alarm name. Default: - replicationTaskIdentifier + ' - CDCLatencyTarget'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        :param threshold: The latency threshold in seconds. This alarm can be used to detect: - High latency indicating target database performance issues or replication lag - Potential data consistency problems affecting downstream applications Consider your application's tolerance for data lag when setting this threshold. Default: 300 (5 minutes - for detecting high latency issues)
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fc88526af55eca64a4ec52eec674536df907580807e10162be48975435162b03)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DmsReplicationTaskCdcLatencyTargetAlarmProps(
            replication_task=replication_task,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskCdcLatencyTargetAlarmProps",
    jsii_struct_bases=[DmsReplicationTaskAlarmProps, DmsCdcLatencyTargetAlarmConfig],
    name_mapping={
        "replication_task": "replicationTask",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "comparison_operator": "comparisonOperator",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class DmsReplicationTaskCdcLatencyTargetAlarmProps(
    DmsReplicationTaskAlarmProps,
    DmsCdcLatencyTargetAlarmConfig,
):
    def __init__(
        self,
        *,
        replication_task: "ReplicationTask",
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DmsReplicationTaskCdcLatencyTargetAlarm construct.

        :param replication_task: The DMS Replication Task to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_description: The description of the alarm. Default: - This alarm monitors CDC latency to the target database. High values may indicate replication lag or target database performance issues. This can affect data consistency in downstream applications.
        :param alarm_name: The alarm name. Default: - replicationTaskIdentifier + ' - CDCLatencyTarget'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        :param threshold: The latency threshold in seconds. This alarm can be used to detect: - High latency indicating target database performance issues or replication lag - Potential data consistency problems affecting downstream applications Consider your application's tolerance for data lag when setting this threshold. Default: 300 (5 minutes - for detecting high latency issues)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc4513de71d2468d1499a72bc651d4afc7a32c212903700bf7dec62d00d27675)
            check_type(argname="argument replication_task", value=replication_task, expected_type=type_hints["replication_task"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "replication_task": replication_task,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if comparison_operator is not None:
            self._values["comparison_operator"] = comparison_operator
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def replication_task(self) -> "ReplicationTask":
        '''The DMS Replication Task to monitor.'''
        result = self._values.get("replication_task")
        assert result is not None, "Required property 'replication_task' is missing"
        return typing.cast("ReplicationTask", result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm monitors CDC latency to the target database.
        High values may indicate replication lag or target database performance issues.
        This can affect data consistency in downstream applications.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationTaskIdentifier + ' - CDCLatencyTarget'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator]:
        '''The comparison operator to use for the alarm.

        :default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        '''
        result = self._values.get("comparison_operator")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2 (allow for some variance while still detecting issues)
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3 (to avoid false alarms from temporary fluctuations)
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The latency threshold in seconds.

        This alarm can be used to detect:

        - High latency indicating target database performance issues or replication lag
        - Potential data consistency problems affecting downstream applications

        Consider your application's tolerance for data lag when setting this threshold.

        :default: 300 (5 minutes - for detecting high latency issues)
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationTaskCdcLatencyTargetAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskMigrationType"
)
class DmsReplicationTaskMigrationType(enum.Enum):
    '''DMS Replication Task migration types.

    These are the valid migration types for AWS DMS Replication Tasks.
    '''

    FULL_LOAD = "FULL_LOAD"
    '''Full load migration - copies all existing data from the source to the target.'''
    CDC = "CDC"
    '''Change Data Capture (CDC) migration - captures ongoing changes from the source.'''
    FULL_LOAD_AND_CDC = "FULL_LOAD_AND_CDC"
    '''Full load and CDC migration - performs initial full load then captures ongoing changes.'''


class DmsReplicationTaskRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for a DMS Replication Task.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        replication_task: "ReplicationTask",
        config_cdc_latency_source_alarm: typing.Optional[typing.Union[DmsCdcLatencySourceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_cdc_latency_target_alarm: typing.Optional[typing.Union[DmsCdcLatencyTargetAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["DmsReplicationTaskRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_task: The DMS Replication Task to monitor.
        :param config_cdc_latency_source_alarm: The configuration for the CDCLatencySource alarm.
        :param config_cdc_latency_target_alarm: The configuration for the CDCLatencyTarget alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe1ec8ca779feae8c648078782b06c677fa4e08dfba04884a75c7de812d0456f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DmsReplicationTaskRecommendedAlarmsProps(
            replication_task=replication_task,
            config_cdc_latency_source_alarm=config_cdc_latency_source_alarm,
            config_cdc_latency_target_alarm=config_cdc_latency_target_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmCdcLatencySource")
    def alarm_cdc_latency_source(
        self,
    ) -> typing.Optional[DmsReplicationTaskCdcLatencySourceAlarm]:
        '''The CDCLatencySource alarm.'''
        return typing.cast(typing.Optional[DmsReplicationTaskCdcLatencySourceAlarm], jsii.get(self, "alarmCdcLatencySource"))

    @builtins.property
    @jsii.member(jsii_name="alarmCdcLatencyTarget")
    def alarm_cdc_latency_target(
        self,
    ) -> typing.Optional[DmsReplicationTaskCdcLatencyTargetAlarm]:
        '''The CDCLatencyTarget alarm.'''
        return typing.cast(typing.Optional[DmsReplicationTaskCdcLatencyTargetAlarm], jsii.get(self, "alarmCdcLatencyTarget"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class DmsReplicationTaskRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for a DMS Replication Task.

    :see: https://aws.amazon.com/blogs/database/setting-up-amazon-cloudwatch-alarms-for-aws-dms-resources-using-the-aws-cli/
    '''

    def __init__(
        self,
        *,
        config_cdc_latency_source_alarm: typing.Optional[typing.Union[DmsCdcLatencySourceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_cdc_latency_target_alarm: typing.Optional[typing.Union[DmsCdcLatencyTargetAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["DmsReplicationTaskRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_cdc_latency_source_alarm: The configuration for the CDCLatencySource alarm.
        :param config_cdc_latency_target_alarm: The configuration for the CDCLatencyTarget alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DmsReplicationTaskRecommendedAlarmsConfig(
            config_cdc_latency_source_alarm=config_cdc_latency_source_alarm,
            config_cdc_latency_target_alarm=config_cdc_latency_target_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbd994d46afbb3a355605c829b801f1a6b0cfd6056a14b3cd62fc4ff03ae561f)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_cdc_latency_source_alarm": "configCdcLatencySourceAlarm",
        "config_cdc_latency_target_alarm": "configCdcLatencyTargetAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class DmsReplicationTaskRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_cdc_latency_source_alarm: typing.Optional[typing.Union[DmsCdcLatencySourceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_cdc_latency_target_alarm: typing.Optional[typing.Union[DmsCdcLatencyTargetAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["DmsReplicationTaskRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for a DMS Replication Task.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_cdc_latency_source_alarm: The configuration for the CDCLatencySource alarm.
        :param config_cdc_latency_target_alarm: The configuration for the CDCLatencyTarget alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_cdc_latency_source_alarm, dict):
            config_cdc_latency_source_alarm = DmsCdcLatencySourceAlarmConfig(**config_cdc_latency_source_alarm)
        if isinstance(config_cdc_latency_target_alarm, dict):
            config_cdc_latency_target_alarm = DmsCdcLatencyTargetAlarmConfig(**config_cdc_latency_target_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b73316528a16858eb2131e00f250c2fcb128466b12c32be23833d6f18e7234af)
            check_type(argname="argument config_cdc_latency_source_alarm", value=config_cdc_latency_source_alarm, expected_type=type_hints["config_cdc_latency_source_alarm"])
            check_type(argname="argument config_cdc_latency_target_alarm", value=config_cdc_latency_target_alarm, expected_type=type_hints["config_cdc_latency_target_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_cdc_latency_source_alarm is not None:
            self._values["config_cdc_latency_source_alarm"] = config_cdc_latency_source_alarm
        if config_cdc_latency_target_alarm is not None:
            self._values["config_cdc_latency_target_alarm"] = config_cdc_latency_target_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_cdc_latency_source_alarm(
        self,
    ) -> typing.Optional[DmsCdcLatencySourceAlarmConfig]:
        '''The configuration for the CDCLatencySource alarm.'''
        result = self._values.get("config_cdc_latency_source_alarm")
        return typing.cast(typing.Optional[DmsCdcLatencySourceAlarmConfig], result)

    @builtins.property
    def config_cdc_latency_target_alarm(
        self,
    ) -> typing.Optional[DmsCdcLatencyTargetAlarmConfig]:
        '''The configuration for the CDCLatencyTarget alarm.'''
        result = self._values.get("config_cdc_latency_target_alarm")
        return typing.cast(typing.Optional[DmsCdcLatencyTargetAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["DmsReplicationTaskRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["DmsReplicationTaskRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationTaskRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskRecommendedAlarmsMetrics"
)
class DmsReplicationTaskRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for DMS Replication Task alarms.'''

    CDC_LATENCY_SOURCE = "CDC_LATENCY_SOURCE"
    '''The gap, in seconds, between the last event captured from the source endpoint and current system time.'''
    CDC_LATENCY_TARGET = "CDC_LATENCY_TARGET"
    '''The gap, in seconds, between a change that was committed to the source and the same change committed to the target.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationTaskRecommendedAlarmsProps",
    jsii_struct_bases=[DmsReplicationTaskRecommendedAlarmsConfig],
    name_mapping={
        "config_cdc_latency_source_alarm": "configCdcLatencySourceAlarm",
        "config_cdc_latency_target_alarm": "configCdcLatencyTargetAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "replication_task": "replicationTask",
    },
)
class DmsReplicationTaskRecommendedAlarmsProps(
    DmsReplicationTaskRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config_cdc_latency_source_alarm: typing.Optional[typing.Union[DmsCdcLatencySourceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_cdc_latency_target_alarm: typing.Optional[typing.Union[DmsCdcLatencyTargetAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[DmsReplicationTaskRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        replication_task: "ReplicationTask",
    ) -> None:
        '''Properties for the DmsReplicationTaskRecommendedAlarms construct.

        :param config_cdc_latency_source_alarm: The configuration for the CDCLatencySource alarm.
        :param config_cdc_latency_target_alarm: The configuration for the CDCLatencyTarget alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param replication_task: The DMS Replication Task to monitor.
        '''
        if isinstance(config_cdc_latency_source_alarm, dict):
            config_cdc_latency_source_alarm = DmsCdcLatencySourceAlarmConfig(**config_cdc_latency_source_alarm)
        if isinstance(config_cdc_latency_target_alarm, dict):
            config_cdc_latency_target_alarm = DmsCdcLatencyTargetAlarmConfig(**config_cdc_latency_target_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__648ab2023b60f0d83f72c45c39ee9dadf30b970d2b27e82aef8c611ca4bf9416)
            check_type(argname="argument config_cdc_latency_source_alarm", value=config_cdc_latency_source_alarm, expected_type=type_hints["config_cdc_latency_source_alarm"])
            check_type(argname="argument config_cdc_latency_target_alarm", value=config_cdc_latency_target_alarm, expected_type=type_hints["config_cdc_latency_target_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument replication_task", value=replication_task, expected_type=type_hints["replication_task"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "replication_task": replication_task,
        }
        if config_cdc_latency_source_alarm is not None:
            self._values["config_cdc_latency_source_alarm"] = config_cdc_latency_source_alarm
        if config_cdc_latency_target_alarm is not None:
            self._values["config_cdc_latency_target_alarm"] = config_cdc_latency_target_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_cdc_latency_source_alarm(
        self,
    ) -> typing.Optional[DmsCdcLatencySourceAlarmConfig]:
        '''The configuration for the CDCLatencySource alarm.'''
        result = self._values.get("config_cdc_latency_source_alarm")
        return typing.cast(typing.Optional[DmsCdcLatencySourceAlarmConfig], result)

    @builtins.property
    def config_cdc_latency_target_alarm(
        self,
    ) -> typing.Optional[DmsCdcLatencyTargetAlarmConfig]:
        '''The configuration for the CDCLatencyTarget alarm.'''
        result = self._values.get("config_cdc_latency_target_alarm")
        return typing.cast(typing.Optional[DmsCdcLatencyTargetAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[DmsReplicationTaskRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[DmsReplicationTaskRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def replication_task(self) -> "ReplicationTask":
        '''The DMS Replication Task to monitor.'''
        result = self._values.get("replication_task")
        assert result is not None, "Required property 'replication_task' is missing"
        return typing.cast("ReplicationTask", result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationTaskRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsSwapUsageAlarmConfig",
    jsii_struct_bases=[DmsAnomalyDetectionAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "std_devs": "stdDevs",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "comparison_operator": "comparisonOperator",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DmsSwapUsageAlarmConfig(DmsAnomalyDetectionAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        std_devs: typing.Optional[jsii.Number] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the SwapUsage alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8 (standard deviation for anomaly detection)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high swap usage for the DMS Replication Instance. High swap usage can indicate memory pressure or performance issues.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - SwapUsage'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_UPPER_THRESHOLD (for detecting high swap usage indicating memory pressure)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__24080eab2fb25483db7d2f588f068c7c996887cd511fc4c41d9babbed7007499)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument std_devs", value=std_devs, expected_type=type_hints["std_devs"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if std_devs is not None:
            self._values["std_devs"] = std_devs
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if comparison_operator is not None:
            self._values["comparison_operator"] = comparison_operator
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def std_devs(self) -> typing.Optional[jsii.Number]:
        '''The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean.

        :default: 8 (standard deviation for anomaly detection)
        '''
        result = self._values.get("std_devs")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high swap usage for the DMS Replication Instance.
        High swap usage can indicate memory pressure or performance issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationInstanceIdentifier + ' - SwapUsage'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator]:
        '''The comparison operator to use for the alarm.

        :default: GREATER_THAN_UPPER_THRESHOLD (for detecting high swap usage indicating memory pressure)
        '''
        result = self._values.get("comparison_operator")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2 (allow for some variance while still detecting issues)
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3 (to avoid false alarms from temporary fluctuations)
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsSwapUsageAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsWriteIopsAlarmConfig",
    jsii_struct_bases=[DmsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class DmsWriteIopsAlarmConfig(DmsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the WriteIops alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high write IOPS for the DMS Replication Instance. High write IOPS can indicate heavy write activity or potential I/O bottlenecks.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - WriteIOPS'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The number of write I/O operations per second against which the specified statistic is compared. High write IOPS can indicate heavy write activity or potential performance bottlenecks. Consider your normal workload patterns when setting this threshold. Default: 1000
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__04ac7f5fbad9b4bb4a90fe8fb96b8465fbe97a95b899d1ff314ca79dbcac639f)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high write IOPS for the DMS Replication
        Instance. High write IOPS can indicate heavy write activity or potential I/O bottlenecks.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationInstanceIdentifier + ' - WriteIOPS'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The number of write I/O operations per second against which the specified statistic is compared.

        High write IOPS can indicate heavy write activity or potential performance bottlenecks.
        Consider your normal workload patterns when setting this threshold.

        :default: 1000
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsWriteIopsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class DynamoDbAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6ecc309d5ec4a50b2d939acd5d395ccb636e2fe8086508598d622ecc196b5682)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbFailedToReplicateRecordCountAlarmConfig",
    jsii_struct_bases=[DynamoDbAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class DynamoDbFailedToReplicateRecordCountAlarmConfig(DynamoDbAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the FailedToReplicateRecordCount alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor the number of records that DynamoDB failed to replicate to your Kinesis data stream because of the item size limit of Kinesis Data Streams.
        :param alarm_name: The alarm name. Default: - tableName + ' - FailedToReplicateRecordCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 1
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 1
        :param threshold: Set the threshold to 0 to detect any records that DynamoDB failed to replicate.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d575f0f8b362375ef77db3876f4a9147ebdd6e7093435d425ec43ae2c5d5c762)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can monitor the number of records that DynamoDB failed to replicate to
        your Kinesis data stream because of the item size limit of Kinesis Data Streams.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - FailedToReplicateRecordCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 1
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 1
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''Set the threshold to 0 to detect any records that DynamoDB failed to replicate.'''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbFailedToReplicateRecordCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbReadThrottleEventsAlarmConfig",
    jsii_struct_bases=[DynamoDbAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DynamoDbReadThrottleEventsAlarmConfig(DynamoDbAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the ReadThrottleEvents alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to the expected read traffic for the DynamoDB table, accounting for an acceptable level of throttling. It is important to monitor whether you are under provisioned and not causing consistent throttling. You can also analyze historical data to find the acceptable throttling level for the application workload, and then tune the threshold to be higher than your usual throttling level. Throttled requests should be retried by the application or service as they are transient. Therefore, a very low threshold may cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained throttling for read requests to the DynamoDB table. Sustained throttling of read requests can negatively impact your workload read operations and reduce the overall efficiency of the system.
        :param alarm_name: The alarm name. Default: - tableName + ' - ReadThrottleEvents'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b5cd40eb7d166aed2672354f28a2ba9387c0df40fafdceb000d5ad038099cbf5)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to the expected read traffic for the DynamoDB table, accounting for an acceptable level of throttling.

        It is important to monitor whether
        you are under provisioned and not causing consistent throttling. You can also analyze
        historical data to find the acceptable throttling level for the application workload,
        and then tune the threshold to be higher than your usual throttling level. Throttled
        requests should be retried by the application or service as they are transient. Therefore,
        a very low threshold may cause the alarm to be too sensitive, causing unwanted state transitions.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect sustained throttling for read requests to the DynamoDB table.
        Sustained throttling of read requests can negatively impact your workload read operations and
        reduce the overall efficiency of the system.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - ReadThrottleEvents'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbReadThrottleEventsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class DynamoDbRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an DynamoDb Table.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#DynamoDB
    '''

    def __init__(
        self,
        *,
        config_read_throttle_events_alarm: typing.Union[DynamoDbReadThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_system_errors_alarm: typing.Union["DynamoDbSystemErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_write_throttle_events_alarm: typing.Union["DynamoDbWriteThrottleEventsAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_age_of_oldest_unreplicated_record_alarm: typing.Optional[typing.Union["DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_failed_to_replicate_record_count_alarm: typing.Optional[typing.Union[DynamoDbFailedToReplicateRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_throttled_put_record_count_alarm: typing.Optional[typing.Union["DynamoDbThrottledPutRecordCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["DynamoDbRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_read_throttle_events_alarm: The configuration for the ReadThrottleEvents alarm.
        :param config_system_errors_alarm: The configuration for the SystemErrors alarm.
        :param config_write_throttle_events_alarm: The configuration for the WriteThrottleEvents alarm.
        :param config_age_of_oldest_unreplicated_record_alarm: The configuration for the AgeOfOldestUnreplicatedRecord alarm.
        :param config_failed_to_replicate_record_count_alarm: The configuration for the FailedToReplicateRecordCount alarm.
        :param config_throttled_put_record_count_alarm: The configuration for the ThrottledPutRecordCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DynamoDbTableRecommendedAlarmsConfig(
            config_read_throttle_events_alarm=config_read_throttle_events_alarm,
            config_system_errors_alarm=config_system_errors_alarm,
            config_write_throttle_events_alarm=config_write_throttle_events_alarm,
            config_age_of_oldest_unreplicated_record_alarm=config_age_of_oldest_unreplicated_record_alarm,
            config_failed_to_replicate_record_count_alarm=config_failed_to_replicate_record_count_alarm,
            config_throttled_put_record_count_alarm=config_throttled_put_record_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5f509f6b48878180ae21ef81ef72d674d0f315fd55d5a5eed2c1e6abaf0a708a)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbRecommendedAlarmsMetrics"
)
class DynamoDbRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for DynamoDb alarms.'''

    READ_THROTTLE_EVENTS = "READ_THROTTLE_EVENTS"
    '''Requests to DynamoDB that exceed the provisioned read capacity units for a table or a global secondary index.'''
    SYSTEM_ERRORS = "SYSTEM_ERRORS"
    '''The requests to DynamoDB or Amazon DynamoDB Streams that generate an HTTP 500 status code during the specified time period.

    An HTTP 500 usually indicates an internal service error.
    '''
    WRITE_THROTTLE_EVENTS = "WRITE_THROTTLE_EVENTS"
    '''Requests to DynamoDB that exceed the provisioned write capacity units for a table or a global secondary index.'''
    AGE_OF_OLDEST_UNREPLICATED_RECORD = "AGE_OF_OLDEST_UNREPLICATED_RECORD"
    '''The elapsed time since a record yet to be replicated to the Kinesis data stream first appeared in the DynamoDB table.'''
    FAILED_TO_REPLICATE_RECORD_COUNT = "FAILED_TO_REPLICATE_RECORD_COUNT"
    '''The number of records that DynamoDB failed to replicate to your Kinesis data stream.'''
    THROTTLED_PUT_RECORD_COUNT = "THROTTLED_PUT_RECORD_COUNT"
    '''The number of records that were throttled by your Kinesis data stream due to insufficient Kinesis Data Streams capacity.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbSystemErrorsAlarmConfig",
    jsii_struct_bases=[DynamoDbAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DynamoDbSystemErrorsAlarmConfig(DynamoDbAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the SystemErrors alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to the expected traffic, accounting for an acceptable level of system errors. You can also analyze historical data to find the acceptable error count for the application workload, and then tune the threshold accordingly. System errors should be retried by the application/service as they are transient. Therefore, a very low threshold might cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained system errors for the DynamoDB table requests. System errors indicate internal service errors from DynamoDB and helps correlate to the issue that the client is having.
        :param alarm_name: The alarm name. Default: - tableName + ' - SystemErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a2502c59346b6d388d4cb60df46167a128968ce86e235a1b79ba0e1fecc783a5)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to the expected traffic, accounting for an acceptable level of system errors.

        You can also analyze historical data to find the acceptable error count for the application workload, and
        then tune the threshold accordingly. System errors should be retried by the application/service as they are
        transient. Therefore, a very low threshold might cause the alarm to be too sensitive, causing unwanted state
        transitions.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect sustained system errors for the DynamoDB table requests. System errors
        indicate internal service errors from DynamoDB and helps correlate to the issue that the client is having.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - SystemErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbSystemErrorsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoDbTableAgeOfOldestUnreplicatedRecordAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableAgeOfOldestUnreplicatedRecordAlarm",
):
    '''This alarm detects the delay in replication to a Kinesis data stream.

    Under normal operation, ``AgeOfOldestUnreplicatedRecord`` should be only milliseconds.
    This number grows based on unsuccessful replication attempts caused by customer-controlled
    configuration choices. Customer-controlled configuration examples that lead to unsuccessful
    replication attempts are an under-provisioned Kinesis data stream capacity that leads to
    excessive throttling. or a manual update to the Kinesis data stream's access policies that
    prevents DynamoDB from adding data to the data stream. To keep this metric as low as possible,
    you need to ensure the right provisioning of Kinesis data stream capacity and make sure that
    DynamoDB's permissions are unchanged.

    The alarm is triggered when the elapsed time since a record yet to be replicated exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param table: The DynamoDb Table to monitor.
        :param threshold: Set the threshold according to the desired replication delay measured in milliseconds. This value depends on your workload's requirements and expected performance.
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor unsuccessful replication attempts and the resulting delay in replication to the Kinesis data stream.
        :param alarm_name: The alarm name. Default: - tableName + ' - AgeOfOldestUnreplicatedRecord'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__324bd24124223ff19ee75a06edc28b1aaf8470beefddab3c63ad669a7b8146b8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoDbTableAgeOfOldestUnreplicatedRecordAlarmProps(
            table=table,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"table": "table"},
)
class DynamoDbTableAlarmProps:
    def __init__(self, *, table: _aws_cdk_aws_dynamodb_ceddda9d.Table) -> None:
        '''The common properties for the DynamoDb Table alarms.

        :param table: The DynamoDb Table to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef9350e286af026856679ce0bddb7a3b3609cec27a15904bf30ab36d4f74e215)
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "table": table,
        }

    @builtins.property
    def table(self) -> _aws_cdk_aws_dynamodb_ceddda9d.Table:
        '''The DynamoDb Table to monitor.'''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_aws_cdk_aws_dynamodb_ceddda9d.Table, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbTableAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoDbTableFailedToReplicateRecordCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableFailedToReplicateRecordCountAlarm",
):
    '''This alarm detects the number of records that DynamoDB failed to replicate to your Kinesis data stream.

    Certain items larger than 34 KB might expand in size to change data records that are larger than the 1 MB
    item size limit of Kinesis Data Streams. This size expansion occurs when these larger than 34 KB items include
    a large number of Boolean or empty attribute values. Boolean and empty attribute values are stored as 1 byte
    in DynamoDB, but expand up to 5 bytes when they're serialized using standard JSON for Kinesis Data Streams
    replication. DynamoDB can't replicate such change records to your Kinesis data stream. DynamoDB skips these
    change data records, and automatically continues replicating subsequent records.

    The alarm is triggered when the the number of records failed to be replicated exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param table: The DynamoDb Table to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor the number of records that DynamoDB failed to replicate to your Kinesis data stream because of the item size limit of Kinesis Data Streams.
        :param alarm_name: The alarm name. Default: - tableName + ' - FailedToReplicateRecordCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 1
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 1
        :param threshold: Set the threshold to 0 to detect any records that DynamoDB failed to replicate.
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a25619b84d7d4b455842b1325cefdaef4deb87b46acb2c73fb3d88d84978d1b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoDbTableFailedToReplicateRecordCountAlarmProps(
            table=table,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableFailedToReplicateRecordCountAlarmProps",
    jsii_struct_bases=[
        DynamoDbTableAlarmProps, DynamoDbFailedToReplicateRecordCountAlarmConfig
    ],
    name_mapping={
        "table": "table",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class DynamoDbTableFailedToReplicateRecordCountAlarmProps(
    DynamoDbTableAlarmProps,
    DynamoDbFailedToReplicateRecordCountAlarmConfig,
):
    def __init__(
        self,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DynamoDbTableFailedToReplicateRecordCountAlarm construct.

        :param table: The DynamoDb Table to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor the number of records that DynamoDB failed to replicate to your Kinesis data stream because of the item size limit of Kinesis Data Streams.
        :param alarm_name: The alarm name. Default: - tableName + ' - FailedToReplicateRecordCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 1
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 1
        :param threshold: Set the threshold to 0 to detect any records that DynamoDB failed to replicate.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5e0a90952505978f8d9108fa3ae493dbcfa58be7c5834bf1503856a27c069363)
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "table": table,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def table(self) -> _aws_cdk_aws_dynamodb_ceddda9d.Table:
        '''The DynamoDb Table to monitor.'''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_aws_cdk_aws_dynamodb_ceddda9d.Table, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can monitor the number of records that DynamoDB failed to replicate to
        your Kinesis data stream because of the item size limit of Kinesis Data Streams.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - FailedToReplicateRecordCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 1
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 1
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''Set the threshold to 0 to detect any records that DynamoDB failed to replicate.'''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbTableFailedToReplicateRecordCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoDbTableReadThrottleEventsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableReadThrottleEventsAlarm",
):
    '''This alarm detects if there are high number of read requests getting throttled for the DynamoDB table.

    To troubleshoot the issue, see {@link https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TroubleshootingThrottling.html Troubleshooting throttling issues in Amazon DynamoDB}.

    The alarm is triggered when the number of read requests exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param table: The DynamoDb Table to monitor.
        :param threshold: Set the threshold according to the expected read traffic for the DynamoDB table, accounting for an acceptable level of throttling. It is important to monitor whether you are under provisioned and not causing consistent throttling. You can also analyze historical data to find the acceptable throttling level for the application workload, and then tune the threshold to be higher than your usual throttling level. Throttled requests should be retried by the application or service as they are transient. Therefore, a very low threshold may cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained throttling for read requests to the DynamoDB table. Sustained throttling of read requests can negatively impact your workload read operations and reduce the overall efficiency of the system.
        :param alarm_name: The alarm name. Default: - tableName + ' - ReadThrottleEvents'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__291ab83e5656eb5fc18eb3ff1fdb981eff5fb569f4e2692feb74452860897fc9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoDbTableReadThrottleEventsAlarmProps(
            table=table,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableReadThrottleEventsAlarmProps",
    jsii_struct_bases=[DynamoDbTableAlarmProps, DynamoDbReadThrottleEventsAlarmConfig],
    name_mapping={
        "table": "table",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DynamoDbTableReadThrottleEventsAlarmProps(
    DynamoDbTableAlarmProps,
    DynamoDbReadThrottleEventsAlarmConfig,
):
    def __init__(
        self,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DynamoDbTableReadThrottleEventsAlarm construct.

        :param table: The DynamoDb Table to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to the expected read traffic for the DynamoDB table, accounting for an acceptable level of throttling. It is important to monitor whether you are under provisioned and not causing consistent throttling. You can also analyze historical data to find the acceptable throttling level for the application workload, and then tune the threshold to be higher than your usual throttling level. Throttled requests should be retried by the application or service as they are transient. Therefore, a very low threshold may cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained throttling for read requests to the DynamoDB table. Sustained throttling of read requests can negatively impact your workload read operations and reduce the overall efficiency of the system.
        :param alarm_name: The alarm name. Default: - tableName + ' - ReadThrottleEvents'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f808f08fbccfed9fbbe711b84a6ea4fe24b0b8cd12997e77b0682ba882e63a5c)
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "table": table,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def table(self) -> _aws_cdk_aws_dynamodb_ceddda9d.Table:
        '''The DynamoDb Table to monitor.'''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_aws_cdk_aws_dynamodb_ceddda9d.Table, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to the expected read traffic for the DynamoDB table, accounting for an acceptable level of throttling.

        It is important to monitor whether
        you are under provisioned and not causing consistent throttling. You can also analyze
        historical data to find the acceptable throttling level for the application workload,
        and then tune the threshold to be higher than your usual throttling level. Throttled
        requests should be retried by the application or service as they are transient. Therefore,
        a very low threshold may cause the alarm to be too sensitive, causing unwanted state transitions.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect sustained throttling for read requests to the DynamoDB table.
        Sustained throttling of read requests can negatively impact your workload read operations and
        reduce the overall efficiency of the system.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - ReadThrottleEvents'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbTableReadThrottleEventsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoDbTableRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an DynamoDb Table.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#DynamoDB
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        config_read_throttle_events_alarm: typing.Union[DynamoDbReadThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_system_errors_alarm: typing.Union[DynamoDbSystemErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_write_throttle_events_alarm: typing.Union["DynamoDbWriteThrottleEventsAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_age_of_oldest_unreplicated_record_alarm: typing.Optional[typing.Union["DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_failed_to_replicate_record_count_alarm: typing.Optional[typing.Union[DynamoDbFailedToReplicateRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_throttled_put_record_count_alarm: typing.Optional[typing.Union["DynamoDbThrottledPutRecordCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[DynamoDbRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param table: The DynamoDb Table to monitor.
        :param config_read_throttle_events_alarm: The configuration for the ReadThrottleEvents alarm.
        :param config_system_errors_alarm: The configuration for the SystemErrors alarm.
        :param config_write_throttle_events_alarm: The configuration for the WriteThrottleEvents alarm.
        :param config_age_of_oldest_unreplicated_record_alarm: The configuration for the AgeOfOldestUnreplicatedRecord alarm.
        :param config_failed_to_replicate_record_count_alarm: The configuration for the FailedToReplicateRecordCount alarm.
        :param config_throttled_put_record_count_alarm: The configuration for the ThrottledPutRecordCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbdb2f512e7c99fb8f08f57dc7d53e124c7e79bdc207305d0ea870678b91cbad)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoDbTableRecommendedAlarmsProps(
            table=table,
            config_read_throttle_events_alarm=config_read_throttle_events_alarm,
            config_system_errors_alarm=config_system_errors_alarm,
            config_write_throttle_events_alarm=config_write_throttle_events_alarm,
            config_age_of_oldest_unreplicated_record_alarm=config_age_of_oldest_unreplicated_record_alarm,
            config_failed_to_replicate_record_count_alarm=config_failed_to_replicate_record_count_alarm,
            config_throttled_put_record_count_alarm=config_throttled_put_record_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmAgeOfOldestUnreplicatedRecord")
    def alarm_age_of_oldest_unreplicated_record(
        self,
    ) -> typing.Optional[DynamoDbTableAgeOfOldestUnreplicatedRecordAlarm]:
        '''The AgeOfOldestUnreplicatedRecord alarm.'''
        return typing.cast(typing.Optional[DynamoDbTableAgeOfOldestUnreplicatedRecordAlarm], jsii.get(self, "alarmAgeOfOldestUnreplicatedRecord"))

    @builtins.property
    @jsii.member(jsii_name="alarmFailedToReplicateRecordCount")
    def alarm_failed_to_replicate_record_count(
        self,
    ) -> typing.Optional[DynamoDbTableFailedToReplicateRecordCountAlarm]:
        '''The FailedToReplicateRecordCount alarm.'''
        return typing.cast(typing.Optional[DynamoDbTableFailedToReplicateRecordCountAlarm], jsii.get(self, "alarmFailedToReplicateRecordCount"))

    @builtins.property
    @jsii.member(jsii_name="alarmReadThrottleEvents")
    def alarm_read_throttle_events(
        self,
    ) -> typing.Optional[DynamoDbTableReadThrottleEventsAlarm]:
        '''The ReadThrottleEvents alarm.'''
        return typing.cast(typing.Optional[DynamoDbTableReadThrottleEventsAlarm], jsii.get(self, "alarmReadThrottleEvents"))

    @builtins.property
    @jsii.member(jsii_name="alarmSystemErrors")
    def alarm_system_errors(self) -> typing.Optional["DynamoDbTableSystemErrorsAlarm"]:
        '''The SystemErrors alarm.'''
        return typing.cast(typing.Optional["DynamoDbTableSystemErrorsAlarm"], jsii.get(self, "alarmSystemErrors"))

    @builtins.property
    @jsii.member(jsii_name="alarmThrottledPutRecordCount")
    def alarm_throttled_put_record_count(
        self,
    ) -> typing.Optional["DynamoDbTableThrottledPutRecordCountAlarm"]:
        '''The ThrottledPutRecordCount alarm.'''
        return typing.cast(typing.Optional["DynamoDbTableThrottledPutRecordCountAlarm"], jsii.get(self, "alarmThrottledPutRecordCount"))

    @builtins.property
    @jsii.member(jsii_name="alarmWriteThrottleEvents")
    def alarm_write_throttle_events(
        self,
    ) -> typing.Optional["DynamoDbTableWriteThrottleEventsAlarm"]:
        '''The WriteThrottleEvents alarm.'''
        return typing.cast(typing.Optional["DynamoDbTableWriteThrottleEventsAlarm"], jsii.get(self, "alarmWriteThrottleEvents"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_read_throttle_events_alarm": "configReadThrottleEventsAlarm",
        "config_system_errors_alarm": "configSystemErrorsAlarm",
        "config_write_throttle_events_alarm": "configWriteThrottleEventsAlarm",
        "config_age_of_oldest_unreplicated_record_alarm": "configAgeOfOldestUnreplicatedRecordAlarm",
        "config_failed_to_replicate_record_count_alarm": "configFailedToReplicateRecordCountAlarm",
        "config_throttled_put_record_count_alarm": "configThrottledPutRecordCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class DynamoDbTableRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_read_throttle_events_alarm: typing.Union[DynamoDbReadThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_system_errors_alarm: typing.Union[DynamoDbSystemErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_write_throttle_events_alarm: typing.Union["DynamoDbWriteThrottleEventsAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_age_of_oldest_unreplicated_record_alarm: typing.Optional[typing.Union["DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_failed_to_replicate_record_count_alarm: typing.Optional[typing.Union[DynamoDbFailedToReplicateRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_throttled_put_record_count_alarm: typing.Optional[typing.Union["DynamoDbThrottledPutRecordCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[DynamoDbRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an DynamoDb Service.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_read_throttle_events_alarm: The configuration for the ReadThrottleEvents alarm.
        :param config_system_errors_alarm: The configuration for the SystemErrors alarm.
        :param config_write_throttle_events_alarm: The configuration for the WriteThrottleEvents alarm.
        :param config_age_of_oldest_unreplicated_record_alarm: The configuration for the AgeOfOldestUnreplicatedRecord alarm.
        :param config_failed_to_replicate_record_count_alarm: The configuration for the FailedToReplicateRecordCount alarm.
        :param config_throttled_put_record_count_alarm: The configuration for the ThrottledPutRecordCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_read_throttle_events_alarm, dict):
            config_read_throttle_events_alarm = DynamoDbReadThrottleEventsAlarmConfig(**config_read_throttle_events_alarm)
        if isinstance(config_system_errors_alarm, dict):
            config_system_errors_alarm = DynamoDbSystemErrorsAlarmConfig(**config_system_errors_alarm)
        if isinstance(config_write_throttle_events_alarm, dict):
            config_write_throttle_events_alarm = DynamoDbWriteThrottleEventsAlarmConfig(**config_write_throttle_events_alarm)
        if isinstance(config_age_of_oldest_unreplicated_record_alarm, dict):
            config_age_of_oldest_unreplicated_record_alarm = DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig(**config_age_of_oldest_unreplicated_record_alarm)
        if isinstance(config_failed_to_replicate_record_count_alarm, dict):
            config_failed_to_replicate_record_count_alarm = DynamoDbFailedToReplicateRecordCountAlarmConfig(**config_failed_to_replicate_record_count_alarm)
        if isinstance(config_throttled_put_record_count_alarm, dict):
            config_throttled_put_record_count_alarm = DynamoDbThrottledPutRecordCountAlarmConfig(**config_throttled_put_record_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__35747c8203fdd27d31c00ee6e1505bc8142f48c425fe19ca5a4ccf4146c124d9)
            check_type(argname="argument config_read_throttle_events_alarm", value=config_read_throttle_events_alarm, expected_type=type_hints["config_read_throttle_events_alarm"])
            check_type(argname="argument config_system_errors_alarm", value=config_system_errors_alarm, expected_type=type_hints["config_system_errors_alarm"])
            check_type(argname="argument config_write_throttle_events_alarm", value=config_write_throttle_events_alarm, expected_type=type_hints["config_write_throttle_events_alarm"])
            check_type(argname="argument config_age_of_oldest_unreplicated_record_alarm", value=config_age_of_oldest_unreplicated_record_alarm, expected_type=type_hints["config_age_of_oldest_unreplicated_record_alarm"])
            check_type(argname="argument config_failed_to_replicate_record_count_alarm", value=config_failed_to_replicate_record_count_alarm, expected_type=type_hints["config_failed_to_replicate_record_count_alarm"])
            check_type(argname="argument config_throttled_put_record_count_alarm", value=config_throttled_put_record_count_alarm, expected_type=type_hints["config_throttled_put_record_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_read_throttle_events_alarm": config_read_throttle_events_alarm,
            "config_system_errors_alarm": config_system_errors_alarm,
            "config_write_throttle_events_alarm": config_write_throttle_events_alarm,
        }
        if config_age_of_oldest_unreplicated_record_alarm is not None:
            self._values["config_age_of_oldest_unreplicated_record_alarm"] = config_age_of_oldest_unreplicated_record_alarm
        if config_failed_to_replicate_record_count_alarm is not None:
            self._values["config_failed_to_replicate_record_count_alarm"] = config_failed_to_replicate_record_count_alarm
        if config_throttled_put_record_count_alarm is not None:
            self._values["config_throttled_put_record_count_alarm"] = config_throttled_put_record_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_read_throttle_events_alarm(
        self,
    ) -> DynamoDbReadThrottleEventsAlarmConfig:
        '''The configuration for the ReadThrottleEvents alarm.'''
        result = self._values.get("config_read_throttle_events_alarm")
        assert result is not None, "Required property 'config_read_throttle_events_alarm' is missing"
        return typing.cast(DynamoDbReadThrottleEventsAlarmConfig, result)

    @builtins.property
    def config_system_errors_alarm(self) -> DynamoDbSystemErrorsAlarmConfig:
        '''The configuration for the SystemErrors alarm.'''
        result = self._values.get("config_system_errors_alarm")
        assert result is not None, "Required property 'config_system_errors_alarm' is missing"
        return typing.cast(DynamoDbSystemErrorsAlarmConfig, result)

    @builtins.property
    def config_write_throttle_events_alarm(
        self,
    ) -> "DynamoDbWriteThrottleEventsAlarmConfig":
        '''The configuration for the WriteThrottleEvents alarm.'''
        result = self._values.get("config_write_throttle_events_alarm")
        assert result is not None, "Required property 'config_write_throttle_events_alarm' is missing"
        return typing.cast("DynamoDbWriteThrottleEventsAlarmConfig", result)

    @builtins.property
    def config_age_of_oldest_unreplicated_record_alarm(
        self,
    ) -> typing.Optional["DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig"]:
        '''The configuration for the AgeOfOldestUnreplicatedRecord alarm.'''
        result = self._values.get("config_age_of_oldest_unreplicated_record_alarm")
        return typing.cast(typing.Optional["DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig"], result)

    @builtins.property
    def config_failed_to_replicate_record_count_alarm(
        self,
    ) -> typing.Optional[DynamoDbFailedToReplicateRecordCountAlarmConfig]:
        '''The configuration for the FailedToReplicateRecordCount alarm.'''
        result = self._values.get("config_failed_to_replicate_record_count_alarm")
        return typing.cast(typing.Optional[DynamoDbFailedToReplicateRecordCountAlarmConfig], result)

    @builtins.property
    def config_throttled_put_record_count_alarm(
        self,
    ) -> typing.Optional["DynamoDbThrottledPutRecordCountAlarmConfig"]:
        '''The configuration for the ThrottledPutRecordCount alarm.'''
        result = self._values.get("config_throttled_put_record_count_alarm")
        return typing.cast(typing.Optional["DynamoDbThrottledPutRecordCountAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[DynamoDbRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[DynamoDbRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbTableRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableRecommendedAlarmsProps",
    jsii_struct_bases=[DynamoDbTableRecommendedAlarmsConfig],
    name_mapping={
        "config_read_throttle_events_alarm": "configReadThrottleEventsAlarm",
        "config_system_errors_alarm": "configSystemErrorsAlarm",
        "config_write_throttle_events_alarm": "configWriteThrottleEventsAlarm",
        "config_age_of_oldest_unreplicated_record_alarm": "configAgeOfOldestUnreplicatedRecordAlarm",
        "config_failed_to_replicate_record_count_alarm": "configFailedToReplicateRecordCountAlarm",
        "config_throttled_put_record_count_alarm": "configThrottledPutRecordCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "table": "table",
    },
)
class DynamoDbTableRecommendedAlarmsProps(DynamoDbTableRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config_read_throttle_events_alarm: typing.Union[DynamoDbReadThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_system_errors_alarm: typing.Union[DynamoDbSystemErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_write_throttle_events_alarm: typing.Union["DynamoDbWriteThrottleEventsAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_age_of_oldest_unreplicated_record_alarm: typing.Optional[typing.Union["DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_failed_to_replicate_record_count_alarm: typing.Optional[typing.Union[DynamoDbFailedToReplicateRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_throttled_put_record_count_alarm: typing.Optional[typing.Union["DynamoDbThrottledPutRecordCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[DynamoDbRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    ) -> None:
        '''Properties for the DynamoDbTableRecommendedAlarms construct.

        :param config_read_throttle_events_alarm: The configuration for the ReadThrottleEvents alarm.
        :param config_system_errors_alarm: The configuration for the SystemErrors alarm.
        :param config_write_throttle_events_alarm: The configuration for the WriteThrottleEvents alarm.
        :param config_age_of_oldest_unreplicated_record_alarm: The configuration for the AgeOfOldestUnreplicatedRecord alarm.
        :param config_failed_to_replicate_record_count_alarm: The configuration for the FailedToReplicateRecordCount alarm.
        :param config_throttled_put_record_count_alarm: The configuration for the ThrottledPutRecordCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param table: The DynamoDb Table to monitor.
        '''
        if isinstance(config_read_throttle_events_alarm, dict):
            config_read_throttle_events_alarm = DynamoDbReadThrottleEventsAlarmConfig(**config_read_throttle_events_alarm)
        if isinstance(config_system_errors_alarm, dict):
            config_system_errors_alarm = DynamoDbSystemErrorsAlarmConfig(**config_system_errors_alarm)
        if isinstance(config_write_throttle_events_alarm, dict):
            config_write_throttle_events_alarm = DynamoDbWriteThrottleEventsAlarmConfig(**config_write_throttle_events_alarm)
        if isinstance(config_age_of_oldest_unreplicated_record_alarm, dict):
            config_age_of_oldest_unreplicated_record_alarm = DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig(**config_age_of_oldest_unreplicated_record_alarm)
        if isinstance(config_failed_to_replicate_record_count_alarm, dict):
            config_failed_to_replicate_record_count_alarm = DynamoDbFailedToReplicateRecordCountAlarmConfig(**config_failed_to_replicate_record_count_alarm)
        if isinstance(config_throttled_put_record_count_alarm, dict):
            config_throttled_put_record_count_alarm = DynamoDbThrottledPutRecordCountAlarmConfig(**config_throttled_put_record_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7ffd2cd3e384b02323fc23eb8159d35a37f55c38040e5610ba1e04be2f6570b)
            check_type(argname="argument config_read_throttle_events_alarm", value=config_read_throttle_events_alarm, expected_type=type_hints["config_read_throttle_events_alarm"])
            check_type(argname="argument config_system_errors_alarm", value=config_system_errors_alarm, expected_type=type_hints["config_system_errors_alarm"])
            check_type(argname="argument config_write_throttle_events_alarm", value=config_write_throttle_events_alarm, expected_type=type_hints["config_write_throttle_events_alarm"])
            check_type(argname="argument config_age_of_oldest_unreplicated_record_alarm", value=config_age_of_oldest_unreplicated_record_alarm, expected_type=type_hints["config_age_of_oldest_unreplicated_record_alarm"])
            check_type(argname="argument config_failed_to_replicate_record_count_alarm", value=config_failed_to_replicate_record_count_alarm, expected_type=type_hints["config_failed_to_replicate_record_count_alarm"])
            check_type(argname="argument config_throttled_put_record_count_alarm", value=config_throttled_put_record_count_alarm, expected_type=type_hints["config_throttled_put_record_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_read_throttle_events_alarm": config_read_throttle_events_alarm,
            "config_system_errors_alarm": config_system_errors_alarm,
            "config_write_throttle_events_alarm": config_write_throttle_events_alarm,
            "table": table,
        }
        if config_age_of_oldest_unreplicated_record_alarm is not None:
            self._values["config_age_of_oldest_unreplicated_record_alarm"] = config_age_of_oldest_unreplicated_record_alarm
        if config_failed_to_replicate_record_count_alarm is not None:
            self._values["config_failed_to_replicate_record_count_alarm"] = config_failed_to_replicate_record_count_alarm
        if config_throttled_put_record_count_alarm is not None:
            self._values["config_throttled_put_record_count_alarm"] = config_throttled_put_record_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_read_throttle_events_alarm(
        self,
    ) -> DynamoDbReadThrottleEventsAlarmConfig:
        '''The configuration for the ReadThrottleEvents alarm.'''
        result = self._values.get("config_read_throttle_events_alarm")
        assert result is not None, "Required property 'config_read_throttle_events_alarm' is missing"
        return typing.cast(DynamoDbReadThrottleEventsAlarmConfig, result)

    @builtins.property
    def config_system_errors_alarm(self) -> DynamoDbSystemErrorsAlarmConfig:
        '''The configuration for the SystemErrors alarm.'''
        result = self._values.get("config_system_errors_alarm")
        assert result is not None, "Required property 'config_system_errors_alarm' is missing"
        return typing.cast(DynamoDbSystemErrorsAlarmConfig, result)

    @builtins.property
    def config_write_throttle_events_alarm(
        self,
    ) -> "DynamoDbWriteThrottleEventsAlarmConfig":
        '''The configuration for the WriteThrottleEvents alarm.'''
        result = self._values.get("config_write_throttle_events_alarm")
        assert result is not None, "Required property 'config_write_throttle_events_alarm' is missing"
        return typing.cast("DynamoDbWriteThrottleEventsAlarmConfig", result)

    @builtins.property
    def config_age_of_oldest_unreplicated_record_alarm(
        self,
    ) -> typing.Optional["DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig"]:
        '''The configuration for the AgeOfOldestUnreplicatedRecord alarm.'''
        result = self._values.get("config_age_of_oldest_unreplicated_record_alarm")
        return typing.cast(typing.Optional["DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig"], result)

    @builtins.property
    def config_failed_to_replicate_record_count_alarm(
        self,
    ) -> typing.Optional[DynamoDbFailedToReplicateRecordCountAlarmConfig]:
        '''The configuration for the FailedToReplicateRecordCount alarm.'''
        result = self._values.get("config_failed_to_replicate_record_count_alarm")
        return typing.cast(typing.Optional[DynamoDbFailedToReplicateRecordCountAlarmConfig], result)

    @builtins.property
    def config_throttled_put_record_count_alarm(
        self,
    ) -> typing.Optional["DynamoDbThrottledPutRecordCountAlarmConfig"]:
        '''The configuration for the ThrottledPutRecordCount alarm.'''
        result = self._values.get("config_throttled_put_record_count_alarm")
        return typing.cast(typing.Optional["DynamoDbThrottledPutRecordCountAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[DynamoDbRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[DynamoDbRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def table(self) -> _aws_cdk_aws_dynamodb_ceddda9d.Table:
        '''The DynamoDb Table to monitor.'''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_aws_cdk_aws_dynamodb_ceddda9d.Table, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbTableRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoDbTableSystemErrorsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableSystemErrorsAlarm",
):
    '''This alarm detects a sustained high number of system errors for the DynamoDB table requests.

    If you continue to get 5xx errors, open the {@link https://status.aws.amazon.com/ AWS Service Health Dashboard}
    to check for operational issues with the service. You can use this alarm to get notified in case there is a prolonged
    internal service issue from DynamoDB and it helps you correlate with the issue your client application is facing.
    Refer {@link https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Programming.Errors.html#Programming.Errors.MessagesAndCodes.http5xx Error handling for DynamoDB} for more information.

    The alarm is triggered when the number of system errors exceeds threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param table: The DynamoDb Table to monitor.
        :param threshold: Set the threshold according to the expected traffic, accounting for an acceptable level of system errors. You can also analyze historical data to find the acceptable error count for the application workload, and then tune the threshold accordingly. System errors should be retried by the application/service as they are transient. Therefore, a very low threshold might cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained system errors for the DynamoDB table requests. System errors indicate internal service errors from DynamoDB and helps correlate to the issue that the client is having.
        :param alarm_name: The alarm name. Default: - tableName + ' - SystemErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7c6b993d5e6de67c32e464285de758149285264db80bb0d4f94678eb98a5dcab)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoDbTableSystemErrorsAlarmProps(
            table=table,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableSystemErrorsAlarmProps",
    jsii_struct_bases=[DynamoDbTableAlarmProps, DynamoDbSystemErrorsAlarmConfig],
    name_mapping={
        "table": "table",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DynamoDbTableSystemErrorsAlarmProps(
    DynamoDbTableAlarmProps,
    DynamoDbSystemErrorsAlarmConfig,
):
    def __init__(
        self,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DynamoDbTableSystemErrorsAlarm construct.

        :param table: The DynamoDb Table to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to the expected traffic, accounting for an acceptable level of system errors. You can also analyze historical data to find the acceptable error count for the application workload, and then tune the threshold accordingly. System errors should be retried by the application/service as they are transient. Therefore, a very low threshold might cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained system errors for the DynamoDB table requests. System errors indicate internal service errors from DynamoDB and helps correlate to the issue that the client is having.
        :param alarm_name: The alarm name. Default: - tableName + ' - SystemErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b0a93b48307aca9b03b0572a4085c43ec1cc5a5c3c0d86a36dadee8a0c65a54)
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "table": table,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def table(self) -> _aws_cdk_aws_dynamodb_ceddda9d.Table:
        '''The DynamoDb Table to monitor.'''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_aws_cdk_aws_dynamodb_ceddda9d.Table, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to the expected traffic, accounting for an acceptable level of system errors.

        You can also analyze historical data to find the acceptable error count for the application workload, and
        then tune the threshold accordingly. System errors should be retried by the application/service as they are
        transient. Therefore, a very low threshold might cause the alarm to be too sensitive, causing unwanted state
        transitions.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect sustained system errors for the DynamoDB table requests. System errors
        indicate internal service errors from DynamoDB and helps correlate to the issue that the client is having.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - SystemErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbTableSystemErrorsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class DynamoDbTableThrottledPutRecordCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableThrottledPutRecordCountAlarm",
):
    '''This alarm detects the records getting throttled by your Kinesis data stream during the replication of change data capture to Kinesis.

    This throttling happens because of insufficient Kinesis data stream capacity. If you experience excessive
    and regular throttling, you might need to increase the number of Kinesis stream shards proportionally to
    the observed write throughput of your table. To learn more about determining the size of a Kinesis data stream,
    see {@link https://docs.aws.amazon.com/streams/latest/dev/amazon-kinesis-streams.html#how-do-i-size-a-stream Determining the Initial Size of a Kinesis Data Stream}.

    The alarm is triggered when the number or records that were throttled exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param table: The DynamoDb Table to monitor.
        :param threshold: You might experience some throttling during exceptional usage peaks, but throttled records should remain as low as possible to avoid higher replication latency (DynamoDB retries sending throttled records to the Kinesis data stream). Set the threshold to a number which can help you catch regular excessive throttling. You can also analyze historical data of this metric to find the acceptable throttling rates for the application workload. Tune the threshold to a value that the application can tolerate based on your use case.
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor the number of records that that were throttled by your Kinesis data stream because of insufficient Kinesis data stream capacity.
        :param alarm_name: The alarm name. Default: - tableName + ' - ThrottledPutRecordCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e3a926e71921855a62486b6da786928f86b9d386ec5b56da64ab1259e0b96f29)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoDbTableThrottledPutRecordCountAlarmProps(
            table=table,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class DynamoDbTableWriteThrottleEventsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableWriteThrottleEventsAlarm",
):
    '''This alarm detects if there are high number of read requests getting throttled for the DynamoDB table.

    To troubleshoot the issue, see {@link https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TroubleshootingThrottling.html Troubleshooting throttling issues in Amazon DynamoDB}.

    The alarm is triggered when the number of read requests exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param table: The DynamoDb Table to monitor.
        :param threshold: Set the threshold according to the expected write traffic for the DynamoDB table, accounting for an acceptable level of throttling. It is important to monitor if you are under provisioned and not causing consistent throttling. You can also analyze historical data to find the acceptable level of throttling for the application workload, and then tune the threshold to a value higher than your usual acceptable throttling level. Throttled requests should be retried by the application/service as they are transient. Therefore, a very low threshold might cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained throttling for write requests to the DynamoDB table. Sustained throttling of write requests can negatively impact your workload write operations and reduce the overall efficiency of the system.
        :param alarm_name: The alarm name. Default: - tableName + ' - WriteThrottleEvents'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b89a3d002025bfe8192cda2bae15fc67656bd831f5a1c3962321a17b4b468d8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = DynamoDbTableWriteThrottleEventsAlarmProps(
            table=table,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbThrottledPutRecordCountAlarmConfig",
    jsii_struct_bases=[DynamoDbAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DynamoDbThrottledPutRecordCountAlarmConfig(DynamoDbAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the ThrottledPutRecordCount alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: You might experience some throttling during exceptional usage peaks, but throttled records should remain as low as possible to avoid higher replication latency (DynamoDB retries sending throttled records to the Kinesis data stream). Set the threshold to a number which can help you catch regular excessive throttling. You can also analyze historical data of this metric to find the acceptable throttling rates for the application workload. Tune the threshold to a value that the application can tolerate based on your use case.
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor the number of records that that were throttled by your Kinesis data stream because of insufficient Kinesis data stream capacity.
        :param alarm_name: The alarm name. Default: - tableName + ' - ThrottledPutRecordCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c58ba20dc0b9e0663ab063b6621e22550cc70b8f9f3908795cd0d3cafdaf748b)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''You might experience some throttling during exceptional usage peaks, but throttled records should remain as low as possible to avoid higher replication latency (DynamoDB retries sending throttled records to the Kinesis data stream).

        Set the threshold to a number which can help you
        catch regular excessive throttling. You can also analyze historical data of this metric to find
        the acceptable throttling rates for the application workload. Tune the threshold to a value that
        the application can tolerate based on your use case.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can monitor the number of records that that were throttled by your Kinesis
        data stream because of insufficient Kinesis data stream capacity.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - ThrottledPutRecordCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 10
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 10
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbThrottledPutRecordCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbWriteThrottleEventsAlarmConfig",
    jsii_struct_bases=[DynamoDbAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DynamoDbWriteThrottleEventsAlarmConfig(DynamoDbAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the WriteThrottleEvents alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to the expected write traffic for the DynamoDB table, accounting for an acceptable level of throttling. It is important to monitor if you are under provisioned and not causing consistent throttling. You can also analyze historical data to find the acceptable level of throttling for the application workload, and then tune the threshold to a value higher than your usual acceptable throttling level. Throttled requests should be retried by the application/service as they are transient. Therefore, a very low threshold might cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained throttling for write requests to the DynamoDB table. Sustained throttling of write requests can negatively impact your workload write operations and reduce the overall efficiency of the system.
        :param alarm_name: The alarm name. Default: - tableName + ' - WriteThrottleEvents'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87b013ab3fefd956673cc58c761062c54f6338bbe503be161bb3fcbe6fc20d7f)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to the expected write traffic for the DynamoDB table, accounting for an acceptable level of throttling.

        It is important to monitor if you
        are under provisioned and not causing consistent throttling. You can also analyze
        historical data to find the acceptable level of throttling for the application workload,
        and then tune the threshold to a value higher than your usual acceptable throttling level.
        Throttled requests should be retried by the application/service as they are transient.
        Therefore, a very low threshold might cause the alarm to be too sensitive, causing
        unwanted state transitions.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect sustained throttling for write requests to the DynamoDB table.
        Sustained throttling of write requests can negatively impact your workload write operations and
        reduce the overall efficiency of the system.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - WriteThrottleEvents'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbWriteThrottleEventsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2AlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class Ec2AlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2acfee6bf8bc47cc16e22eb9e742c07f1dbfe468e105e152d0d2e2330e8db5d1)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2AlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2CpuUtilizationAlarmConfig",
    jsii_struct_bases=[Ec2AlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class Ec2CpuUtilizationAlarmConfig(Ec2AlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the CPUUtilization alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization.
        :param alarm_name: The alarm name. Default: - instanceId + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: Typically, you can set the threshold for CPU utilization to 70-80%. However, you can adjust this value based on your acceptable performance level and workload characteristics. For some systems, consistently high CPU utilization may be normal and not indicate a problem, while for others, it may be cause of concern. Analyze historical CPU utilization data to identify the usage, find what CPU utilization is acceptable for your system, and set the threshold accordingly. Default: 80
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__da69fedfa474f63777151900474d5b9b3bbbe274dbdc47b00df12932e6af223d)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect high CPU utilization.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - instanceId + ' - CPUUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''Typically, you can set the threshold for CPU utilization to 70-80%.

        However, you can
        adjust this value based on your acceptable performance level and workload characteristics.
        For some systems, consistently high CPU utilization may be normal and not indicate a problem,
        while for others, it may be cause of concern. Analyze historical CPU utilization data to
        identify the usage, find what CPU utilization is acceptable for your system, and set the
        threshold accordingly.

        :default: 80
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2CpuUtilizationAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2InstanceAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"instance": "instance"},
)
class Ec2InstanceAlarmProps:
    def __init__(self, *, instance: _aws_cdk_aws_ec2_ceddda9d.Instance) -> None:
        '''The common properties for the EC2 Instance alarms.

        :param instance: The EC2 Instance to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51109f896f0b2aa1cd8b00cb3ed1cd101ec7a6f632b108181a1ff7e8302ff176)
            check_type(argname="argument instance", value=instance, expected_type=type_hints["instance"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "instance": instance,
        }

    @builtins.property
    def instance(self) -> _aws_cdk_aws_ec2_ceddda9d.Instance:
        '''The EC2 Instance to monitor.'''
        result = self._values.get("instance")
        assert result is not None, "Required property 'instance' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.Instance, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2InstanceAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Ec2InstanceCpuUtilizationAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2InstanceCpuUtilizationAlarm",
):
    '''This alarm helps to monitor the CPU utilization of an EC2 instance.

    Depending on the application, consistently high utilization levels might be normal. But if performance is degraded,
    and the application is not constrained by disk I/O, memory, or network resources, then a maxed-out CPU might indicate
    a resource bottleneck or application performance problems. High CPU utilization might indicate that an upgrade to a
    more CPU intensive instance is required. If detailed monitoring is enabled, you can change the period to 60 seconds
    instead of 300 seconds. For more information, see Enable or turn off detailed monitoring for your instances.

    The alarm is triggered when the percentage exceeds % threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param instance: The EC2 Instance to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization.
        :param alarm_name: The alarm name. Default: - instanceId + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: Typically, you can set the threshold for CPU utilization to 70-80%. However, you can adjust this value based on your acceptable performance level and workload characteristics. For some systems, consistently high CPU utilization may be normal and not indicate a problem, while for others, it may be cause of concern. Analyze historical CPU utilization data to identify the usage, find what CPU utilization is acceptable for your system, and set the threshold accordingly. Default: 80
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a192e90bcfeb52ed8ea8767b96c9968ed722b4593e1b8fa9893c96c87b3420f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = Ec2InstanceCpuUtilizationAlarmProps(
            instance=instance,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2InstanceCpuUtilizationAlarmProps",
    jsii_struct_bases=[Ec2InstanceAlarmProps, Ec2CpuUtilizationAlarmConfig],
    name_mapping={
        "instance": "instance",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class Ec2InstanceCpuUtilizationAlarmProps(
    Ec2InstanceAlarmProps,
    Ec2CpuUtilizationAlarmConfig,
):
    def __init__(
        self,
        *,
        instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the Ec2InstanceCpuUtilizationAlarm construct.

        :param instance: The EC2 Instance to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization.
        :param alarm_name: The alarm name. Default: - instanceId + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: Typically, you can set the threshold for CPU utilization to 70-80%. However, you can adjust this value based on your acceptable performance level and workload characteristics. For some systems, consistently high CPU utilization may be normal and not indicate a problem, while for others, it may be cause of concern. Analyze historical CPU utilization data to identify the usage, find what CPU utilization is acceptable for your system, and set the threshold accordingly. Default: 80
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0bd42a0901293e1b30a68755e84d60cb6bfaced6fd1d3e4173af577dd49bafe1)
            check_type(argname="argument instance", value=instance, expected_type=type_hints["instance"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "instance": instance,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def instance(self) -> _aws_cdk_aws_ec2_ceddda9d.Instance:
        '''The EC2 Instance to monitor.'''
        result = self._values.get("instance")
        assert result is not None, "Required property 'instance' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.Instance, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect high CPU utilization.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - instanceId + ' - CPUUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''Typically, you can set the threshold for CPU utilization to 70-80%.

        However, you can
        adjust this value based on your acceptable performance level and workload characteristics.
        For some systems, consistently high CPU utilization may be normal and not indicate a problem,
        while for others, it may be cause of concern. Analyze historical CPU utilization data to
        identify the usage, find what CPU utilization is acceptable for your system, and set the
        threshold accordingly.

        :default: 80
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2InstanceCpuUtilizationAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Ec2InstanceRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2InstanceRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an EC2 Instance.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#EC2
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
        config_cpu_utilization_alarm: typing.Optional[typing.Union[Ec2CpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_status_check_failed_alarm: typing.Optional[typing.Union["Ec2StatusCheckFailedAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["Ec2RecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param instance: The EC2 Instance to monitor.
        :param config_cpu_utilization_alarm: The configuration for the CPUUtilization alarm.
        :param config_status_check_failed_alarm: The configuration for the StatusCheckFailed alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0360502e32c49c2ce7682a7119762b8eefd7c8269c94215b35572e7f30572ce5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = Ec2InstanceRecommendedAlarmsProps(
            instance=instance,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            config_status_check_failed_alarm=config_status_check_failed_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmCpuUtilization")
    def alarm_cpu_utilization(self) -> typing.Optional[Ec2InstanceCpuUtilizationAlarm]:
        '''The CPUUtilization alarm.'''
        return typing.cast(typing.Optional[Ec2InstanceCpuUtilizationAlarm], jsii.get(self, "alarmCpuUtilization"))

    @builtins.property
    @jsii.member(jsii_name="alarmStatusCheckFailed")
    def alarm_status_check_failed(
        self,
    ) -> typing.Optional["Ec2InstanceStatusCheckFailedAlarm"]:
        '''The StatusCheckFailed alarm.'''
        return typing.cast(typing.Optional["Ec2InstanceStatusCheckFailedAlarm"], jsii.get(self, "alarmStatusCheckFailed"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2InstanceRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_cpu_utilization_alarm": "configCpuUtilizationAlarm",
        "config_status_check_failed_alarm": "configStatusCheckFailedAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class Ec2InstanceRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_cpu_utilization_alarm: typing.Optional[typing.Union[Ec2CpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_status_check_failed_alarm: typing.Optional[typing.Union["Ec2StatusCheckFailedAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["Ec2RecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an EC2 Service.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_cpu_utilization_alarm: The configuration for the CPUUtilization alarm.
        :param config_status_check_failed_alarm: The configuration for the StatusCheckFailed alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_cpu_utilization_alarm, dict):
            config_cpu_utilization_alarm = Ec2CpuUtilizationAlarmConfig(**config_cpu_utilization_alarm)
        if isinstance(config_status_check_failed_alarm, dict):
            config_status_check_failed_alarm = Ec2StatusCheckFailedAlarmConfig(**config_status_check_failed_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ddcf5625916efb6d352d9f1dd8342c33940ae561c3553dbe33f970cf9e00d09)
            check_type(argname="argument config_cpu_utilization_alarm", value=config_cpu_utilization_alarm, expected_type=type_hints["config_cpu_utilization_alarm"])
            check_type(argname="argument config_status_check_failed_alarm", value=config_status_check_failed_alarm, expected_type=type_hints["config_status_check_failed_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_cpu_utilization_alarm is not None:
            self._values["config_cpu_utilization_alarm"] = config_cpu_utilization_alarm
        if config_status_check_failed_alarm is not None:
            self._values["config_status_check_failed_alarm"] = config_status_check_failed_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[Ec2CpuUtilizationAlarmConfig]:
        '''The configuration for the CPUUtilization alarm.'''
        result = self._values.get("config_cpu_utilization_alarm")
        return typing.cast(typing.Optional[Ec2CpuUtilizationAlarmConfig], result)

    @builtins.property
    def config_status_check_failed_alarm(
        self,
    ) -> typing.Optional["Ec2StatusCheckFailedAlarmConfig"]:
        '''The configuration for the StatusCheckFailed alarm.'''
        result = self._values.get("config_status_check_failed_alarm")
        return typing.cast(typing.Optional["Ec2StatusCheckFailedAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["Ec2RecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["Ec2RecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2InstanceRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2InstanceRecommendedAlarmsProps",
    jsii_struct_bases=[Ec2InstanceRecommendedAlarmsConfig],
    name_mapping={
        "config_cpu_utilization_alarm": "configCpuUtilizationAlarm",
        "config_status_check_failed_alarm": "configStatusCheckFailedAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "instance": "instance",
    },
)
class Ec2InstanceRecommendedAlarmsProps(Ec2InstanceRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config_cpu_utilization_alarm: typing.Optional[typing.Union[Ec2CpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_status_check_failed_alarm: typing.Optional[typing.Union["Ec2StatusCheckFailedAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["Ec2RecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
    ) -> None:
        '''Properties for the Ec2InstanceRecommendedAlarms construct.

        :param config_cpu_utilization_alarm: The configuration for the CPUUtilization alarm.
        :param config_status_check_failed_alarm: The configuration for the StatusCheckFailed alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param instance: The EC2 Instance to monitor.
        '''
        if isinstance(config_cpu_utilization_alarm, dict):
            config_cpu_utilization_alarm = Ec2CpuUtilizationAlarmConfig(**config_cpu_utilization_alarm)
        if isinstance(config_status_check_failed_alarm, dict):
            config_status_check_failed_alarm = Ec2StatusCheckFailedAlarmConfig(**config_status_check_failed_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87f3897346b11f7f5083dc18346ba5c114ba26d48ca2c77100ae9016ad3fb6cc)
            check_type(argname="argument config_cpu_utilization_alarm", value=config_cpu_utilization_alarm, expected_type=type_hints["config_cpu_utilization_alarm"])
            check_type(argname="argument config_status_check_failed_alarm", value=config_status_check_failed_alarm, expected_type=type_hints["config_status_check_failed_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument instance", value=instance, expected_type=type_hints["instance"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "instance": instance,
        }
        if config_cpu_utilization_alarm is not None:
            self._values["config_cpu_utilization_alarm"] = config_cpu_utilization_alarm
        if config_status_check_failed_alarm is not None:
            self._values["config_status_check_failed_alarm"] = config_status_check_failed_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[Ec2CpuUtilizationAlarmConfig]:
        '''The configuration for the CPUUtilization alarm.'''
        result = self._values.get("config_cpu_utilization_alarm")
        return typing.cast(typing.Optional[Ec2CpuUtilizationAlarmConfig], result)

    @builtins.property
    def config_status_check_failed_alarm(
        self,
    ) -> typing.Optional["Ec2StatusCheckFailedAlarmConfig"]:
        '''The configuration for the StatusCheckFailed alarm.'''
        result = self._values.get("config_status_check_failed_alarm")
        return typing.cast(typing.Optional["Ec2StatusCheckFailedAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["Ec2RecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["Ec2RecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def instance(self) -> _aws_cdk_aws_ec2_ceddda9d.Instance:
        '''The EC2 Instance to monitor.'''
        result = self._values.get("instance")
        assert result is not None, "Required property 'instance' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.Instance, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2InstanceRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Ec2InstanceStatusCheckFailedAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2InstanceStatusCheckFailedAlarm",
):
    '''This alarm helps to monitor both system status checks and instance status checks.

    If either type of status check fails, then this alarm should be in ALARM state.

    The alarm is triggered when the status reported is greater or equal to threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param instance: The EC2 Instance to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect the underlying problems with instances, including both system status check failures and instance status check failures.
        :param alarm_name: The alarm name. Default: - instanceId + ' - StatusCheckFailed'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: When a status check fails, the value of this metric is 1. The threshold is set so that whenever the status check fails, the alarm is in ALARM state. Default: 1
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5516121dcab145bdbc42e4b31ddbc8dc71284ff14ba61b6ee15308c6c5313056)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = Ec2InstanceStatusCheckFailedAlarmProps(
            instance=instance,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class Ec2RecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2RecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an EC2 Instance.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#EC2
    '''

    def __init__(
        self,
        *,
        config_cpu_utilization_alarm: typing.Optional[typing.Union[Ec2CpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_status_check_failed_alarm: typing.Optional[typing.Union["Ec2StatusCheckFailedAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["Ec2RecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_cpu_utilization_alarm: The configuration for the CPUUtilization alarm.
        :param config_status_check_failed_alarm: The configuration for the StatusCheckFailed alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = Ec2InstanceRecommendedAlarmsConfig(
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            config_status_check_failed_alarm=config_status_check_failed_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a19b2d14b4bc32c186bd77f44b75461fda6b4cf63f779d16f6d9f8578b88c9a2)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2RecommendedAlarmsMetrics"
)
class Ec2RecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for EC2 alarms.'''

    CPU_UTILIZATION = "CPU_UTILIZATION"
    '''The percentage of physical CPU time that Amazon EC2 uses to run the EC2 instance, which includes time spent to run both the user code and the Amazon EC2 code.'''
    STATUS_CHECK_FAILED = "STATUS_CHECK_FAILED"
    '''Reports whether the instance has passed all status checks in the last minute.

    This metric can be either 0 (passed) or 1 (failed). By default, this metric is available at
    a 1-minute frequency at no charge.
    '''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2StatusCheckFailedAlarmConfig",
    jsii_struct_bases=[Ec2AlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class Ec2StatusCheckFailedAlarmConfig(Ec2AlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the StatusCheckFailed alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect the underlying problems with instances, including both system status check failures and instance status check failures.
        :param alarm_name: The alarm name. Default: - instanceId + ' - StatusCheckFailed'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: When a status check fails, the value of this metric is 1. The threshold is set so that whenever the status check fails, the alarm is in ALARM state. Default: 1
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74972eaf9be4c95dd2883750141bbbbcbaf0796242871063a2a6edb6456735ab)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect the underlying problems with instances, including both system
        status check failures and instance status check failures.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - instanceId + ' - StatusCheckFailed'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 2
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''When a status check fails, the value of this metric is 1.

        The threshold is set so that whenever the
        status check fails, the alarm is in ALARM state.

        :default: 1
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2StatusCheckFailedAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class EcsAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__435cfc2d1cfde9c2203fe0daa10bcd3b41f7de25b559e11efef241dc9bc26922)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsCpuUtilizationAlarmConfig",
    jsii_struct_bases=[EcsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class EcsCpuUtilizationAlarmConfig(EcsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the CpuUtilization alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization for the ECS service. Consistent high CPU utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The service metrics for CPU utilization might exceed 100% utilization. However, we recommend that you monitor the metric for high CPU utilization to avoid impacting other services. Set the threshold to about 90-95%. We recommend that you update your task definitions to reflect actual usage to prevent future issues with other services. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48324fe5e5b8daac5fbd26667cddfc678366e54992134e47206b10a34fab5b95)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high CPU utilization for the ECS service.
        Consistent high CPU utilization can indicate a resource bottleneck or application
        performance problems.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - clusterName + ' - ' + serviceName + ' - CPUUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The percentage (0-100) value against which the specified statistic is compared.

        The service metrics for CPU utilization might exceed 100% utilization. However,
        we recommend that you monitor the metric for high CPU utilization to avoid impacting
        other services. Set the threshold to about 90-95%. We recommend that you update your
        task definitions to reflect actual usage to prevent future issues with other services.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsCpuUtilizationAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsEphemeralStorageUtilizedAlarmConfig",
    jsii_struct_bases=[EcsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class EcsEphemeralStorageUtilizedAlarmConfig(EcsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the EphemeralStorageUtilized alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value in GB against which the specified statistic is compared. Set the threshold to about 90% of the ephemeral storage size. You can adjust this value based on your acceptable ephemeral storage utilization of the Fargate cluster. For some systems, a consistently high ephemeral storage utilized might be normal, while for others, it might lead to failure of the container.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high ephemeral storage usage for the Fargate cluster. Consistent high ephemeral storage utilized can indicate that the disk is full and it might lead to failure of the container.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - EphemeralStorageUtilized'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1395f2f33e520892de58821ff0556cca8137d15dbd6ce7665ec7936fbc306ead)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value in GB against which the specified statistic is compared.

        Set the threshold to about 90% of the ephemeral storage size. You can adjust this
        value based on your acceptable ephemeral storage utilization of the Fargate cluster.
        For some systems, a consistently high ephemeral storage utilized might be normal,
        while for others, it might lead to failure of the container.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high ephemeral storage usage for the Fargate cluster.
        Consistent high ephemeral storage utilized can indicate that the disk is full and it might
        lead to failure of the container.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - clusterName + ' - ' + serviceName + ' - EphemeralStorageUtilized'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsEphemeralStorageUtilizedAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsMemoryUtilizationAlarmConfig",
    jsii_struct_bases=[EcsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class EcsMemoryUtilizationAlarmConfig(EcsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the MemoryUtilization alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization for the ECS service. Consistent high memory utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - MemoryUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The memory utilization is measured as the total memory in use by the tasks that belong to the service, divided by the total memory reserved for the tasks that belong to the service. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2705f62db643ae90d66d170ae3c281bf6a34204a6d46765ee5882ba8050d20d1)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high memory utilization for the ECS service.
        Consistent high memory utilization can indicate a resource bottleneck or application
        performance problems.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - clusterName + ' - ' + serviceName + ' - MemoryUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The percentage (0-100) value against which the specified statistic is compared.

        The memory utilization is measured as the total memory in use by the tasks that
        belong to the service, divided by the total memory reserved for the tasks that
        belong to the service.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsMemoryUtilizationAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class EcsRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an ECS service.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ECS
    '''

    def __init__(
        self,
        *,
        config_ephemeral_storage_utilized_alarm: typing.Union[EcsEphemeralStorageUtilizedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[EcsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_memory_utilization_alarm: typing.Optional[typing.Union[EcsMemoryUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_running_task_count_alarm: typing.Optional[typing.Union["EcsRunningTaskCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["EcsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_ephemeral_storage_utilized_alarm: The configuration for the EphemeralStorageUtilized alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_memory_utilization_alarm: The configuration for the MemoryUtilization alarm.
        :param config_running_task_count_alarm: The configuration for the RunningTaskCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = EcsServiceRecommendedAlarmsConfig(
            config_ephemeral_storage_utilized_alarm=config_ephemeral_storage_utilized_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            config_memory_utilization_alarm=config_memory_utilization_alarm,
            config_running_task_count_alarm=config_running_task_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4beab2c93287f276fbcaf4a5218c27add48314583ce161890625081294689334)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsRecommendedAlarmsMetrics"
)
class EcsRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for ECS alarms.'''

    CPU_UTILIZATION = "CPU_UTILIZATION"
    '''The percentage of CPU units that is used by the cluster or service.'''
    MEMORY_UTILIZATION = "MEMORY_UTILIZATION"
    '''The percentage of memory in use by the cluster or service.'''
    EPHEMERAL_STORAGE_UTILIZED = "EPHEMERAL_STORAGE_UTILIZED"
    '''The ephemeral storage in GB that is used by the cluster or service.'''
    RUNNING_TASK_COUNT = "RUNNING_TASK_COUNT"
    '''The number of tasks in your services that are in the RUNNING state.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsRunningTaskCountAlarmConfig",
    jsii_struct_bases=[EcsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class EcsRunningTaskCountAlarmConfig(EcsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the RunningTaskCount alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect whether the number of running tasks are too low. A consistent low running task count can indicate ECS service deployment or performance issues.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - RunningTaskCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You can adjust the threshold based on the minimum running task count of the ECS service. If the running task count is 0, the Amazon ECS service will be unavailable. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a50f5604bbcf82d3ca8d6c6b332f24f921e0324fceb0f3c3bf99609d85fcc84)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect whether the number of running tasks are too low.
        A consistent low running task count can indicate ECS service deployment or performance issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - clusterName + ' - ' + serviceName + ' - RunningTaskCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You can adjust the threshold based on the minimum running task count of the ECS
        service. If the running task count is 0, the Amazon ECS service will be unavailable.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsRunningTaskCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"service": "service"},
)
class EcsServiceAlarmProps:
    def __init__(self, *, service: _aws_cdk_aws_ecs_ceddda9d.FargateService) -> None:
        '''The common properties for the ECS service alarms.

        :param service: The ECS service to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3b6c6389510c4b5c6845eb21357a642c028a9ca2009848136d2d1438bbb09083)
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service": service,
        }

    @builtins.property
    def service(self) -> _aws_cdk_aws_ecs_ceddda9d.FargateService:
        '''The ECS service to monitor.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(_aws_cdk_aws_ecs_ceddda9d.FargateService, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsServiceAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EcsServiceCpuUtilizationAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceCpuUtilizationAlarm",
):
    '''This alarm is used to detect high CPU utilization for the ECS service.

    Consistent high CPU utilization can indicate a resource bottleneck or
    application performance problems.

    The alarm is triggered when CPU utilization exceeds % threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param service: The ECS service to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization for the ECS service. Consistent high CPU utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The service metrics for CPU utilization might exceed 100% utilization. However, we recommend that you monitor the metric for high CPU utilization to avoid impacting other services. Set the threshold to about 90-95%. We recommend that you update your task definitions to reflect actual usage to prevent future issues with other services. Default: 90
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1120b7c76e3542cfe4fcaa078948787170d8089ce3e967a17b31b977b29df724)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EcsServiceCpuUtilizationAlarmProps(
            service=service,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceCpuUtilizationAlarmProps",
    jsii_struct_bases=[EcsServiceAlarmProps, EcsCpuUtilizationAlarmConfig],
    name_mapping={
        "service": "service",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class EcsServiceCpuUtilizationAlarmProps(
    EcsServiceAlarmProps,
    EcsCpuUtilizationAlarmConfig,
):
    def __init__(
        self,
        *,
        service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the EcsServiceCpuUtilizationAlarm construct.

        :param service: The ECS service to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization for the ECS service. Consistent high CPU utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The service metrics for CPU utilization might exceed 100% utilization. However, we recommend that you monitor the metric for high CPU utilization to avoid impacting other services. Set the threshold to about 90-95%. We recommend that you update your task definitions to reflect actual usage to prevent future issues with other services. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fa33f504adb615b68b32454b260c7cd0f2f3e56b305a7f752151437faa8aa3da)
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service": service,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def service(self) -> _aws_cdk_aws_ecs_ceddda9d.FargateService:
        '''The ECS service to monitor.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(_aws_cdk_aws_ecs_ceddda9d.FargateService, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high CPU utilization for the ECS service.
        Consistent high CPU utilization can indicate a resource bottleneck or application
        performance problems.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - clusterName + ' - ' + serviceName + ' - CPUUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The percentage (0-100) value against which the specified statistic is compared.

        The service metrics for CPU utilization might exceed 100% utilization. However,
        we recommend that you monitor the metric for high CPU utilization to avoid impacting
        other services. Set the threshold to about 90-95%. We recommend that you update your
        task definitions to reflect actual usage to prevent future issues with other services.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsServiceCpuUtilizationAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EcsServiceEphemeralStorageUtilizedAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceEphemeralStorageUtilizedAlarm",
):
    '''This alarm is used to detect high ephemeral storage usage for the Fargate cluster.

    Consistent high ephemeral storage utilized can indicate that the disk is full and it
    might lead to failure of the container.

    The alarm is triggered when the storage utilized (GB) exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param service: The ECS service to monitor.
        :param threshold: The value in GB against which the specified statistic is compared. Set the threshold to about 90% of the ephemeral storage size. You can adjust this value based on your acceptable ephemeral storage utilization of the Fargate cluster. For some systems, a consistently high ephemeral storage utilized might be normal, while for others, it might lead to failure of the container.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high ephemeral storage usage for the Fargate cluster. Consistent high ephemeral storage utilized can indicate that the disk is full and it might lead to failure of the container.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - EphemeralStorageUtilized'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2f3e2d84f095bf643f21bc6e3ee976c637c29b00aa2fe192d9a70fd4f37262f2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EcsServiceEphemeralStorageUtilizedAlarmProps(
            service=service,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceEphemeralStorageUtilizedAlarmProps",
    jsii_struct_bases=[EcsServiceAlarmProps, EcsEphemeralStorageUtilizedAlarmConfig],
    name_mapping={
        "service": "service",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class EcsServiceEphemeralStorageUtilizedAlarmProps(
    EcsServiceAlarmProps,
    EcsEphemeralStorageUtilizedAlarmConfig,
):
    def __init__(
        self,
        *,
        service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the EcsServiceEphemeralStorageUtilizedAlarm construct.

        :param service: The ECS service to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value in GB against which the specified statistic is compared. Set the threshold to about 90% of the ephemeral storage size. You can adjust this value based on your acceptable ephemeral storage utilization of the Fargate cluster. For some systems, a consistently high ephemeral storage utilized might be normal, while for others, it might lead to failure of the container.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high ephemeral storage usage for the Fargate cluster. Consistent high ephemeral storage utilized can indicate that the disk is full and it might lead to failure of the container.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - EphemeralStorageUtilized'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d18209f00433f5a3e6c4b792b59560a561373182c22387db3ddc360d50a2ccde)
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service": service,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def service(self) -> _aws_cdk_aws_ecs_ceddda9d.FargateService:
        '''The ECS service to monitor.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(_aws_cdk_aws_ecs_ceddda9d.FargateService, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value in GB against which the specified statistic is compared.

        Set the threshold to about 90% of the ephemeral storage size. You can adjust this
        value based on your acceptable ephemeral storage utilization of the Fargate cluster.
        For some systems, a consistently high ephemeral storage utilized might be normal,
        while for others, it might lead to failure of the container.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high ephemeral storage usage for the Fargate cluster.
        Consistent high ephemeral storage utilized can indicate that the disk is full and it might
        lead to failure of the container.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - clusterName + ' - ' + serviceName + ' - EphemeralStorageUtilized'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsServiceEphemeralStorageUtilizedAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EcsServiceMemoryUtilizationAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceMemoryUtilizationAlarm",
):
    '''This alarm is used to detect high memory utilization for the ECS service.

    Consistent high memory utilization can indicate a resource bottleneck or
    application performance problems.

    The alarm is triggered when memory utilization exceeds % threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param service: The ECS service to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization for the ECS service. Consistent high memory utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - MemoryUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The memory utilization is measured as the total memory in use by the tasks that belong to the service, divided by the total memory reserved for the tasks that belong to the service. Default: 90
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8661ecd7abbab2f17b094ec4f4dca9a8d1b3d3c91ef51fcc936bc6a1067dbb34)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EcsServiceMemoryUtilizationAlarmProps(
            service=service,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceMemoryUtilizationAlarmProps",
    jsii_struct_bases=[EcsServiceAlarmProps, EcsMemoryUtilizationAlarmConfig],
    name_mapping={
        "service": "service",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class EcsServiceMemoryUtilizationAlarmProps(
    EcsServiceAlarmProps,
    EcsMemoryUtilizationAlarmConfig,
):
    def __init__(
        self,
        *,
        service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the EcsServiceMemoryUtilizationAlarm construct.

        :param service: The ECS service to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization for the ECS service. Consistent high memory utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - MemoryUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The memory utilization is measured as the total memory in use by the tasks that belong to the service, divided by the total memory reserved for the tasks that belong to the service. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f297f23a60726c901eab5af0c1269d648d2bd51563d95f6fab50e01adafcc597)
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service": service,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def service(self) -> _aws_cdk_aws_ecs_ceddda9d.FargateService:
        '''The ECS service to monitor.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(_aws_cdk_aws_ecs_ceddda9d.FargateService, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high memory utilization for the ECS service.
        Consistent high memory utilization can indicate a resource bottleneck or application
        performance problems.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - clusterName + ' - ' + serviceName + ' - MemoryUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The percentage (0-100) value against which the specified statistic is compared.

        The memory utilization is measured as the total memory in use by the tasks that
        belong to the service, divided by the total memory reserved for the tasks that
        belong to the service.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsServiceMemoryUtilizationAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EcsServiceRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an ECS service.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ECS
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
        config_ephemeral_storage_utilized_alarm: typing.Union[EcsEphemeralStorageUtilizedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[EcsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_memory_utilization_alarm: typing.Optional[typing.Union[EcsMemoryUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_running_task_count_alarm: typing.Optional[typing.Union[EcsRunningTaskCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[EcsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param service: The ECS service to monitor.
        :param config_ephemeral_storage_utilized_alarm: The configuration for the EphemeralStorageUtilized alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_memory_utilization_alarm: The configuration for the MemoryUtilization alarm.
        :param config_running_task_count_alarm: The configuration for the RunningTaskCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__724a213d96a78a28650ab2f88c23a32d8acc4e510ab175389fe19dfde7067b1d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EcsServiceRecommendedAlarmsProps(
            service=service,
            config_ephemeral_storage_utilized_alarm=config_ephemeral_storage_utilized_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            config_memory_utilization_alarm=config_memory_utilization_alarm,
            config_running_task_count_alarm=config_running_task_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmCpuUtilization")
    def alarm_cpu_utilization(self) -> typing.Optional[EcsServiceCpuUtilizationAlarm]:
        '''The CpuUtilization alarm.'''
        return typing.cast(typing.Optional[EcsServiceCpuUtilizationAlarm], jsii.get(self, "alarmCpuUtilization"))

    @builtins.property
    @jsii.member(jsii_name="alarmEphemeralStorageUtilized")
    def alarm_ephemeral_storage_utilized(
        self,
    ) -> typing.Optional[EcsServiceEphemeralStorageUtilizedAlarm]:
        '''The EphemeralStorageUtilized alarm.'''
        return typing.cast(typing.Optional[EcsServiceEphemeralStorageUtilizedAlarm], jsii.get(self, "alarmEphemeralStorageUtilized"))

    @builtins.property
    @jsii.member(jsii_name="alarmMemoryUtilization")
    def alarm_memory_utilization(
        self,
    ) -> typing.Optional[EcsServiceMemoryUtilizationAlarm]:
        '''The MemoryUtilization alarm.'''
        return typing.cast(typing.Optional[EcsServiceMemoryUtilizationAlarm], jsii.get(self, "alarmMemoryUtilization"))

    @builtins.property
    @jsii.member(jsii_name="alarmRunningTaskCount")
    def alarm_running_task_count(
        self,
    ) -> typing.Optional["EcsServiceRunningTaskCountAlarm"]:
        '''The RunningTaskCount alarm.'''
        return typing.cast(typing.Optional["EcsServiceRunningTaskCountAlarm"], jsii.get(self, "alarmRunningTaskCount"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_ephemeral_storage_utilized_alarm": "configEphemeralStorageUtilizedAlarm",
        "config_cpu_utilization_alarm": "configCpuUtilizationAlarm",
        "config_memory_utilization_alarm": "configMemoryUtilizationAlarm",
        "config_running_task_count_alarm": "configRunningTaskCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class EcsServiceRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_ephemeral_storage_utilized_alarm: typing.Union[EcsEphemeralStorageUtilizedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[EcsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_memory_utilization_alarm: typing.Optional[typing.Union[EcsMemoryUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_running_task_count_alarm: typing.Optional[typing.Union[EcsRunningTaskCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[EcsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an ECS Service.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_ephemeral_storage_utilized_alarm: The configuration for the EphemeralStorageUtilized alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_memory_utilization_alarm: The configuration for the MemoryUtilization alarm.
        :param config_running_task_count_alarm: The configuration for the RunningTaskCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_ephemeral_storage_utilized_alarm, dict):
            config_ephemeral_storage_utilized_alarm = EcsEphemeralStorageUtilizedAlarmConfig(**config_ephemeral_storage_utilized_alarm)
        if isinstance(config_cpu_utilization_alarm, dict):
            config_cpu_utilization_alarm = EcsCpuUtilizationAlarmConfig(**config_cpu_utilization_alarm)
        if isinstance(config_memory_utilization_alarm, dict):
            config_memory_utilization_alarm = EcsMemoryUtilizationAlarmConfig(**config_memory_utilization_alarm)
        if isinstance(config_running_task_count_alarm, dict):
            config_running_task_count_alarm = EcsRunningTaskCountAlarmConfig(**config_running_task_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__96de4954f44195026f55eea03f2bf9f94ce48ca03a87d1ceb3b7e0562af66c36)
            check_type(argname="argument config_ephemeral_storage_utilized_alarm", value=config_ephemeral_storage_utilized_alarm, expected_type=type_hints["config_ephemeral_storage_utilized_alarm"])
            check_type(argname="argument config_cpu_utilization_alarm", value=config_cpu_utilization_alarm, expected_type=type_hints["config_cpu_utilization_alarm"])
            check_type(argname="argument config_memory_utilization_alarm", value=config_memory_utilization_alarm, expected_type=type_hints["config_memory_utilization_alarm"])
            check_type(argname="argument config_running_task_count_alarm", value=config_running_task_count_alarm, expected_type=type_hints["config_running_task_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_ephemeral_storage_utilized_alarm": config_ephemeral_storage_utilized_alarm,
        }
        if config_cpu_utilization_alarm is not None:
            self._values["config_cpu_utilization_alarm"] = config_cpu_utilization_alarm
        if config_memory_utilization_alarm is not None:
            self._values["config_memory_utilization_alarm"] = config_memory_utilization_alarm
        if config_running_task_count_alarm is not None:
            self._values["config_running_task_count_alarm"] = config_running_task_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_ephemeral_storage_utilized_alarm(
        self,
    ) -> EcsEphemeralStorageUtilizedAlarmConfig:
        '''The configuration for the EphemeralStorageUtilized alarm.'''
        result = self._values.get("config_ephemeral_storage_utilized_alarm")
        assert result is not None, "Required property 'config_ephemeral_storage_utilized_alarm' is missing"
        return typing.cast(EcsEphemeralStorageUtilizedAlarmConfig, result)

    @builtins.property
    def config_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[EcsCpuUtilizationAlarmConfig]:
        '''The configuration for the CpuUtilization alarm.'''
        result = self._values.get("config_cpu_utilization_alarm")
        return typing.cast(typing.Optional[EcsCpuUtilizationAlarmConfig], result)

    @builtins.property
    def config_memory_utilization_alarm(
        self,
    ) -> typing.Optional[EcsMemoryUtilizationAlarmConfig]:
        '''The configuration for the MemoryUtilization alarm.'''
        result = self._values.get("config_memory_utilization_alarm")
        return typing.cast(typing.Optional[EcsMemoryUtilizationAlarmConfig], result)

    @builtins.property
    def config_running_task_count_alarm(
        self,
    ) -> typing.Optional[EcsRunningTaskCountAlarmConfig]:
        '''The configuration for the RunningTaskCount alarm.'''
        result = self._values.get("config_running_task_count_alarm")
        return typing.cast(typing.Optional[EcsRunningTaskCountAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[EcsRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[EcsRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsServiceRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceRecommendedAlarmsProps",
    jsii_struct_bases=[EcsServiceRecommendedAlarmsConfig],
    name_mapping={
        "config_ephemeral_storage_utilized_alarm": "configEphemeralStorageUtilizedAlarm",
        "config_cpu_utilization_alarm": "configCpuUtilizationAlarm",
        "config_memory_utilization_alarm": "configMemoryUtilizationAlarm",
        "config_running_task_count_alarm": "configRunningTaskCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "service": "service",
    },
)
class EcsServiceRecommendedAlarmsProps(EcsServiceRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config_ephemeral_storage_utilized_alarm: typing.Union[EcsEphemeralStorageUtilizedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[EcsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_memory_utilization_alarm: typing.Optional[typing.Union[EcsMemoryUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_running_task_count_alarm: typing.Optional[typing.Union[EcsRunningTaskCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[EcsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
    ) -> None:
        '''Properties for the EcsServiceRecommendedAlarms construct.

        :param config_ephemeral_storage_utilized_alarm: The configuration for the EphemeralStorageUtilized alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_memory_utilization_alarm: The configuration for the MemoryUtilization alarm.
        :param config_running_task_count_alarm: The configuration for the RunningTaskCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param service: The ECS service to monitor.
        '''
        if isinstance(config_ephemeral_storage_utilized_alarm, dict):
            config_ephemeral_storage_utilized_alarm = EcsEphemeralStorageUtilizedAlarmConfig(**config_ephemeral_storage_utilized_alarm)
        if isinstance(config_cpu_utilization_alarm, dict):
            config_cpu_utilization_alarm = EcsCpuUtilizationAlarmConfig(**config_cpu_utilization_alarm)
        if isinstance(config_memory_utilization_alarm, dict):
            config_memory_utilization_alarm = EcsMemoryUtilizationAlarmConfig(**config_memory_utilization_alarm)
        if isinstance(config_running_task_count_alarm, dict):
            config_running_task_count_alarm = EcsRunningTaskCountAlarmConfig(**config_running_task_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe69211690b966f8fe399214b1abfa3ee0f8e6e23a52e1e0c86e724d667261b5)
            check_type(argname="argument config_ephemeral_storage_utilized_alarm", value=config_ephemeral_storage_utilized_alarm, expected_type=type_hints["config_ephemeral_storage_utilized_alarm"])
            check_type(argname="argument config_cpu_utilization_alarm", value=config_cpu_utilization_alarm, expected_type=type_hints["config_cpu_utilization_alarm"])
            check_type(argname="argument config_memory_utilization_alarm", value=config_memory_utilization_alarm, expected_type=type_hints["config_memory_utilization_alarm"])
            check_type(argname="argument config_running_task_count_alarm", value=config_running_task_count_alarm, expected_type=type_hints["config_running_task_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_ephemeral_storage_utilized_alarm": config_ephemeral_storage_utilized_alarm,
            "service": service,
        }
        if config_cpu_utilization_alarm is not None:
            self._values["config_cpu_utilization_alarm"] = config_cpu_utilization_alarm
        if config_memory_utilization_alarm is not None:
            self._values["config_memory_utilization_alarm"] = config_memory_utilization_alarm
        if config_running_task_count_alarm is not None:
            self._values["config_running_task_count_alarm"] = config_running_task_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_ephemeral_storage_utilized_alarm(
        self,
    ) -> EcsEphemeralStorageUtilizedAlarmConfig:
        '''The configuration for the EphemeralStorageUtilized alarm.'''
        result = self._values.get("config_ephemeral_storage_utilized_alarm")
        assert result is not None, "Required property 'config_ephemeral_storage_utilized_alarm' is missing"
        return typing.cast(EcsEphemeralStorageUtilizedAlarmConfig, result)

    @builtins.property
    def config_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[EcsCpuUtilizationAlarmConfig]:
        '''The configuration for the CpuUtilization alarm.'''
        result = self._values.get("config_cpu_utilization_alarm")
        return typing.cast(typing.Optional[EcsCpuUtilizationAlarmConfig], result)

    @builtins.property
    def config_memory_utilization_alarm(
        self,
    ) -> typing.Optional[EcsMemoryUtilizationAlarmConfig]:
        '''The configuration for the MemoryUtilization alarm.'''
        result = self._values.get("config_memory_utilization_alarm")
        return typing.cast(typing.Optional[EcsMemoryUtilizationAlarmConfig], result)

    @builtins.property
    def config_running_task_count_alarm(
        self,
    ) -> typing.Optional[EcsRunningTaskCountAlarmConfig]:
        '''The configuration for the RunningTaskCount alarm.'''
        result = self._values.get("config_running_task_count_alarm")
        return typing.cast(typing.Optional[EcsRunningTaskCountAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[EcsRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[EcsRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def service(self) -> _aws_cdk_aws_ecs_ceddda9d.FargateService:
        '''The ECS service to monitor.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(_aws_cdk_aws_ecs_ceddda9d.FargateService, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsServiceRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EcsServiceRunningTaskCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceRunningTaskCountAlarm",
):
    '''This alarm helps you detect a low running task count of the ECS service.

    If the running task count is too low, it can can indicate that the application
    cant handle the service load and it might lead to performance issues. If there
    is no running task, the Amazon ECS service might be unavailable or there might
    be deployment issues.

    The alarm is triggered when the number of running tasks is less than or equal to
    threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param service: The ECS service to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect whether the number of running tasks are too low. A consistent low running task count can indicate ECS service deployment or performance issues.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - RunningTaskCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You can adjust the threshold based on the minimum running task count of the ECS service. If the running task count is 0, the Amazon ECS service will be unavailable. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__65d769a09ddada5b86a816fdf76fa6e40b1e6948c9c25f105b126a90f3c88a3b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EcsServiceRunningTaskCountAlarmProps(
            service=service,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EcsServiceRunningTaskCountAlarmProps",
    jsii_struct_bases=[EcsServiceAlarmProps, EcsRunningTaskCountAlarmConfig],
    name_mapping={
        "service": "service",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class EcsServiceRunningTaskCountAlarmProps(
    EcsServiceAlarmProps,
    EcsRunningTaskCountAlarmConfig,
):
    def __init__(
        self,
        *,
        service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the EcsServiceRunningTaskCountAlarm construct.

        :param service: The ECS service to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect whether the number of running tasks are too low. A consistent low running task count can indicate ECS service deployment or performance issues.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - RunningTaskCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You can adjust the threshold based on the minimum running task count of the ECS service. If the running task count is 0, the Amazon ECS service will be unavailable. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__533c120ca79a560c491be2018ed62af66a6cfb05771c387e262af7fefa786787)
            check_type(argname="argument service", value=service, expected_type=type_hints["service"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "service": service,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def service(self) -> _aws_cdk_aws_ecs_ceddda9d.FargateService:
        '''The ECS service to monitor.'''
        result = self._values.get("service")
        assert result is not None, "Required property 'service' is missing"
        return typing.cast(_aws_cdk_aws_ecs_ceddda9d.FargateService, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect whether the number of running tasks are too low.
        A consistent low running task count can indicate ECS service deployment or performance issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - clusterName + ' - ' + serviceName + ' - RunningTaskCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You can adjust the threshold based on the minimum running task count of the ECS
        service. If the running task count is 0, the Amazon ECS service will be unavailable.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsServiceRunningTaskCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class EfsAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ef76ba01d053c9a485c2342a9760eff63fe09a50b5347c65e20096a91b3214a)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EfsAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsBurstCreditBalanceAlarmConfig",
    jsii_struct_bases=[EfsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class EfsBurstCreditBalanceAlarmConfig(EfsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the BurstCreditBalance alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect low burst credit balance of the file system. Consistent low burst credit balance can be an indicator of the slowing down in throughput and increase in I/O latency.
        :param alarm_name: The alarm name. Default: - fileSystemId + ' - BurstCreditBalance'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param threshold: When the file system run out of burst credits and even if the baseline throughput rate is lower, EFS continues to provide a metered throughput of 1 MiBps to all file systems. However, it is recommended that the metric is monitored for low burst credit balance to avoid the file system acting as resource bottleneck for the applications. The threshold can be set around 0 bytes. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a272ff765dac917db57580a5ee50999d563b95e06b6f478221f6127d622bd84)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect low burst credit balance of the file system. Consistent low
        burst credit balance can be an indicator of the slowing down in throughput and increase in I/O latency.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - fileSystemId + ' - BurstCreditBalance'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''When the file system run out of burst credits and even if the baseline throughput rate is lower, EFS continues to provide a metered throughput of 1 MiBps to all file systems.

        However, it is recommended
        that the metric is monitored for low burst credit balance to avoid the file system acting as resource
        bottleneck for the applications. The threshold can be set around 0 bytes.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EfsBurstCreditBalanceAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsFileSystemAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"file_system": "fileSystem"},
)
class EfsFileSystemAlarmProps:
    def __init__(self, *, file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem) -> None:
        '''The common properties for the EFS FileSystem alarms.

        :param file_system: The EFS FileSystem to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ba59444e9f296288573427957ad8c2ffa01de4987e11c3fc3bf6bebb012aff55)
            check_type(argname="argument file_system", value=file_system, expected_type=type_hints["file_system"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "file_system": file_system,
        }

    @builtins.property
    def file_system(self) -> _aws_cdk_aws_efs_ceddda9d.FileSystem:
        '''The EFS FileSystem to monitor.'''
        result = self._values.get("file_system")
        assert result is not None, "Required property 'file_system' is missing"
        return typing.cast(_aws_cdk_aws_efs_ceddda9d.FileSystem, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EfsFileSystemAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EfsFileSystemBurstCreditBalanceAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsFileSystemBurstCreditBalanceAlarm",
):
    '''This alarm helps in ensuring that there is available burst credit balance for the file system usage.

    When there is no available burst credit, applications access to the the file system will be limited due to low throughput.
    If the metric drops to 0 consistently, consider changing the throughput mode to Elastic or Provisioned throughput mode.

    The alarm is triggered when the percentage is lower or equals the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param file_system: The EFS FileSystem to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect low burst credit balance of the file system. Consistent low burst credit balance can be an indicator of the slowing down in throughput and increase in I/O latency.
        :param alarm_name: The alarm name. Default: - fileSystemId + ' - BurstCreditBalance'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param threshold: When the file system run out of burst credits and even if the baseline throughput rate is lower, EFS continues to provide a metered throughput of 1 MiBps to all file systems. However, it is recommended that the metric is monitored for low burst credit balance to avoid the file system acting as resource bottleneck for the applications. The threshold can be set around 0 bytes. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4afc816ca557f0da7bcae39a7e4ecd7231af3dca2609be47c3b2fbd43baedd7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EfsFileSystemBurstCreditBalanceAlarmProps(
            file_system=file_system,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsFileSystemBurstCreditBalanceAlarmProps",
    jsii_struct_bases=[EfsFileSystemAlarmProps, EfsBurstCreditBalanceAlarmConfig],
    name_mapping={
        "file_system": "fileSystem",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class EfsFileSystemBurstCreditBalanceAlarmProps(
    EfsFileSystemAlarmProps,
    EfsBurstCreditBalanceAlarmConfig,
):
    def __init__(
        self,
        *,
        file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the EfsFileSystemBurstCreditBalanceAlarm construct.

        :param file_system: The EFS FileSystem to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect low burst credit balance of the file system. Consistent low burst credit balance can be an indicator of the slowing down in throughput and increase in I/O latency.
        :param alarm_name: The alarm name. Default: - fileSystemId + ' - BurstCreditBalance'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param threshold: When the file system run out of burst credits and even if the baseline throughput rate is lower, EFS continues to provide a metered throughput of 1 MiBps to all file systems. However, it is recommended that the metric is monitored for low burst credit balance to avoid the file system acting as resource bottleneck for the applications. The threshold can be set around 0 bytes. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4df10c3f676eabf19dd289788c7ac7a7ff09a1feb4a268ac4db29bffac3a872)
            check_type(argname="argument file_system", value=file_system, expected_type=type_hints["file_system"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "file_system": file_system,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def file_system(self) -> _aws_cdk_aws_efs_ceddda9d.FileSystem:
        '''The EFS FileSystem to monitor.'''
        result = self._values.get("file_system")
        assert result is not None, "Required property 'file_system' is missing"
        return typing.cast(_aws_cdk_aws_efs_ceddda9d.FileSystem, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect low burst credit balance of the file system. Consistent low
        burst credit balance can be an indicator of the slowing down in throughput and increase in I/O latency.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - fileSystemId + ' - BurstCreditBalance'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''When the file system run out of burst credits and even if the baseline throughput rate is lower, EFS continues to provide a metered throughput of 1 MiBps to all file systems.

        However, it is recommended
        that the metric is monitored for low burst credit balance to avoid the file system acting as resource
        bottleneck for the applications. The threshold can be set around 0 bytes.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EfsFileSystemBurstCreditBalanceAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EfsFileSystemPercentIOLimitAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsFileSystemPercentIOLimitAlarm",
):
    '''This alarm helps in ensuring that the workload stays within the I/O limit available to the file system.

    If the metric reaches its I/O limit consistently, consider moving the application to a file system that
    uses Max I/O performance as mode. For troubleshooting, check clients that are connected to the file system
    and applications of the clients that throttles the file system.

    The alarm is triggered when the percentage exceed or equals % threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param file_system: The EFS FileSystem to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the file system is to reach the I/O limit of the General Purpose performance mode. Consistent high I/O percentage can be an indicator of the file system cannot scale with respect to I/O requests enough and the file system can be a resource bottleneck for the applications that use the file system.
        :param alarm_name: The alarm name. Default: - fileSystemId + ' - PercentIOLimit'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param threshold: When the file system reaches its I/O limit, it may respond to read and write requests slower. Therefore, it is recommended that the metric is monitored to avoid impacting applications that use the file system. The threshold can be set around 100%. However, this value can be adjusted to a lower value based on file system characteristics. Default: 100
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__eed52f080dbf663706bf9635f310e07a61a918e8163f27b252f3eb8dbd3791ad)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EfsFileSystemPercentIOLimitAlarmProps(
            file_system=file_system,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class EfsFileSystemRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsFileSystemRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an EFS FileSystem.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#EFS
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
        config_burst_credit_balance_alarm: typing.Optional[typing.Union[EfsBurstCreditBalanceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_percent_io_limit_alarm: typing.Optional[typing.Union["EfsPercentIOLimitAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["EfsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param file_system: The EFS FileSystem to monitor.
        :param config_burst_credit_balance_alarm: The configuration for the BurstCreditBalance alarm.
        :param config_percent_io_limit_alarm: The configuration for the PercentIOLimit alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cf7440c85270651772318b9debc5f85bcd8f547bca2241d8ab4566fa4d39d1d9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EfsFileSystemRecommendedAlarmsProps(
            file_system=file_system,
            config_burst_credit_balance_alarm=config_burst_credit_balance_alarm,
            config_percent_io_limit_alarm=config_percent_io_limit_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmBurstCreditBalance")
    def alarm_burst_credit_balance(
        self,
    ) -> typing.Optional[EfsFileSystemBurstCreditBalanceAlarm]:
        '''The BurstCreditBalance alarm.'''
        return typing.cast(typing.Optional[EfsFileSystemBurstCreditBalanceAlarm], jsii.get(self, "alarmBurstCreditBalance"))

    @builtins.property
    @jsii.member(jsii_name="alarmPercentIOLimit")
    def alarm_percent_io_limit(
        self,
    ) -> typing.Optional[EfsFileSystemPercentIOLimitAlarm]:
        '''The PercentIOLimit alarm.'''
        return typing.cast(typing.Optional[EfsFileSystemPercentIOLimitAlarm], jsii.get(self, "alarmPercentIOLimit"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsFileSystemRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_burst_credit_balance_alarm": "configBurstCreditBalanceAlarm",
        "config_percent_io_limit_alarm": "configPercentIOLimitAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class EfsFileSystemRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_burst_credit_balance_alarm: typing.Optional[typing.Union[EfsBurstCreditBalanceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_percent_io_limit_alarm: typing.Optional[typing.Union["EfsPercentIOLimitAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["EfsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an EFS Service.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_burst_credit_balance_alarm: The configuration for the BurstCreditBalance alarm.
        :param config_percent_io_limit_alarm: The configuration for the PercentIOLimit alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_burst_credit_balance_alarm, dict):
            config_burst_credit_balance_alarm = EfsBurstCreditBalanceAlarmConfig(**config_burst_credit_balance_alarm)
        if isinstance(config_percent_io_limit_alarm, dict):
            config_percent_io_limit_alarm = EfsPercentIOLimitAlarmConfig(**config_percent_io_limit_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e79ebeca62049ce971fc36abf56c94e42a78352bf516d7694767dfe454d1c61d)
            check_type(argname="argument config_burst_credit_balance_alarm", value=config_burst_credit_balance_alarm, expected_type=type_hints["config_burst_credit_balance_alarm"])
            check_type(argname="argument config_percent_io_limit_alarm", value=config_percent_io_limit_alarm, expected_type=type_hints["config_percent_io_limit_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_burst_credit_balance_alarm is not None:
            self._values["config_burst_credit_balance_alarm"] = config_burst_credit_balance_alarm
        if config_percent_io_limit_alarm is not None:
            self._values["config_percent_io_limit_alarm"] = config_percent_io_limit_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_burst_credit_balance_alarm(
        self,
    ) -> typing.Optional[EfsBurstCreditBalanceAlarmConfig]:
        '''The configuration for the BurstCreditBalance alarm.'''
        result = self._values.get("config_burst_credit_balance_alarm")
        return typing.cast(typing.Optional[EfsBurstCreditBalanceAlarmConfig], result)

    @builtins.property
    def config_percent_io_limit_alarm(
        self,
    ) -> typing.Optional["EfsPercentIOLimitAlarmConfig"]:
        '''The configuration for the PercentIOLimit alarm.'''
        result = self._values.get("config_percent_io_limit_alarm")
        return typing.cast(typing.Optional["EfsPercentIOLimitAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["EfsRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["EfsRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EfsFileSystemRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsFileSystemRecommendedAlarmsProps",
    jsii_struct_bases=[EfsFileSystemRecommendedAlarmsConfig],
    name_mapping={
        "config_burst_credit_balance_alarm": "configBurstCreditBalanceAlarm",
        "config_percent_io_limit_alarm": "configPercentIOLimitAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "file_system": "fileSystem",
    },
)
class EfsFileSystemRecommendedAlarmsProps(EfsFileSystemRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config_burst_credit_balance_alarm: typing.Optional[typing.Union[EfsBurstCreditBalanceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_percent_io_limit_alarm: typing.Optional[typing.Union["EfsPercentIOLimitAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["EfsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
    ) -> None:
        '''Properties for the EfsFileSystemRecommendedAlarms construct.

        :param config_burst_credit_balance_alarm: The configuration for the BurstCreditBalance alarm.
        :param config_percent_io_limit_alarm: The configuration for the PercentIOLimit alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param file_system: The EFS FileSystem to monitor.
        '''
        if isinstance(config_burst_credit_balance_alarm, dict):
            config_burst_credit_balance_alarm = EfsBurstCreditBalanceAlarmConfig(**config_burst_credit_balance_alarm)
        if isinstance(config_percent_io_limit_alarm, dict):
            config_percent_io_limit_alarm = EfsPercentIOLimitAlarmConfig(**config_percent_io_limit_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f441685864da7a9749a71ceb7f25f5934fa568544256ccd656a18f4bd6618c1)
            check_type(argname="argument config_burst_credit_balance_alarm", value=config_burst_credit_balance_alarm, expected_type=type_hints["config_burst_credit_balance_alarm"])
            check_type(argname="argument config_percent_io_limit_alarm", value=config_percent_io_limit_alarm, expected_type=type_hints["config_percent_io_limit_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument file_system", value=file_system, expected_type=type_hints["file_system"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "file_system": file_system,
        }
        if config_burst_credit_balance_alarm is not None:
            self._values["config_burst_credit_balance_alarm"] = config_burst_credit_balance_alarm
        if config_percent_io_limit_alarm is not None:
            self._values["config_percent_io_limit_alarm"] = config_percent_io_limit_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_burst_credit_balance_alarm(
        self,
    ) -> typing.Optional[EfsBurstCreditBalanceAlarmConfig]:
        '''The configuration for the BurstCreditBalance alarm.'''
        result = self._values.get("config_burst_credit_balance_alarm")
        return typing.cast(typing.Optional[EfsBurstCreditBalanceAlarmConfig], result)

    @builtins.property
    def config_percent_io_limit_alarm(
        self,
    ) -> typing.Optional["EfsPercentIOLimitAlarmConfig"]:
        '''The configuration for the PercentIOLimit alarm.'''
        result = self._values.get("config_percent_io_limit_alarm")
        return typing.cast(typing.Optional["EfsPercentIOLimitAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["EfsRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["EfsRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def file_system(self) -> _aws_cdk_aws_efs_ceddda9d.FileSystem:
        '''The EFS FileSystem to monitor.'''
        result = self._values.get("file_system")
        assert result is not None, "Required property 'file_system' is missing"
        return typing.cast(_aws_cdk_aws_efs_ceddda9d.FileSystem, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EfsFileSystemRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsPercentIOLimitAlarmConfig",
    jsii_struct_bases=[EfsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class EfsPercentIOLimitAlarmConfig(EfsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the PercentIOLimit alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the file system is to reach the I/O limit of the General Purpose performance mode. Consistent high I/O percentage can be an indicator of the file system cannot scale with respect to I/O requests enough and the file system can be a resource bottleneck for the applications that use the file system.
        :param alarm_name: The alarm name. Default: - fileSystemId + ' - PercentIOLimit'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param threshold: When the file system reaches its I/O limit, it may respond to read and write requests slower. Therefore, it is recommended that the metric is monitored to avoid impacting applications that use the file system. The threshold can be set around 100%. However, this value can be adjusted to a lower value based on file system characteristics. Default: 100
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__99e4c0f308e1f2ee42b02f0e6f9fda43b65f43af5c7c8d7036399a6967c6b615)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect how close the file system is to reach the I/O limit of the General
        Purpose performance mode. Consistent high I/O percentage can be an indicator of the file system cannot scale
        with respect to I/O requests enough and the file system can be a resource bottleneck for the applications
        that use the file system.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - fileSystemId + ' - PercentIOLimit'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''When the file system reaches its I/O limit, it may respond to read and write requests slower.

        Therefore, it is recommended that the metric is monitored to avoid impacting applications that
        use the file system. The threshold can be set around 100%. However, this value can be adjusted
        to a lower value based on file system characteristics.

        :default: 100
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EfsPercentIOLimitAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class EfsRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an EFS FileSystem.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#EFS
    '''

    def __init__(
        self,
        *,
        config_burst_credit_balance_alarm: typing.Optional[typing.Union[EfsBurstCreditBalanceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_percent_io_limit_alarm: typing.Optional[typing.Union[EfsPercentIOLimitAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["EfsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_burst_credit_balance_alarm: The configuration for the BurstCreditBalance alarm.
        :param config_percent_io_limit_alarm: The configuration for the PercentIOLimit alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = EfsFileSystemRecommendedAlarmsConfig(
            config_burst_credit_balance_alarm=config_burst_credit_balance_alarm,
            config_percent_io_limit_alarm=config_percent_io_limit_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a43c894e8d06fc4444207a26b40a6beb7a083725cf88fdabccd6db4c9c52649d)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsRecommendedAlarmsMetrics"
)
class EfsRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for EFS alarms.'''

    PERCENT_IO_LIMIT = "PERCENT_IO_LIMIT"
    '''Percentage of how close a file system is to reaching the I/O limit of the General Purpose performance mode.'''
    BURST_CREDIT_BALANCE = "BURST_CREDIT_BALANCE"
    '''The number of burst credits that a file system has.

    Burst credits allow a file system to burst
    to throughput levels above a file system's baseline level for periods of time.
    '''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class ElastiCacheAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f8536cc9a2a6711272f1ad7b7f883385a70f60edf232b235dc7d33c11990559)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"cache_cluster": "cacheCluster"},
)
class ElastiCacheClusterAlarmProps:
    def __init__(
        self,
        *,
        cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
    ) -> None:
        '''The common properties for the ElastiCache CfnCacheCluster alarms.

        :param cache_cluster: The ElastiCache CfnCacheCluster to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e9689b396bdba25f39a440fe28ea746c5d3320a47e381dd4e7af3cf91d4c51f9)
            check_type(argname="argument cache_cluster", value=cache_cluster, expected_type=type_hints["cache_cluster"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cache_cluster": cache_cluster,
        }

    @builtins.property
    def cache_cluster(self) -> _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster:
        '''The ElastiCache CfnCacheCluster to monitor.'''
        result = self._values.get("cache_cluster")
        assert result is not None, "Required property 'cache_cluster' is missing"
        return typing.cast(_aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheClusterAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ElastiCacheClusterDatabaseMemoryUsagePercentageAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterDatabaseMemoryUsagePercentageAlarm",
):
    '''This alarm helps you monitor the memory utilization of your cluster.

    When your DatabaseMemoryUsagePercentage reaches 100%, the Redis OSS maxmemory policy is triggered and evictions might occur
    based on the policy selected. If no object in the cache matches the eviction policy, write operations fail. Some workloads
    expect or rely on evictions, but if not, you will need to increase the memory capacity of your cluster. You can scale your
    cluster out by adding more primary nodes, or scale it up by using a larger node type.
    Refer to {@link https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Scaling.html Scaling ElastiCache for Redis OSS clusters} for details.

    The alarm is triggered when the percentage exceeds % threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cache_cluster: The ElastiCache CfnCacheCluster to monitor.
        :param threshold: Depending on your application's memory requirements and the memory capacity of your ElastiCache cluster, you should set the threshold to the percentage that reflects the critical level of memory usage of the cluster. You can use historical memory usage data as reference for acceptable memory usage threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization of your cluster so that you can avoid failures when writing to your cluster. It is useful to know when you will need to scale up your cluster if your application does not expect to experience evictions.
        :param alarm_name: The alarm name. Default: - logicalId + ' - DatabaseMemoryUsagePercentage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81ca50c2abaeb952d84142803af82654ac1f0245c5c300e59e61eb75673689e6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ElastiCacheClusterDatabaseMemoryUsagePercentageAlarmProps(
            cache_cluster=cache_cluster,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class ElastiCacheClusterEngineCpuUtilizationAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterEngineCpuUtilizationAlarm",
):
    '''This alarm helps to monitor the CPU utilization of a Redis OSS engine thread within the ElastiCache instance.

    Common reasons for high engine CPU are long-running commands that consume high CPU, a high number of requests, an increase of new
    client connection requests in a short time period, and high evictions when the cache doesn't have enough memory to hold new data.
    You should consider {@link https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Scaling.html Scaling ElastiCache for Redis OSS clusters}
    by adding more nodes or scaling up your instance type.

    The alarm is triggered when the percentage exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cache_cluster: The ElastiCache CfnCacheCluster to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization of the Redis OSS engine thread. It is useful if you want to monitor the CPU usage of the database engine itself.
        :param alarm_name: The alarm name. Default: - logicalId + ' - EngineCPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: Set the threshold to a percentage that reflects the critical engine CPU utilization level for your application. You can benchmark your cluster using your application and expected workload to correlate EngineCPUUtilization and performance as a reference, and then set the threshold accordingly. In most cases, you can set the threshold to about 90% of your available CPU. Default: 90
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__df3fa636514cc018599dc9eddfe511a4d43344935134aa7a6ed2da71248d26f7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ElastiCacheClusterEngineCpuUtilizationAlarmProps(
            cache_cluster=cache_cluster,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class ElastiCacheClusterRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an ElastiCache CfnCacheCluster.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ElastiCache
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
        config_database_memory_usage_percentage_alarm: typing.Union["ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_replication_lag_alarm: typing.Union["ElastiCacheReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_engine_cpu_utilization_alarm: typing.Optional[typing.Union["ElastiCacheEngineCpuUtilizationAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ElastiCacheRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cache_cluster: The ElastiCache CfnCacheCluster to monitor.
        :param config_database_memory_usage_percentage_alarm: The configuration for the DatabaseMemoryUsagePercentage alarm.
        :param config_replication_lag_alarm: The configuration for the ReplicationLag alarm.
        :param config_engine_cpu_utilization_alarm: The configuration for the EngineCpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__992c9cd9515809dbe36303afb6cb722c430caf9c8047878fcb8c3f3fc88d955b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ElastiCacheClusterRecommendedAlarmsProps(
            cache_cluster=cache_cluster,
            config_database_memory_usage_percentage_alarm=config_database_memory_usage_percentage_alarm,
            config_replication_lag_alarm=config_replication_lag_alarm,
            config_engine_cpu_utilization_alarm=config_engine_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmDatabaseMemoryUsagePercentage")
    def alarm_database_memory_usage_percentage(
        self,
    ) -> typing.Optional[ElastiCacheClusterDatabaseMemoryUsagePercentageAlarm]:
        '''The DatabaseMemoryUsagePercentage alarm.'''
        return typing.cast(typing.Optional[ElastiCacheClusterDatabaseMemoryUsagePercentageAlarm], jsii.get(self, "alarmDatabaseMemoryUsagePercentage"))

    @builtins.property
    @jsii.member(jsii_name="alarmEngineCpuUtilization")
    def alarm_engine_cpu_utilization(
        self,
    ) -> typing.Optional[ElastiCacheClusterEngineCpuUtilizationAlarm]:
        '''The EngineCpuUtilization alarm.'''
        return typing.cast(typing.Optional[ElastiCacheClusterEngineCpuUtilizationAlarm], jsii.get(self, "alarmEngineCpuUtilization"))

    @builtins.property
    @jsii.member(jsii_name="alarmReplicationLag")
    def alarm_replication_lag(
        self,
    ) -> typing.Optional["ElastiCacheClusterReplicationLagAlarm"]:
        '''The ReplicationLag alarm.'''
        return typing.cast(typing.Optional["ElastiCacheClusterReplicationLagAlarm"], jsii.get(self, "alarmReplicationLag"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class ElastiCacheClusterRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an ElastiCache CfnCacheCluster.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ElastiCache
    '''

    def __init__(
        self,
        *,
        config_database_memory_usage_percentage_alarm: typing.Union["ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_replication_lag_alarm: typing.Union["ElastiCacheReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_engine_cpu_utilization_alarm: typing.Optional[typing.Union["ElastiCacheEngineCpuUtilizationAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ElastiCacheRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_database_memory_usage_percentage_alarm: The configuration for the DatabaseMemoryUsagePercentage alarm.
        :param config_replication_lag_alarm: The configuration for the ReplicationLag alarm.
        :param config_engine_cpu_utilization_alarm: The configuration for the EngineCpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ElastiCacheClusterRecommendedAlarmsConfig(
            config_database_memory_usage_percentage_alarm=config_database_memory_usage_percentage_alarm,
            config_replication_lag_alarm=config_replication_lag_alarm,
            config_engine_cpu_utilization_alarm=config_engine_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__adcf101bda44240579cdebd708e4750e654def35a484bf41c6f5b0bdaa8bd0cb)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_database_memory_usage_percentage_alarm": "configDatabaseMemoryUsagePercentageAlarm",
        "config_replication_lag_alarm": "configReplicationLagAlarm",
        "config_engine_cpu_utilization_alarm": "configEngineCpuUtilizationAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class ElastiCacheClusterRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_database_memory_usage_percentage_alarm: typing.Union["ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_replication_lag_alarm: typing.Union["ElastiCacheReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_engine_cpu_utilization_alarm: typing.Optional[typing.Union["ElastiCacheEngineCpuUtilizationAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ElastiCacheRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an ElastiCache Service.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_database_memory_usage_percentage_alarm: The configuration for the DatabaseMemoryUsagePercentage alarm.
        :param config_replication_lag_alarm: The configuration for the ReplicationLag alarm.
        :param config_engine_cpu_utilization_alarm: The configuration for the EngineCpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_database_memory_usage_percentage_alarm, dict):
            config_database_memory_usage_percentage_alarm = ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig(**config_database_memory_usage_percentage_alarm)
        if isinstance(config_replication_lag_alarm, dict):
            config_replication_lag_alarm = ElastiCacheReplicationLagAlarmConfig(**config_replication_lag_alarm)
        if isinstance(config_engine_cpu_utilization_alarm, dict):
            config_engine_cpu_utilization_alarm = ElastiCacheEngineCpuUtilizationAlarmConfig(**config_engine_cpu_utilization_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b4239aabe2d3d85cd6e3c20d6cab4febd6741a2026326883425c0ff8cf8ebf84)
            check_type(argname="argument config_database_memory_usage_percentage_alarm", value=config_database_memory_usage_percentage_alarm, expected_type=type_hints["config_database_memory_usage_percentage_alarm"])
            check_type(argname="argument config_replication_lag_alarm", value=config_replication_lag_alarm, expected_type=type_hints["config_replication_lag_alarm"])
            check_type(argname="argument config_engine_cpu_utilization_alarm", value=config_engine_cpu_utilization_alarm, expected_type=type_hints["config_engine_cpu_utilization_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_database_memory_usage_percentage_alarm": config_database_memory_usage_percentage_alarm,
            "config_replication_lag_alarm": config_replication_lag_alarm,
        }
        if config_engine_cpu_utilization_alarm is not None:
            self._values["config_engine_cpu_utilization_alarm"] = config_engine_cpu_utilization_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_database_memory_usage_percentage_alarm(
        self,
    ) -> "ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig":
        '''The configuration for the DatabaseMemoryUsagePercentage alarm.'''
        result = self._values.get("config_database_memory_usage_percentage_alarm")
        assert result is not None, "Required property 'config_database_memory_usage_percentage_alarm' is missing"
        return typing.cast("ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig", result)

    @builtins.property
    def config_replication_lag_alarm(self) -> "ElastiCacheReplicationLagAlarmConfig":
        '''The configuration for the ReplicationLag alarm.'''
        result = self._values.get("config_replication_lag_alarm")
        assert result is not None, "Required property 'config_replication_lag_alarm' is missing"
        return typing.cast("ElastiCacheReplicationLagAlarmConfig", result)

    @builtins.property
    def config_engine_cpu_utilization_alarm(
        self,
    ) -> typing.Optional["ElastiCacheEngineCpuUtilizationAlarmConfig"]:
        '''The configuration for the EngineCpuUtilization alarm.'''
        result = self._values.get("config_engine_cpu_utilization_alarm")
        return typing.cast(typing.Optional["ElastiCacheEngineCpuUtilizationAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["ElastiCacheRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["ElastiCacheRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheClusterRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterRecommendedAlarmsProps",
    jsii_struct_bases=[ElastiCacheClusterRecommendedAlarmsConfig],
    name_mapping={
        "config_database_memory_usage_percentage_alarm": "configDatabaseMemoryUsagePercentageAlarm",
        "config_replication_lag_alarm": "configReplicationLagAlarm",
        "config_engine_cpu_utilization_alarm": "configEngineCpuUtilizationAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "cache_cluster": "cacheCluster",
    },
)
class ElastiCacheClusterRecommendedAlarmsProps(
    ElastiCacheClusterRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config_database_memory_usage_percentage_alarm: typing.Union["ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_replication_lag_alarm: typing.Union["ElastiCacheReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_engine_cpu_utilization_alarm: typing.Optional[typing.Union["ElastiCacheEngineCpuUtilizationAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["ElastiCacheRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
    ) -> None:
        '''Properties for the ElastiCacheClusterRecommendedAlarms construct.

        :param config_database_memory_usage_percentage_alarm: The configuration for the DatabaseMemoryUsagePercentage alarm.
        :param config_replication_lag_alarm: The configuration for the ReplicationLag alarm.
        :param config_engine_cpu_utilization_alarm: The configuration for the EngineCpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param cache_cluster: The ElastiCache CfnCacheCluster to monitor.
        '''
        if isinstance(config_database_memory_usage_percentage_alarm, dict):
            config_database_memory_usage_percentage_alarm = ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig(**config_database_memory_usage_percentage_alarm)
        if isinstance(config_replication_lag_alarm, dict):
            config_replication_lag_alarm = ElastiCacheReplicationLagAlarmConfig(**config_replication_lag_alarm)
        if isinstance(config_engine_cpu_utilization_alarm, dict):
            config_engine_cpu_utilization_alarm = ElastiCacheEngineCpuUtilizationAlarmConfig(**config_engine_cpu_utilization_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c10c40110c98066726c626b1963f37da4625770d863088d10181176466a6610d)
            check_type(argname="argument config_database_memory_usage_percentage_alarm", value=config_database_memory_usage_percentage_alarm, expected_type=type_hints["config_database_memory_usage_percentage_alarm"])
            check_type(argname="argument config_replication_lag_alarm", value=config_replication_lag_alarm, expected_type=type_hints["config_replication_lag_alarm"])
            check_type(argname="argument config_engine_cpu_utilization_alarm", value=config_engine_cpu_utilization_alarm, expected_type=type_hints["config_engine_cpu_utilization_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument cache_cluster", value=cache_cluster, expected_type=type_hints["cache_cluster"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_database_memory_usage_percentage_alarm": config_database_memory_usage_percentage_alarm,
            "config_replication_lag_alarm": config_replication_lag_alarm,
            "cache_cluster": cache_cluster,
        }
        if config_engine_cpu_utilization_alarm is not None:
            self._values["config_engine_cpu_utilization_alarm"] = config_engine_cpu_utilization_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_database_memory_usage_percentage_alarm(
        self,
    ) -> "ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig":
        '''The configuration for the DatabaseMemoryUsagePercentage alarm.'''
        result = self._values.get("config_database_memory_usage_percentage_alarm")
        assert result is not None, "Required property 'config_database_memory_usage_percentage_alarm' is missing"
        return typing.cast("ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig", result)

    @builtins.property
    def config_replication_lag_alarm(self) -> "ElastiCacheReplicationLagAlarmConfig":
        '''The configuration for the ReplicationLag alarm.'''
        result = self._values.get("config_replication_lag_alarm")
        assert result is not None, "Required property 'config_replication_lag_alarm' is missing"
        return typing.cast("ElastiCacheReplicationLagAlarmConfig", result)

    @builtins.property
    def config_engine_cpu_utilization_alarm(
        self,
    ) -> typing.Optional["ElastiCacheEngineCpuUtilizationAlarmConfig"]:
        '''The configuration for the EngineCpuUtilization alarm.'''
        result = self._values.get("config_engine_cpu_utilization_alarm")
        return typing.cast(typing.Optional["ElastiCacheEngineCpuUtilizationAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["ElastiCacheRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["ElastiCacheRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def cache_cluster(self) -> _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster:
        '''The ElastiCache CfnCacheCluster to monitor.'''
        result = self._values.get("cache_cluster")
        assert result is not None, "Required property 'cache_cluster' is missing"
        return typing.cast(_aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheClusterRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ElastiCacheClusterReplicationLagAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterReplicationLagAlarm",
):
    '''This alarm helps to monitor the replication health of your ElastiCache cluster.

    A high replication lag means that the primary node or the replica can't keep up the pace of the replication. If your write
    activity is too high, consider scaling your cluster out by adding more primary nodes, or scaling it up by using a larger node type.
    Refer to {@link https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Scaling.html Scaling ElastiCache for Redis OSS clusters} for
    details. If your read replicas are overloaded by the amount of read requests,
    consider adding more read replicas.

    The alarm is triggered when the number of milliseconds exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cache_cluster: The ElastiCache CfnCacheCluster to monitor.
        :param threshold: Set the threshold according to your application's requirements and the potential impact of replication lag. You should consider your application's expected write rates and network conditions for the acceptable replication lag.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a delay between data updates on the primary node and their synchronization to replica node. It helps to ensure data consistency of a read replica cluster node.
        :param alarm_name: The alarm name. Default: - logicalId + ' - ReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__734c09c05108f7b104ae5fcf19130b831e45f46b6927113af4237fe769e32930)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ElastiCacheClusterReplicationLagAlarmProps(
            cache_cluster=cache_cluster,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig",
    jsii_struct_bases=[ElastiCacheAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig(ElastiCacheAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the DatabaseMemoryUsagePercentage alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Depending on your application's memory requirements and the memory capacity of your ElastiCache cluster, you should set the threshold to the percentage that reflects the critical level of memory usage of the cluster. You can use historical memory usage data as reference for acceptable memory usage threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization of your cluster so that you can avoid failures when writing to your cluster. It is useful to know when you will need to scale up your cluster if your application does not expect to experience evictions.
        :param alarm_name: The alarm name. Default: - logicalId + ' - DatabaseMemoryUsagePercentage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd3e64b7518214232a674845684344d9cb26789fec344c96c82c42aaa6960652)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Depending on your application's memory requirements and the memory capacity of your ElastiCache cluster, you should set the threshold to the percentage that reflects the critical level of memory usage of the cluster.

        You can use historical memory usage data as reference for acceptable memory usage threshold.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high memory utilization of your cluster so that you can avoid failures when writing to
        your cluster. It is useful to know when you will need to scale up your cluster if your application does not expect to experience
        evictions.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - logicalId + ' - DatabaseMemoryUsagePercentage'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheEngineCpuUtilizationAlarmConfig",
    jsii_struct_bases=[ElastiCacheAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ElastiCacheEngineCpuUtilizationAlarmConfig(ElastiCacheAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the EngineCpuUtilization alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization of the Redis OSS engine thread. It is useful if you want to monitor the CPU usage of the database engine itself.
        :param alarm_name: The alarm name. Default: - logicalId + ' - EngineCPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: Set the threshold to a percentage that reflects the critical engine CPU utilization level for your application. You can benchmark your cluster using your application and expected workload to correlate EngineCPUUtilization and performance as a reference, and then set the threshold accordingly. In most cases, you can set the threshold to about 90% of your available CPU. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__244c49ef4cee9e947d4a9d5c92eb17b4e19f71f78b1619f6250d0ce3460b93b9)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high CPU utilization of the Redis OSS engine thread. It is useful if you want
        to monitor the CPU usage of the database engine itself.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - logicalId + ' - EngineCPUUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''Set the threshold to a percentage that reflects the critical engine CPU utilization level for your application.

        You can benchmark your cluster using your application and expected workload to correlate EngineCPUUtilization and
        performance as a reference, and then set the threshold accordingly. In most cases, you can set the threshold to
        about 90% of your available CPU.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheEngineCpuUtilizationAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheRecommendedAlarmsMetrics"
)
class ElastiCacheRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for ElastiCache alarms.'''

    DATABASE_MEMORY_USAGE_PERCENTAGE = "DATABASE_MEMORY_USAGE_PERCENTAGE"
    '''Percentage of the memory for the cluster that is in use.'''
    ENGINE_CPU_UTILIZATION = "ENGINE_CPU_UTILIZATION"
    '''Provides CPU utilization of the Valkey or Redis OSS engine thread.

    Because Valkey and Redis OSS are single-threaded,
    you can use this metric to analyze the load of the process itself. The ``EngineCPUUtilization`` metric provides a more
    precise visibility of the process. You can use it in conjunction with the ``CPUUtilization`` metric. ``CPUUtilization``
    exposes CPU utilization for the server instance as a whole, including other operating system and management processes.
    For larger node types with four vCPUs or more, use the EngineCPUUtilization metric to monitor and set thresholds for scaling.
    '''
    REPLICATION_LAG = "REPLICATION_LAG"
    '''It represents how far behind, in seconds, the replica is in applying changes from the primary node.

    For Valkey 7.2 and onwards,
    and Redis OSS engine version 5.0.6 onwards, the lag can be measured in milliseconds.
    '''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"cache_replication_group": "cacheReplicationGroup"},
)
class ElastiCacheReplicationGroupAlarmProps:
    def __init__(
        self,
        *,
        cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
    ) -> None:
        '''The common properties for the ElastiCache CfnReplicationGroup alarms.

        :param cache_replication_group: The ElastiCache CfnReplicationGroup to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2dcc3c4ba7f5fd325b214c550c46c80f9db54d2f0b6d0210095f67ca59375af8)
            check_type(argname="argument cache_replication_group", value=cache_replication_group, expected_type=type_hints["cache_replication_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cache_replication_group": cache_replication_group,
        }

    @builtins.property
    def cache_replication_group(
        self,
    ) -> _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup:
        '''The ElastiCache CfnReplicationGroup to monitor.'''
        result = self._values.get("cache_replication_group")
        assert result is not None, "Required property 'cache_replication_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheReplicationGroupAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarm",
):
    '''This alarm helps you monitor the memory utilization of your cluster.

    When your DatabaseMemoryUsagePercentage reaches 100%, the Redis OSS maxmemory policy is triggered and evictions might occur
    based on the policy selected. If no object in the cache matches the eviction policy, write operations fail. Some workloads
    expect or rely on evictions, but if not, you will need to increase the memory capacity of your cluster. You can scale your
    cluster out by adding more primary nodes, or scale it up by using a larger node type.
    Refer to {@link https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Scaling.html Scaling ElastiCache for Redis OSS clusters} for details.

    The alarm is triggered when the percentage exceeds % threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cache_replication_group: The ElastiCache CfnReplicationGroup to monitor.
        :param threshold: Depending on your application's memory requirements and the memory capacity of your ElastiCache cluster, you should set the threshold to the percentage that reflects the critical level of memory usage of the cluster. You can use historical memory usage data as reference for acceptable memory usage threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization of your cluster so that you can avoid failures when writing to your cluster. It is useful to know when you will need to scale up your cluster if your application does not expect to experience evictions.
        :param alarm_name: The alarm name. Default: - logicalId + ' - DatabaseMemoryUsagePercentage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6436e491efc7cc84e780c19bf1aa069e11eca40983f454d9f07ebd0d9fd86101)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarmProps(
            cache_replication_group=cache_replication_group,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarmProps",
    jsii_struct_bases=[
        ElastiCacheReplicationGroupAlarmProps,
        ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig,
    ],
    name_mapping={
        "cache_replication_group": "cacheReplicationGroup",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarmProps(
    ElastiCacheReplicationGroupAlarmProps,
    ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig,
):
    def __init__(
        self,
        *,
        cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarm construct.

        :param cache_replication_group: The ElastiCache CfnReplicationGroup to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Depending on your application's memory requirements and the memory capacity of your ElastiCache cluster, you should set the threshold to the percentage that reflects the critical level of memory usage of the cluster. You can use historical memory usage data as reference for acceptable memory usage threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization of your cluster so that you can avoid failures when writing to your cluster. It is useful to know when you will need to scale up your cluster if your application does not expect to experience evictions.
        :param alarm_name: The alarm name. Default: - logicalId + ' - DatabaseMemoryUsagePercentage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9649102b99a4eef0d967f15d8aae62a17592680121971f890c461c44b797eec0)
            check_type(argname="argument cache_replication_group", value=cache_replication_group, expected_type=type_hints["cache_replication_group"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cache_replication_group": cache_replication_group,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def cache_replication_group(
        self,
    ) -> _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup:
        '''The ElastiCache CfnReplicationGroup to monitor.'''
        result = self._values.get("cache_replication_group")
        assert result is not None, "Required property 'cache_replication_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Depending on your application's memory requirements and the memory capacity of your ElastiCache cluster, you should set the threshold to the percentage that reflects the critical level of memory usage of the cluster.

        You can use historical memory usage data as reference for acceptable memory usage threshold.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high memory utilization of your cluster so that you can avoid failures when writing to
        your cluster. It is useful to know when you will need to scale up your cluster if your application does not expect to experience
        evictions.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - logicalId + ' - DatabaseMemoryUsagePercentage'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ElastiCacheReplicationGroupEngineCpuUtilizationAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupEngineCpuUtilizationAlarm",
):
    '''This alarm helps to monitor the CPU utilization of a Redis OSS engine thread within the ElastiCache instance.

    Common reasons for high engine CPU are long-running commands that consume high CPU, a high number of requests, an increase of new
    client connection requests in a short time period, and high evictions when the cache doesn't have enough memory to hold new data.
    You should consider {@link https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Scaling.html Scaling ElastiCache for Redis OSS clusters}
    by adding more nodes or scaling up your instance type.

    The alarm is triggered when the percentage exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cache_replication_group: The ElastiCache CfnReplicationGroup to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization of the Redis OSS engine thread. It is useful if you want to monitor the CPU usage of the database engine itself.
        :param alarm_name: The alarm name. Default: - logicalId + ' - EngineCPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: Set the threshold to a percentage that reflects the critical engine CPU utilization level for your application. You can benchmark your cluster using your application and expected workload to correlate EngineCPUUtilization and performance as a reference, and then set the threshold accordingly. In most cases, you can set the threshold to about 90% of your available CPU. Default: 90
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cce02b0949579fd22d58a1bd7d4bf251578e331a530c197cb62e241af54720e5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ElastiCacheReplicationGroupEngineCpuUtilizationAlarmProps(
            cache_replication_group=cache_replication_group,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupEngineCpuUtilizationAlarmProps",
    jsii_struct_bases=[
        ElastiCacheReplicationGroupAlarmProps,
        ElastiCacheEngineCpuUtilizationAlarmConfig,
    ],
    name_mapping={
        "cache_replication_group": "cacheReplicationGroup",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ElastiCacheReplicationGroupEngineCpuUtilizationAlarmProps(
    ElastiCacheReplicationGroupAlarmProps,
    ElastiCacheEngineCpuUtilizationAlarmConfig,
):
    def __init__(
        self,
        *,
        cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ElastiCacheReplicationGroupEngineCpuUtilizationAlarm construct.

        :param cache_replication_group: The ElastiCache CfnReplicationGroup to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization of the Redis OSS engine thread. It is useful if you want to monitor the CPU usage of the database engine itself.
        :param alarm_name: The alarm name. Default: - logicalId + ' - EngineCPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: Set the threshold to a percentage that reflects the critical engine CPU utilization level for your application. You can benchmark your cluster using your application and expected workload to correlate EngineCPUUtilization and performance as a reference, and then set the threshold accordingly. In most cases, you can set the threshold to about 90% of your available CPU. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d072460c3c69608633b621bfc176d384f6852fbf6882a71ebb92effda24353b9)
            check_type(argname="argument cache_replication_group", value=cache_replication_group, expected_type=type_hints["cache_replication_group"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cache_replication_group": cache_replication_group,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def cache_replication_group(
        self,
    ) -> _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup:
        '''The ElastiCache CfnReplicationGroup to monitor.'''
        result = self._values.get("cache_replication_group")
        assert result is not None, "Required property 'cache_replication_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high CPU utilization of the Redis OSS engine thread. It is useful if you want
        to monitor the CPU usage of the database engine itself.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - logicalId + ' - EngineCPUUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''Set the threshold to a percentage that reflects the critical engine CPU utilization level for your application.

        You can benchmark your cluster using your application and expected workload to correlate EngineCPUUtilization and
        performance as a reference, and then set the threshold accordingly. In most cases, you can set the threshold to
        about 90% of your available CPU.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheReplicationGroupEngineCpuUtilizationAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ElastiCacheReplicationGroupRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an ElastiCache CfnReplicationGroup.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ElastiCache
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
        config_database_memory_usage_percentage_alarm: typing.Union[ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_replication_lag_alarm: typing.Union["ElastiCacheReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_engine_cpu_utilization_alarm: typing.Optional[typing.Union[ElastiCacheEngineCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[ElastiCacheRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cache_replication_group: The ElastiCache CfnReplicationGroup to monitor.
        :param config_database_memory_usage_percentage_alarm: The configuration for the DatabaseMemoryUsagePercentage alarm.
        :param config_replication_lag_alarm: The configuration for the ReplicationLag alarm.
        :param config_engine_cpu_utilization_alarm: The configuration for the EngineCPUUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6778be5913fc3575a96b5e811675a4cca0ee4185b7a9fe905f05372d639b23b6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ElastiCacheReplicationGroupRecommendedAlarmsProps(
            cache_replication_group=cache_replication_group,
            config_database_memory_usage_percentage_alarm=config_database_memory_usage_percentage_alarm,
            config_replication_lag_alarm=config_replication_lag_alarm,
            config_engine_cpu_utilization_alarm=config_engine_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmDatabaseMemoryUsagePercentage")
    def alarm_database_memory_usage_percentage(
        self,
    ) -> typing.Optional[ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarm]:
        '''The DatabaseMemoryUsagePercentage alarm.'''
        return typing.cast(typing.Optional[ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarm], jsii.get(self, "alarmDatabaseMemoryUsagePercentage"))

    @builtins.property
    @jsii.member(jsii_name="alarmEngineCpuUtilization")
    def alarm_engine_cpu_utilization(
        self,
    ) -> typing.Optional[ElastiCacheReplicationGroupEngineCpuUtilizationAlarm]:
        '''The EngineCpuUtilization alarm.'''
        return typing.cast(typing.Optional[ElastiCacheReplicationGroupEngineCpuUtilizationAlarm], jsii.get(self, "alarmEngineCpuUtilization"))

    @builtins.property
    @jsii.member(jsii_name="alarmReplicationLag")
    def alarm_replication_lag(
        self,
    ) -> typing.Optional["ElastiCacheReplicationGroupReplicationLagAlarm"]:
        '''The ReplicationLag alarm.'''
        return typing.cast(typing.Optional["ElastiCacheReplicationGroupReplicationLagAlarm"], jsii.get(self, "alarmReplicationLag"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class ElastiCacheReplicationGroupRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an ElastiCache CfnReplicationGroup.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ElastiCache
    '''

    def __init__(
        self,
        *,
        config_database_memory_usage_percentage_alarm: typing.Union[ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_replication_lag_alarm: typing.Union["ElastiCacheReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_engine_cpu_utilization_alarm: typing.Optional[typing.Union[ElastiCacheEngineCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[ElastiCacheRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_database_memory_usage_percentage_alarm: The configuration for the DatabaseMemoryUsagePercentage alarm.
        :param config_replication_lag_alarm: The configuration for the ReplicationLag alarm.
        :param config_engine_cpu_utilization_alarm: The configuration for the EngineCPUUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ElastiCacheReplicationGroupRecommendedAlarmsConfig(
            config_database_memory_usage_percentage_alarm=config_database_memory_usage_percentage_alarm,
            config_replication_lag_alarm=config_replication_lag_alarm,
            config_engine_cpu_utilization_alarm=config_engine_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f98def7f41e6788a9c9feef462a4a4dc002c4b1a314e4dfbdcbda2f753163f72)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_database_memory_usage_percentage_alarm": "configDatabaseMemoryUsagePercentageAlarm",
        "config_replication_lag_alarm": "configReplicationLagAlarm",
        "config_engine_cpu_utilization_alarm": "configEngineCpuUtilizationAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class ElastiCacheReplicationGroupRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_database_memory_usage_percentage_alarm: typing.Union[ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_replication_lag_alarm: typing.Union["ElastiCacheReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_engine_cpu_utilization_alarm: typing.Optional[typing.Union[ElastiCacheEngineCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[ElastiCacheRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an ElastiCache ReplicationGroup.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_database_memory_usage_percentage_alarm: The configuration for the DatabaseMemoryUsagePercentage alarm.
        :param config_replication_lag_alarm: The configuration for the ReplicationLag alarm.
        :param config_engine_cpu_utilization_alarm: The configuration for the EngineCPUUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_database_memory_usage_percentage_alarm, dict):
            config_database_memory_usage_percentage_alarm = ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig(**config_database_memory_usage_percentage_alarm)
        if isinstance(config_replication_lag_alarm, dict):
            config_replication_lag_alarm = ElastiCacheReplicationLagAlarmConfig(**config_replication_lag_alarm)
        if isinstance(config_engine_cpu_utilization_alarm, dict):
            config_engine_cpu_utilization_alarm = ElastiCacheEngineCpuUtilizationAlarmConfig(**config_engine_cpu_utilization_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dacc7a7a50c9083f6e577de2b328dd10aff5eaa0a740fd7cf8120cc8256a1cae)
            check_type(argname="argument config_database_memory_usage_percentage_alarm", value=config_database_memory_usage_percentage_alarm, expected_type=type_hints["config_database_memory_usage_percentage_alarm"])
            check_type(argname="argument config_replication_lag_alarm", value=config_replication_lag_alarm, expected_type=type_hints["config_replication_lag_alarm"])
            check_type(argname="argument config_engine_cpu_utilization_alarm", value=config_engine_cpu_utilization_alarm, expected_type=type_hints["config_engine_cpu_utilization_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_database_memory_usage_percentage_alarm": config_database_memory_usage_percentage_alarm,
            "config_replication_lag_alarm": config_replication_lag_alarm,
        }
        if config_engine_cpu_utilization_alarm is not None:
            self._values["config_engine_cpu_utilization_alarm"] = config_engine_cpu_utilization_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_database_memory_usage_percentage_alarm(
        self,
    ) -> ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig:
        '''The configuration for the DatabaseMemoryUsagePercentage alarm.'''
        result = self._values.get("config_database_memory_usage_percentage_alarm")
        assert result is not None, "Required property 'config_database_memory_usage_percentage_alarm' is missing"
        return typing.cast(ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, result)

    @builtins.property
    def config_replication_lag_alarm(self) -> "ElastiCacheReplicationLagAlarmConfig":
        '''The configuration for the ReplicationLag alarm.'''
        result = self._values.get("config_replication_lag_alarm")
        assert result is not None, "Required property 'config_replication_lag_alarm' is missing"
        return typing.cast("ElastiCacheReplicationLagAlarmConfig", result)

    @builtins.property
    def config_engine_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[ElastiCacheEngineCpuUtilizationAlarmConfig]:
        '''The configuration for the EngineCPUUtilization alarm.'''
        result = self._values.get("config_engine_cpu_utilization_alarm")
        return typing.cast(typing.Optional[ElastiCacheEngineCpuUtilizationAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[ElastiCacheRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[ElastiCacheRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheReplicationGroupRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupRecommendedAlarmsProps",
    jsii_struct_bases=[ElastiCacheReplicationGroupRecommendedAlarmsConfig],
    name_mapping={
        "config_database_memory_usage_percentage_alarm": "configDatabaseMemoryUsagePercentageAlarm",
        "config_replication_lag_alarm": "configReplicationLagAlarm",
        "config_engine_cpu_utilization_alarm": "configEngineCpuUtilizationAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "cache_replication_group": "cacheReplicationGroup",
    },
)
class ElastiCacheReplicationGroupRecommendedAlarmsProps(
    ElastiCacheReplicationGroupRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config_database_memory_usage_percentage_alarm: typing.Union[ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_replication_lag_alarm: typing.Union["ElastiCacheReplicationLagAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_engine_cpu_utilization_alarm: typing.Optional[typing.Union[ElastiCacheEngineCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[ElastiCacheRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
    ) -> None:
        '''Properties for the ElastiCacheReplicationGroupRecommendedAlarms construct.

        :param config_database_memory_usage_percentage_alarm: The configuration for the DatabaseMemoryUsagePercentage alarm.
        :param config_replication_lag_alarm: The configuration for the ReplicationLag alarm.
        :param config_engine_cpu_utilization_alarm: The configuration for the EngineCPUUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param cache_replication_group: The ElastiCache CfnReplicationGroup to monitor.
        '''
        if isinstance(config_database_memory_usage_percentage_alarm, dict):
            config_database_memory_usage_percentage_alarm = ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig(**config_database_memory_usage_percentage_alarm)
        if isinstance(config_replication_lag_alarm, dict):
            config_replication_lag_alarm = ElastiCacheReplicationLagAlarmConfig(**config_replication_lag_alarm)
        if isinstance(config_engine_cpu_utilization_alarm, dict):
            config_engine_cpu_utilization_alarm = ElastiCacheEngineCpuUtilizationAlarmConfig(**config_engine_cpu_utilization_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4901d4925a0e7dfde9a1eda23277c20746051b03baba9d17efb30c3046460e91)
            check_type(argname="argument config_database_memory_usage_percentage_alarm", value=config_database_memory_usage_percentage_alarm, expected_type=type_hints["config_database_memory_usage_percentage_alarm"])
            check_type(argname="argument config_replication_lag_alarm", value=config_replication_lag_alarm, expected_type=type_hints["config_replication_lag_alarm"])
            check_type(argname="argument config_engine_cpu_utilization_alarm", value=config_engine_cpu_utilization_alarm, expected_type=type_hints["config_engine_cpu_utilization_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument cache_replication_group", value=cache_replication_group, expected_type=type_hints["cache_replication_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_database_memory_usage_percentage_alarm": config_database_memory_usage_percentage_alarm,
            "config_replication_lag_alarm": config_replication_lag_alarm,
            "cache_replication_group": cache_replication_group,
        }
        if config_engine_cpu_utilization_alarm is not None:
            self._values["config_engine_cpu_utilization_alarm"] = config_engine_cpu_utilization_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_database_memory_usage_percentage_alarm(
        self,
    ) -> ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig:
        '''The configuration for the DatabaseMemoryUsagePercentage alarm.'''
        result = self._values.get("config_database_memory_usage_percentage_alarm")
        assert result is not None, "Required property 'config_database_memory_usage_percentage_alarm' is missing"
        return typing.cast(ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, result)

    @builtins.property
    def config_replication_lag_alarm(self) -> "ElastiCacheReplicationLagAlarmConfig":
        '''The configuration for the ReplicationLag alarm.'''
        result = self._values.get("config_replication_lag_alarm")
        assert result is not None, "Required property 'config_replication_lag_alarm' is missing"
        return typing.cast("ElastiCacheReplicationLagAlarmConfig", result)

    @builtins.property
    def config_engine_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[ElastiCacheEngineCpuUtilizationAlarmConfig]:
        '''The configuration for the EngineCPUUtilization alarm.'''
        result = self._values.get("config_engine_cpu_utilization_alarm")
        return typing.cast(typing.Optional[ElastiCacheEngineCpuUtilizationAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[ElastiCacheRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[ElastiCacheRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def cache_replication_group(
        self,
    ) -> _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup:
        '''The ElastiCache CfnReplicationGroup to monitor.'''
        result = self._values.get("cache_replication_group")
        assert result is not None, "Required property 'cache_replication_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheReplicationGroupRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ElastiCacheReplicationGroupReplicationLagAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupReplicationLagAlarm",
):
    '''This alarm helps to monitor the replication health of your ElastiCache cluster.

    A high replication lag means that the primary node or the replica can't keep up the pace of the replication. If your write
    activity is too high, consider scaling your cluster out by adding more primary nodes, or scaling it up by using a larger node type.
    Refer to {@link https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/Scaling.html Scaling ElastiCache for Redis OSS clusters} for
    details. If your read replicas are overloaded by the amount of read requests,
    consider adding more read replicas.

    The alarm is triggered when the number of milliseconds exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cache_replication_group: The ElastiCache CfnReplicationGroup to monitor.
        :param threshold: Set the threshold according to your application's requirements and the potential impact of replication lag. You should consider your application's expected write rates and network conditions for the acceptable replication lag.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a delay between data updates on the primary node and their synchronization to replica node. It helps to ensure data consistency of a read replica cluster node.
        :param alarm_name: The alarm name. Default: - logicalId + ' - ReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__23785f2a0a27d7f49cd78c1bb124335276aca8e839174ca6154b628b14dd04e5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ElastiCacheReplicationGroupReplicationLagAlarmProps(
            cache_replication_group=cache_replication_group,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationLagAlarmConfig",
    jsii_struct_bases=[ElastiCacheAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class ElastiCacheReplicationLagAlarmConfig(ElastiCacheAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the ReplicationLag alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to your application's requirements and the potential impact of replication lag. You should consider your application's expected write rates and network conditions for the acceptable replication lag.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a delay between data updates on the primary node and their synchronization to replica node. It helps to ensure data consistency of a read replica cluster node.
        :param alarm_name: The alarm name. Default: - logicalId + ' - ReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4c8342630d0f7958814da4cbad3cff13ca5387a6004060a989ddf087242ebb3b)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to your application's requirements and the potential impact of replication lag.

        You should
        consider your application's expected write rates and network conditions for the acceptable replication lag.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect a delay between data updates on the primary node and their synchronization to replica node.
        It helps to ensure data consistency of a read replica cluster node.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - logicalId + ' - ReplicationLag'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheReplicationLagAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class FargateService(
    _aws_cdk_aws_ecs_ceddda9d.FargateService,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.FargateService",
):
    '''An extension for the FargateService construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        task_definition: _aws_cdk_aws_ecs_ceddda9d.TaskDefinition,
        assign_public_ip: typing.Optional[builtins.bool] = None,
        availability_zone_rebalancing: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.AvailabilityZoneRebalancing] = None,
        platform_version: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.FargatePlatformVersion] = None,
        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
        cluster: _aws_cdk_aws_ecs_ceddda9d.ICluster,
        capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ecs_ceddda9d.CapacityProviderStrategy, typing.Dict[builtins.str, typing.Any]]]] = None,
        circuit_breaker: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.DeploymentCircuitBreaker, typing.Dict[builtins.str, typing.Any]]] = None,
        cloud_map_options: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.CloudMapOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        deployment_alarms: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.DeploymentAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        deployment_controller: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.DeploymentController, typing.Dict[builtins.str, typing.Any]]] = None,
        desired_count: typing.Optional[jsii.Number] = None,
        enable_ecs_managed_tags: typing.Optional[builtins.bool] = None,
        enable_execute_command: typing.Optional[builtins.bool] = None,
        health_check_grace_period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        max_healthy_percent: typing.Optional[jsii.Number] = None,
        min_healthy_percent: typing.Optional[jsii.Number] = None,
        propagate_tags: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.PropagatedTagSource] = None,
        service_connect_configuration: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.ServiceConnectProps, typing.Dict[builtins.str, typing.Any]]] = None,
        service_name: typing.Optional[builtins.str] = None,
        task_definition_revision: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.TaskDefinitionRevision] = None,
        volume_configurations: typing.Optional[typing.Sequence[_aws_cdk_aws_ecs_ceddda9d.ServiceManagedVolume]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param task_definition: The task definition to use for tasks in the service. [disable-awslint:ref-via-interface]
        :param assign_public_ip: Specifies whether the task's elastic network interface receives a public IP address. If true, each task will receive a public IP address. Default: false
        :param availability_zone_rebalancing: Whether to use Availability Zone rebalancing for the service. If enabled, ``maxHealthyPercent`` must be greater than 100, and the service must not be a target of a Classic Load Balancer. Default: AvailabilityZoneRebalancing.DISABLED
        :param platform_version: The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest
        :param security_groups: The security groups to associate with the service. If you do not specify a security group, a new security group is created. Default: - A new security group is created.
        :param vpc_subnets: The subnets to associate with the service. Default: - Public subnets if ``assignPublicIp`` is set, otherwise the first available one of Private, Isolated, Public, in that order.
        :param cluster: The name of the cluster that hosts the service.
        :param capacity_provider_strategies: A list of Capacity Provider strategies used to place a service. Default: - undefined
        :param circuit_breaker: Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled
        :param cloud_map_options: The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.
        :param deployment_alarms: The alarm(s) to monitor during deployment, and behavior to apply if at least one enters a state of alarm during the deployment or bake time. Default: - No alarms will be monitored during deployment.
        :param deployment_controller: Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)
        :param desired_count: The desired number of instantiations of the task definition to keep running on the service. Default: - When creating the service, default is 1; when updating the service, default uses the current task number.
        :param enable_ecs_managed_tags: Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false
        :param enable_execute_command: Whether to enable the ability to execute into a container. Default: - undefined
        :param health_check_grace_period: The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set
        :param max_healthy_percent: The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200
        :param min_healthy_percent: The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50
        :param propagate_tags: Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Valid values are: PropagatedTagSource.SERVICE, PropagatedTagSource.TASK_DEFINITION or PropagatedTagSource.NONE Default: PropagatedTagSource.NONE
        :param service_connect_configuration: Configuration for Service Connect. Default: No ports are advertised via Service Connect on this service, and the service cannot make requests to other services via Service Connect.
        :param service_name: The name of the service. Default: - CloudFormation-generated name.
        :param task_definition_revision: Revision number for the task definition or ``latest`` to use the latest active task revision. Default: - Uses the revision of the passed task definition deployed by CloudFormation
        :param volume_configurations: Configuration details for a volume used by the service. This allows you to specify details about the EBS volume that can be attched to ECS tasks. Default: - undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a925b369fa7502a1278f860002de54ff34491bf2318e7394cdef10811ddedf00)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_ecs_ceddda9d.FargateServiceProps(
            task_definition=task_definition,
            assign_public_ip=assign_public_ip,
            availability_zone_rebalancing=availability_zone_rebalancing,
            platform_version=platform_version,
            security_groups=security_groups,
            vpc_subnets=vpc_subnets,
            cluster=cluster,
            capacity_provider_strategies=capacity_provider_strategies,
            circuit_breaker=circuit_breaker,
            cloud_map_options=cloud_map_options,
            deployment_alarms=deployment_alarms,
            deployment_controller=deployment_controller,
            desired_count=desired_count,
            enable_ecs_managed_tags=enable_ecs_managed_tags,
            enable_execute_command=enable_execute_command,
            health_check_grace_period=health_check_grace_period,
            max_healthy_percent=max_healthy_percent,
            min_healthy_percent=min_healthy_percent,
            propagate_tags=propagate_tags,
            service_connect_configuration=service_connect_configuration,
            service_name=service_name,
            task_definition_revision=task_definition_revision,
            volume_configurations=volume_configurations,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmCpuUtilization")
    def alarm_cpu_utilization(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> EcsServiceCpuUtilizationAlarm:
        '''Creates an alarm that monitors the CPU utilization for the Fargate service.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization for the ECS service. Consistent high CPU utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The service metrics for CPU utilization might exceed 100% utilization. However, we recommend that you monitor the metric for high CPU utilization to avoid impacting other services. Set the threshold to about 90-95%. We recommend that you update your task definitions to reflect actual usage to prevent future issues with other services. Default: 90
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = EcsCpuUtilizationAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(EcsServiceCpuUtilizationAlarm, jsii.invoke(self, "alarmCpuUtilization", [props]))

    @jsii.member(jsii_name="alarmEphemeralStorageUtilized")
    def alarm_ephemeral_storage_utilized(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> EcsServiceEphemeralStorageUtilizedAlarm:
        '''Creates an alarm that monitors the ephemeral storage utilized for the Fargate service.

        :param threshold: The value in GB against which the specified statistic is compared. Set the threshold to about 90% of the ephemeral storage size. You can adjust this value based on your acceptable ephemeral storage utilization of the Fargate cluster. For some systems, a consistently high ephemeral storage utilized might be normal, while for others, it might lead to failure of the container.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high ephemeral storage usage for the Fargate cluster. Consistent high ephemeral storage utilized can indicate that the disk is full and it might lead to failure of the container.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - EphemeralStorageUtilized'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = EcsEphemeralStorageUtilizedAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(EcsServiceEphemeralStorageUtilizedAlarm, jsii.invoke(self, "alarmEphemeralStorageUtilized", [props]))

    @jsii.member(jsii_name="alarmMemoryUtilization")
    def alarm_memory_utilization(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> EcsServiceMemoryUtilizationAlarm:
        '''Creates an alarm that monitors the memory utilization for the Fargate service.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization for the ECS service. Consistent high memory utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - MemoryUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The memory utilization is measured as the total memory in use by the tasks that belong to the service, divided by the total memory reserved for the tasks that belong to the service. Default: 90
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = EcsMemoryUtilizationAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(EcsServiceMemoryUtilizationAlarm, jsii.invoke(self, "alarmMemoryUtilization", [props]))

    @jsii.member(jsii_name="alarmRunningTaskCount")
    def alarm_running_task_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> EcsServiceRunningTaskCountAlarm:
        '''Creates an alarm that monitors the number of task running.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect whether the number of running tasks are too low. A consistent low running task count can indicate ECS service deployment or performance issues.
        :param alarm_name: The alarm name. Default: - clusterName + ' - ' + serviceName + ' - RunningTaskCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You can adjust the threshold based on the minimum running task count of the ECS service. If the running task count is 0, the Amazon ECS service will be unavailable. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = EcsRunningTaskCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(EcsServiceRunningTaskCountAlarm, jsii.invoke(self, "alarmRunningTaskCount", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_ephemeral_storage_utilized_alarm: typing.Union[EcsEphemeralStorageUtilizedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[EcsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_memory_utilization_alarm: typing.Optional[typing.Union[EcsMemoryUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_running_task_count_alarm: typing.Optional[typing.Union[EcsRunningTaskCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[EcsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> EcsServiceRecommendedAlarms:
        '''Creates the recommended alarms for the ECS service.

        :param config_ephemeral_storage_utilized_alarm: The configuration for the EphemeralStorageUtilized alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_memory_utilization_alarm: The configuration for the MemoryUtilization alarm.
        :param config_running_task_count_alarm: The configuration for the RunningTaskCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ECS
        '''
        props = EcsServiceRecommendedAlarmsConfig(
            config_ephemeral_storage_utilized_alarm=config_ephemeral_storage_utilized_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            config_memory_utilization_alarm=config_memory_utilization_alarm,
            config_running_task_count_alarm=config_running_task_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(EcsServiceRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))


class FileSystem(
    _aws_cdk_aws_efs_ceddda9d.FileSystem,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.FileSystem",
):
    '''An extension for the FileSystem construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
        allow_anonymous_access: typing.Optional[builtins.bool] = None,
        enable_automatic_backups: typing.Optional[builtins.bool] = None,
        encrypted: typing.Optional[builtins.bool] = None,
        file_system_name: typing.Optional[builtins.str] = None,
        file_system_policy: typing.Optional[_aws_cdk_aws_iam_ceddda9d.PolicyDocument] = None,
        kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        lifecycle_policy: typing.Optional[_aws_cdk_aws_efs_ceddda9d.LifecyclePolicy] = None,
        one_zone: typing.Optional[builtins.bool] = None,
        out_of_infrequent_access_policy: typing.Optional[_aws_cdk_aws_efs_ceddda9d.OutOfInfrequentAccessPolicy] = None,
        performance_mode: typing.Optional[_aws_cdk_aws_efs_ceddda9d.PerformanceMode] = None,
        provisioned_throughput_per_second: typing.Optional[_aws_cdk_ceddda9d.Size] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        replication_configuration: typing.Optional[_aws_cdk_aws_efs_ceddda9d.ReplicationConfiguration] = None,
        replication_overwrite_protection: typing.Optional[_aws_cdk_aws_efs_ceddda9d.ReplicationOverwriteProtection] = None,
        security_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup] = None,
        throughput_mode: typing.Optional[_aws_cdk_aws_efs_ceddda9d.ThroughputMode] = None,
        transition_to_archive_policy: typing.Optional[_aws_cdk_aws_efs_ceddda9d.LifecyclePolicy] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc: VPC to launch the file system in.
        :param allow_anonymous_access: Allow access from anonymous client that doesn't use IAM authentication. Default: false when using ``grantRead``, ``grantWrite``, ``grantRootAccess`` or set ``@aws-cdk/aws-efs:denyAnonymousAccess`` feature flag, otherwise true
        :param enable_automatic_backups: Whether to enable automatic backups for the file system. Default: false
        :param encrypted: Defines if the data at rest in the file system is encrypted or not. Default: - If your application has the '@aws-cdk/aws-efs:defaultEncryptionAtRest' feature flag set, the default is true, otherwise, the default is false.
        :param file_system_name: The file system's name. Default: - CDK generated name
        :param file_system_policy: File system policy is an IAM resource policy used to control NFS access to an EFS file system. Default: none
        :param kms_key: The KMS key used for encryption. This is required to encrypt the data at rest if Default: - if 'encrypted' is true, the default key for EFS (/aws/elasticfilesystem) is used
        :param lifecycle_policy: A policy used by EFS lifecycle management to transition files to the Infrequent Access (IA) storage class. Default: - None. EFS will not transition files to the IA storage class.
        :param one_zone: Whether this is a One Zone file system. If enabled, ``performanceMode`` must be set to ``GENERAL_PURPOSE`` and ``vpcSubnets`` cannot be set. Default: false
        :param out_of_infrequent_access_policy: A policy used by EFS lifecycle management to transition files from Infrequent Access (IA) storage class to primary storage class. Default: - None. EFS will not transition files from IA storage to primary storage.
        :param performance_mode: The performance mode that the file system will operate under. An Amazon EFS file system's performance mode can't be changed after the file system has been created. Updating this property will replace the file system. Default: PerformanceMode.GENERAL_PURPOSE
        :param provisioned_throughput_per_second: Provisioned throughput for the file system. This is a required property if the throughput mode is set to PROVISIONED. Must be at least 1MiB/s. Default: - none, errors out
        :param removal_policy: The removal policy to apply to the file system. Default: RemovalPolicy.RETAIN
        :param replication_configuration: Replication configuration for the file system. Default: - no replication
        :param replication_overwrite_protection: Whether to enable the filesystem's replication overwrite protection or not. Set false if you want to create a read-only filesystem for use as a replication destination. Default: ReplicationOverwriteProtection.ENABLED
        :param security_group: Security Group to assign to this file system. Default: - creates new security group which allows all outbound traffic
        :param throughput_mode: Enum to mention the throughput mode of the file system. Default: ThroughputMode.BURSTING
        :param transition_to_archive_policy: The number of days after files were last accessed in primary storage (the Standard storage class) at which to move them to Archive storage. Metadata operations such as listing the contents of a directory don't count as file access events. Default: - None. EFS will not transition files to Archive storage class.
        :param vpc_subnets: Which subnets to place the mount target in the VPC. Default: - the Vpc default strategy if not specified
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__384fdb3a399ee5975ce3e6efdf8b8fa9562e3b74d41f06b276e3d10bcf50f833)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_efs_ceddda9d.FileSystemProps(
            vpc=vpc,
            allow_anonymous_access=allow_anonymous_access,
            enable_automatic_backups=enable_automatic_backups,
            encrypted=encrypted,
            file_system_name=file_system_name,
            file_system_policy=file_system_policy,
            kms_key=kms_key,
            lifecycle_policy=lifecycle_policy,
            one_zone=one_zone,
            out_of_infrequent_access_policy=out_of_infrequent_access_policy,
            performance_mode=performance_mode,
            provisioned_throughput_per_second=provisioned_throughput_per_second,
            removal_policy=removal_policy,
            replication_configuration=replication_configuration,
            replication_overwrite_protection=replication_overwrite_protection,
            security_group=security_group,
            throughput_mode=throughput_mode,
            transition_to_archive_policy=transition_to_archive_policy,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmBurstCreditBalance")
    def alarm_burst_credit_balance(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> EfsFileSystemBurstCreditBalanceAlarm:
        '''Creates an alarm that monitors the BurstCreditBalance for the EFS fileSystem.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect low burst credit balance of the file system. Consistent low burst credit balance can be an indicator of the slowing down in throughput and increase in I/O latency.
        :param alarm_name: The alarm name. Default: - fileSystemId + ' - BurstCreditBalance'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param threshold: When the file system run out of burst credits and even if the baseline throughput rate is lower, EFS continues to provide a metered throughput of 1 MiBps to all file systems. However, it is recommended that the metric is monitored for low burst credit balance to avoid the file system acting as resource bottleneck for the applications. The threshold can be set around 0 bytes. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = EfsBurstCreditBalanceAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(EfsFileSystemBurstCreditBalanceAlarm, jsii.invoke(self, "alarmBurstCreditBalance", [props]))

    @jsii.member(jsii_name="alarmPercentIOLimit")
    def alarm_percent_io_limit(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> EfsFileSystemPercentIOLimitAlarm:
        '''Creates an alarm that monitors the PercentIOLimit for the EFS fileSystem.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the file system is to reach the I/O limit of the General Purpose performance mode. Consistent high I/O percentage can be an indicator of the file system cannot scale with respect to I/O requests enough and the file system can be a resource bottleneck for the applications that use the file system.
        :param alarm_name: The alarm name. Default: - fileSystemId + ' - PercentIOLimit'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param threshold: When the file system reaches its I/O limit, it may respond to read and write requests slower. Therefore, it is recommended that the metric is monitored to avoid impacting applications that use the file system. The threshold can be set around 100%. However, this value can be adjusted to a lower value based on file system characteristics. Default: 100
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = EfsPercentIOLimitAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(EfsFileSystemPercentIOLimitAlarm, jsii.invoke(self, "alarmPercentIOLimit", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_burst_credit_balance_alarm: typing.Optional[typing.Union[EfsBurstCreditBalanceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_percent_io_limit_alarm: typing.Optional[typing.Union[EfsPercentIOLimitAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[EfsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> EfsFileSystemRecommendedAlarms:
        '''Creates the recommended alarms for the EFS FileSystem.

        :param config_burst_credit_balance_alarm: The configuration for the BurstCreditBalance alarm.
        :param config_percent_io_limit_alarm: The configuration for the PercentIOLimit alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#EFS
        '''
        props = EfsFileSystemRecommendedAlarmsConfig(
            config_burst_credit_balance_alarm=config_burst_credit_balance_alarm,
            config_percent_io_limit_alarm=config_percent_io_limit_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(EfsFileSystemRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))


class Function(
    _aws_cdk_aws_lambda_ceddda9d.Function,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Function",
):
    '''An extension of the Lambda function construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        code: _aws_cdk_aws_lambda_ceddda9d.Code,
        handler: builtins.str,
        runtime: _aws_cdk_aws_lambda_ceddda9d.Runtime,
        adot_instrumentation: typing.Optional[typing.Union[_aws_cdk_aws_lambda_ceddda9d.AdotInstrumentationConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        allow_all_ipv6_outbound: typing.Optional[builtins.bool] = None,
        allow_all_outbound: typing.Optional[builtins.bool] = None,
        allow_public_subnet: typing.Optional[builtins.bool] = None,
        application_log_level: typing.Optional[builtins.str] = None,
        application_log_level_v2: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.ApplicationLogLevel] = None,
        architecture: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.Architecture] = None,
        code_signing_config: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.ICodeSigningConfig] = None,
        current_version_options: typing.Optional[typing.Union[_aws_cdk_aws_lambda_ceddda9d.VersionOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        dead_letter_queue: typing.Optional[_aws_cdk_aws_sqs_ceddda9d.IQueue] = None,
        dead_letter_queue_enabled: typing.Optional[builtins.bool] = None,
        dead_letter_topic: typing.Optional[_aws_cdk_aws_sns_ceddda9d.ITopic] = None,
        description: typing.Optional[builtins.str] = None,
        environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        environment_encryption: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        ephemeral_storage_size: typing.Optional[_aws_cdk_ceddda9d.Size] = None,
        events: typing.Optional[typing.Sequence[_aws_cdk_aws_lambda_ceddda9d.IEventSource]] = None,
        filesystem: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.FileSystem] = None,
        function_name: typing.Optional[builtins.str] = None,
        initial_policy: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]] = None,
        insights_version: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.LambdaInsightsVersion] = None,
        ipv6_allowed_for_dual_stack: typing.Optional[builtins.bool] = None,
        layers: typing.Optional[typing.Sequence[_aws_cdk_aws_lambda_ceddda9d.ILayerVersion]] = None,
        log_format: typing.Optional[builtins.str] = None,
        logging_format: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.LoggingFormat] = None,
        log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
        log_removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        log_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
        log_retention_retry_options: typing.Optional[typing.Union[_aws_cdk_aws_lambda_ceddda9d.LogRetentionRetryOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        log_retention_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        memory_size: typing.Optional[jsii.Number] = None,
        params_and_secrets: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.ParamsAndSecretsLayerVersion] = None,
        profiling: typing.Optional[builtins.bool] = None,
        profiling_group: typing.Optional[_aws_cdk_aws_codeguruprofiler_ceddda9d.IProfilingGroup] = None,
        recursive_loop: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.RecursiveLoop] = None,
        reserved_concurrent_executions: typing.Optional[jsii.Number] = None,
        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        runtime_management_mode: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.RuntimeManagementMode] = None,
        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
        snap_start: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.SnapStartConf] = None,
        system_log_level: typing.Optional[builtins.str] = None,
        system_log_level_v2: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.SystemLogLevel] = None,
        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        tracing: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.Tracing] = None,
        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
        max_event_age: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        on_failure: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.IDestination] = None,
        on_success: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.IDestination] = None,
        retry_attempts: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param code: The source code of your Lambda function. You can point to a file in an Amazon Simple Storage Service (Amazon S3) bucket or specify your source code as inline text.
        :param handler: The name of the method within your code that Lambda calls to execute your function. The format includes the file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information, see https://docs.aws.amazon.com/lambda/latest/dg/foundation-progmodel.html. Use ``Handler.FROM_IMAGE`` when defining a function from a Docker image. NOTE: If you specify your source code as inline text by specifying the ZipFile property within the Code property, specify index.function_name as the handler.
        :param runtime: The runtime environment for the Lambda function that you are uploading. For valid values, see the Runtime property in the AWS Lambda Developer Guide. Use ``Runtime.FROM_IMAGE`` when defining a function from a Docker image.
        :param adot_instrumentation: Specify the configuration of AWS Distro for OpenTelemetry (ADOT) instrumentation. Default: - No ADOT instrumentation
        :param allow_all_ipv6_outbound: Whether to allow the Lambda to send all ipv6 network traffic. If set to true, there will only be a single egress rule which allows all outbound ipv6 traffic. If set to false, you must individually add traffic rules to allow the Lambda to connect to network targets using ipv6. Do not specify this property if the ``securityGroups`` or ``securityGroup`` property is set. Instead, configure ``allowAllIpv6Outbound`` directly on the security group. Default: false
        :param allow_all_outbound: Whether to allow the Lambda to send all network traffic (except ipv6). If set to false, you must individually add traffic rules to allow the Lambda to connect to network targets. Do not specify this property if the ``securityGroups`` or ``securityGroup`` property is set. Instead, configure ``allowAllOutbound`` directly on the security group. Default: true
        :param allow_public_subnet: Lambda Functions in a public subnet can NOT access the internet. Use this property to acknowledge this limitation and still place the function in a public subnet. Default: false
        :param application_log_level: (deprecated) Sets the application log level for the function. Default: "INFO"
        :param application_log_level_v2: Sets the application log level for the function. Default: ApplicationLogLevel.INFO
        :param architecture: The system architectures compatible with this lambda function. Default: Architecture.X86_64
        :param code_signing_config: Code signing config associated with this function. Default: - Not Sign the Code
        :param current_version_options: Options for the ``lambda.Version`` resource automatically created by the ``fn.currentVersion`` method. Default: - default options as described in ``VersionOptions``
        :param dead_letter_queue: The SQS queue to use if DLQ is enabled. If SNS topic is desired, specify ``deadLetterTopic`` property instead. Default: - SQS queue with 14 day retention period if ``deadLetterQueueEnabled`` is ``true``
        :param dead_letter_queue_enabled: Enabled DLQ. If ``deadLetterQueue`` is undefined, an SQS queue with default options will be defined for your Function. Default: - false unless ``deadLetterQueue`` is set, which implies DLQ is enabled.
        :param dead_letter_topic: The SNS topic to use as a DLQ. Note that if ``deadLetterQueueEnabled`` is set to ``true``, an SQS queue will be created rather than an SNS topic. Using an SNS topic as a DLQ requires this property to be set explicitly. Default: - no SNS topic
        :param description: A description of the function. Default: - No description.
        :param environment: Key-value pairs that Lambda caches and makes available for your Lambda functions. Use environment variables to apply configuration changes, such as test and production environment configurations, without changing your Lambda function source code. Default: - No environment variables.
        :param environment_encryption: The AWS KMS key that's used to encrypt your function's environment variables. Default: - AWS Lambda creates and uses an AWS managed customer master key (CMK).
        :param ephemeral_storage_size: The size of the functions /tmp directory in MiB. Default: 512 MiB
        :param events: Event sources for this function. You can also add event sources using ``addEventSource``. Default: - No event sources.
        :param filesystem: The filesystem configuration for the lambda function. Default: - will not mount any filesystem
        :param function_name: A name for the function. Default: - AWS CloudFormation generates a unique physical ID and uses that ID for the function's name. For more information, see Name Type.
        :param initial_policy: Initial policy statements to add to the created Lambda Role. You can call ``addToRolePolicy`` to the created lambda to add statements post creation. Default: - No policy statements are added to the created Lambda role.
        :param insights_version: Specify the version of CloudWatch Lambda insights to use for monitoring. Default: - No Lambda Insights
        :param ipv6_allowed_for_dual_stack: Allows outbound IPv6 traffic on VPC functions that are connected to dual-stack subnets. Only used if 'vpc' is supplied. Default: false
        :param layers: A list of layers to add to the function's execution environment. You can configure your Lambda function to pull in additional code during initialization in the form of layers. Layers are packages of libraries or other dependencies that can be used by multiple functions. Default: - No layers.
        :param log_format: (deprecated) Sets the logFormat for the function. Default: "Text"
        :param logging_format: Sets the loggingFormat for the function. Default: LoggingFormat.TEXT
        :param log_group: The log group the function sends logs to. By default, Lambda functions send logs to an automatically created default log group named /aws/lambda/<function name>. However you cannot change the properties of this auto-created log group using the AWS CDK, e.g. you cannot set a different log retention. Use the ``logGroup`` property to create a fully customizable LogGroup ahead of time, and instruct the Lambda function to send logs to it. Providing a user-controlled log group was rolled out to commercial regions on 2023-11-16. If you are deploying to another type of region, please check regional availability first. Default: ``/aws/lambda/${this.functionName}`` - default log group created by Lambda
        :param log_removal_policy: (deprecated) Determine the removal policy of the log group that is auto-created by this construct. Normally you want to retain the log group so you can diagnose issues from logs even after a deployment that no longer includes the log group. In that case, use the normal date-based retention policy to age out your logs. Default: RemovalPolicy.Retain
        :param log_retention: (deprecated) The number of days log events are kept in CloudWatch Logs. When updating this property, unsetting it doesn't remove the log retention policy. To remove the retention policy, set the value to ``INFINITE``. This is a legacy API and we strongly recommend you move away from it if you can. Instead create a fully customizable log group with ``logs.LogGroup`` and use the ``logGroup`` property to instruct the Lambda function to send logs to it. Migrating from ``logRetention`` to ``logGroup`` will cause the name of the log group to change. Users and code and referencing the name verbatim will have to adjust. In AWS CDK code, you can access the log group name directly from the LogGroup construct:: import * as logs from 'aws-cdk-lib/aws-logs'; declare const myLogGroup: logs.LogGroup; myLogGroup.logGroupName; Default: logs.RetentionDays.INFINITE
        :param log_retention_retry_options: When log retention is specified, a custom resource attempts to create the CloudWatch log group. These options control the retry policy when interacting with CloudWatch APIs. This is a legacy API and we strongly recommend you migrate to ``logGroup`` if you can. ``logGroup`` allows you to create a fully customizable log group and instruct the Lambda function to send logs to it. Default: - Default AWS SDK retry options.
        :param log_retention_role: The IAM role for the Lambda function associated with the custom resource that sets the retention policy. This is a legacy API and we strongly recommend you migrate to ``logGroup`` if you can. ``logGroup`` allows you to create a fully customizable log group and instruct the Lambda function to send logs to it. Default: - A new role is created.
        :param memory_size: The amount of memory, in MB, that is allocated to your Lambda function. Lambda uses this value to proportionally allocate the amount of CPU power. For more information, see Resource Model in the AWS Lambda Developer Guide. Default: 128
        :param params_and_secrets: Specify the configuration of Parameters and Secrets Extension. Default: - No Parameters and Secrets Extension
        :param profiling: Enable profiling. Default: - No profiling.
        :param profiling_group: Profiling Group. Default: - A new profiling group will be created if ``profiling`` is set.
        :param recursive_loop: Sets the Recursive Loop Protection for Lambda Function. It lets Lambda detect and terminate unintended recursive loops. Default: RecursiveLoop.Terminate
        :param reserved_concurrent_executions: The maximum of concurrent executions you want to reserve for the function. Default: - No specific limit - account limit.
        :param role: Lambda execution role. This is the role that will be assumed by the function upon execution. It controls the permissions that the function will have. The Role must be assumable by the 'lambda.amazonaws.com' service principal. The default Role automatically has permissions granted for Lambda execution. If you provide a Role, you must add the relevant AWS managed policies yourself. The relevant managed policies are "service-role/AWSLambdaBasicExecutionRole" and "service-role/AWSLambdaVPCAccessExecutionRole". Default: - A unique role will be generated for this lambda function. Both supplied and generated roles can always be changed by calling ``addToRolePolicy``.
        :param runtime_management_mode: Sets the runtime management configuration for a function's version. Default: Auto
        :param security_groups: The list of security groups to associate with the Lambda's network interfaces. Only used if 'vpc' is supplied. Default: - If the function is placed within a VPC and a security group is not specified, either by this or securityGroup prop, a dedicated security group will be created for this function.
        :param snap_start: Enable SnapStart for Lambda Function. SnapStart is currently supported for Java 11, Java 17, Python 3.12, Python 3.13, and .NET 8 runtime Default: - No snapstart
        :param system_log_level: (deprecated) Sets the system log level for the function. Default: "INFO"
        :param system_log_level_v2: Sets the system log level for the function. Default: SystemLogLevel.INFO
        :param timeout: The function execution time (in seconds) after which Lambda terminates the function. Because the execution time affects cost, set this value based on the function's expected execution time. Default: Duration.seconds(3)
        :param tracing: Enable AWS X-Ray Tracing for Lambda Function. Default: Tracing.Disabled
        :param vpc: VPC network to place Lambda network interfaces. Specify this if the Lambda function needs to access resources in a VPC. This is required when ``vpcSubnets`` is specified. Default: - Function is not placed within a VPC.
        :param vpc_subnets: Where to place the network interfaces within the VPC. This requires ``vpc`` to be specified in order for interfaces to actually be placed in the subnets. If ``vpc`` is not specify, this will raise an error. Note: Internet access for Lambda Functions requires a NAT Gateway, so picking public subnets is not allowed (unless ``allowPublicSubnet`` is set to ``true``). Default: - the Vpc default strategy if not specified
        :param max_event_age: The maximum age of a request that Lambda sends to a function for processing. Minimum: 60 seconds Maximum: 6 hours Default: Duration.hours(6)
        :param on_failure: The destination for failed invocations. Default: - no destination
        :param on_success: The destination for successful invocations. Default: - no destination
        :param retry_attempts: The maximum number of times to retry when the function returns an error. Minimum: 0 Maximum: 2 Default: 2
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__300e1b7b513ed361a8dde12f23c6adb84738ebf013386259a5dbea5024022ffa)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_lambda_ceddda9d.FunctionProps(
            code=code,
            handler=handler,
            runtime=runtime,
            adot_instrumentation=adot_instrumentation,
            allow_all_ipv6_outbound=allow_all_ipv6_outbound,
            allow_all_outbound=allow_all_outbound,
            allow_public_subnet=allow_public_subnet,
            application_log_level=application_log_level,
            application_log_level_v2=application_log_level_v2,
            architecture=architecture,
            code_signing_config=code_signing_config,
            current_version_options=current_version_options,
            dead_letter_queue=dead_letter_queue,
            dead_letter_queue_enabled=dead_letter_queue_enabled,
            dead_letter_topic=dead_letter_topic,
            description=description,
            environment=environment,
            environment_encryption=environment_encryption,
            ephemeral_storage_size=ephemeral_storage_size,
            events=events,
            filesystem=filesystem,
            function_name=function_name,
            initial_policy=initial_policy,
            insights_version=insights_version,
            ipv6_allowed_for_dual_stack=ipv6_allowed_for_dual_stack,
            layers=layers,
            log_format=log_format,
            logging_format=logging_format,
            log_group=log_group,
            log_removal_policy=log_removal_policy,
            log_retention=log_retention,
            log_retention_retry_options=log_retention_retry_options,
            log_retention_role=log_retention_role,
            memory_size=memory_size,
            params_and_secrets=params_and_secrets,
            profiling=profiling,
            profiling_group=profiling_group,
            recursive_loop=recursive_loop,
            reserved_concurrent_executions=reserved_concurrent_executions,
            role=role,
            runtime_management_mode=runtime_management_mode,
            security_groups=security_groups,
            snap_start=snap_start,
            system_log_level=system_log_level,
            system_log_level_v2=system_log_level_v2,
            timeout=timeout,
            tracing=tracing,
            vpc=vpc,
            vpc_subnets=vpc_subnets,
            max_event_age=max_event_age,
            on_failure=on_failure,
            on_success=on_success,
            retry_attempts=retry_attempts,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmConcurrentExecutions")
    def alarm_concurrent_executions(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "LambdaConcurrentExecutionsAlarm":
        '''Creates an alarm that monitors the number of concurrent executions.

        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor if the concurrency of the function is approaching the Region-level concurrency limit of your account. A function starts to be throttled if it reaches the concurrency limit.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - ConcurrentExecutions'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        :param threshold: The value against which the specified statictis is compared. Set the threshold to about 90% of the concurrency quota set for the account in the Region. By default, your account has a concurrency quota of 1,000 across all functions in a Region. However, you can check the quota of your account, as it can be increased by contacting AWS support. Default: 900
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = LambdaConcurrentExecutionsAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("LambdaConcurrentExecutionsAlarm", jsii.invoke(self, "alarmConcurrentExecutions", [props]))

    @jsii.member(jsii_name="alarmDuration")
    def alarm_duration(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "LambdaDurationAlarm":
        '''Creates an alarm that monitors the duration of the function invocations.

        :param threshold: The value against which the specified statictis is compared. The threshold for the duration depends on your application and workloads and your performance requirements. For high-performance requirements, set the threshold to a shorter time to see if the function is meeting expectations. You can also analyze historical data for duration metrics to see the if the time taken matches the performance expectation of the function, and then set the threshold to a longer time than the historical average. Make sure to set the threshold lower than the configured function timeout.
        :param alarm_description: The description of the alarm. Default: - This alarm detects long duration times for processing an event by a Lambda function. Long durations might be because of changes in function code making the function take longer to execute, or the function's dependencies taking longer.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Duration'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = LambdaDurationAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("LambdaDurationAlarm", jsii.invoke(self, "alarmDuration", [props]))

    @jsii.member(jsii_name="alarmErrors")
    def alarm_errors(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "LambdaErrorsAlarm":
        '''Creates an alarm that monitors the number of errors.

        :param threshold: The value against which the specified statistics is compared. Set the threshold to a number greater than zero. The exact value can depend on the tolerance for errors in your application. Understand the criticality of the invocations that the function is handling. For some applications, any error might be unacceptable, while other applications might allow for a certain margin of error.
        :param alarm_description: The description of the alarm. Default: - This alarm detects high error counts. Errors includes the exceptions thrown by the code as well as exceptions thrown by the Lambda runtime. You can check the logs related to the function to diagnose the issue.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Errors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = LambdaErrorsAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("LambdaErrorsAlarm", jsii.invoke(self, "alarmErrors", [props]))

    @jsii.member(jsii_name="alarmThrottles")
    def alarm_throttles(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "LambdaThrottlesAlarm":
        '''Creates an alarm that monitors the number of throttles.

        :param threshold: The value against which the specified statictis is compared. Set the threshold to a number greater than zero. The exact value of the threshold can depend on the tolerance of the application. Set the threshold according to its usage and scaling requirements of the function.
        :param alarm_description: The description of the alarm. Default: - This alarm detects a high number of throttled invocation requests. Throttling occurs when there is no concurrency is available for scale up. There are several approaches to resolve this issue. 1. Request a concurrency increase from AWS Support in this Region. 2) Identify performance issues in the function to improve the speed of processing and therefore improve throughput. 3) Increase the batch size of the function, so that more messages are processed by each function invocation.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Throttles'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = LambdaThrottlesAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("LambdaThrottlesAlarm", jsii.invoke(self, "alarmThrottles", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_duration_alarm: typing.Union["LambdaDurationAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_errors_alarm: typing.Union["LambdaErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_throttles_alarm: typing.Union["LambdaThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_concurrent_executions_alarm: typing.Optional[typing.Union["LambdaConcurrentExecutionsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["LambdaRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "LambdaRecommendedAlarms":
        '''Creates recommended alarms for the Lambda function.

        :param config_duration_alarm: The configuration for the Duration alarm.
        :param config_errors_alarm: The configuration for the Errors alarm.
        :param config_throttles_alarm: The configuration for the Throttles alarm.
        :param config_concurrent_executions_alarm: The configuration for the ConcurrentExecutions alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#Lambda
        '''
        props = LambdaRecommendedAlarmsConfig(
            config_duration_alarm=config_duration_alarm,
            config_errors_alarm=config_errors_alarm,
            config_throttles_alarm=config_throttles_alarm,
            config_concurrent_executions_alarm=config_concurrent_executions_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("LambdaRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


class Instance(
    _aws_cdk_aws_ec2_ceddda9d.Instance,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Instance",
):
    '''An extension for the Instance construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        instance_type: _aws_cdk_aws_ec2_ceddda9d.InstanceType,
        machine_image: _aws_cdk_aws_ec2_ceddda9d.IMachineImage,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
        allow_all_ipv6_outbound: typing.Optional[builtins.bool] = None,
        allow_all_outbound: typing.Optional[builtins.bool] = None,
        associate_public_ip_address: typing.Optional[builtins.bool] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        block_devices: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.BlockDevice, typing.Dict[builtins.str, typing.Any]]]] = None,
        credit_specification: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.CpuCredits] = None,
        detailed_monitoring: typing.Optional[builtins.bool] = None,
        disable_api_termination: typing.Optional[builtins.bool] = None,
        ebs_optimized: typing.Optional[builtins.bool] = None,
        enclave_enabled: typing.Optional[builtins.bool] = None,
        hibernation_enabled: typing.Optional[builtins.bool] = None,
        init: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.CloudFormationInit] = None,
        init_options: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.ApplyCloudFormationInitOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        instance_initiated_shutdown_behavior: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.InstanceInitiatedShutdownBehavior] = None,
        instance_name: typing.Optional[builtins.str] = None,
        instance_profile: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IInstanceProfile] = None,
        ipv6_address_count: typing.Optional[jsii.Number] = None,
        key_name: typing.Optional[builtins.str] = None,
        key_pair: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IKeyPair] = None,
        placement_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IPlacementGroup] = None,
        private_ip_address: typing.Optional[builtins.str] = None,
        propagate_tags_to_volume_on_creation: typing.Optional[builtins.bool] = None,
        require_imdsv2: typing.Optional[builtins.bool] = None,
        resource_signal_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        security_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup] = None,
        source_dest_check: typing.Optional[builtins.bool] = None,
        ssm_session_permissions: typing.Optional[builtins.bool] = None,
        user_data: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.UserData] = None,
        user_data_causes_replacement: typing.Optional[builtins.bool] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param instance_type: Type of instance to launch.
        :param machine_image: AMI to launch.
        :param vpc: VPC to launch the instance in.
        :param allow_all_ipv6_outbound: Whether the instance could initiate IPv6 connections to anywhere by default. This property is only used when you do not provide a security group. Default: false
        :param allow_all_outbound: Whether the instance could initiate connections to anywhere by default. This property is only used when you do not provide a security group. Default: true
        :param associate_public_ip_address: Whether to associate a public IP address to the primary network interface attached to this instance. You cannot specify this property and ``ipv6AddressCount`` at the same time. Default: - public IP address is automatically assigned based on default behavior
        :param availability_zone: In which AZ to place the instance within the VPC. Default: - Random zone.
        :param block_devices: Specifies how block devices are exposed to the instance. You can specify virtual devices and EBS volumes. Each instance that is launched has an associated root device volume, either an Amazon EBS volume or an instance store volume. You can use block device mappings to specify additional EBS volumes or instance store volumes to attach to an instance when it is launched. Default: - Uses the block device mapping of the AMI
        :param credit_specification: Specifying the CPU credit type for burstable EC2 instance types (T2, T3, T3a, etc). The unlimited CPU credit option is not supported for T3 instances with a dedicated host. Default: - T2 instances are standard, while T3, T4g, and T3a instances are unlimited.
        :param detailed_monitoring: Whether "Detailed Monitoring" is enabled for this instance Keep in mind that Detailed Monitoring results in extra charges. Default: - false
        :param disable_api_termination: If true, the instance will not be able to be terminated using the Amazon EC2 console, CLI, or API. To change this attribute after launch, use `ModifyInstanceAttribute <https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_ModifyInstanceAttribute.html>`_. Alternatively, if you set InstanceInitiatedShutdownBehavior to terminate, you can terminate the instance by running the shutdown command from the instance. Default: false
        :param ebs_optimized: Indicates whether the instance is optimized for Amazon EBS I/O. This optimization provides dedicated throughput to Amazon EBS and an optimized configuration stack to provide optimal Amazon EBS I/O performance. This optimization isn't available with all instance types. Additional usage charges apply when using an EBS-optimized instance. Default: false
        :param enclave_enabled: Whether the instance is enabled for AWS Nitro Enclaves. Nitro Enclaves requires a Nitro-based virtualized parent instance with specific Intel/AMD with at least 4 vCPUs or Graviton with at least 2 vCPUs instance types and Linux/Windows host OS, while the enclave itself supports only Linux OS. You can't set both ``enclaveEnabled`` and ``hibernationEnabled`` to true on the same instance. Default: - false
        :param hibernation_enabled: Whether the instance is enabled for hibernation. You can't set both ``enclaveEnabled`` and ``hibernationEnabled`` to true on the same instance. Default: - false
        :param init: Apply the given CloudFormation Init configuration to the instance at startup. Default: - no CloudFormation init
        :param init_options: Use the given options for applying CloudFormation Init. Describes the configsets to use and the timeout to wait Default: - default options
        :param instance_initiated_shutdown_behavior: Indicates whether an instance stops or terminates when you initiate shutdown from the instance (using the operating system command for system shutdown). Default: InstanceInitiatedShutdownBehavior.STOP
        :param instance_name: The name of the instance. Default: - CDK generated name
        :param instance_profile: The instance profile used to pass role information to EC2 instances. Note: You can provide an instanceProfile or a role, but not both. Default: - No instance profile
        :param ipv6_address_count: The number of IPv6 addresses to associate with the primary network interface. Amazon EC2 chooses the IPv6 addresses from the range of your subnet. You cannot specify this property and ``associatePublicIpAddress`` at the same time. Default: - For instances associated with an IPv6 subnet, use 1; otherwise, use 0.
        :param key_name: (deprecated) Name of SSH keypair to grant access to instance. Default: - No SSH access will be possible.
        :param key_pair: The SSH keypair to grant access to the instance. Default: - No SSH access will be possible.
        :param placement_group: The placement group that you want to launch the instance into. Default: - no placement group will be used for this instance.
        :param private_ip_address: Defines a private IP address to associate with an instance. Private IP should be available within the VPC that the instance is build within. Default: - no association
        :param propagate_tags_to_volume_on_creation: Propagate the EC2 instance tags to the EBS volumes. Default: - false
        :param require_imdsv2: Whether IMDSv2 should be required on this instance. Default: - false
        :param resource_signal_timeout: The length of time to wait for the resourceSignalCount. The maximum value is 43200 (12 hours). Default: Duration.minutes(5)
        :param role: An IAM role to associate with the instance profile assigned to this Auto Scaling Group. The role must be assumable by the service principal ``ec2.amazonaws.com``: Note: You can provide an instanceProfile or a role, but not both. Default: - A role will automatically be created, it can be accessed via the ``role`` property
        :param security_group: Security Group to assign to this instance. Default: - create new security group
        :param source_dest_check: Specifies whether to enable an instance launched in a VPC to perform NAT. This controls whether source/destination checking is enabled on the instance. A value of true means that checking is enabled, and false means that checking is disabled. The value must be false for the instance to perform NAT. Default: true
        :param ssm_session_permissions: Add SSM session permissions to the instance role. Setting this to ``true`` adds the necessary permissions to connect to the instance using SSM Session Manager. You can do this from the AWS Console. NOTE: Setting this flag to ``true`` may not be enough by itself. You must also use an AMI that comes with the SSM Agent, or install the SSM Agent yourself. See `Working with SSM Agent <https://docs.aws.amazon.com/systems-manager/latest/userguide/ssm-agent.html>`_ in the SSM Developer Guide. Default: false
        :param user_data: Specific UserData to use. The UserData may still be mutated after creation. Default: - A UserData object appropriate for the MachineImage's Operating System is created.
        :param user_data_causes_replacement: Changes to the UserData force replacement. Depending the EC2 instance type, changing UserData either restarts the instance or replaces the instance. - Instance store-backed instances are replaced. - EBS-backed instances are restarted. By default, restarting does not execute the new UserData so you will need a different mechanism to ensure the instance is restarted. Setting this to ``true`` will make the instance's Logical ID depend on the UserData, which will cause CloudFormation to replace it if the UserData changes. Default: - true if ``initOptions`` is specified, false otherwise.
        :param vpc_subnets: Where to place the instance within the VPC. Default: - Private subnets.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fe9b92d47374b9befb971a26f4d4dbe90f31098ac9851e1d6a2d80880b8939c7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_ec2_ceddda9d.InstanceProps(
            instance_type=instance_type,
            machine_image=machine_image,
            vpc=vpc,
            allow_all_ipv6_outbound=allow_all_ipv6_outbound,
            allow_all_outbound=allow_all_outbound,
            associate_public_ip_address=associate_public_ip_address,
            availability_zone=availability_zone,
            block_devices=block_devices,
            credit_specification=credit_specification,
            detailed_monitoring=detailed_monitoring,
            disable_api_termination=disable_api_termination,
            ebs_optimized=ebs_optimized,
            enclave_enabled=enclave_enabled,
            hibernation_enabled=hibernation_enabled,
            init=init,
            init_options=init_options,
            instance_initiated_shutdown_behavior=instance_initiated_shutdown_behavior,
            instance_name=instance_name,
            instance_profile=instance_profile,
            ipv6_address_count=ipv6_address_count,
            key_name=key_name,
            key_pair=key_pair,
            placement_group=placement_group,
            private_ip_address=private_ip_address,
            propagate_tags_to_volume_on_creation=propagate_tags_to_volume_on_creation,
            require_imdsv2=require_imdsv2,
            resource_signal_timeout=resource_signal_timeout,
            role=role,
            security_group=security_group,
            source_dest_check=source_dest_check,
            ssm_session_permissions=ssm_session_permissions,
            user_data=user_data,
            user_data_causes_replacement=user_data_causes_replacement,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmCpuUtilization")
    def alarm_cpu_utilization(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> Ec2InstanceCpuUtilizationAlarm:
        '''Creates an alarm that monitors the CPUUtilization for the EC2 instance.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization.
        :param alarm_name: The alarm name. Default: - instanceId + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: Typically, you can set the threshold for CPU utilization to 70-80%. However, you can adjust this value based on your acceptable performance level and workload characteristics. For some systems, consistently high CPU utilization may be normal and not indicate a problem, while for others, it may be cause of concern. Analyze historical CPU utilization data to identify the usage, find what CPU utilization is acceptable for your system, and set the threshold accordingly. Default: 80
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = Ec2CpuUtilizationAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(Ec2InstanceCpuUtilizationAlarm, jsii.invoke(self, "alarmCpuUtilization", [props]))

    @jsii.member(jsii_name="alarmStatusCheckFailed")
    def alarm_status_check_failed(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> Ec2InstanceStatusCheckFailedAlarm:
        '''Creates an alarm that monitors the StatusCheckFailed for the EC2 instance.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect the underlying problems with instances, including both system status check failures and instance status check failures.
        :param alarm_name: The alarm name. Default: - instanceId + ' - StatusCheckFailed'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: When a status check fails, the value of this metric is 1. The threshold is set so that whenever the status check fails, the alarm is in ALARM state. Default: 1
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = Ec2StatusCheckFailedAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(Ec2InstanceStatusCheckFailedAlarm, jsii.invoke(self, "alarmStatusCheckFailed", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_cpu_utilization_alarm: typing.Optional[typing.Union[Ec2CpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_status_check_failed_alarm: typing.Optional[typing.Union[Ec2StatusCheckFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[Ec2RecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> Ec2InstanceRecommendedAlarms:
        '''Creates the recommended alarms for the EC2 Instance.

        :param config_cpu_utilization_alarm: The configuration for the CPUUtilization alarm.
        :param config_status_check_failed_alarm: The configuration for the StatusCheckFailed alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#EC2
        '''
        props = Ec2InstanceRecommendedAlarmsConfig(
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            config_status_check_failed_alarm=config_status_check_failed_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(Ec2InstanceRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))


class InterfaceVpcEndpoint(
    _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.InterfaceVpcEndpoint",
):
    '''An extension for the InterfaceVpcEndpoint construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
        service: _aws_cdk_aws_ec2_ceddda9d.IInterfaceVpcEndpointService,
        dns_record_ip_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.VpcEndpointDnsRecordIpType] = None,
        ip_address_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.VpcEndpointIpAddressType] = None,
        lookup_supported_azs: typing.Optional[builtins.bool] = None,
        open: typing.Optional[builtins.bool] = None,
        private_dns_enabled: typing.Optional[builtins.bool] = None,
        private_dns_only_for_inbound_resolver_endpoint: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.VpcEndpointPrivateDnsOnlyForInboundResolverEndpoint] = None,
        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
        subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc: The VPC network in which the interface endpoint will be used.
        :param service: The service to use for this interface VPC endpoint.
        :param dns_record_ip_type: Type of DNS records created for the VPC endpoint. Default: not specified
        :param ip_address_type: The IP address type for the endpoint. Default: not specified
        :param lookup_supported_azs: Limit to only those availability zones where the endpoint service can be created. Setting this to 'true' requires a lookup to be performed at synthesis time. Account and region must be set on the containing stack for this to work. Default: false
        :param open: Whether to automatically allow VPC traffic to the endpoint. If enabled, all traffic to the endpoint from within the VPC will be automatically allowed. This is done based on the VPC's CIDR range. Default: true
        :param private_dns_enabled: Whether to associate a private hosted zone with the specified VPC. This allows you to make requests to the service using its default DNS hostname. Default: set by the instance of IInterfaceVpcEndpointService, or true if not defined by the instance of IInterfaceVpcEndpointService
        :param private_dns_only_for_inbound_resolver_endpoint: Whether to enable private DNS only for inbound endpoints. Default: not specified
        :param security_groups: The security groups to associate with this interface VPC endpoint. Default: - a new security group is created
        :param subnets: The subnets in which to create an endpoint network interface. At most one per availability zone. Default: - private subnets
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dc0e1f097f03b2fa123e12d6dcd4c4ab950585fc2a1da7f2c3e4c5ba7aabc9ce)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpointProps(
            vpc=vpc,
            service=service,
            dns_record_ip_type=dns_record_ip_type,
            ip_address_type=ip_address_type,
            lookup_supported_azs=lookup_supported_azs,
            open=open,
            private_dns_enabled=private_dns_enabled,
            private_dns_only_for_inbound_resolver_endpoint=private_dns_only_for_inbound_resolver_endpoint,
            security_groups=security_groups,
            subnets=subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmPacketsDropped")
    def alarm_packets_dropped(
        self,
        *,
        endpoint_type: builtins.str,
        service_name: builtins.str,
        threshold: jsii.Number,
        vpc_id: builtins.str,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        subnets: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISubnet]] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> typing.List["PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarm"]:
        '''Creates an alarm that monitors the PacketsDropped for the PrivateLink endpoint.

        :param endpoint_type: The type of the PrivateLink InterfaceVpcEndpoint.
        :param service_name: The service name of the PrivateLink InterfaceVpcEndpoint.
        :param threshold: Set the threshold according to the use case. If you want to be aware of the unhealthy status of the endpoint or endpoint service, you should set the threshold low so that you get a chance to fix the issue before a huge data loss. You can use historical data to understand the tolerance for dropped packets and set the threshold accordingly.
        :param vpc_id: The VPC ID of the PrivateLink InterfaceVpcEndpoint.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect if the endpoint or endpoint service is unhealthy.
        :param alarm_name: The alarm name. Default: - endpointId + ' - ' + subnetId + ' - PacketsDropped'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param subnets: The subnets of the PrivateLink InterfaceVpcEndpoint.
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = PrivateLinkEndpointsPacketsDroppedAlarmConfig(
            endpoint_type=endpoint_type,
            service_name=service_name,
            threshold=threshold,
            vpc_id=vpc_id,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            subnets=subnets,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(typing.List["PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarm"], jsii.invoke(self, "alarmPacketsDropped", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_packets_dropped_alarm: typing.Union["PrivateLinkEndpointsPacketsDroppedAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["PrivateLinkEndpointsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarms":
        '''Creates the recommended alarms for the PrivateLink InterfaceVpcEndpoint.

        :param config_packets_dropped_alarm: The configuration for the PacketsDropped alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#PrivateLinkEndpoints
        '''
        props = PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsConfig(
            config_packets_dropped_alarm=config_packets_dropped_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class LambdaAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__716b419718f93d506f3a8f28e319b9f808eddee3d4641ebd195dccca8d474eec)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LambdaConcurrentExecutionsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaConcurrentExecutionsAlarm",
):
    '''This alarm can proactively detect if the concurrency of the function is approaching the Region-level concurrency quota of your account, so that you can act on it.

    A function is
    throttled if it reaches the Region-level concurrency quota
    of the account.

    The alarm is triggered when the number of concurrent executions
    exceeds the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param lambda_function: The Lambda function to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor if the concurrency of the function is approaching the Region-level concurrency limit of your account. A function starts to be throttled if it reaches the concurrency limit.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - ConcurrentExecutions'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        :param threshold: The value against which the specified statictis is compared. Set the threshold to about 90% of the concurrency quota set for the account in the Region. By default, your account has a concurrency quota of 1,000 across all functions in a Region. However, you can check the quota of your account, as it can be increased by contacting AWS support. Default: 900
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9bfb27966b8b66696e58f0cdca63f38b3e4abd2f029e1dcdd883870f471a74c7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = LambdaConcurrentExecutionsAlarmProps(
            lambda_function=lambda_function,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaConcurrentExecutionsAlarmConfig",
    jsii_struct_bases=[LambdaAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class LambdaConcurrentExecutionsAlarmConfig(LambdaAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the ConcurrentExecutions alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor if the concurrency of the function is approaching the Region-level concurrency limit of your account. A function starts to be throttled if it reaches the concurrency limit.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - ConcurrentExecutions'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        :param threshold: The value against which the specified statictis is compared. Set the threshold to about 90% of the concurrency quota set for the account in the Region. By default, your account has a concurrency quota of 1,000 across all functions in a Region. However, you can check the quota of your account, as it can be increased by contacting AWS support. Default: 900
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f6d24fc2ab7dcff701615e4987ae78b3dd173cefd3eb98f56fd3cd288d75b47)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to monitor if the concurrency of the function is approaching the Region-level
        concurrency limit of your account. A function starts to be throttled if it reaches the concurrency limit.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - lambdaFunction.functionName + ' - ConcurrentExecutions'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 10
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 10
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statictis is compared.

        Set the threshold to about 90% of the concurrency quota set
        for the account in the Region. By default, your account has
        a concurrency quota of 1,000 across all functions in a Region.
        However, you can check the quota of your account, as it can
        be increased by contacting AWS support.

        :default: 900
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaConcurrentExecutionsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaConcurrentExecutionsAlarmProps",
    jsii_struct_bases=[LambdaConcurrentExecutionsAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "lambda_function": "lambdaFunction",
    },
)
class LambdaConcurrentExecutionsAlarmProps(LambdaConcurrentExecutionsAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
    ) -> None:
        '''The properties for the LambdaConcurrentExecutionsAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor if the concurrency of the function is approaching the Region-level concurrency limit of your account. A function starts to be throttled if it reaches the concurrency limit.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - ConcurrentExecutions'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        :param threshold: The value against which the specified statictis is compared. Set the threshold to about 90% of the concurrency quota set for the account in the Region. By default, your account has a concurrency quota of 1,000 across all functions in a Region. However, you can check the quota of your account, as it can be increased by contacting AWS support. Default: 900
        :param lambda_function: The Lambda function to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d8926f47d763f0933cbd527860988a8a2749c891924dcd36c2f3f1e29039d6f)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "lambda_function": lambda_function,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to monitor if the concurrency of the function is approaching the Region-level
        concurrency limit of your account. A function starts to be throttled if it reaches the concurrency limit.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - lambdaFunction.functionName + ' - ConcurrentExecutions'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 10
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 10
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statictis is compared.

        Set the threshold to about 90% of the concurrency quota set
        for the account in the Region. By default, your account has
        a concurrency quota of 1,000 across all functions in a Region.
        However, you can check the quota of your account, as it can
        be increased by contacting AWS support.

        :default: 900
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def lambda_function(self) -> _aws_cdk_aws_lambda_ceddda9d.IFunction:
        '''The Lambda function to monitor.'''
        result = self._values.get("lambda_function")
        assert result is not None, "Required property 'lambda_function' is missing"
        return typing.cast(_aws_cdk_aws_lambda_ceddda9d.IFunction, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaConcurrentExecutionsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LambdaDurationAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaDurationAlarm",
):
    '''This alarm can detect a long running duration of a Lambda function.

    High runtime duration indicates that
    a function is taking a longer time for invocation, and
    can also impact the concurrency capacity of invocation
    if Lambda is handling a higher number of events. It is
    critical to know if the Lambda function is constantly
    taking longer execution time than expected.

    The alarm is triggered when the duration of the function
    invocations exceeds the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param lambda_function: The Lambda function to monitor.
        :param threshold: The value against which the specified statictis is compared. The threshold for the duration depends on your application and workloads and your performance requirements. For high-performance requirements, set the threshold to a shorter time to see if the function is meeting expectations. You can also analyze historical data for duration metrics to see the if the time taken matches the performance expectation of the function, and then set the threshold to a longer time than the historical average. Make sure to set the threshold lower than the configured function timeout.
        :param alarm_description: The description of the alarm. Default: - This alarm detects long duration times for processing an event by a Lambda function. Long durations might be because of changes in function code making the function take longer to execute, or the function's dependencies taking longer.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Duration'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e14f288432f1c93dade6ca87e081a4cf16901cbcbef6b7c783c411f561140323)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = LambdaDurationAlarmProps(
            lambda_function=lambda_function,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaDurationAlarmConfig",
    jsii_struct_bases=[LambdaAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class LambdaDurationAlarmConfig(LambdaAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the Duration alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statictis is compared. The threshold for the duration depends on your application and workloads and your performance requirements. For high-performance requirements, set the threshold to a shorter time to see if the function is meeting expectations. You can also analyze historical data for duration metrics to see the if the time taken matches the performance expectation of the function, and then set the threshold to a longer time than the historical average. Make sure to set the threshold lower than the configured function timeout.
        :param alarm_description: The description of the alarm. Default: - This alarm detects long duration times for processing an event by a Lambda function. Long durations might be because of changes in function code making the function take longer to execute, or the function's dependencies taking longer.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Duration'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__16f9aa6367d9f62672010c74b9c77970e9a4ad803a8333d788aa6ea4f74dfb61)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statictis is compared.

        The threshold for the duration depends on your application
        and workloads and your performance requirements. For
        high-performance requirements, set the threshold to a
        shorter time to see if the function is meeting expectations.
        You can also analyze historical data for duration metrics
        to see the if the time taken matches the performance
        expectation of the function, and then set the threshold to
        a longer time than the historical average. Make sure to
        set the threshold lower than the configured function
        timeout.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm detects long duration times for processing an event by a Lambda function. Long durations might be because of changes in function code making the function take longer to execute, or the function's dependencies taking longer.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - lambdaFunction.functionName + ' - Duration'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaDurationAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaDurationAlarmProps",
    jsii_struct_bases=[LambdaDurationAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "lambda_function": "lambdaFunction",
    },
)
class LambdaDurationAlarmProps(LambdaDurationAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
    ) -> None:
        '''The properties for the LambdaDurationAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statictis is compared. The threshold for the duration depends on your application and workloads and your performance requirements. For high-performance requirements, set the threshold to a shorter time to see if the function is meeting expectations. You can also analyze historical data for duration metrics to see the if the time taken matches the performance expectation of the function, and then set the threshold to a longer time than the historical average. Make sure to set the threshold lower than the configured function timeout.
        :param alarm_description: The description of the alarm. Default: - This alarm detects long duration times for processing an event by a Lambda function. Long durations might be because of changes in function code making the function take longer to execute, or the function's dependencies taking longer.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Duration'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param lambda_function: The Lambda function to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c35e2842ae53ffd154b79e7db69c642434d4bb574cd771ed7bdc184108099771)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
            "lambda_function": lambda_function,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statictis is compared.

        The threshold for the duration depends on your application
        and workloads and your performance requirements. For
        high-performance requirements, set the threshold to a
        shorter time to see if the function is meeting expectations.
        You can also analyze historical data for duration metrics
        to see the if the time taken matches the performance
        expectation of the function, and then set the threshold to
        a longer time than the historical average. Make sure to
        set the threshold lower than the configured function
        timeout.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm detects long duration times for processing an event by a Lambda function. Long durations might be because of changes in function code making the function take longer to execute, or the function's dependencies taking longer.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - lambdaFunction.functionName + ' - Duration'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def lambda_function(self) -> _aws_cdk_aws_lambda_ceddda9d.IFunction:
        '''The Lambda function to monitor.'''
        result = self._values.get("lambda_function")
        assert result is not None, "Required property 'lambda_function' is missing"
        return typing.cast(_aws_cdk_aws_lambda_ceddda9d.IFunction, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaDurationAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LambdaErrorsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaErrorsAlarm",
):
    '''The alarm helps detect high error counts in function invocations.

    The alarm is triggered when the number of errors exceeds the specified
    threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param lambda_function: The Lambda function to monitor.
        :param threshold: The value against which the specified statistics is compared. Set the threshold to a number greater than zero. The exact value can depend on the tolerance for errors in your application. Understand the criticality of the invocations that the function is handling. For some applications, any error might be unacceptable, while other applications might allow for a certain margin of error.
        :param alarm_description: The description of the alarm. Default: - This alarm detects high error counts. Errors includes the exceptions thrown by the code as well as exceptions thrown by the Lambda runtime. You can check the logs related to the function to diagnose the issue.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Errors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1f5d57bf581f2eea2bb19216346016a8105d14c7a16a9ac673410b280a87fc3a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = LambdaErrorsAlarmProps(
            lambda_function=lambda_function,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaErrorsAlarmConfig",
    jsii_struct_bases=[LambdaAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class LambdaErrorsAlarmConfig(LambdaAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the Errors alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistics is compared. Set the threshold to a number greater than zero. The exact value can depend on the tolerance for errors in your application. Understand the criticality of the invocations that the function is handling. For some applications, any error might be unacceptable, while other applications might allow for a certain margin of error.
        :param alarm_description: The description of the alarm. Default: - This alarm detects high error counts. Errors includes the exceptions thrown by the code as well as exceptions thrown by the Lambda runtime. You can check the logs related to the function to diagnose the issue.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Errors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5a80f94cd00993ff5508c02a09a080a5e3dfe40d123f162a15591a81b8faf940)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistics is compared.

        Set the threshold to a number greater than zero. The exact
        value can depend on the tolerance for errors in your
        application. Understand the criticality of the invocations
        that the function is handling. For some applications, any
        error might be unacceptable, while other applications might
        allow for a certain margin of error.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm detects high error counts. Errors includes the exceptions thrown by the code
        as well as exceptions thrown by the Lambda runtime. You can check the logs related to the function
        to diagnose the issue.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - lambdaFunction.functionName + ' - Errors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaErrorsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaErrorsAlarmProps",
    jsii_struct_bases=[LambdaErrorsAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "lambda_function": "lambdaFunction",
    },
)
class LambdaErrorsAlarmProps(LambdaErrorsAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
    ) -> None:
        '''The properties for the LambdaErrorsAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistics is compared. Set the threshold to a number greater than zero. The exact value can depend on the tolerance for errors in your application. Understand the criticality of the invocations that the function is handling. For some applications, any error might be unacceptable, while other applications might allow for a certain margin of error.
        :param alarm_description: The description of the alarm. Default: - This alarm detects high error counts. Errors includes the exceptions thrown by the code as well as exceptions thrown by the Lambda runtime. You can check the logs related to the function to diagnose the issue.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Errors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param lambda_function: The Lambda function to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__065075f4736ec308df17eee0d6a5100064d7a899d094aeb4533fdde663ffc607)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
            "lambda_function": lambda_function,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistics is compared.

        Set the threshold to a number greater than zero. The exact
        value can depend on the tolerance for errors in your
        application. Understand the criticality of the invocations
        that the function is handling. For some applications, any
        error might be unacceptable, while other applications might
        allow for a certain margin of error.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm detects high error counts. Errors includes the exceptions thrown by the code
        as well as exceptions thrown by the Lambda runtime. You can check the logs related to the function
        to diagnose the issue.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - lambdaFunction.functionName + ' - Errors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def lambda_function(self) -> _aws_cdk_aws_lambda_ceddda9d.IFunction:
        '''The Lambda function to monitor.'''
        result = self._values.get("lambda_function")
        assert result is not None, "Required property 'lambda_function' is missing"
        return typing.cast(_aws_cdk_aws_lambda_ceddda9d.IFunction, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaErrorsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LambdaRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaRecommendedAlarms",
):
    '''A construct that creates recommended alarms for a Lambda function.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#Lambda
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
        config_duration_alarm: typing.Union[LambdaDurationAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_errors_alarm: typing.Union[LambdaErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_throttles_alarm: typing.Union["LambdaThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_concurrent_executions_alarm: typing.Optional[typing.Union[LambdaConcurrentExecutionsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["LambdaRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param lambda_function: The lambda function to apply the recommended alarms.
        :param config_duration_alarm: The configuration for the Duration alarm.
        :param config_errors_alarm: The configuration for the Errors alarm.
        :param config_throttles_alarm: The configuration for the Throttles alarm.
        :param config_concurrent_executions_alarm: The configuration for the ConcurrentExecutions alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__27101909e8d5207062982ebba2ceaa835aa71fc168b8d767b66d1a5c1a11d99b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = LambdaRecommendedAlarmsProps(
            lambda_function=lambda_function,
            config_duration_alarm=config_duration_alarm,
            config_errors_alarm=config_errors_alarm,
            config_throttles_alarm=config_throttles_alarm,
            config_concurrent_executions_alarm=config_concurrent_executions_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmConcurrentExecutions")
    def alarm_concurrent_executions(
        self,
    ) -> typing.Optional[LambdaConcurrentExecutionsAlarm]:
        '''The concurrent executions alarm for the Lambda function.'''
        return typing.cast(typing.Optional[LambdaConcurrentExecutionsAlarm], jsii.get(self, "alarmConcurrentExecutions"))

    @builtins.property
    @jsii.member(jsii_name="alarmDuration")
    def alarm_duration(self) -> typing.Optional[LambdaDurationAlarm]:
        '''The duration alarm for the Lambda function.'''
        return typing.cast(typing.Optional[LambdaDurationAlarm], jsii.get(self, "alarmDuration"))

    @builtins.property
    @jsii.member(jsii_name="alarmErrors")
    def alarm_errors(self) -> typing.Optional[LambdaErrorsAlarm]:
        '''The error alarm for the Lambda function.'''
        return typing.cast(typing.Optional[LambdaErrorsAlarm], jsii.get(self, "alarmErrors"))

    @builtins.property
    @jsii.member(jsii_name="alarmThrottles")
    def alarm_throttles(self) -> typing.Optional["LambdaThrottlesAlarm"]:
        '''The throttles alarm for the Lambda function.'''
        return typing.cast(typing.Optional["LambdaThrottlesAlarm"], jsii.get(self, "alarmThrottles"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class LambdaRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaRecommendedAlarmsAspect",
):
    '''An aspect that applies recommended alarms for Lambda functions.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#Lambda
    '''

    def __init__(
        self,
        *,
        config_duration_alarm: typing.Union[LambdaDurationAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_errors_alarm: typing.Union[LambdaErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_throttles_alarm: typing.Union["LambdaThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_concurrent_executions_alarm: typing.Optional[typing.Union[LambdaConcurrentExecutionsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["LambdaRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_duration_alarm: The configuration for the Duration alarm.
        :param config_errors_alarm: The configuration for the Errors alarm.
        :param config_throttles_alarm: The configuration for the Throttles alarm.
        :param config_concurrent_executions_alarm: The configuration for the ConcurrentExecutions alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = LambdaRecommendedAlarmsConfig(
            config_duration_alarm=config_duration_alarm,
            config_errors_alarm=config_errors_alarm,
            config_throttles_alarm=config_throttles_alarm,
            config_concurrent_executions_alarm=config_concurrent_executions_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ac98314bcd4923aabdf6919cacbc99fe09b02e5eba9973007f013c04c677d9e)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_duration_alarm": "configDurationAlarm",
        "config_errors_alarm": "configErrorsAlarm",
        "config_throttles_alarm": "configThrottlesAlarm",
        "config_concurrent_executions_alarm": "configConcurrentExecutionsAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class LambdaRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_duration_alarm: typing.Union[LambdaDurationAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_errors_alarm: typing.Union[LambdaErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_throttles_alarm: typing.Union["LambdaThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_concurrent_executions_alarm: typing.Optional[typing.Union[LambdaConcurrentExecutionsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["LambdaRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configuration for Lambda recommended alarms.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_duration_alarm: The configuration for the Duration alarm.
        :param config_errors_alarm: The configuration for the Errors alarm.
        :param config_throttles_alarm: The configuration for the Throttles alarm.
        :param config_concurrent_executions_alarm: The configuration for the ConcurrentExecutions alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_duration_alarm, dict):
            config_duration_alarm = LambdaDurationAlarmConfig(**config_duration_alarm)
        if isinstance(config_errors_alarm, dict):
            config_errors_alarm = LambdaErrorsAlarmConfig(**config_errors_alarm)
        if isinstance(config_throttles_alarm, dict):
            config_throttles_alarm = LambdaThrottlesAlarmConfig(**config_throttles_alarm)
        if isinstance(config_concurrent_executions_alarm, dict):
            config_concurrent_executions_alarm = LambdaConcurrentExecutionsAlarmConfig(**config_concurrent_executions_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0cd52c68a63a1358db1966d2a14b5e03f18458ff71753842a0c469174dd15066)
            check_type(argname="argument config_duration_alarm", value=config_duration_alarm, expected_type=type_hints["config_duration_alarm"])
            check_type(argname="argument config_errors_alarm", value=config_errors_alarm, expected_type=type_hints["config_errors_alarm"])
            check_type(argname="argument config_throttles_alarm", value=config_throttles_alarm, expected_type=type_hints["config_throttles_alarm"])
            check_type(argname="argument config_concurrent_executions_alarm", value=config_concurrent_executions_alarm, expected_type=type_hints["config_concurrent_executions_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_duration_alarm": config_duration_alarm,
            "config_errors_alarm": config_errors_alarm,
            "config_throttles_alarm": config_throttles_alarm,
        }
        if config_concurrent_executions_alarm is not None:
            self._values["config_concurrent_executions_alarm"] = config_concurrent_executions_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_duration_alarm(self) -> LambdaDurationAlarmConfig:
        '''The configuration for the Duration alarm.'''
        result = self._values.get("config_duration_alarm")
        assert result is not None, "Required property 'config_duration_alarm' is missing"
        return typing.cast(LambdaDurationAlarmConfig, result)

    @builtins.property
    def config_errors_alarm(self) -> LambdaErrorsAlarmConfig:
        '''The configuration for the Errors alarm.'''
        result = self._values.get("config_errors_alarm")
        assert result is not None, "Required property 'config_errors_alarm' is missing"
        return typing.cast(LambdaErrorsAlarmConfig, result)

    @builtins.property
    def config_throttles_alarm(self) -> "LambdaThrottlesAlarmConfig":
        '''The configuration for the Throttles alarm.'''
        result = self._values.get("config_throttles_alarm")
        assert result is not None, "Required property 'config_throttles_alarm' is missing"
        return typing.cast("LambdaThrottlesAlarmConfig", result)

    @builtins.property
    def config_concurrent_executions_alarm(
        self,
    ) -> typing.Optional[LambdaConcurrentExecutionsAlarmConfig]:
        '''The configuration for the ConcurrentExecutions alarm.'''
        result = self._values.get("config_concurrent_executions_alarm")
        return typing.cast(typing.Optional[LambdaConcurrentExecutionsAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["LambdaRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["LambdaRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaRecommendedAlarmsMetrics"
)
class LambdaRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for Lambda alarms.'''

    ERRORS = "ERRORS"
    '''Errors include the exceptions thrown by the code as well as exceptions thrown by the Lambda runtime.'''
    THROTTLES = "THROTTLES"
    '''Throttles occur when there is no concurrency available for scale up.'''
    DURATION = "DURATION"
    '''Duration is the time taken for the function to process an event.'''
    CONCURRENT_EXECUTIONS = "CONCURRENT_EXECUTIONS"
    '''ConcurrentExecutions is the number of concurrent executions of the function.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaRecommendedAlarmsProps",
    jsii_struct_bases=[LambdaRecommendedAlarmsConfig],
    name_mapping={
        "config_duration_alarm": "configDurationAlarm",
        "config_errors_alarm": "configErrorsAlarm",
        "config_throttles_alarm": "configThrottlesAlarm",
        "config_concurrent_executions_alarm": "configConcurrentExecutionsAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "lambda_function": "lambdaFunction",
    },
)
class LambdaRecommendedAlarmsProps(LambdaRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config_duration_alarm: typing.Union[LambdaDurationAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_errors_alarm: typing.Union[LambdaErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_throttles_alarm: typing.Union["LambdaThrottlesAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_concurrent_executions_alarm: typing.Optional[typing.Union[LambdaConcurrentExecutionsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[LambdaRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
    ) -> None:
        '''
        :param config_duration_alarm: The configuration for the Duration alarm.
        :param config_errors_alarm: The configuration for the Errors alarm.
        :param config_throttles_alarm: The configuration for the Throttles alarm.
        :param config_concurrent_executions_alarm: The configuration for the ConcurrentExecutions alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param lambda_function: The lambda function to apply the recommended alarms.
        '''
        if isinstance(config_duration_alarm, dict):
            config_duration_alarm = LambdaDurationAlarmConfig(**config_duration_alarm)
        if isinstance(config_errors_alarm, dict):
            config_errors_alarm = LambdaErrorsAlarmConfig(**config_errors_alarm)
        if isinstance(config_throttles_alarm, dict):
            config_throttles_alarm = LambdaThrottlesAlarmConfig(**config_throttles_alarm)
        if isinstance(config_concurrent_executions_alarm, dict):
            config_concurrent_executions_alarm = LambdaConcurrentExecutionsAlarmConfig(**config_concurrent_executions_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a2028de2c7bc54f62581b4499458b79fb36fb2c32306e074814ca31178c7a120)
            check_type(argname="argument config_duration_alarm", value=config_duration_alarm, expected_type=type_hints["config_duration_alarm"])
            check_type(argname="argument config_errors_alarm", value=config_errors_alarm, expected_type=type_hints["config_errors_alarm"])
            check_type(argname="argument config_throttles_alarm", value=config_throttles_alarm, expected_type=type_hints["config_throttles_alarm"])
            check_type(argname="argument config_concurrent_executions_alarm", value=config_concurrent_executions_alarm, expected_type=type_hints["config_concurrent_executions_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_duration_alarm": config_duration_alarm,
            "config_errors_alarm": config_errors_alarm,
            "config_throttles_alarm": config_throttles_alarm,
            "lambda_function": lambda_function,
        }
        if config_concurrent_executions_alarm is not None:
            self._values["config_concurrent_executions_alarm"] = config_concurrent_executions_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_duration_alarm(self) -> LambdaDurationAlarmConfig:
        '''The configuration for the Duration alarm.'''
        result = self._values.get("config_duration_alarm")
        assert result is not None, "Required property 'config_duration_alarm' is missing"
        return typing.cast(LambdaDurationAlarmConfig, result)

    @builtins.property
    def config_errors_alarm(self) -> LambdaErrorsAlarmConfig:
        '''The configuration for the Errors alarm.'''
        result = self._values.get("config_errors_alarm")
        assert result is not None, "Required property 'config_errors_alarm' is missing"
        return typing.cast(LambdaErrorsAlarmConfig, result)

    @builtins.property
    def config_throttles_alarm(self) -> "LambdaThrottlesAlarmConfig":
        '''The configuration for the Throttles alarm.'''
        result = self._values.get("config_throttles_alarm")
        assert result is not None, "Required property 'config_throttles_alarm' is missing"
        return typing.cast("LambdaThrottlesAlarmConfig", result)

    @builtins.property
    def config_concurrent_executions_alarm(
        self,
    ) -> typing.Optional[LambdaConcurrentExecutionsAlarmConfig]:
        '''The configuration for the ConcurrentExecutions alarm.'''
        result = self._values.get("config_concurrent_executions_alarm")
        return typing.cast(typing.Optional[LambdaConcurrentExecutionsAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[LambdaRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[LambdaRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def lambda_function(self) -> _aws_cdk_aws_lambda_ceddda9d.IFunction:
        '''The lambda function to apply the recommended alarms.'''
        result = self._values.get("lambda_function")
        assert result is not None, "Required property 'lambda_function' is missing"
        return typing.cast(_aws_cdk_aws_lambda_ceddda9d.IFunction, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class LambdaThrottlesAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaThrottlesAlarm",
):
    '''The alarm helps detect a high number of throttled invocation requests for a Lambda function.

    It is important to know if requests are constantly
    getting rejected due to throttling and if you need to improve Lambda
    function performance or increase concurrency capacity to avoid constant
    throttling.

    The alarm is triggered when the number of throttles exceeds or equals
    the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param lambda_function: The Lambda function to monitor.
        :param threshold: The value against which the specified statictis is compared. Set the threshold to a number greater than zero. The exact value of the threshold can depend on the tolerance of the application. Set the threshold according to its usage and scaling requirements of the function.
        :param alarm_description: The description of the alarm. Default: - This alarm detects a high number of throttled invocation requests. Throttling occurs when there is no concurrency is available for scale up. There are several approaches to resolve this issue. 1. Request a concurrency increase from AWS Support in this Region. 2) Identify performance issues in the function to improve the speed of processing and therefore improve throughput. 3) Increase the batch size of the function, so that more messages are processed by each function invocation.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Throttles'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__488351c06ad0ced06f68b654c629b883306654b7e2b923062e130cd249a4ad16)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = LambdaThrottlesAlarmProps(
            lambda_function=lambda_function,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaThrottlesAlarmConfig",
    jsii_struct_bases=[LambdaAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class LambdaThrottlesAlarmConfig(LambdaAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the Throttles alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statictis is compared. Set the threshold to a number greater than zero. The exact value of the threshold can depend on the tolerance of the application. Set the threshold according to its usage and scaling requirements of the function.
        :param alarm_description: The description of the alarm. Default: - This alarm detects a high number of throttled invocation requests. Throttling occurs when there is no concurrency is available for scale up. There are several approaches to resolve this issue. 1. Request a concurrency increase from AWS Support in this Region. 2) Identify performance issues in the function to improve the speed of processing and therefore improve throughput. 3) Increase the batch size of the function, so that more messages are processed by each function invocation.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Throttles'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73e2fd37e074d8437164ecec0a7146e6185d991ab6cce0ab1f03a6d551db8a84)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statictis is compared.

        Set the threshold to a number greater than zero. The exact value
        of the threshold can depend on the tolerance of the application.
        Set the threshold according to its usage and scaling requirements
        of the function.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm detects a high number of throttled invocation requests. Throttling occurs when
        there is no concurrency is available for scale up. There are several approaches to resolve this issue.

        1. Request a concurrency increase from AWS Support in this Region. 2) Identify performance issues in
        the function to improve the speed of processing and therefore improve throughput. 3) Increase the batch
        size of the function, so that more messages are processed by each function invocation.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - lambdaFunction.functionName + ' - Throttles'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaThrottlesAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.LambdaThrottlesAlarmProps",
    jsii_struct_bases=[LambdaThrottlesAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "lambda_function": "lambdaFunction",
    },
)
class LambdaThrottlesAlarmProps(LambdaThrottlesAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
    ) -> None:
        '''The properties for the LambdaThrottlesAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statictis is compared. Set the threshold to a number greater than zero. The exact value of the threshold can depend on the tolerance of the application. Set the threshold according to its usage and scaling requirements of the function.
        :param alarm_description: The description of the alarm. Default: - This alarm detects a high number of throttled invocation requests. Throttling occurs when there is no concurrency is available for scale up. There are several approaches to resolve this issue. 1. Request a concurrency increase from AWS Support in this Region. 2) Identify performance issues in the function to improve the speed of processing and therefore improve throughput. 3) Increase the batch size of the function, so that more messages are processed by each function invocation.
        :param alarm_name: The alarm name. Default: - lambdaFunction.functionName + ' - Throttles'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param lambda_function: The Lambda function to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6e1cacf0523a9e7229f0a95e8fd3bb47e8e7bceca45491724237db0109dd5b93)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument lambda_function", value=lambda_function, expected_type=type_hints["lambda_function"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
            "lambda_function": lambda_function,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statictis is compared.

        Set the threshold to a number greater than zero. The exact value
        of the threshold can depend on the tolerance of the application.
        Set the threshold according to its usage and scaling requirements
        of the function.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm detects a high number of throttled invocation requests. Throttling occurs when
        there is no concurrency is available for scale up. There are several approaches to resolve this issue.

        1. Request a concurrency increase from AWS Support in this Region. 2) Identify performance issues in
        the function to improve the speed of processing and therefore improve throughput. 3) Increase the batch
        size of the function, so that more messages are processed by each function invocation.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - lambdaFunction.functionName + ' - Throttles'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def lambda_function(self) -> _aws_cdk_aws_lambda_ceddda9d.IFunction:
        '''The Lambda function to monitor.'''
        result = self._values.get("lambda_function")
        assert result is not None, "Required property 'lambda_function' is missing"
        return typing.cast(_aws_cdk_aws_lambda_ceddda9d.IFunction, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "LambdaThrottlesAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkLoadBalancer(
    _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancer",
):
    '''An extension for the NetworkLoadBalancer construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        client_routing_policy: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ClientRoutingPolicy] = None,
        enable_prefix_for_ipv6_source_nat: typing.Optional[builtins.bool] = None,
        enforce_security_group_inbound_rules_on_private_link_traffic: typing.Optional[builtins.bool] = None,
        ip_address_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.IpAddressType] = None,
        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
        subnet_mappings: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.SubnetMapping, typing.Dict[builtins.str, typing.Any]]]] = None,
        zonal_shift: typing.Optional[builtins.bool] = None,
        vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
        cross_zone_enabled: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        deny_all_igw_traffic: typing.Optional[builtins.bool] = None,
        internet_facing: typing.Optional[builtins.bool] = None,
        load_balancer_name: typing.Optional[builtins.str] = None,
        minimum_capacity_unit: typing.Optional[jsii.Number] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param client_routing_policy: The AZ affinity routing policy. Default: - AZ affinity is disabled.
        :param enable_prefix_for_ipv6_source_nat: Indicates whether to use an IPv6 prefix from each subnet for source NAT. The IP address type must be IpAddressType.DUALSTACK. Default: undefined - NLB default behavior is false
        :param enforce_security_group_inbound_rules_on_private_link_traffic: Indicates whether to evaluate inbound security group rules for traffic sent to a Network Load Balancer through AWS PrivateLink. Default: true
        :param ip_address_type: The type of IP addresses to use. If you want to add a UDP or TCP_UDP listener to the load balancer, you must choose IPv4. Default: IpAddressType.IPV4
        :param security_groups: Security groups to associate with this load balancer. Default: - No security groups associated with the load balancer.
        :param subnet_mappings: Subnet information for the load balancer. Default: undefined - The VPC default strategy for subnets is used
        :param zonal_shift: Indicates whether zonal shift is enabled. Default: false
        :param vpc: The VPC network to place the load balancer in.
        :param cross_zone_enabled: Indicates whether cross-zone load balancing is enabled. Default: - false for Network Load Balancers and true for Application Load Balancers. This can not be ``false`` for Application Load Balancers.
        :param deletion_protection: Indicates whether deletion protection is enabled. Default: false
        :param deny_all_igw_traffic: Indicates whether the load balancer blocks traffic through the Internet Gateway (IGW). Default: - false for internet-facing load balancers and true for internal load balancers
        :param internet_facing: Whether the load balancer has an internet-routable address. Default: false
        :param load_balancer_name: Name of the load balancer. Default: - Automatically generated name.
        :param minimum_capacity_unit: The minimum capacity (LCU) for a load balancer. Default: undefined - ELB default is 0 LCU
        :param vpc_subnets: Which subnets place the load balancer in. Default: - the Vpc default strategy.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__874e9ac8bfe6b4390ce3de1ea0547a4b95e0deaa39bde80303f049200372a208)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancerProps(
            client_routing_policy=client_routing_policy,
            enable_prefix_for_ipv6_source_nat=enable_prefix_for_ipv6_source_nat,
            enforce_security_group_inbound_rules_on_private_link_traffic=enforce_security_group_inbound_rules_on_private_link_traffic,
            ip_address_type=ip_address_type,
            security_groups=security_groups,
            subnet_mappings=subnet_mappings,
            zonal_shift=zonal_shift,
            vpc=vpc,
            cross_zone_enabled=cross_zone_enabled,
            deletion_protection=deletion_protection,
            deny_all_igw_traffic=deny_all_igw_traffic,
            internet_facing=internet_facing,
            load_balancer_name=load_balancer_name,
            minimum_capacity_unit=minimum_capacity_unit,
            vpc_subnets=vpc_subnets,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmTcpElbResetCount")
    def alarm_tcp_elb_reset_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "NetworkLoadBalancerTcpElbResetCountAlarm":
        '''Creates an alarm that monitors the TCP reset count from the load balancer.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is sending TCP reset packets. A high number of resets can indicate connectivity issues between the load balancer and clients.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - TcpElbResetCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of TCP resets from the load balancer. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = NetworkLoadBalancerTcpElbResetCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("NetworkLoadBalancerTcpElbResetCountAlarm", jsii.invoke(self, "alarmTcpElbResetCount", [props]))

    @jsii.member(jsii_name="alarmTcpTargetResetCount")
    def alarm_tcp_target_reset_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "NetworkLoadBalancerTcpTargetResetCountAlarm":
        '''Creates an alarm that monitors the TCP reset count from targets.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the targets are sending TCP reset packets. A high number of resets can indicate connectivity issues between the load balancer and targets.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - TcpTargetResetCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of TCP resets from targets. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = NetworkLoadBalancerTcpTargetResetCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("NetworkLoadBalancerTcpTargetResetCountAlarm", jsii.invoke(self, "alarmTcpTargetResetCount", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_tcp_elb_reset_count_alarm: typing.Optional[typing.Union["NetworkLoadBalancerTcpElbResetCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_tcp_target_reset_count_alarm: typing.Optional[typing.Union["NetworkLoadBalancerTcpTargetResetCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["NetworkLoadBalancerRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "NetworkLoadBalancerRecommendedAlarms":
        '''Creates the recommended alarms for the NetworkLoadBalancer.

        :param config_tcp_elb_reset_count_alarm: The configuration for the TcpElbResetCount alarm.
        :param config_tcp_target_reset_count_alarm: The configuration for the TcpTargetResetCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
        '''
        props = NetworkLoadBalancerRecommendedAlarmsConfig(
            config_tcp_elb_reset_count_alarm=config_tcp_elb_reset_count_alarm,
            config_tcp_target_reset_count_alarm=config_tcp_target_reset_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("NetworkLoadBalancerRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class NetworkLoadBalancerAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0515ec7baa9a97e7fe9dca5f5fb09c4ccd2f756be846c83a08b945f926c79991)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkLoadBalancerAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"load_balancer": "loadBalancer"},
)
class NetworkLoadBalancerAlarmProps:
    def __init__(
        self,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
    ) -> None:
        '''The common properties for the NetworkLoadBalancer alarms.

        :param load_balancer: The NetworkLoadBalancer to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a042005463fef364a5f88c76af00084ea1545130546ffbfa88720e8d7a5a30ff)
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer": load_balancer,
        }

    @builtins.property
    def load_balancer(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer:
        '''The NetworkLoadBalancer to monitor.'''
        result = self._values.get("load_balancer")
        assert result is not None, "Required property 'load_balancer' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkLoadBalancerAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkLoadBalancerRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for a NetworkLoadBalancer.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
        config_tcp_elb_reset_count_alarm: typing.Optional[typing.Union["NetworkLoadBalancerTcpElbResetCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_tcp_target_reset_count_alarm: typing.Optional[typing.Union["NetworkLoadBalancerTcpTargetResetCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["NetworkLoadBalancerRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param load_balancer: The NetworkLoadBalancer to monitor.
        :param config_tcp_elb_reset_count_alarm: The configuration for the TcpElbResetCount alarm.
        :param config_tcp_target_reset_count_alarm: The configuration for the TcpTargetResetCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d65070d625da4f4f5bd8bbb6a934e43bc1eead3d7256fc7bce8dadf7fb9e3ba9)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = NetworkLoadBalancerRecommendedAlarmsProps(
            load_balancer=load_balancer,
            config_tcp_elb_reset_count_alarm=config_tcp_elb_reset_count_alarm,
            config_tcp_target_reset_count_alarm=config_tcp_target_reset_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmTcpElbResetCount")
    def alarm_tcp_elb_reset_count(
        self,
    ) -> typing.Optional["NetworkLoadBalancerTcpElbResetCountAlarm"]:
        '''The TcpElbResetCount alarm.'''
        return typing.cast(typing.Optional["NetworkLoadBalancerTcpElbResetCountAlarm"], jsii.get(self, "alarmTcpElbResetCount"))

    @builtins.property
    @jsii.member(jsii_name="alarmTcpTargetResetCount")
    def alarm_tcp_target_reset_count(
        self,
    ) -> typing.Optional["NetworkLoadBalancerTcpTargetResetCountAlarm"]:
        '''The TcpTargetResetCount alarm.'''
        return typing.cast(typing.Optional["NetworkLoadBalancerTcpTargetResetCountAlarm"], jsii.get(self, "alarmTcpTargetResetCount"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class NetworkLoadBalancerRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for a NetworkLoadBalancer.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
    '''

    def __init__(
        self,
        *,
        config_tcp_elb_reset_count_alarm: typing.Optional[typing.Union["NetworkLoadBalancerTcpElbResetCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_tcp_target_reset_count_alarm: typing.Optional[typing.Union["NetworkLoadBalancerTcpTargetResetCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["NetworkLoadBalancerRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_tcp_elb_reset_count_alarm: The configuration for the TcpElbResetCount alarm.
        :param config_tcp_target_reset_count_alarm: The configuration for the TcpTargetResetCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = NetworkLoadBalancerRecommendedAlarmsConfig(
            config_tcp_elb_reset_count_alarm=config_tcp_elb_reset_count_alarm,
            config_tcp_target_reset_count_alarm=config_tcp_target_reset_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1db9f286784a34f19abe8e6d579bab5004c193dd611df480072819f96cbe24bd)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_tcp_elb_reset_count_alarm": "configTcpElbResetCountAlarm",
        "config_tcp_target_reset_count_alarm": "configTcpTargetResetCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class NetworkLoadBalancerRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_tcp_elb_reset_count_alarm: typing.Optional[typing.Union["NetworkLoadBalancerTcpElbResetCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_tcp_target_reset_count_alarm: typing.Optional[typing.Union["NetworkLoadBalancerTcpTargetResetCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["NetworkLoadBalancerRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for a NetworkLoadBalancer.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_tcp_elb_reset_count_alarm: The configuration for the TcpElbResetCount alarm.
        :param config_tcp_target_reset_count_alarm: The configuration for the TcpTargetResetCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_tcp_elb_reset_count_alarm, dict):
            config_tcp_elb_reset_count_alarm = NetworkLoadBalancerTcpElbResetCountAlarmConfig(**config_tcp_elb_reset_count_alarm)
        if isinstance(config_tcp_target_reset_count_alarm, dict):
            config_tcp_target_reset_count_alarm = NetworkLoadBalancerTcpTargetResetCountAlarmConfig(**config_tcp_target_reset_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e6f19bb799f2b45f402b4b1db18463c0fdd741831880cac23bd2976ed7ccfd59)
            check_type(argname="argument config_tcp_elb_reset_count_alarm", value=config_tcp_elb_reset_count_alarm, expected_type=type_hints["config_tcp_elb_reset_count_alarm"])
            check_type(argname="argument config_tcp_target_reset_count_alarm", value=config_tcp_target_reset_count_alarm, expected_type=type_hints["config_tcp_target_reset_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_tcp_elb_reset_count_alarm is not None:
            self._values["config_tcp_elb_reset_count_alarm"] = config_tcp_elb_reset_count_alarm
        if config_tcp_target_reset_count_alarm is not None:
            self._values["config_tcp_target_reset_count_alarm"] = config_tcp_target_reset_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_tcp_elb_reset_count_alarm(
        self,
    ) -> typing.Optional["NetworkLoadBalancerTcpElbResetCountAlarmConfig"]:
        '''The configuration for the TcpElbResetCount alarm.'''
        result = self._values.get("config_tcp_elb_reset_count_alarm")
        return typing.cast(typing.Optional["NetworkLoadBalancerTcpElbResetCountAlarmConfig"], result)

    @builtins.property
    def config_tcp_target_reset_count_alarm(
        self,
    ) -> typing.Optional["NetworkLoadBalancerTcpTargetResetCountAlarmConfig"]:
        '''The configuration for the TcpTargetResetCount alarm.'''
        result = self._values.get("config_tcp_target_reset_count_alarm")
        return typing.cast(typing.Optional["NetworkLoadBalancerTcpTargetResetCountAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["NetworkLoadBalancerRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["NetworkLoadBalancerRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkLoadBalancerRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerRecommendedAlarmsMetrics"
)
class NetworkLoadBalancerRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for NetworkLoadBalancer alarms.'''

    TCP_ELB_RESET_COUNT = "TCP_ELB_RESET_COUNT"
    '''The number of reset (RST) packets sent from the load balancer.'''
    TCP_TARGET_RESET_COUNT = "TCP_TARGET_RESET_COUNT"
    '''The number of reset (RST) packets generated by the targets.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerRecommendedAlarmsProps",
    jsii_struct_bases=[NetworkLoadBalancerRecommendedAlarmsConfig],
    name_mapping={
        "config_tcp_elb_reset_count_alarm": "configTcpElbResetCountAlarm",
        "config_tcp_target_reset_count_alarm": "configTcpTargetResetCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "load_balancer": "loadBalancer",
    },
)
class NetworkLoadBalancerRecommendedAlarmsProps(
    NetworkLoadBalancerRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config_tcp_elb_reset_count_alarm: typing.Optional[typing.Union["NetworkLoadBalancerTcpElbResetCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_tcp_target_reset_count_alarm: typing.Optional[typing.Union["NetworkLoadBalancerTcpTargetResetCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[NetworkLoadBalancerRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
    ) -> None:
        '''Properties for the NetworkLoadBalancerRecommendedAlarms construct.

        :param config_tcp_elb_reset_count_alarm: The configuration for the TcpElbResetCount alarm.
        :param config_tcp_target_reset_count_alarm: The configuration for the TcpTargetResetCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param load_balancer: The NetworkLoadBalancer to monitor.
        '''
        if isinstance(config_tcp_elb_reset_count_alarm, dict):
            config_tcp_elb_reset_count_alarm = NetworkLoadBalancerTcpElbResetCountAlarmConfig(**config_tcp_elb_reset_count_alarm)
        if isinstance(config_tcp_target_reset_count_alarm, dict):
            config_tcp_target_reset_count_alarm = NetworkLoadBalancerTcpTargetResetCountAlarmConfig(**config_tcp_target_reset_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c20735cdb328f14217da067af2cbd56f7eea52a6416a904ef77e6b9e3f950ba9)
            check_type(argname="argument config_tcp_elb_reset_count_alarm", value=config_tcp_elb_reset_count_alarm, expected_type=type_hints["config_tcp_elb_reset_count_alarm"])
            check_type(argname="argument config_tcp_target_reset_count_alarm", value=config_tcp_target_reset_count_alarm, expected_type=type_hints["config_tcp_target_reset_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer": load_balancer,
        }
        if config_tcp_elb_reset_count_alarm is not None:
            self._values["config_tcp_elb_reset_count_alarm"] = config_tcp_elb_reset_count_alarm
        if config_tcp_target_reset_count_alarm is not None:
            self._values["config_tcp_target_reset_count_alarm"] = config_tcp_target_reset_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_tcp_elb_reset_count_alarm(
        self,
    ) -> typing.Optional["NetworkLoadBalancerTcpElbResetCountAlarmConfig"]:
        '''The configuration for the TcpElbResetCount alarm.'''
        result = self._values.get("config_tcp_elb_reset_count_alarm")
        return typing.cast(typing.Optional["NetworkLoadBalancerTcpElbResetCountAlarmConfig"], result)

    @builtins.property
    def config_tcp_target_reset_count_alarm(
        self,
    ) -> typing.Optional["NetworkLoadBalancerTcpTargetResetCountAlarmConfig"]:
        '''The configuration for the TcpTargetResetCount alarm.'''
        result = self._values.get("config_tcp_target_reset_count_alarm")
        return typing.cast(typing.Optional["NetworkLoadBalancerTcpTargetResetCountAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[NetworkLoadBalancerRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[NetworkLoadBalancerRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def load_balancer(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer:
        '''The NetworkLoadBalancer to monitor.'''
        result = self._values.get("load_balancer")
        assert result is not None, "Required property 'load_balancer' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkLoadBalancerRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkLoadBalancerTcpElbResetCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerTcpElbResetCountAlarm",
):
    '''This alarm is used to detect when the load balancer is sending TCP reset packets.

    A high number of resets can indicate connectivity issues between the load balancer and clients.

    The alarm is triggered when the number of TCP resets from the load balancer is greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param load_balancer: The NetworkLoadBalancer to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is sending TCP reset packets. A high number of resets can indicate connectivity issues between the load balancer and clients.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - TcpElbResetCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of TCP resets from the load balancer. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab43ec376817ab515b876d1b7f25cf2c60b7fe8d81b1acfcc894580e87bbdafe)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = NetworkLoadBalancerTcpElbResetCountAlarmProps(
            load_balancer=load_balancer,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerTcpElbResetCountAlarmConfig",
    jsii_struct_bases=[NetworkLoadBalancerAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class NetworkLoadBalancerTcpElbResetCountAlarmConfig(
    NetworkLoadBalancerAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the TcpElbResetCount alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is sending TCP reset packets. A high number of resets can indicate connectivity issues between the load balancer and clients.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - TcpElbResetCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of TCP resets from the load balancer. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__41e8b925eece3dd92773a65de87f89ba82cc955bd301ee53994c41145aa1d661)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the load balancer is sending TCP reset packets.
        A high number of resets can indicate connectivity issues between the load balancer and clients.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - TcpElbResetCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the acceptable number of TCP resets from the load balancer.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkLoadBalancerTcpElbResetCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerTcpElbResetCountAlarmProps",
    jsii_struct_bases=[
        NetworkLoadBalancerAlarmProps, NetworkLoadBalancerTcpElbResetCountAlarmConfig
    ],
    name_mapping={
        "load_balancer": "loadBalancer",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class NetworkLoadBalancerTcpElbResetCountAlarmProps(
    NetworkLoadBalancerAlarmProps,
    NetworkLoadBalancerTcpElbResetCountAlarmConfig,
):
    def __init__(
        self,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the NetworkLoadBalancerTcpElbResetCountAlarm construct.

        :param load_balancer: The NetworkLoadBalancer to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the load balancer is sending TCP reset packets. A high number of resets can indicate connectivity issues between the load balancer and clients.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - TcpElbResetCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of TCP resets from the load balancer. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48192b1f47fd7069ea7cb2570e07a605b5b4babc55ac3775b7bbc07d5f37fa65)
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer": load_balancer,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def load_balancer(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer:
        '''The NetworkLoadBalancer to monitor.'''
        result = self._values.get("load_balancer")
        assert result is not None, "Required property 'load_balancer' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the load balancer is sending TCP reset packets.
        A high number of resets can indicate connectivity issues between the load balancer and clients.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - TcpElbResetCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the acceptable number of TCP resets from the load balancer.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkLoadBalancerTcpElbResetCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkLoadBalancerTcpTargetResetCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerTcpTargetResetCountAlarm",
):
    '''This alarm is used to detect when the targets are sending TCP reset packets.

    A high number of resets can indicate connectivity issues between the load balancer and targets.

    The alarm is triggered when the number of TCP resets from targets is greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param load_balancer: The NetworkLoadBalancer to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the targets are sending TCP reset packets. A high number of resets can indicate connectivity issues between the load balancer and targets.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - TcpTargetResetCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of TCP resets from targets. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0a76efa5d158d5895364ed3746b7368fdeb34e34bada265019b3249248ff7bc8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = NetworkLoadBalancerTcpTargetResetCountAlarmProps(
            load_balancer=load_balancer,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerTcpTargetResetCountAlarmConfig",
    jsii_struct_bases=[NetworkLoadBalancerAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class NetworkLoadBalancerTcpTargetResetCountAlarmConfig(
    NetworkLoadBalancerAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the TcpTargetResetCount alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the targets are sending TCP reset packets. A high number of resets can indicate connectivity issues between the load balancer and targets.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - TcpTargetResetCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of TCP resets from targets. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8da4f13d68355310c54154c754f80672835a1bbe422124b6501860e62f850f50)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the targets are sending TCP reset packets.
        A high number of resets can indicate connectivity issues between the load balancer and targets.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - TcpTargetResetCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the acceptable number of TCP resets from targets.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkLoadBalancerTcpTargetResetCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkLoadBalancerTcpTargetResetCountAlarmProps",
    jsii_struct_bases=[
        NetworkLoadBalancerAlarmProps,
        NetworkLoadBalancerTcpTargetResetCountAlarmConfig,
    ],
    name_mapping={
        "load_balancer": "loadBalancer",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class NetworkLoadBalancerTcpTargetResetCountAlarmProps(
    NetworkLoadBalancerAlarmProps,
    NetworkLoadBalancerTcpTargetResetCountAlarmConfig,
):
    def __init__(
        self,
        *,
        load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the NetworkLoadBalancerTcpTargetResetCountAlarm construct.

        :param load_balancer: The NetworkLoadBalancer to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the targets are sending TCP reset packets. A high number of resets can indicate connectivity issues between the load balancer and targets.
        :param alarm_name: The alarm name. Default: - loadBalancerName + ' - TcpTargetResetCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the acceptable number of TCP resets from targets. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ae6c36fc4b83d6eb07e7b90c83534a4f2b6edd09f188cad8a92f686641fb9cd1)
            check_type(argname="argument load_balancer", value=load_balancer, expected_type=type_hints["load_balancer"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer": load_balancer,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def load_balancer(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer:
        '''The NetworkLoadBalancer to monitor.'''
        result = self._values.get("load_balancer")
        assert result is not None, "Required property 'load_balancer' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the targets are sending TCP reset packets.
        A high number of resets can indicate connectivity issues between the load balancer and targets.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - loadBalancerName + ' - TcpTargetResetCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the acceptable number of TCP resets from targets.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkLoadBalancerTcpTargetResetCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkTargetGroup(
    _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroup",
):
    '''An extension for the NetworkTargetGroup construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        port: jsii.Number,
        connection_termination: typing.Optional[builtins.bool] = None,
        preserve_client_ip: typing.Optional[builtins.bool] = None,
        protocol: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.Protocol] = None,
        proxy_protocol_v2: typing.Optional[builtins.bool] = None,
        targets: typing.Optional[typing.Sequence[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.INetworkLoadBalancerTarget]] = None,
        cross_zone_enabled: typing.Optional[builtins.bool] = None,
        deregistration_delay: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        health_check: typing.Optional[typing.Union[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.HealthCheck, typing.Dict[builtins.str, typing.Any]]] = None,
        ip_address_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.TargetGroupIpAddressType] = None,
        target_group_name: typing.Optional[builtins.str] = None,
        target_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.TargetType] = None,
        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param port: The port on which the target receives traffic.
        :param connection_termination: Indicates whether the load balancer terminates connections at the end of the deregistration timeout. Default: false
        :param preserve_client_ip: Indicates whether client IP preservation is enabled. Default: false if the target group type is IP address and the target group protocol is TCP or TLS. Otherwise, true.
        :param protocol: Protocol for target group, expects TCP, TLS, UDP, or TCP_UDP. Default: - TCP
        :param proxy_protocol_v2: Indicates whether Proxy Protocol version 2 is enabled. Default: false
        :param targets: The targets to add to this target group. Can be ``Instance``, ``IPAddress``, or any self-registering load balancing target. If you use either ``Instance`` or ``IPAddress`` as targets, all target must be of the same type. Default: - No targets.
        :param cross_zone_enabled: Indicates whether cross zone load balancing is enabled. Default: - use load balancer configuration
        :param deregistration_delay: The amount of time for Elastic Load Balancing to wait before deregistering a target. The range is 0-3600 seconds. Default: 300
        :param health_check: Health check configuration. Default: - The default value for each property in this configuration varies depending on the target.
        :param ip_address_type: The type of IP addresses of the targets registered with the target group. Default: undefined - ELB defaults to IPv4
        :param target_group_name: The name of the target group. This name must be unique per region per account, can have a maximum of 32 characters, must contain only alphanumeric characters or hyphens, and must not begin or end with a hyphen. Default: - Automatically generated.
        :param target_type: The type of targets registered to this TargetGroup, either IP or Instance. All targets registered into the group must be of this type. If you register targets to the TargetGroup in the CDK app, the TargetType is determined automatically. Default: - Determined automatically.
        :param vpc: The virtual private cloud (VPC). only if ``TargetType`` is ``Ip`` or ``InstanceId`` Default: - undefined
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__627d81e1a6674ec72062a0ab3ca6a35a9653340ccfcbe1696a77d86472d6eb43)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroupProps(
            port=port,
            connection_termination=connection_termination,
            preserve_client_ip=preserve_client_ip,
            protocol=protocol,
            proxy_protocol_v2=proxy_protocol_v2,
            targets=targets,
            cross_zone_enabled=cross_zone_enabled,
            deregistration_delay=deregistration_delay,
            health_check=health_check,
            ip_address_type=ip_address_type,
            target_group_name=target_group_name,
            target_type=target_type,
            vpc=vpc,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmHealthyHostCount")
    def alarm_healthy_host_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "NetworkTargetGroupHealthyHostCountAlarm":
        '''Creates an alarm that monitors the healthy host count for the NetworkTargetGroup.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of healthy hosts in the target group falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - HealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the minimum number of healthy hosts required for your application to function properly. Default: 1
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = NetworkTargetGroupHealthyHostCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("NetworkTargetGroupHealthyHostCountAlarm", jsii.invoke(self, "alarmHealthyHostCount", [props]))

    @jsii.member(jsii_name="alarmUnHealthyHostCount")
    def alarm_un_healthy_host_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "NetworkTargetGroupUnHealthyHostCountAlarm":
        '''Creates an alarm that monitors the unhealthy host count for the NetworkTargetGroup.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of unhealthy hosts in the target group exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - UnHealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the maximum number of unhealthy hosts that your application can tolerate before service is impacted. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = NetworkTargetGroupUnHealthyHostCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("NetworkTargetGroupUnHealthyHostCountAlarm", jsii.invoke(self, "alarmUnHealthyHostCount", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_healthy_host_count_alarm: typing.Optional[typing.Union["NetworkTargetGroupHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_un_healthy_host_count_alarm: typing.Optional[typing.Union["NetworkTargetGroupUnHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["NetworkTargetGroupRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "NetworkTargetGroupRecommendedAlarms":
        '''Creates the recommended alarms for the NetworkTargetGroup.

        :param config_healthy_host_count_alarm: The configuration for the HealthyHostCount alarm.
        :param config_un_healthy_host_count_alarm: The configuration for the UnHealthyHostCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
        '''
        props = NetworkTargetGroupRecommendedAlarmsConfig(
            config_healthy_host_count_alarm=config_healthy_host_count_alarm,
            config_un_healthy_host_count_alarm=config_un_healthy_host_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("NetworkTargetGroupRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class NetworkTargetGroupAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8d61a24f86c919c4efda6399e4c6de688c683bbc631c225d31afb4727051e304)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkTargetGroupAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"target_group": "targetGroup"},
)
class NetworkTargetGroupAlarmProps:
    def __init__(
        self,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
    ) -> None:
        '''The common properties for the NetworkTargetGroup alarms.

        :param target_group: The NetworkTargetGroup to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__94ea805edd5c2534fca28e7747f63a6fdd8388c96342e5cf391e26fdd2552b2b)
            check_type(argname="argument target_group", value=target_group, expected_type=type_hints["target_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "target_group": target_group,
        }

    @builtins.property
    def target_group(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup:
        '''The NetworkTargetGroup to monitor.'''
        result = self._values.get("target_group")
        assert result is not None, "Required property 'target_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkTargetGroupAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkTargetGroupHealthyHostCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupHealthyHostCountAlarm",
):
    '''This alarm is used to detect when the number of healthy hosts in the target group falls below the threshold.

    A low number of healthy hosts can indicate service availability issues.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param target_group: The NetworkTargetGroup to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of healthy hosts in the target group falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - HealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the minimum number of healthy hosts required for your application to function properly. Default: 1
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d4e4c83d2335cae7725bc362c38102a05363a5f3158734f62a68d91c68d5f9ce)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = NetworkTargetGroupHealthyHostCountAlarmProps(
            target_group=target_group,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupHealthyHostCountAlarmConfig",
    jsii_struct_bases=[NetworkTargetGroupAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class NetworkTargetGroupHealthyHostCountAlarmConfig(NetworkTargetGroupAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the HealthyHostCount alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of healthy hosts in the target group falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - HealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the minimum number of healthy hosts required for your application to function properly. Default: 1
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1aa11b231c6b8b433836d1fc73c0ef765dd1329c2f8a3bb14eabf1520d2e3d21)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the number of healthy hosts in the target group
        falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - targetGroupName + ' - HealthyHostCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the minimum number of healthy hosts
        required for your application to function properly.

        :default: 1
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkTargetGroupHealthyHostCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupHealthyHostCountAlarmProps",
    jsii_struct_bases=[
        NetworkTargetGroupAlarmProps, NetworkTargetGroupHealthyHostCountAlarmConfig
    ],
    name_mapping={
        "target_group": "targetGroup",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class NetworkTargetGroupHealthyHostCountAlarmProps(
    NetworkTargetGroupAlarmProps,
    NetworkTargetGroupHealthyHostCountAlarmConfig,
):
    def __init__(
        self,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the NetworkTargetGroupHealthyHostCountAlarm construct.

        :param target_group: The NetworkTargetGroup to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of healthy hosts in the target group falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - HealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the minimum number of healthy hosts required for your application to function properly. Default: 1
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__857fe8dcb085f183a8d4602e51f88041d7882252de61f7fabb1baa8a04e7453a)
            check_type(argname="argument target_group", value=target_group, expected_type=type_hints["target_group"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "target_group": target_group,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def target_group(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup:
        '''The NetworkTargetGroup to monitor.'''
        result = self._values.get("target_group")
        assert result is not None, "Required property 'target_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the number of healthy hosts in the target group
        falls below the threshold. A low number of healthy hosts can indicate service availability issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - targetGroupName + ' - HealthyHostCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the minimum number of healthy hosts
        required for your application to function properly.

        :default: 1
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkTargetGroupHealthyHostCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkTargetGroupRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for a NetworkTargetGroup.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
        config_healthy_host_count_alarm: typing.Optional[typing.Union[NetworkTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_un_healthy_host_count_alarm: typing.Optional[typing.Union["NetworkTargetGroupUnHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["NetworkTargetGroupRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param target_group: The NetworkTargetGroup to monitor.
        :param config_healthy_host_count_alarm: The configuration for the HealthyHostCount alarm.
        :param config_un_healthy_host_count_alarm: The configuration for the UnHealthyHostCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__60ea91e825b25cd9eed9bb40d155812dc0a8bd73008214a67c25f16d41aa268a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = NetworkTargetGroupRecommendedAlarmsProps(
            target_group=target_group,
            config_healthy_host_count_alarm=config_healthy_host_count_alarm,
            config_un_healthy_host_count_alarm=config_un_healthy_host_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmHealthyHostCount")
    def alarm_healthy_host_count(
        self,
    ) -> typing.Optional[NetworkTargetGroupHealthyHostCountAlarm]:
        '''The HealthyHostCount alarm.'''
        return typing.cast(typing.Optional[NetworkTargetGroupHealthyHostCountAlarm], jsii.get(self, "alarmHealthyHostCount"))

    @builtins.property
    @jsii.member(jsii_name="alarmUnHealthyHostCount")
    def alarm_un_healthy_host_count(
        self,
    ) -> typing.Optional["NetworkTargetGroupUnHealthyHostCountAlarm"]:
        '''The UnHealthyHostCount alarm.'''
        return typing.cast(typing.Optional["NetworkTargetGroupUnHealthyHostCountAlarm"], jsii.get(self, "alarmUnHealthyHostCount"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class NetworkTargetGroupRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for a NetworkTargetGroup.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/elb-metricscollected.html
    '''

    def __init__(
        self,
        *,
        config_healthy_host_count_alarm: typing.Optional[typing.Union[NetworkTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_un_healthy_host_count_alarm: typing.Optional[typing.Union["NetworkTargetGroupUnHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["NetworkTargetGroupRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_healthy_host_count_alarm: The configuration for the HealthyHostCount alarm.
        :param config_un_healthy_host_count_alarm: The configuration for the UnHealthyHostCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = NetworkTargetGroupRecommendedAlarmsConfig(
            config_healthy_host_count_alarm=config_healthy_host_count_alarm,
            config_un_healthy_host_count_alarm=config_un_healthy_host_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab884658252b1f82046d44ffa0176382e35c5307b0dfa633905a7e952412ad5f)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_healthy_host_count_alarm": "configHealthyHostCountAlarm",
        "config_un_healthy_host_count_alarm": "configUnHealthyHostCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class NetworkTargetGroupRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_healthy_host_count_alarm: typing.Optional[typing.Union[NetworkTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_un_healthy_host_count_alarm: typing.Optional[typing.Union["NetworkTargetGroupUnHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["NetworkTargetGroupRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for a NetworkTargetGroup.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_healthy_host_count_alarm: The configuration for the HealthyHostCount alarm.
        :param config_un_healthy_host_count_alarm: The configuration for the UnHealthyHostCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_healthy_host_count_alarm, dict):
            config_healthy_host_count_alarm = NetworkTargetGroupHealthyHostCountAlarmConfig(**config_healthy_host_count_alarm)
        if isinstance(config_un_healthy_host_count_alarm, dict):
            config_un_healthy_host_count_alarm = NetworkTargetGroupUnHealthyHostCountAlarmConfig(**config_un_healthy_host_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a40c85d5c69c0d5aa4357ad525b38c0e9ac7f00ccaa6498fc475cfe0dc8d0222)
            check_type(argname="argument config_healthy_host_count_alarm", value=config_healthy_host_count_alarm, expected_type=type_hints["config_healthy_host_count_alarm"])
            check_type(argname="argument config_un_healthy_host_count_alarm", value=config_un_healthy_host_count_alarm, expected_type=type_hints["config_un_healthy_host_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_healthy_host_count_alarm is not None:
            self._values["config_healthy_host_count_alarm"] = config_healthy_host_count_alarm
        if config_un_healthy_host_count_alarm is not None:
            self._values["config_un_healthy_host_count_alarm"] = config_un_healthy_host_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_healthy_host_count_alarm(
        self,
    ) -> typing.Optional[NetworkTargetGroupHealthyHostCountAlarmConfig]:
        '''The configuration for the HealthyHostCount alarm.'''
        result = self._values.get("config_healthy_host_count_alarm")
        return typing.cast(typing.Optional[NetworkTargetGroupHealthyHostCountAlarmConfig], result)

    @builtins.property
    def config_un_healthy_host_count_alarm(
        self,
    ) -> typing.Optional["NetworkTargetGroupUnHealthyHostCountAlarmConfig"]:
        '''The configuration for the UnHealthyHostCount alarm.'''
        result = self._values.get("config_un_healthy_host_count_alarm")
        return typing.cast(typing.Optional["NetworkTargetGroupUnHealthyHostCountAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["NetworkTargetGroupRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["NetworkTargetGroupRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkTargetGroupRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupRecommendedAlarmsMetrics"
)
class NetworkTargetGroupRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for NetworkTargetGroup alarms.'''

    HEALTHY_HOST_COUNT = "HEALTHY_HOST_COUNT"
    '''The number of healthy targets in the target group.'''
    UNHEALTHY_HOST_COUNT = "UNHEALTHY_HOST_COUNT"
    '''The number of unhealthy targets in the target group.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupRecommendedAlarmsProps",
    jsii_struct_bases=[NetworkTargetGroupRecommendedAlarmsConfig],
    name_mapping={
        "config_healthy_host_count_alarm": "configHealthyHostCountAlarm",
        "config_un_healthy_host_count_alarm": "configUnHealthyHostCountAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "target_group": "targetGroup",
    },
)
class NetworkTargetGroupRecommendedAlarmsProps(
    NetworkTargetGroupRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config_healthy_host_count_alarm: typing.Optional[typing.Union[NetworkTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_un_healthy_host_count_alarm: typing.Optional[typing.Union["NetworkTargetGroupUnHealthyHostCountAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[NetworkTargetGroupRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
    ) -> None:
        '''Properties for the NetworkTargetGroupRecommendedAlarms construct.

        :param config_healthy_host_count_alarm: The configuration for the HealthyHostCount alarm.
        :param config_un_healthy_host_count_alarm: The configuration for the UnHealthyHostCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param target_group: The NetworkTargetGroup to monitor.
        '''
        if isinstance(config_healthy_host_count_alarm, dict):
            config_healthy_host_count_alarm = NetworkTargetGroupHealthyHostCountAlarmConfig(**config_healthy_host_count_alarm)
        if isinstance(config_un_healthy_host_count_alarm, dict):
            config_un_healthy_host_count_alarm = NetworkTargetGroupUnHealthyHostCountAlarmConfig(**config_un_healthy_host_count_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8fc4e40c8e0cc44d2fb42c90e36c26093379cc0534cb6c6d592475b3898bc6c7)
            check_type(argname="argument config_healthy_host_count_alarm", value=config_healthy_host_count_alarm, expected_type=type_hints["config_healthy_host_count_alarm"])
            check_type(argname="argument config_un_healthy_host_count_alarm", value=config_un_healthy_host_count_alarm, expected_type=type_hints["config_un_healthy_host_count_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument target_group", value=target_group, expected_type=type_hints["target_group"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "target_group": target_group,
        }
        if config_healthy_host_count_alarm is not None:
            self._values["config_healthy_host_count_alarm"] = config_healthy_host_count_alarm
        if config_un_healthy_host_count_alarm is not None:
            self._values["config_un_healthy_host_count_alarm"] = config_un_healthy_host_count_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_healthy_host_count_alarm(
        self,
    ) -> typing.Optional[NetworkTargetGroupHealthyHostCountAlarmConfig]:
        '''The configuration for the HealthyHostCount alarm.'''
        result = self._values.get("config_healthy_host_count_alarm")
        return typing.cast(typing.Optional[NetworkTargetGroupHealthyHostCountAlarmConfig], result)

    @builtins.property
    def config_un_healthy_host_count_alarm(
        self,
    ) -> typing.Optional["NetworkTargetGroupUnHealthyHostCountAlarmConfig"]:
        '''The configuration for the UnHealthyHostCount alarm.'''
        result = self._values.get("config_un_healthy_host_count_alarm")
        return typing.cast(typing.Optional["NetworkTargetGroupUnHealthyHostCountAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[NetworkTargetGroupRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[NetworkTargetGroupRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def target_group(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup:
        '''The NetworkTargetGroup to monitor.'''
        result = self._values.get("target_group")
        assert result is not None, "Required property 'target_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkTargetGroupRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class NetworkTargetGroupUnHealthyHostCountAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupUnHealthyHostCountAlarm",
):
    '''This alarm is used to detect when the number of unhealthy hosts in the target group exceeds the threshold.

    A high number of unhealthy hosts can indicate service health issues.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param target_group: The NetworkTargetGroup to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of unhealthy hosts in the target group exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - UnHealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the maximum number of unhealthy hosts that your application can tolerate before service is impacted. Default: 0
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f500a18e915524270f3ec1ba216ee7b9e0e53a790757c455ae4f524ae0ff2222)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = NetworkTargetGroupUnHealthyHostCountAlarmProps(
            target_group=target_group,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupUnHealthyHostCountAlarmConfig",
    jsii_struct_bases=[NetworkTargetGroupAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class NetworkTargetGroupUnHealthyHostCountAlarmConfig(
    NetworkTargetGroupAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the UnHealthyHostCount alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of unhealthy hosts in the target group exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - UnHealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the maximum number of unhealthy hosts that your application can tolerate before service is impacted. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1b0eda90b1fc39f4e834c835cfd0f264fdab83c0f820e4a067fd0998f38aef4)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the number of unhealthy hosts in the target group
        exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - targetGroupName + ' - UnHealthyHostCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the maximum number of unhealthy hosts
        that your application can tolerate before service is impacted.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkTargetGroupUnHealthyHostCountAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.NetworkTargetGroupUnHealthyHostCountAlarmProps",
    jsii_struct_bases=[
        NetworkTargetGroupAlarmProps, NetworkTargetGroupUnHealthyHostCountAlarmConfig
    ],
    name_mapping={
        "target_group": "targetGroup",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class NetworkTargetGroupUnHealthyHostCountAlarmProps(
    NetworkTargetGroupAlarmProps,
    NetworkTargetGroupUnHealthyHostCountAlarmConfig,
):
    def __init__(
        self,
        *,
        target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the NetworkTargetGroupUnHealthyHostCountAlarm construct.

        :param target_group: The NetworkTargetGroup to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect when the number of unhealthy hosts in the target group exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        :param alarm_name: The alarm name. Default: - targetGroupName + ' - UnHealthyHostCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value against which the specified statistic is compared. You should set this threshold based on the maximum number of unhealthy hosts that your application can tolerate before service is impacted. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a4c5f589e445ce03d110a99a0c78d6c8ebdeb189355a52f66a19b753d7ca9de7)
            check_type(argname="argument target_group", value=target_group, expected_type=type_hints["target_group"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "target_group": target_group,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def target_group(
        self,
    ) -> _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup:
        '''The NetworkTargetGroup to monitor.'''
        result = self._values.get("target_group")
        assert result is not None, "Required property 'target_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect when the number of unhealthy hosts in the target group
        exceeds the threshold. A high number of unhealthy hosts can indicate service health issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - targetGroupName + ' - UnHealthyHostCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        You should set this threshold based on the maximum number of unhealthy hosts
        that your application can tolerate before service is impacted.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "NetworkTargetGroupUnHealthyHostCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkEndpointsAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class PrivateLinkEndpointsAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6f8fcb8114f64470dce03d9b1f591def295af76f6ac26e5d96480a752b81da6b)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkEndpointsAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkEndpointsInterfaceVpcEndpointAlarmProps",
    jsii_struct_bases=[],
    name_mapping={
        "endpoint": "endpoint",
        "endpoint_type": "endpointType",
        "service_name": "serviceName",
        "subnet_id": "subnetId",
        "vpc_id": "vpcId",
    },
)
class PrivateLinkEndpointsInterfaceVpcEndpointAlarmProps:
    def __init__(
        self,
        *,
        endpoint: _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
        endpoint_type: builtins.str,
        service_name: builtins.str,
        subnet_id: builtins.str,
        vpc_id: builtins.str,
    ) -> None:
        '''The common properties for the PrivateLink InterfaceVpcEndpoint alarms.

        :param endpoint: The PrivateLink InterfaceVpcEndpoint to monitor.
        :param endpoint_type: The type of the PrivateLink InterfaceVpcEndpoint.
        :param service_name: The service name of the PrivateLink InterfaceVpcEndpoint.
        :param subnet_id: The subnet ID of the PrivateLink InterfaceVpcEndpoint.
        :param vpc_id: The VPC ID of the PrivateLink InterfaceVpcEndpoint.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e7c32932c91a0c292e091c8aa6b3ea109446b4ee649ff43bc92bf9314b5302ef)
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument endpoint_type", value=endpoint_type, expected_type=type_hints["endpoint_type"])
            check_type(argname="argument service_name", value=service_name, expected_type=type_hints["service_name"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint": endpoint,
            "endpoint_type": endpoint_type,
            "service_name": service_name,
            "subnet_id": subnet_id,
            "vpc_id": vpc_id,
        }

    @builtins.property
    def endpoint(self) -> _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint:
        '''The PrivateLink InterfaceVpcEndpoint to monitor.'''
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint, result)

    @builtins.property
    def endpoint_type(self) -> builtins.str:
        '''The type of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("endpoint_type")
        assert result is not None, "Required property 'endpoint_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_name(self) -> builtins.str:
        '''The service name of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("service_name")
        assert result is not None, "Required property 'service_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The subnet ID of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The VPC ID of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkEndpointsInterfaceVpcEndpointAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarm",
):
    '''This alarm helps to detect if the endpoint or endpoint service is unhealthy by monitoring the number of packets dropped by the endpoint.

    Note that packets larger than 8500 bytes that arrive at the VPC endpoint are dropped. For troubleshooting,
    see connectivity problems between an interface VPC endpoint and an endpoint service.

    The alarm is triggered when the number of packets dropped exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        endpoint: _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
        endpoint_type: builtins.str,
        service_name: builtins.str,
        subnet_id: builtins.str,
        vpc_id: builtins.str,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        subnets: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISubnet]] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param endpoint: The PrivateLink InterfaceVpcEndpoint to monitor.
        :param endpoint_type: The type of the PrivateLink InterfaceVpcEndpoint.
        :param service_name: The service name of the PrivateLink InterfaceVpcEndpoint.
        :param subnet_id: The subnet ID of the PrivateLink InterfaceVpcEndpoint.
        :param vpc_id: The VPC ID of the PrivateLink InterfaceVpcEndpoint.
        :param threshold: Set the threshold according to the use case. If you want to be aware of the unhealthy status of the endpoint or endpoint service, you should set the threshold low so that you get a chance to fix the issue before a huge data loss. You can use historical data to understand the tolerance for dropped packets and set the threshold accordingly.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect if the endpoint or endpoint service is unhealthy.
        :param alarm_name: The alarm name. Default: - endpointId + ' - ' + subnetId + ' - PacketsDropped'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param subnets: The subnets of the PrivateLink InterfaceVpcEndpoint.
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e29234a4677469008bb4721aa92dd359e80b705446ae051d7b6df69797343916)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarmProps(
            endpoint=endpoint,
            endpoint_type=endpoint_type,
            service_name=service_name,
            subnet_id=subnet_id,
            vpc_id=vpc_id,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            subnets=subnets,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an PrivateLink InterfaceVpcEndpoint.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#PrivateLinkEndpoints
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        endpoint: _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
        config_packets_dropped_alarm: typing.Union["PrivateLinkEndpointsPacketsDroppedAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["PrivateLinkEndpointsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param endpoint: The PrivateLink InterfaceVpcEndpoint to monitor.
        :param config_packets_dropped_alarm: The configuration for the PacketsDropped alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70f23ef143484cf34dcd626e20c76473e0163abac0017f968f70a1306d459034)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsProps(
            endpoint=endpoint,
            config_packets_dropped_alarm=config_packets_dropped_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmPacketsDroppedList")
    def alarm_packets_dropped_list(
        self,
    ) -> typing.Optional[typing.List[PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarm]]:
        '''The PacketsDropped alarm.'''
        return typing.cast(typing.Optional[typing.List[PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarm]], jsii.get(self, "alarmPacketsDroppedList"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_packets_dropped_alarm": "configPacketsDroppedAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_packets_dropped_alarm: typing.Union["PrivateLinkEndpointsPacketsDroppedAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["PrivateLinkEndpointsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an PrivateLink Service.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_packets_dropped_alarm: The configuration for the PacketsDropped alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_packets_dropped_alarm, dict):
            config_packets_dropped_alarm = PrivateLinkEndpointsPacketsDroppedAlarmConfig(**config_packets_dropped_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68e9f6cc3de404c6c67539b37f29edca951989c0e4ad916dd9a1847c092ad4d0)
            check_type(argname="argument config_packets_dropped_alarm", value=config_packets_dropped_alarm, expected_type=type_hints["config_packets_dropped_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_packets_dropped_alarm": config_packets_dropped_alarm,
        }
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_packets_dropped_alarm(
        self,
    ) -> "PrivateLinkEndpointsPacketsDroppedAlarmConfig":
        '''The configuration for the PacketsDropped alarm.'''
        result = self._values.get("config_packets_dropped_alarm")
        assert result is not None, "Required property 'config_packets_dropped_alarm' is missing"
        return typing.cast("PrivateLinkEndpointsPacketsDroppedAlarmConfig", result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["PrivateLinkEndpointsRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["PrivateLinkEndpointsRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsProps",
    jsii_struct_bases=[
        PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsConfig
    ],
    name_mapping={
        "config_packets_dropped_alarm": "configPacketsDroppedAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "endpoint": "endpoint",
    },
)
class PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsProps(
    PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config_packets_dropped_alarm: typing.Union["PrivateLinkEndpointsPacketsDroppedAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["PrivateLinkEndpointsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        endpoint: _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
    ) -> None:
        '''Properties for the PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarms construct.

        :param config_packets_dropped_alarm: The configuration for the PacketsDropped alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param endpoint: The PrivateLink InterfaceVpcEndpoint to monitor.
        '''
        if isinstance(config_packets_dropped_alarm, dict):
            config_packets_dropped_alarm = PrivateLinkEndpointsPacketsDroppedAlarmConfig(**config_packets_dropped_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__258cca477637122d9e8e211bfc918fa1819149ccb9e2f2a76fa2bc8fb6e88441)
            check_type(argname="argument config_packets_dropped_alarm", value=config_packets_dropped_alarm, expected_type=type_hints["config_packets_dropped_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_packets_dropped_alarm": config_packets_dropped_alarm,
            "endpoint": endpoint,
        }
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_packets_dropped_alarm(
        self,
    ) -> "PrivateLinkEndpointsPacketsDroppedAlarmConfig":
        '''The configuration for the PacketsDropped alarm.'''
        result = self._values.get("config_packets_dropped_alarm")
        assert result is not None, "Required property 'config_packets_dropped_alarm' is missing"
        return typing.cast("PrivateLinkEndpointsPacketsDroppedAlarmConfig", result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["PrivateLinkEndpointsRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["PrivateLinkEndpointsRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def endpoint(self) -> _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint:
        '''The PrivateLink InterfaceVpcEndpoint to monitor.'''
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkEndpointsPacketsDroppedAlarmConfig",
    jsii_struct_bases=[PrivateLinkEndpointsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "endpoint_type": "endpointType",
        "service_name": "serviceName",
        "threshold": "threshold",
        "vpc_id": "vpcId",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "subnets": "subnets",
    },
)
class PrivateLinkEndpointsPacketsDroppedAlarmConfig(
    PrivateLinkEndpointsAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        endpoint_type: builtins.str,
        service_name: builtins.str,
        threshold: jsii.Number,
        vpc_id: builtins.str,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        subnets: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISubnet]] = None,
    ) -> None:
        '''Configuration for the PacketsDropped alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param endpoint_type: The type of the PrivateLink InterfaceVpcEndpoint.
        :param service_name: The service name of the PrivateLink InterfaceVpcEndpoint.
        :param threshold: Set the threshold according to the use case. If you want to be aware of the unhealthy status of the endpoint or endpoint service, you should set the threshold low so that you get a chance to fix the issue before a huge data loss. You can use historical data to understand the tolerance for dropped packets and set the threshold accordingly.
        :param vpc_id: The VPC ID of the PrivateLink InterfaceVpcEndpoint.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect if the endpoint or endpoint service is unhealthy.
        :param alarm_name: The alarm name. Default: - endpointId + ' - ' + subnetId + ' - PacketsDropped'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param subnets: The subnets of the PrivateLink InterfaceVpcEndpoint.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7ab04c8ace04a70ddc839d55ba7a4228c4e2af3a687ba238e6af0fccc601e839)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument endpoint_type", value=endpoint_type, expected_type=type_hints["endpoint_type"])
            check_type(argname="argument service_name", value=service_name, expected_type=type_hints["service_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint_type": endpoint_type,
            "service_name": service_name,
            "threshold": threshold,
            "vpc_id": vpc_id,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def endpoint_type(self) -> builtins.str:
        '''The type of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("endpoint_type")
        assert result is not None, "Required property 'endpoint_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_name(self) -> builtins.str:
        '''The service name of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("service_name")
        assert result is not None, "Required property 'service_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to the use case.

        If you want to be aware of the unhealthy status of the endpoint or endpoint service,
        you should set the threshold low so that you get a chance to fix the issue before a huge data loss. You can use historical data to
        understand the tolerance for dropped packets and set the threshold accordingly.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The VPC ID of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect if the endpoint or endpoint service is unhealthy.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - endpointId + ' - ' + subnetId + ' - PacketsDropped'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def subnets(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISubnet]]:
        '''The subnets of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISubnet]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkEndpointsPacketsDroppedAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkEndpointsRecommendedAlarmsMetrics"
)
class PrivateLinkEndpointsRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for PrivateLink Endpoints alarms.'''

    PACKETS_DROPPED = "PACKETS_DROPPED"
    '''Percentage of how close a file system is to reaching the I/O limit of the General Purpose performance mode.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkServicesAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class PrivateLinkServicesAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__28fb5e837383b87c0fd59c2f26d66fccdfc47923790080f20192aa8e7987f01c)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkServicesAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkServicesRecommendedAlarmsMetrics"
)
class PrivateLinkServicesRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for PrivateLink Services alarms.'''

    RST_PACKETS_SENT = "RST_PACKETS_SENT"
    '''The number of RST packets sent to endpoints by the endpoint service.

    Increasing values could indicate
    that there are unhealthy targets.
    '''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkServicesRstPacketsSentAlarmConfig",
    jsii_struct_bases=[PrivateLinkServicesAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "load_balancer_arn": "loadBalancerArn",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "azs": "azs",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class PrivateLinkServicesRstPacketsSentAlarmConfig(PrivateLinkServicesAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        load_balancer_arn: builtins.str,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        azs: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the RstPacketsSent alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param load_balancer_arn: The load balancer ARN of the PrivateLink VpcEndpointService.
        :param threshold: The threshold depends on the use case. If your use case can tolerate targets being unhealthy, you can set the threshold high. If the use case cant tolerate unhealthy targets you can set the threshold very low.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect unhealthy targets of an endpoint service.
        :param alarm_name: The alarm name. Default: - endpointServiceName + ' - ' + az + ' - RstPacketsSent'
        :param azs: The availability zone of the PrivateLink VpcEndpointService.
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__87d96e717cd760d7a134135b669a2d2cb8499bf3a643f3112bbcfea819d758aa)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument load_balancer_arn", value=load_balancer_arn, expected_type=type_hints["load_balancer_arn"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument azs", value=azs, expected_type=type_hints["azs"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "load_balancer_arn": load_balancer_arn,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if azs is not None:
            self._values["azs"] = azs
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def load_balancer_arn(self) -> builtins.str:
        '''The load balancer ARN of the PrivateLink VpcEndpointService.'''
        result = self._values.get("load_balancer_arn")
        assert result is not None, "Required property 'load_balancer_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The threshold depends on the use case.

        If your use case can tolerate targets being unhealthy, you can set the threshold high.
        If the use case cant tolerate unhealthy targets you can set the threshold very low.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect unhealthy targets of an endpoint service.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - endpointServiceName + ' - ' + az + ' - RstPacketsSent'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def azs(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The availability zone of the PrivateLink VpcEndpointService.'''
        result = self._values.get("azs")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkServicesRstPacketsSentAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkServicesVpcEndpointServiceAlarmProps",
    jsii_struct_bases=[],
    name_mapping={
        "az": "az",
        "endpoint_service": "endpointService",
        "load_balancer_arn": "loadBalancerArn",
    },
)
class PrivateLinkServicesVpcEndpointServiceAlarmProps:
    def __init__(
        self,
        *,
        az: builtins.str,
        endpoint_service: _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
        load_balancer_arn: builtins.str,
    ) -> None:
        '''The common properties for the PrivateLink VpcEndpointService alarms.

        :param az: The availability zone of the PrivateLink VpcEndpointService.
        :param endpoint_service: The PrivateLink VpcEndpointService to monitor.
        :param load_balancer_arn: The load balancer ARN of the PrivateLink VpcEndpointService.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4445156337e0b40c4735e7371802327b96c89c83740aa2f95b310d2871d43833)
            check_type(argname="argument az", value=az, expected_type=type_hints["az"])
            check_type(argname="argument endpoint_service", value=endpoint_service, expected_type=type_hints["endpoint_service"])
            check_type(argname="argument load_balancer_arn", value=load_balancer_arn, expected_type=type_hints["load_balancer_arn"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "az": az,
            "endpoint_service": endpoint_service,
            "load_balancer_arn": load_balancer_arn,
        }

    @builtins.property
    def az(self) -> builtins.str:
        '''The availability zone of the PrivateLink VpcEndpointService.'''
        result = self._values.get("az")
        assert result is not None, "Required property 'az' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint_service(self) -> _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService:
        '''The PrivateLink VpcEndpointService to monitor.'''
        result = self._values.get("endpoint_service")
        assert result is not None, "Required property 'endpoint_service' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.VpcEndpointService, result)

    @builtins.property
    def load_balancer_arn(self) -> builtins.str:
        '''The load balancer ARN of the PrivateLink VpcEndpointService.'''
        result = self._values.get("load_balancer_arn")
        assert result is not None, "Required property 'load_balancer_arn' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkServicesVpcEndpointServiceAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PrivateLinkServicesVpcEndpointServiceRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkServicesVpcEndpointServiceRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an PrivateLink VpcEndpointService.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#PrivateLinkServices
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        endpoint_service: _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
        config_rst_packets_sent_alarm: typing.Union[PrivateLinkServicesRstPacketsSentAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[PrivateLinkServicesRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param endpoint_service: The PrivateLink VpcEndpointService to monitor.
        :param config_rst_packets_sent_alarm: The configuration for the RstPacketsSent alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f45bc6941dfbe09c6f25f7ca0e103741be8ad01250d07c3c375b9c7ceb6c7a9b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsProps(
            endpoint_service=endpoint_service,
            config_rst_packets_sent_alarm=config_rst_packets_sent_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmRstPacketsSentList")
    def alarm_rst_packets_sent_list(
        self,
    ) -> typing.Optional[typing.List["PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarm"]]:
        '''The RstPacketsSent alarm.'''
        return typing.cast(typing.Optional[typing.List["PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarm"]], jsii.get(self, "alarmRstPacketsSentList"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_rst_packets_sent_alarm": "configRstPacketsSentAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_rst_packets_sent_alarm: typing.Union[PrivateLinkServicesRstPacketsSentAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[PrivateLinkServicesRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an PrivateLink Service.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_rst_packets_sent_alarm: The configuration for the RstPacketsSent alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_rst_packets_sent_alarm, dict):
            config_rst_packets_sent_alarm = PrivateLinkServicesRstPacketsSentAlarmConfig(**config_rst_packets_sent_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2e62f6e1d73cea5a6314c95b51263b3361b816d11e5c77804cee2481d5d48ce8)
            check_type(argname="argument config_rst_packets_sent_alarm", value=config_rst_packets_sent_alarm, expected_type=type_hints["config_rst_packets_sent_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_rst_packets_sent_alarm": config_rst_packets_sent_alarm,
        }
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_rst_packets_sent_alarm(
        self,
    ) -> PrivateLinkServicesRstPacketsSentAlarmConfig:
        '''The configuration for the RstPacketsSent alarm.'''
        result = self._values.get("config_rst_packets_sent_alarm")
        assert result is not None, "Required property 'config_rst_packets_sent_alarm' is missing"
        return typing.cast(PrivateLinkServicesRstPacketsSentAlarmConfig, result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[PrivateLinkServicesRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[PrivateLinkServicesRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsProps",
    jsii_struct_bases=[PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsConfig],
    name_mapping={
        "config_rst_packets_sent_alarm": "configRstPacketsSentAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "endpoint_service": "endpointService",
    },
)
class PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsProps(
    PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsConfig,
):
    def __init__(
        self,
        *,
        config_rst_packets_sent_alarm: typing.Union[PrivateLinkServicesRstPacketsSentAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[PrivateLinkServicesRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        endpoint_service: _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
    ) -> None:
        '''Properties for the PrivateLinkServicesVpcEndpointServiceRecommendedAlarms construct.

        :param config_rst_packets_sent_alarm: The configuration for the RstPacketsSent alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param endpoint_service: The PrivateLink VpcEndpointService to monitor.
        '''
        if isinstance(config_rst_packets_sent_alarm, dict):
            config_rst_packets_sent_alarm = PrivateLinkServicesRstPacketsSentAlarmConfig(**config_rst_packets_sent_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4f4f497e9997b54f313169cb2a212ddde1ef63d15d806faad75b911a9df9c6b4)
            check_type(argname="argument config_rst_packets_sent_alarm", value=config_rst_packets_sent_alarm, expected_type=type_hints["config_rst_packets_sent_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument endpoint_service", value=endpoint_service, expected_type=type_hints["endpoint_service"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_rst_packets_sent_alarm": config_rst_packets_sent_alarm,
            "endpoint_service": endpoint_service,
        }
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_rst_packets_sent_alarm(
        self,
    ) -> PrivateLinkServicesRstPacketsSentAlarmConfig:
        '''The configuration for the RstPacketsSent alarm.'''
        result = self._values.get("config_rst_packets_sent_alarm")
        assert result is not None, "Required property 'config_rst_packets_sent_alarm' is missing"
        return typing.cast(PrivateLinkServicesRstPacketsSentAlarmConfig, result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[PrivateLinkServicesRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[PrivateLinkServicesRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def endpoint_service(self) -> _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService:
        '''The PrivateLink VpcEndpointService to monitor.'''
        result = self._values.get("endpoint_service")
        assert result is not None, "Required property 'endpoint_service' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.VpcEndpointService, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarm",
):
    '''This alarm helps you detect unhealthy targets of an endpoint service based on the number of reset packets that are sent to endpoints.

    When you debug connection errors with a consumer of your service, you can validate whether the service is resetting connections with
    the RstPacketsSent metric, or if something else is failing on the network path.

    The alarm is triggered when the the number of reset packets exceeds the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        az: builtins.str,
        endpoint_service: _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
        load_balancer_arn: builtins.str,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        azs: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param az: The availability zone of the PrivateLink VpcEndpointService.
        :param endpoint_service: The PrivateLink VpcEndpointService to monitor.
        :param load_balancer_arn: The load balancer ARN of the PrivateLink VpcEndpointService.
        :param threshold: The threshold depends on the use case. If your use case can tolerate targets being unhealthy, you can set the threshold high. If the use case cant tolerate unhealthy targets you can set the threshold very low.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect unhealthy targets of an endpoint service.
        :param alarm_name: The alarm name. Default: - endpointServiceName + ' - ' + az + ' - RstPacketsSent'
        :param azs: The availability zone of the PrivateLink VpcEndpointService.
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__22106faffa1b0234d2dd3516fd6649502e4c1da5c7be82d11173d45536e56828)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarmProps(
            az=az,
            endpoint_service=endpoint_service,
            load_balancer_arn=load_balancer_arn,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            azs=azs,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarmProps",
    jsii_struct_bases=[
        PrivateLinkServicesVpcEndpointServiceAlarmProps,
        PrivateLinkServicesRstPacketsSentAlarmConfig,
    ],
    name_mapping={
        "az": "az",
        "endpoint_service": "endpointService",
        "load_balancer_arn": "loadBalancerArn",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "azs": "azs",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarmProps(
    PrivateLinkServicesVpcEndpointServiceAlarmProps,
    PrivateLinkServicesRstPacketsSentAlarmConfig,
):
    def __init__(
        self,
        *,
        az: builtins.str,
        endpoint_service: _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
        load_balancer_arn: builtins.str,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        azs: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarm construct.

        :param az: The availability zone of the PrivateLink VpcEndpointService.
        :param endpoint_service: The PrivateLink VpcEndpointService to monitor.
        :param load_balancer_arn: The load balancer ARN of the PrivateLink VpcEndpointService.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The threshold depends on the use case. If your use case can tolerate targets being unhealthy, you can set the threshold high. If the use case cant tolerate unhealthy targets you can set the threshold very low.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect unhealthy targets of an endpoint service.
        :param alarm_name: The alarm name. Default: - endpointServiceName + ' - ' + az + ' - RstPacketsSent'
        :param azs: The availability zone of the PrivateLink VpcEndpointService.
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bedb6bd45a3c1c50bed606dd1f038a50f2048d17655306e6b21c1bb05d4e3d31)
            check_type(argname="argument az", value=az, expected_type=type_hints["az"])
            check_type(argname="argument endpoint_service", value=endpoint_service, expected_type=type_hints["endpoint_service"])
            check_type(argname="argument load_balancer_arn", value=load_balancer_arn, expected_type=type_hints["load_balancer_arn"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument azs", value=azs, expected_type=type_hints["azs"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "az": az,
            "endpoint_service": endpoint_service,
            "load_balancer_arn": load_balancer_arn,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if azs is not None:
            self._values["azs"] = azs
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def az(self) -> builtins.str:
        '''The availability zone of the PrivateLink VpcEndpointService.'''
        result = self._values.get("az")
        assert result is not None, "Required property 'az' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def endpoint_service(self) -> _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService:
        '''The PrivateLink VpcEndpointService to monitor.'''
        result = self._values.get("endpoint_service")
        assert result is not None, "Required property 'endpoint_service' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.VpcEndpointService, result)

    @builtins.property
    def load_balancer_arn(self) -> builtins.str:
        '''The load balancer ARN of the PrivateLink VpcEndpointService.'''
        result = self._values.get("load_balancer_arn")
        assert result is not None, "Required property 'load_balancer_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The threshold depends on the use case.

        If your use case can tolerate targets being unhealthy, you can set the threshold high.
        If the use case cant tolerate unhealthy targets you can set the threshold very low.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect unhealthy targets of an endpoint service.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - endpointServiceName + ' - ' + az + ' - RstPacketsSent'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def azs(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The availability zone of the PrivateLink VpcEndpointService.'''
        result = self._values.get("azs")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class Queue(
    _aws_cdk_aws_sqs_ceddda9d.Queue,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Queue",
):
    '''An extension of the SQS Queue construct that adds methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        content_based_deduplication: typing.Optional[builtins.bool] = None,
        data_key_reuse: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        dead_letter_queue: typing.Optional[typing.Union[_aws_cdk_aws_sqs_ceddda9d.DeadLetterQueue, typing.Dict[builtins.str, typing.Any]]] = None,
        deduplication_scope: typing.Optional[_aws_cdk_aws_sqs_ceddda9d.DeduplicationScope] = None,
        delivery_delay: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        encryption: typing.Optional[_aws_cdk_aws_sqs_ceddda9d.QueueEncryption] = None,
        encryption_master_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        enforce_ssl: typing.Optional[builtins.bool] = None,
        fifo: typing.Optional[builtins.bool] = None,
        fifo_throughput_limit: typing.Optional[_aws_cdk_aws_sqs_ceddda9d.FifoThroughputLimit] = None,
        max_message_size_bytes: typing.Optional[jsii.Number] = None,
        queue_name: typing.Optional[builtins.str] = None,
        receive_message_wait_time: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        redrive_allow_policy: typing.Optional[typing.Union[_aws_cdk_aws_sqs_ceddda9d.RedriveAllowPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        retention_period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        visibility_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param content_based_deduplication: Specifies whether to enable content-based deduplication. During the deduplication interval (5 minutes), Amazon SQS treats messages that are sent with identical content (excluding attributes) as duplicates and delivers only one copy of the message. If you don't enable content-based deduplication and you want to deduplicate messages, provide an explicit deduplication ID in your SendMessage() call. (Only applies to FIFO queues.) Default: false
        :param data_key_reuse: The length of time that Amazon SQS reuses a data key before calling KMS again. The value must be an integer between 60 (1 minute) and 86,400 (24 hours). The default is 300 (5 minutes). Default: Duration.minutes(5)
        :param dead_letter_queue: Send messages to this queue if they were unsuccessfully dequeued a number of times. Default: no dead-letter queue
        :param deduplication_scope: For high throughput for FIFO queues, specifies whether message deduplication occurs at the message group or queue level. (Only applies to FIFO queues.) Default: DeduplicationScope.QUEUE
        :param delivery_delay: The time in seconds that the delivery of all messages in the queue is delayed. You can specify an integer value of 0 to 900 (15 minutes). The default value is 0. Default: 0
        :param encryption: Whether the contents of the queue are encrypted, and by what type of key. Be aware that encryption is not available in all regions, please see the docs for current availability details. Default: SQS_MANAGED (SSE-SQS) for newly created queues
        :param encryption_master_key: External KMS key to use for queue encryption. Individual messages will be encrypted using data keys. The data keys in turn will be encrypted using this key, and reused for a maximum of ``dataKeyReuseSecs`` seconds. If the 'encryptionMasterKey' property is set, 'encryption' type will be implicitly set to "KMS". Default: If encryption is set to KMS and not specified, a key will be created.
        :param enforce_ssl: Enforce encryption of data in transit. Default: false
        :param fifo: Whether this a first-in-first-out (FIFO) queue. Default: false, unless queueName ends in '.fifo' or 'contentBasedDeduplication' is true.
        :param fifo_throughput_limit: For high throughput for FIFO queues, specifies whether the FIFO queue throughput quota applies to the entire queue or per message group. (Only applies to FIFO queues.) Default: FifoThroughputLimit.PER_QUEUE
        :param max_message_size_bytes: The limit of how many bytes that a message can contain before Amazon SQS rejects it. You can specify an integer value from 1024 bytes (1 KiB) to 262144 bytes (256 KiB). The default value is 262144 (256 KiB). Default: 256KiB
        :param queue_name: A name for the queue. If specified and this is a FIFO queue, must end in the string '.fifo'. Default: CloudFormation-generated name
        :param receive_message_wait_time: Default wait time for ReceiveMessage calls. Does not wait if set to 0, otherwise waits this amount of seconds by default for messages to arrive. For more information, see Amazon SQS Long Poll. Default: 0
        :param redrive_allow_policy: The string that includes the parameters for the permissions for the dead-letter queue redrive permission and which source queues can specify dead-letter queues. Default: - All source queues can designate this queue as their dead-letter queue.
        :param removal_policy: Policy to apply when the queue is removed from the stack. Even though queues are technically stateful, their contents are transient and it is common to add and remove Queues while rearchitecting your application. The default is therefore ``DESTROY``. Change it to ``RETAIN`` if the messages are so valuable that accidentally losing them would be unacceptable. Default: RemovalPolicy.DESTROY
        :param retention_period: The number of seconds that Amazon SQS retains a message. You can specify an integer value from 60 seconds (1 minute) to 1209600 seconds (14 days). The default value is 345600 seconds (4 days). Default: Duration.days(4)
        :param visibility_timeout: Timeout of processing a single message. After dequeuing, the processor has this much time to handle the message and delete it from the queue before it becomes visible again for dequeueing by another processor. Values must be from 0 to 43200 seconds (12 hours). If you don't specify a value, AWS CloudFormation uses the default value of 30 seconds. Default: Duration.seconds(30)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e63632b9287782cde140e2fa25c2d500852c1e3fdad4c8d2118b305c4ebd894d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_sqs_ceddda9d.QueueProps(
            content_based_deduplication=content_based_deduplication,
            data_key_reuse=data_key_reuse,
            dead_letter_queue=dead_letter_queue,
            deduplication_scope=deduplication_scope,
            delivery_delay=delivery_delay,
            encryption=encryption,
            encryption_master_key=encryption_master_key,
            enforce_ssl=enforce_ssl,
            fifo=fifo,
            fifo_throughput_limit=fifo_throughput_limit,
            max_message_size_bytes=max_message_size_bytes,
            queue_name=queue_name,
            receive_message_wait_time=receive_message_wait_time,
            redrive_allow_policy=redrive_allow_policy,
            removal_policy=removal_policy,
            retention_period=retention_period,
            visibility_timeout=visibility_timeout,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmApproximateAgeOfOldestMessage")
    def alarm_approximate_age_of_oldest_message(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "SqsApproximateAgeOfOldestMessageAlarm":
        '''Creates an alarm that watches the age of the oldest message in the queue.

        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the expected message processing time. You can use historical data to calculate the average message processing time, and then set the threshold to 50% higher than the maximum expected SQS message processing time by queue consumers.
        :param alarm_description: The description of the alarm. Default: - This alarm watches the age of the oldest message in the queue. You can use this alarm to monitor if your consumers are processing SQS messages at the desired speed. Consider increasing the consumer count or consumer throughput to reduce message age. This metric can be used in combination with ApproximateNumberOfMessagesVisible to determine how big the queue backlog is and how quickly messages are being processed. To prevent messages from being deleted before processed, consider configuring the dead-letter queue to sideline potential poison pill messages.
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateAgeOfOldestMessage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SqsApproximateAgeOfOldestMessageAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("SqsApproximateAgeOfOldestMessageAlarm", jsii.invoke(self, "alarmApproximateAgeOfOldestMessage", [props]))

    @jsii.member(jsii_name="alarmApproximateNumberOfMessagesNotVisible")
    def alarm_approximate_number_of_messages_not_visible(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "SqsApproximateNumberOfMessagesNotVisibleAlarm":
        '''Creates an alarm that watches the number of messages that are in flight.

        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the expected number of messages in flight. You can use historical data to calculate the maximum expected number of messages in flight and set the threshold to 50% over this value. If consumers of the queue are processing but not deleting messages from the queue, this number will suddenly increase.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateNumberOfMessagesNotVisible'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SqsApproximateNumberOfMessagesNotVisibleAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("SqsApproximateNumberOfMessagesNotVisibleAlarm", jsii.invoke(self, "alarmApproximateNumberOfMessagesNotVisible", [props]))

    @jsii.member(jsii_name="alarmApproximateNumberOfMessagesVisible")
    def alarm_approximate_number_of_messages_visible(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "SqsApproximateNumberOfMessagesVisibleAlarm":
        '''Creates an alarm that watches the number of messages that are visible in the queue.

        :param threshold: The value against which the specified statistic is compared. An unexpectedly high number of messages visible indicates that messages are not being processed by a consumer at the expected rate. You should consider historical data when you set this threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateNumberOfMessagesVisible'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SqsApproximateNumberOfMessagesVisibleAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("SqsApproximateNumberOfMessagesVisibleAlarm", jsii.invoke(self, "alarmApproximateNumberOfMessagesVisible", [props]))

    @jsii.member(jsii_name="alarmNumberOfMessagesSent")
    def alarm_number_of_messages_sent(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "SqsNumberOfMessagesSentAlarm":
        '''Creates an alarm that watches the number of messages that are sent.

        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - NumberOfMessagesSent'
        :param threshold: The value against which the specified statistic is compared. If the number of messages sent is 0, the producer is not sending any messages. If this queue has a low TPS, increase the number of EvaluationPeriods accordingly. Default: 0
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SqsNumberOfMessagesSentAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            threshold=threshold,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("SqsNumberOfMessagesSentAlarm", jsii.invoke(self, "alarmNumberOfMessagesSent", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_approximate_age_of_oldest_message_alarm: typing.Union["SqsApproximateAgeOfOldestMessageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_approximate_number_of_messages_not_visible_alarm: typing.Union["SqsApproximateNumberOfMessagesNotVisibleAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_approximate_number_of_messages_visible_alarm: typing.Union["SqsApproximateNumberOfMessagesVisibleAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_dlq_approximate_number_of_messages_visible_alarm: typing.Optional[typing.Union["SqsApproximateNumberOfMessagesVisibleAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_messages_sent_alarm: typing.Optional[typing.Union["SqsNumberOfMessagesSentAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        dlqs_get_full_recommended_alarms: typing.Optional[builtins.bool] = None,
        exclude_alarms: typing.Optional[typing.Sequence["SqsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Creates the recommended alarms for an SQS queue.

        :param config_approximate_age_of_oldest_message_alarm: The configuration for the approximate age of oldest message alarm.
        :param config_approximate_number_of_messages_not_visible_alarm: The configuration for the approximate number of messages not visible alarm.
        :param config_approximate_number_of_messages_visible_alarm: The configuration for the approximate number of messages visible alarm.
        :param config_dlq_approximate_number_of_messages_visible_alarm: The configuration for the approximate number of messages visible alarm for DLQs. This is used for dead letter queues only. The threshold is set to 0 by default.
        :param config_number_of_messages_sent_alarm: The configuration for the number of messages sent alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param dlqs_get_full_recommended_alarms: Whether to apply the usual recommended alarms to dead letter queues. If true, the dead letter queues will have the same alarms as normal queues. If false, the dead letter queues will only have the ApproximateNumberOfMessagesVisible alarm with a default threshold of 0. Default: false
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SqsRecommendedAlarmsConfig(
            config_approximate_age_of_oldest_message_alarm=config_approximate_age_of_oldest_message_alarm,
            config_approximate_number_of_messages_not_visible_alarm=config_approximate_number_of_messages_not_visible_alarm,
            config_approximate_number_of_messages_visible_alarm=config_approximate_number_of_messages_visible_alarm,
            config_dlq_approximate_number_of_messages_visible_alarm=config_dlq_approximate_number_of_messages_visible_alarm,
            config_number_of_messages_sent_alarm=config_number_of_messages_sent_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            dlqs_get_full_recommended_alarms=dlqs_get_full_recommended_alarms,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(None, jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class RdsAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2f0c9f06d3063631c0f0f381e5c5fe86873ce3f2d52c8b0482687567e0ab123)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RdsAuroraBinLogReplicationLagAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAuroraBinLogReplicationLagAlarm",
):
    '''An alarm that monitors the error state of Aurora writer instance replication.

    This alarm is used to detect whether the writer instance is in an error state and cant replicate the source.

    The alarm is triggered when the value is less than or equal to threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_cluster: The database cluster to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect whether the writer instance is in an error state and cant replicate the source. This alarm is recommended only for Aurora MySQL.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - AuroraBinLogReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: The value against which the specified statistic is compared. We recommend that you use -1 as the threshold value because Aurora MySQL publishes this value if the replica is in an error state. Default: -1
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8ae625b44a196c36eb59faf5ea9e1370fa81440d171558b0109a406cb17dfd9c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsAuroraBinLogReplicationLagAlarmProps(
            database_cluster=database_cluster,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAuroraBinLogReplicationLagAlarmConfig",
    jsii_struct_bases=[RdsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class RdsAuroraBinLogReplicationLagAlarmConfig(RdsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the AuroraBinLogReplicationLag alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect whether the writer instance is in an error state and cant replicate the source. This alarm is recommended only for Aurora MySQL.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - AuroraBinLogReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: The value against which the specified statistic is compared. We recommend that you use -1 as the threshold value because Aurora MySQL publishes this value if the replica is in an error state. Default: -1
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b52548f181557f32a37e5ffc6bf59d8e0f903d4fe3e9070e94cb6685b5a79462)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect whether the writer instance is in an error
        state and cant replicate the source. This alarm is recommended only for Aurora MySQL.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - AuroraBinLogReplicationLag'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 2
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        We recommend that you use -1 as the threshold value because Aurora MySQL publishes
        this value if the replica is in an error state.

        :default: -1
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsAuroraBinLogReplicationLagAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAuroraBinLogReplicationLagAlarmProps",
    jsii_struct_bases=[RdsAuroraBinLogReplicationLagAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "database_cluster": "databaseCluster",
    },
)
class RdsAuroraBinLogReplicationLagAlarmProps(RdsAuroraBinLogReplicationLagAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
    ) -> None:
        '''The properties for the RdsAuroraBinLogReplicationLag construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect whether the writer instance is in an error state and cant replicate the source. This alarm is recommended only for Aurora MySQL.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - AuroraBinLogReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: The value against which the specified statistic is compared. We recommend that you use -1 as the threshold value because Aurora MySQL publishes this value if the replica is in an error state. Default: -1
        :param database_cluster: The database cluster to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2b4bd72b075660e29961e9a35d0092b5e1486d45e33a4d77b0c4ed27bfd673ce)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument database_cluster", value=database_cluster, expected_type=type_hints["database_cluster"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "database_cluster": database_cluster,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect whether the writer instance is in an error
        state and cant replicate the source. This alarm is recommended only for Aurora MySQL.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - AuroraBinLogReplicationLag'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 2
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        We recommend that you use -1 as the threshold value because Aurora MySQL publishes
        this value if the replica is in an error state.

        :default: -1
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def database_cluster(self) -> _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster:
        '''The database cluster to monitor.'''
        result = self._values.get("database_cluster")
        assert result is not None, "Required property 'database_cluster' is missing"
        return typing.cast(_aws_cdk_aws_rds_ceddda9d.IDatabaseCluster, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsAuroraBinLogReplicationLagAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RdsAuroraRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAuroraRecommendedAlarms",
):
    '''A construct that creates recommended alarms for an RDS cluster.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#RDS
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
        config_aurora_bin_log_replication_lag_alarm: typing.Optional[typing.Union[RdsAuroraBinLogReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_aurora_volume_bytes_left_total_alarm: typing.Optional[typing.Union["RdsAuroraVolumeBytesLeftTotalAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_database_connections_alarm: typing.Union["RdsDatabaseConnectionsAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_db_load_alarm: typing.Union["RdsDbLoadAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_freeable_memory_alarm: typing.Union["RdsFreeableMemoryAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_free_local_storage_alarm: typing.Union["RdsFreeLocalStorageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union["RdsFreeStorageSpaceAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_read_latency_alarm: typing.Union["RdsReadLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_write_latency_alarm: typing.Union["RdsWriteLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union["RdsCpuUtilizationAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["RdsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_cluster: The database cluster to apply the recommended alarms.
        :param config_aurora_bin_log_replication_lag_alarm: The configuration for the AuroraBinLogReplicationLag alarm.
        :param config_aurora_volume_bytes_left_total_alarm: The configuration for the AuroraVolumeBytesLeftTotal alarm.
        :param config_database_connections_alarm: The configuration for the DatabaseConnections alarm.
        :param config_db_load_alarm: The configuration for the DbLoad alarm.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_local_storage_alarm: The configuration for the FreeLocalStorage alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_read_latency_alarm: The configuration for the ReadLatency alarm.
        :param config_write_latency_alarm: The configuration for the WriteLatency alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36a65cf78dc54ad7efd28569350daee761511a0fc59da75eb9a13f1c03eb68b2)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsAuroraRecommendedAlarmsProps(
            database_cluster=database_cluster,
            config_aurora_bin_log_replication_lag_alarm=config_aurora_bin_log_replication_lag_alarm,
            config_aurora_volume_bytes_left_total_alarm=config_aurora_volume_bytes_left_total_alarm,
            config_database_connections_alarm=config_database_connections_alarm,
            config_db_load_alarm=config_db_load_alarm,
            config_freeable_memory_alarm=config_freeable_memory_alarm,
            config_free_local_storage_alarm=config_free_local_storage_alarm,
            config_free_storage_space_alarm=config_free_storage_space_alarm,
            config_read_latency_alarm=config_read_latency_alarm,
            config_write_latency_alarm=config_write_latency_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmAuroraBinLogReplicationLag")
    def alarm_aurora_bin_log_replication_lag(
        self,
    ) -> typing.Optional[RdsAuroraBinLogReplicationLagAlarm]:
        '''The Bin Log Replication lag alarm for the database cluster.'''
        return typing.cast(typing.Optional[RdsAuroraBinLogReplicationLagAlarm], jsii.get(self, "alarmAuroraBinLogReplicationLag"))

    @builtins.property
    @jsii.member(jsii_name="alarmAuroraVolumeBytesLeftTotal")
    def alarm_aurora_volume_bytes_left_total(
        self,
    ) -> typing.Optional["RdsAuroraVolumeBytesLeftTotalAlarm"]:
        '''The AuroraVolumeBytesLeftTotal alarm for the database cluster.'''
        return typing.cast(typing.Optional["RdsAuroraVolumeBytesLeftTotalAlarm"], jsii.get(self, "alarmAuroraVolumeBytesLeftTotal"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class RdsAuroraRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAuroraRecommendedAlarmsAspect",
):
    '''An aspect that applies recommended alarms for RDS clusters.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#RDS
    '''

    def __init__(
        self,
        *,
        config_aurora_bin_log_replication_lag_alarm: typing.Optional[typing.Union[RdsAuroraBinLogReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_aurora_volume_bytes_left_total_alarm: typing.Optional[typing.Union["RdsAuroraVolumeBytesLeftTotalAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_database_connections_alarm: typing.Union["RdsDatabaseConnectionsAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_db_load_alarm: typing.Union["RdsDbLoadAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_freeable_memory_alarm: typing.Union["RdsFreeableMemoryAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_free_local_storage_alarm: typing.Union["RdsFreeLocalStorageAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union["RdsFreeStorageSpaceAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_read_latency_alarm: typing.Union["RdsReadLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_write_latency_alarm: typing.Union["RdsWriteLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union["RdsCpuUtilizationAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["RdsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_aurora_bin_log_replication_lag_alarm: The configuration for the AuroraBinLogReplicationLag alarm.
        :param config_aurora_volume_bytes_left_total_alarm: The configuration for the AuroraVolumeBytesLeftTotal alarm.
        :param config_database_connections_alarm: The configuration for the DatabaseConnections alarm.
        :param config_db_load_alarm: The configuration for the DbLoad alarm.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_local_storage_alarm: The configuration for the FreeLocalStorage alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_read_latency_alarm: The configuration for the ReadLatency alarm.
        :param config_write_latency_alarm: The configuration for the WriteLatency alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsAuroraRecommendedAlarmsConfig(
            config_aurora_bin_log_replication_lag_alarm=config_aurora_bin_log_replication_lag_alarm,
            config_aurora_volume_bytes_left_total_alarm=config_aurora_volume_bytes_left_total_alarm,
            config_database_connections_alarm=config_database_connections_alarm,
            config_db_load_alarm=config_db_load_alarm,
            config_freeable_memory_alarm=config_freeable_memory_alarm,
            config_free_local_storage_alarm=config_free_local_storage_alarm,
            config_free_storage_space_alarm=config_free_storage_space_alarm,
            config_read_latency_alarm=config_read_latency_alarm,
            config_write_latency_alarm=config_write_latency_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ea3c33057c551fe29704e0d1bdb6b0da0b489809f29c70cc912adab97b153841)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


class RdsAuroraVolumeBytesLeftTotalAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAuroraVolumeBytesLeftTotalAlarm",
):
    '''An alarm that monitors the remaining available space (in bytes) for the cluster volume.

    This alarm is used to detect how close the Aurora cluster is to the volume size limit. This
    alarm can prevent an out-of-space error that occurs when your cluster runs out of space.

    The alarm is triggered when the remaining available space (in bytes) is less than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_cluster: The database cluster to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the Aurora cluster is to the volume size limit. This alarm can prevent an out-of-space error that occurs when your cluster runs out of space. This alarm is recommended only for Aurora MySQL.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - AuroraVolumeBytesLeftTotal'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in bytes against which the specified statistic is compared. You should calculate 10%-20% of the actual size limit based on velocity and trend of volume usage increase, and then use that result as the threshold value to proactively take action before the volume reaches its limit.
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7cb015a0f2a148a3b92fbe5fa27d2e60c87b309aaae55b85f49e648cc22c0d29)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsAuroraVolumeBytesLeftTotalAlarmProps(
            database_cluster=database_cluster,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAuroraVolumeBytesLeftTotalAlarmConfig",
    jsii_struct_bases=[RdsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class RdsAuroraVolumeBytesLeftTotalAlarmConfig(RdsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the AuroraVolumeBytesLeftTotal alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the Aurora cluster is to the volume size limit. This alarm can prevent an out-of-space error that occurs when your cluster runs out of space. This alarm is recommended only for Aurora MySQL.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - AuroraVolumeBytesLeftTotal'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in bytes against which the specified statistic is compared. You should calculate 10%-20% of the actual size limit based on velocity and trend of volume usage increase, and then use that result as the threshold value to proactively take action before the volume reaches its limit.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85330b777411eaa6bd19301419465a48e61bd9335dedb5c705cdf8f1cf816f09)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect how close the Aurora cluster is to the volume
        size limit. This alarm can prevent an out-of-space error that occurs when your cluster
        runs out of space. This alarm is recommended only for Aurora MySQL.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - AuroraVolumeBytesLeftTotal'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value in bytes against which the specified statistic is compared.

        You should calculate 10%-20% of the actual size limit based on velocity and
        trend of volume usage increase, and then use that result as the threshold value
        to proactively take action before the volume reaches its limit.
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsAuroraVolumeBytesLeftTotalAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAuroraVolumeBytesLeftTotalAlarmProps",
    jsii_struct_bases=[RdsAuroraVolumeBytesLeftTotalAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "database_cluster": "databaseCluster",
    },
)
class RdsAuroraVolumeBytesLeftTotalAlarmProps(RdsAuroraVolumeBytesLeftTotalAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
    ) -> None:
        '''The properties for the RdsAuroraVolumeBytesLeftTotal construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the Aurora cluster is to the volume size limit. This alarm can prevent an out-of-space error that occurs when your cluster runs out of space. This alarm is recommended only for Aurora MySQL.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - AuroraVolumeBytesLeftTotal'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in bytes against which the specified statistic is compared. You should calculate 10%-20% of the actual size limit based on velocity and trend of volume usage increase, and then use that result as the threshold value to proactively take action before the volume reaches its limit.
        :param database_cluster: The database cluster to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f18e3856858f568d2f5e4e03a7ab1e1ef51ebe53a0a56798e0b11062c78b5106)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument database_cluster", value=database_cluster, expected_type=type_hints["database_cluster"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "database_cluster": database_cluster,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect how close the Aurora cluster is to the volume
        size limit. This alarm can prevent an out-of-space error that occurs when your cluster
        runs out of space. This alarm is recommended only for Aurora MySQL.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - AuroraVolumeBytesLeftTotal'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value in bytes against which the specified statistic is compared.

        You should calculate 10%-20% of the actual size limit based on velocity and
        trend of volume usage increase, and then use that result as the threshold value
        to proactively take action before the volume reaches its limit.
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def database_cluster(self) -> _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster:
        '''The database cluster to monitor.'''
        result = self._values.get("database_cluster")
        assert result is not None, "Required property 'database_cluster' is missing"
        return typing.cast(_aws_cdk_aws_rds_ceddda9d.IDatabaseCluster, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsAuroraVolumeBytesLeftTotalAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsCpuUtilizationAlarmConfig",
    jsii_struct_bases=[RdsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class RdsCpuUtilizationAlarmConfig(RdsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the CpuUtilization alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect consistent high CPU utilization in order to prevent very high response time and time-outs. If you want to check micro-bursting of CPU utilization you can set a lower alarm evaluation time.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - CpuUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. Random spikes in CPU consumption might not hamper database performance, but sustained high CPU can hinder upcoming database requests. Depending on the overall database workload, high CPU at your RDS/Aurora instance can degrade the overall performance. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__11064370710b7a12c4ca3b5dbc11d11742fab3b2928757058193bb9af080ad7b)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect consistent high CPU utilization in order to
        prevent very high response time and time-outs. If you want to check micro-bursting
        of CPU utilization you can set a lower alarm evaluation time.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - CpuUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The percentage (0-100) value against which the specified statistic is compared.

        Random spikes in CPU consumption might not hamper database performance, but sustained
        high CPU can hinder upcoming database requests. Depending on the overall database
        workload, high CPU at your RDS/Aurora instance can degrade the overall performance.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsCpuUtilizationAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsDatabaseConnectionsAlarmConfig",
    jsii_struct_bases=[RdsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsDatabaseConnectionsAlarmConfig(RdsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the DatabaseConnections alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The number of connections against which the specified statistic is compared. The number of connections allowed depends on the size of your DB instance class and database engine-specific parameters related to processes/connections. You should calculate a value between 90-95% of the maximum number of connections for your database and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent rejected connections when the maximum number of DB connections is reached. This alarm is not recommended if you frequently change DB instance class, because doing so changes the memory and default maximum number of connections.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - DatabaseConnections'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cd904878d77126a9943345dc77a0d050ed7d57d6b72ef057b604cec5fb116328)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The number of connections against which the specified statistic is compared.

        The number of connections allowed depends on the size of your DB instance class and
        database engine-specific parameters related to processes/connections. You should
        calculate a value between 90-95% of the maximum number of connections for your database
        and use that result as the threshold value.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to help prevent rejected connections when the maximum
        number of DB connections is reached. This alarm is not recommended if you frequently
        change DB instance class, because doing so changes the memory and default maximum
        number of connections.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - DatabaseConnections'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsDatabaseConnectionsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsDbLoadAlarmConfig",
    jsii_struct_bases=[RdsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsDbLoadAlarmConfig(RdsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the DbLoad alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The maximum vCPU value is determined by the number of vCPU (virtual CPU) cores for your DB instance. Depending on the maximum vCPU, different values for the threshold can be appropriate. Ideally, DB load should not go above vCPU line.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a high DB load. High DB load can cause performance issues in the DB instance. This alarm is not applicable to serverless DB instances.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - DBLoad'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ab2fa45170a79d2ce79eae19b901d3f4a55e9d72243e706a3f73b32862956335)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The maximum vCPU value is determined by the number of vCPU (virtual CPU) cores
        for your DB instance. Depending on the maximum vCPU, different values for the
        threshold can be appropriate. Ideally, DB load should not go above vCPU line.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect a high DB load. High DB load can cause
        performance issues in the DB instance. This alarm is not applicable to serverless
        DB instances.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - DBLoad'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsDbLoadAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsFreeLocalStorageAlarmConfig",
    jsii_struct_bases=[RdsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsFreeLocalStorageAlarmConfig(RdsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the FreeLocalStorage alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The percentage value (0-100) against which the specified statistic is compared. You should calculate about 10%-20% of the amount of storage available based on velocity and trend of volume usage, and then use that result as the threshold value to proactively take action before the volume reaches its limit.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the Aurora DB instance is to reaching the local storage limit, if you do not use Aurora Serverless v2 or higher. Local storage can reach capacity when you store non-persistent data, such as temporary table and log files, in the local storage. This alarm can prevent an out-of-space error that occurs when your DB instance runs out of local storage.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeLocalStorage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3779adad9c6233f0287a82355af3a9ef92980d5bbd00adba0d40502a16b5f328)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The percentage value (0-100) against which the specified statistic is compared.

        You should calculate about 10%-20% of the amount of storage available based on
        velocity and trend of volume usage, and then use that result as the threshold value
        to proactively take action before the volume reaches its limit.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect how close the Aurora DB instance is to reaching
        the local storage limit, if you do not use Aurora Serverless v2 or higher. Local storage
        can reach capacity when you store non-persistent data, such as temporary table and log
        files, in the local storage. This alarm can prevent an out-of-space error that occurs when
        your DB instance runs out of local storage.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - FreeLocalStorage'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsFreeLocalStorageAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsFreeStorageSpaceAlarmConfig",
    jsii_struct_bases=[RdsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsFreeStorageSpaceAlarmConfig(RdsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the FreeStorageSpace alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The percentage value (0-100) against which the specified statistic is compared. The threshold value will depend on the currently allocated storage space. Typically, you should calculate the value of 10 percent of the allocated storage space and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm helps prevent storage full issues. This can prevent downtime that occurs when your database instance runs out of storage. We do not recommend using this alarm if you have storage auto scaling enabled, or if you frequently change the storage capacity of the database instance.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeStorageSpace'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f4c25828b191532fd78e8fe00e3ef3866f6fcdfcff1476ab0924b93d297de28)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The percentage value (0-100) against which the specified statistic is compared.

        The threshold value will depend on the currently allocated storage space. Typically,
        you should calculate the value of 10 percent of the allocated storage space and use
        that result as the threshold value.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps prevent storage full issues. This can prevent downtime
        that occurs when your database instance runs out of storage. We do not recommend
        using this alarm if you have storage auto scaling enabled, or if you frequently change
        the storage capacity of the database instance.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - FreeStorageSpace'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsFreeStorageSpaceAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsFreeableMemoryAlarmConfig",
    jsii_struct_bases=[RdsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsFreeableMemoryAlarmConfig(RdsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the FreeableMemory alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The percentage value (0-100) against which the specified statistic is compared. Depending on the workload and instance class, different values for the threshold can be appropriate. Ideally, available memory should not go below 25% of total memory for prolonged periods. For Aurora, you can set the threshold close to 5%, because the metric approaching 0 means that the DB instance has scaled up as much as it can. You can analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent running out of memory which can result in rejected connections.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeableMemory'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3f9352001ef4edd8dde95ab794f338b01f49a4775964b0a24481197424cf547d)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The percentage value (0-100) against which the specified statistic is compared.

        Depending on the workload and instance class, different values for the threshold
        can be appropriate. Ideally, available memory should not go below 25% of total
        memory for prolonged periods. For Aurora, you can set the threshold close to 5%,
        because the metric approaching 0 means that the DB instance has scaled up as much
        as it can. You can analyze the historical behavior of this metric to determine
        sensible threshold levels.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to help prevent running out of memory
        which can result in rejected connections.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - FreeableMemory'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsFreeableMemoryAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceAlarmProps",
    jsii_struct_bases=[],
    name_mapping={
        "database_instance": "databaseInstance",
        "instance_identifier": "instanceIdentifier",
    },
)
class RdsInstanceAlarmProps:
    def __init__(
        self,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''The common properties for the instance alarms.

        The alarm should receive either
        instanceIdentifier or databaseInstance.

        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f856c8962a5dced29c4d9f95610231f694aac0a200cd784b02129a04a9bc9346)
            check_type(argname="argument database_instance", value=database_instance, expected_type=type_hints["database_instance"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if database_instance is not None:
            self._values["database_instance"] = database_instance
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier

    @builtins.property
    def database_instance(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance]:
        '''The database instance to monitor.'''
        result = self._values.get("database_instance")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''The database instance identifier to monitor.'''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RdsInstanceCpuUtilizationAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceCpuUtilizationAlarm",
):
    '''An alarm that monitors CPU utilization for an RDS instance.

    This alarm is used to detect consistent high CPU utilization in order to prevent very
    high response time and time-outs.

    The alarm is triggered when the CPU utilization exceeds the % threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect consistent high CPU utilization in order to prevent very high response time and time-outs. If you want to check micro-bursting of CPU utilization you can set a lower alarm evaluation time.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - CpuUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. Random spikes in CPU consumption might not hamper database performance, but sustained high CPU can hinder upcoming database requests. Depending on the overall database workload, high CPU at your RDS/Aurora instance can degrade the overall performance. Default: 90
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ccd4b2b9857d1e3f62fccf945625617c4b27995b3674edf455ee532d3db28b31)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsInstanceCpuUtilizationAlarmProps(
            database_instance=database_instance,
            instance_identifier=instance_identifier,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceCpuUtilizationAlarmProps",
    jsii_struct_bases=[RdsInstanceAlarmProps, RdsCpuUtilizationAlarmConfig],
    name_mapping={
        "database_instance": "databaseInstance",
        "instance_identifier": "instanceIdentifier",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class RdsInstanceCpuUtilizationAlarmProps(
    RdsInstanceAlarmProps,
    RdsCpuUtilizationAlarmConfig,
):
    def __init__(
        self,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the RdsInstanceCpuUtilizationAlarm construct.

        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect consistent high CPU utilization in order to prevent very high response time and time-outs. If you want to check micro-bursting of CPU utilization you can set a lower alarm evaluation time.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - CpuUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. Random spikes in CPU consumption might not hamper database performance, but sustained high CPU can hinder upcoming database requests. Depending on the overall database workload, high CPU at your RDS/Aurora instance can degrade the overall performance. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5b76867ab0300177fee37a2434ec45a2f7255a7b8f78b438004aa3338c5237ff)
            check_type(argname="argument database_instance", value=database_instance, expected_type=type_hints["database_instance"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if database_instance is not None:
            self._values["database_instance"] = database_instance
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def database_instance(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance]:
        '''The database instance to monitor.'''
        result = self._values.get("database_instance")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''The database instance identifier to monitor.'''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect consistent high CPU utilization in order to
        prevent very high response time and time-outs. If you want to check micro-bursting
        of CPU utilization you can set a lower alarm evaluation time.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - CpuUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The percentage (0-100) value against which the specified statistic is compared.

        Random spikes in CPU consumption might not hamper database performance, but sustained
        high CPU can hinder upcoming database requests. Depending on the overall database
        workload, high CPU at your RDS/Aurora instance can degrade the overall performance.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceCpuUtilizationAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RdsInstanceDatabaseConnectionsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceDatabaseConnectionsAlarm",
):
    '''An alarm that monitors the number of client network connections to the database instance.

    This alarm is used to help prevent rejected connections when the maximum number of DB
    connections is reached.

    The alarm is triggered when number of connections is greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param threshold: The number of connections against which the specified statistic is compared. The number of connections allowed depends on the size of your DB instance class and database engine-specific parameters related to processes/connections. You should calculate a value between 90-95% of the maximum number of connections for your database and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent rejected connections when the maximum number of DB connections is reached. This alarm is not recommended if you frequently change DB instance class, because doing so changes the memory and default maximum number of connections.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - DatabaseConnections'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__13b74b57eb858f4d3c9013c5a44aa658602aa43a29e79aa6ae7d4f6bd4fc03c1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsInstanceDatabaseConnectionsAlarmProps(
            database_instance=database_instance,
            instance_identifier=instance_identifier,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceDatabaseConnectionsAlarmProps",
    jsii_struct_bases=[RdsInstanceAlarmProps, RdsDatabaseConnectionsAlarmConfig],
    name_mapping={
        "database_instance": "databaseInstance",
        "instance_identifier": "instanceIdentifier",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsInstanceDatabaseConnectionsAlarmProps(
    RdsInstanceAlarmProps,
    RdsDatabaseConnectionsAlarmConfig,
):
    def __init__(
        self,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the RdsInstanceDatabaseConnectionsAlarm construct.

        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The number of connections against which the specified statistic is compared. The number of connections allowed depends on the size of your DB instance class and database engine-specific parameters related to processes/connections. You should calculate a value between 90-95% of the maximum number of connections for your database and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent rejected connections when the maximum number of DB connections is reached. This alarm is not recommended if you frequently change DB instance class, because doing so changes the memory and default maximum number of connections.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - DatabaseConnections'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__424ad66e36b791e98505612be6b5f295e19b0e2d7cc2bc2c136c958862295cee)
            check_type(argname="argument database_instance", value=database_instance, expected_type=type_hints["database_instance"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if database_instance is not None:
            self._values["database_instance"] = database_instance
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def database_instance(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance]:
        '''The database instance to monitor.'''
        result = self._values.get("database_instance")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''The database instance identifier to monitor.'''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The number of connections against which the specified statistic is compared.

        The number of connections allowed depends on the size of your DB instance class and
        database engine-specific parameters related to processes/connections. You should
        calculate a value between 90-95% of the maximum number of connections for your database
        and use that result as the threshold value.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to help prevent rejected connections when the maximum
        number of DB connections is reached. This alarm is not recommended if you frequently
        change DB instance class, because doing so changes the memory and default maximum
        number of connections.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - DatabaseConnections'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceDatabaseConnectionsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RdsInstanceDbLoadAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceDbLoadAlarm",
):
    '''An alarm that monitors the number of concurrent active sessions on the database.

    This alarm helps to monitor high DB load. If the number of processes exceed the number of vCPUs,
    the processes start queuing. When the queuing increases, the performance is impacted.

    The alarm is triggered when the number of active sessions for the database is
    greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param threshold: The value against which the specified statistic is compared. The maximum vCPU value is determined by the number of vCPU (virtual CPU) cores for your DB instance. Depending on the maximum vCPU, different values for the threshold can be appropriate. Ideally, DB load should not go above vCPU line.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a high DB load. High DB load can cause performance issues in the DB instance. This alarm is not applicable to serverless DB instances.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - DBLoad'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e8bbdd017b24da0137c9781dc3340e21b181b0d791d5529112316b31c6a539f8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsInstanceDbLoadAlarmProps(
            database_instance=database_instance,
            instance_identifier=instance_identifier,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceDbLoadAlarmProps",
    jsii_struct_bases=[RdsInstanceAlarmProps, RdsDbLoadAlarmConfig],
    name_mapping={
        "database_instance": "databaseInstance",
        "instance_identifier": "instanceIdentifier",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsInstanceDbLoadAlarmProps(RdsInstanceAlarmProps, RdsDbLoadAlarmConfig):
    def __init__(
        self,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the RdsInstanceDbLoadAlarm construct.

        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The maximum vCPU value is determined by the number of vCPU (virtual CPU) cores for your DB instance. Depending on the maximum vCPU, different values for the threshold can be appropriate. Ideally, DB load should not go above vCPU line.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a high DB load. High DB load can cause performance issues in the DB instance. This alarm is not applicable to serverless DB instances.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - DBLoad'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8caf758b3f402d44aa791c062f7963ced6487e358b7f86713ca8d77980dbc549)
            check_type(argname="argument database_instance", value=database_instance, expected_type=type_hints["database_instance"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if database_instance is not None:
            self._values["database_instance"] = database_instance
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def database_instance(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance]:
        '''The database instance to monitor.'''
        result = self._values.get("database_instance")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''The database instance identifier to monitor.'''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The maximum vCPU value is determined by the number of vCPU (virtual CPU) cores
        for your DB instance. Depending on the maximum vCPU, different values for the
        threshold can be appropriate. Ideally, DB load should not go above vCPU line.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect a high DB load. High DB load can cause
        performance issues in the DB instance. This alarm is not applicable to serverless
        DB instances.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - DBLoad'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceDbLoadAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RdsInstanceFreeLocalStorageAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceFreeLocalStorageAlarm",
):
    '''An alarm that monitors the amount of available local storage space for an Aurora instance used for temporary files.

    This alarm is used to detect how close the Aurora DB instance is to reaching the local storage limit.
    This alarm can prevent an out-of-space error that occurs when your DB instance runs out of local storage.

    The alarm is triggered when the amount of available local storage space (bytes) is less than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param threshold: The percentage value (0-100) against which the specified statistic is compared. You should calculate about 10%-20% of the amount of storage available based on velocity and trend of volume usage, and then use that result as the threshold value to proactively take action before the volume reaches its limit.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the Aurora DB instance is to reaching the local storage limit, if you do not use Aurora Serverless v2 or higher. Local storage can reach capacity when you store non-persistent data, such as temporary table and log files, in the local storage. This alarm can prevent an out-of-space error that occurs when your DB instance runs out of local storage.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeLocalStorage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9c070ab270a5c4d3af61054452b623be2b812fe1081142410f97c9d71c2dd53e)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsInstanceFreeLocalStorageAlarmProps(
            database_instance=database_instance,
            instance_identifier=instance_identifier,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceFreeLocalStorageAlarmProps",
    jsii_struct_bases=[RdsInstanceAlarmProps, RdsFreeLocalStorageAlarmConfig],
    name_mapping={
        "database_instance": "databaseInstance",
        "instance_identifier": "instanceIdentifier",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsInstanceFreeLocalStorageAlarmProps(
    RdsInstanceAlarmProps,
    RdsFreeLocalStorageAlarmConfig,
):
    def __init__(
        self,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the RdsInstanceFreeLocalStorageAlarm construct.

        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The percentage value (0-100) against which the specified statistic is compared. You should calculate about 10%-20% of the amount of storage available based on velocity and trend of volume usage, and then use that result as the threshold value to proactively take action before the volume reaches its limit.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the Aurora DB instance is to reaching the local storage limit, if you do not use Aurora Serverless v2 or higher. Local storage can reach capacity when you store non-persistent data, such as temporary table and log files, in the local storage. This alarm can prevent an out-of-space error that occurs when your DB instance runs out of local storage.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeLocalStorage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8f0e1dbeaa4b4f4374428dd9d68acbfdefca0ea516824428036800752f16c6bb)
            check_type(argname="argument database_instance", value=database_instance, expected_type=type_hints["database_instance"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if database_instance is not None:
            self._values["database_instance"] = database_instance
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def database_instance(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance]:
        '''The database instance to monitor.'''
        result = self._values.get("database_instance")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''The database instance identifier to monitor.'''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The percentage value (0-100) against which the specified statistic is compared.

        You should calculate about 10%-20% of the amount of storage available based on
        velocity and trend of volume usage, and then use that result as the threshold value
        to proactively take action before the volume reaches its limit.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect how close the Aurora DB instance is to reaching
        the local storage limit, if you do not use Aurora Serverless v2 or higher. Local storage
        can reach capacity when you store non-persistent data, such as temporary table and log
        files, in the local storage. This alarm can prevent an out-of-space error that occurs when
        your DB instance runs out of local storage.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - FreeLocalStorage'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceFreeLocalStorageAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RdsInstanceFreeStorageSpaceAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceFreeStorageSpaceAlarm",
):
    '''An alarm that monitors the amount of available storage space for an Aurora instance.

    This alarm helps prevent storage full issues. This can prevent downtime that occurs when your database
    instance runs out of storage.

    The alarm is triggered when the amount of available storage space (bytes) is less than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param threshold: The percentage value (0-100) against which the specified statistic is compared. The threshold value will depend on the currently allocated storage space. Typically, you should calculate the value of 10 percent of the allocated storage space and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm helps prevent storage full issues. This can prevent downtime that occurs when your database instance runs out of storage. We do not recommend using this alarm if you have storage auto scaling enabled, or if you frequently change the storage capacity of the database instance.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeStorageSpace'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a2c452ff0baecdbab050dd920bb173f12f3b938cbf8c7841d0db12df34e0abbd)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsInstanceFreeStorageSpaceAlarmProps(
            database_instance=database_instance,
            instance_identifier=instance_identifier,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceFreeStorageSpaceAlarmProps",
    jsii_struct_bases=[RdsInstanceAlarmProps, RdsFreeStorageSpaceAlarmConfig],
    name_mapping={
        "database_instance": "databaseInstance",
        "instance_identifier": "instanceIdentifier",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsInstanceFreeStorageSpaceAlarmProps(
    RdsInstanceAlarmProps,
    RdsFreeStorageSpaceAlarmConfig,
):
    def __init__(
        self,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the RdsInstanceFreeStorageSpaceAlarm construct.

        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The percentage value (0-100) against which the specified statistic is compared. The threshold value will depend on the currently allocated storage space. Typically, you should calculate the value of 10 percent of the allocated storage space and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm helps prevent storage full issues. This can prevent downtime that occurs when your database instance runs out of storage. We do not recommend using this alarm if you have storage auto scaling enabled, or if you frequently change the storage capacity of the database instance.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeStorageSpace'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd3d98903dfd1b9e0daa6b64e4d9e18c6986debabb15445ffc4d0004a88a2090)
            check_type(argname="argument database_instance", value=database_instance, expected_type=type_hints["database_instance"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if database_instance is not None:
            self._values["database_instance"] = database_instance
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def database_instance(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance]:
        '''The database instance to monitor.'''
        result = self._values.get("database_instance")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''The database instance identifier to monitor.'''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The percentage value (0-100) against which the specified statistic is compared.

        The threshold value will depend on the currently allocated storage space. Typically,
        you should calculate the value of 10 percent of the allocated storage space and use
        that result as the threshold value.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps prevent storage full issues. This can prevent downtime
        that occurs when your database instance runs out of storage. We do not recommend
        using this alarm if you have storage auto scaling enabled, or if you frequently change
        the storage capacity of the database instance.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - FreeStorageSpace'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceFreeStorageSpaceAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RdsInstanceFreeableMemoryAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceFreeableMemoryAlarm",
):
    '''An alarm that monitors the amount of available memory (RAM) on the RDS instance.

    This alarm is used to help prevent running out of memory which can result in rejected connections.

    The alarm is triggered when the percentage of available memory is less than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param threshold: The percentage value (0-100) against which the specified statistic is compared. Depending on the workload and instance class, different values for the threshold can be appropriate. Ideally, available memory should not go below 25% of total memory for prolonged periods. For Aurora, you can set the threshold close to 5%, because the metric approaching 0 means that the DB instance has scaled up as much as it can. You can analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent running out of memory which can result in rejected connections.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeableMemory'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9acfd0592f5bbf27c262a24a54076955065f64d73ac8e6e60bc13a6b522b0a5d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsInstanceFreeableMemoryAlarmProps(
            database_instance=database_instance,
            instance_identifier=instance_identifier,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceFreeableMemoryAlarmProps",
    jsii_struct_bases=[RdsInstanceAlarmProps, RdsFreeableMemoryAlarmConfig],
    name_mapping={
        "database_instance": "databaseInstance",
        "instance_identifier": "instanceIdentifier",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsInstanceFreeableMemoryAlarmProps(
    RdsInstanceAlarmProps,
    RdsFreeableMemoryAlarmConfig,
):
    def __init__(
        self,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the RdsInstanceFreeableMemoryAlarm construct.

        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The percentage value (0-100) against which the specified statistic is compared. Depending on the workload and instance class, different values for the threshold can be appropriate. Ideally, available memory should not go below 25% of total memory for prolonged periods. For Aurora, you can set the threshold close to 5%, because the metric approaching 0 means that the DB instance has scaled up as much as it can. You can analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent running out of memory which can result in rejected connections.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - FreeableMemory'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__216ee8d8751dcf6df88d71c185ec14a3de98e53f1cd338e7d0c51fa591b4d9e6)
            check_type(argname="argument database_instance", value=database_instance, expected_type=type_hints["database_instance"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if database_instance is not None:
            self._values["database_instance"] = database_instance
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def database_instance(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance]:
        '''The database instance to monitor.'''
        result = self._values.get("database_instance")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''The database instance identifier to monitor.'''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The percentage value (0-100) against which the specified statistic is compared.

        Depending on the workload and instance class, different values for the threshold
        can be appropriate. Ideally, available memory should not go below 25% of total
        memory for prolonged periods. For Aurora, you can set the threshold close to 5%,
        because the metric approaching 0 means that the DB instance has scaled up as much
        as it can. You can analyze the historical behavior of this metric to determine
        sensible threshold levels.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to help prevent running out of memory
        which can result in rejected connections.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - FreeableMemory'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceFreeableMemoryAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RdsInstanceReadLatencyAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceReadLatencyAlarm",
):
    '''An alarm that monitors the average amount of time taken per disk read I/O operation.

    This alarm is used to detect high read latency. Database disks normally have a low read/write latency,
    but they can have issues that can cause high latency operations.

    The alarm is triggered when the average amount of time per disk read operation (in milliseconds) is
    greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param threshold: The value in milliseconds against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on your use case. Read latencies higher than 20 milliseconds are likely a cause for investigation. You can also set a higher threshold if your application can have higher latency for read operations. Review the criticality and requirements of read latency and analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high read latency. Database disks normally have a low read/write latency, but they can have issues that can cause high latency operations.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - ReadLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d50eeda9644ca7e4584f0cae2bccf9b598d5d1a49e8201ed0b5fa5dbc20a3c3f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsInstanceReadLatencyAlarmProps(
            database_instance=database_instance,
            instance_identifier=instance_identifier,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class RdsInstanceRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceRecommendedAlarms",
):
    '''A construct that creates recommended alarms for an RDS cluster instance.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#RDS
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_read_latency_alarm: typing.Union["RdsReadLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_write_latency_alarm: typing.Union["RdsWriteLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["RdsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_instance: The cluster instance to apply the recommended alarms.
        :param instance_identifier: The cluster instance identifier to apply the recommended alarms.
        :param config_database_connections_alarm: The configuration for the DatabaseConnections alarm.
        :param config_db_load_alarm: The configuration for the DbLoad alarm.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_local_storage_alarm: The configuration for the FreeLocalStorage alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_read_latency_alarm: The configuration for the ReadLatency alarm.
        :param config_write_latency_alarm: The configuration for the WriteLatency alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1b211ebf3783040f36dd40c0125e9888685bc3ca0097403392309653a39b362b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsInstanceRecommendedAlarmsProps(
            database_instance=database_instance,
            instance_identifier=instance_identifier,
            config_database_connections_alarm=config_database_connections_alarm,
            config_db_load_alarm=config_db_load_alarm,
            config_freeable_memory_alarm=config_freeable_memory_alarm,
            config_free_local_storage_alarm=config_free_local_storage_alarm,
            config_free_storage_space_alarm=config_free_storage_space_alarm,
            config_read_latency_alarm=config_read_latency_alarm,
            config_write_latency_alarm=config_write_latency_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmCpuUtilization")
    def alarm_cpu_utilization(self) -> typing.Optional[RdsInstanceCpuUtilizationAlarm]:
        '''The CpuUtilization alarm for the database instance.'''
        return typing.cast(typing.Optional[RdsInstanceCpuUtilizationAlarm], jsii.get(self, "alarmCpuUtilization"))

    @builtins.property
    @jsii.member(jsii_name="alarmDatabaseConnections")
    def alarm_database_connections(
        self,
    ) -> typing.Optional[RdsInstanceDatabaseConnectionsAlarm]:
        '''The DatabaseConnections alarm for the database instance.'''
        return typing.cast(typing.Optional[RdsInstanceDatabaseConnectionsAlarm], jsii.get(self, "alarmDatabaseConnections"))

    @builtins.property
    @jsii.member(jsii_name="alarmDbLoad")
    def alarm_db_load(self) -> typing.Optional[RdsInstanceDbLoadAlarm]:
        '''The DbLoad alarm for the database instance.'''
        return typing.cast(typing.Optional[RdsInstanceDbLoadAlarm], jsii.get(self, "alarmDbLoad"))

    @builtins.property
    @jsii.member(jsii_name="alarmFreeableMemory")
    def alarm_freeable_memory(self) -> typing.Optional[RdsInstanceFreeableMemoryAlarm]:
        '''The FreeableMemory alarm for the database instance.'''
        return typing.cast(typing.Optional[RdsInstanceFreeableMemoryAlarm], jsii.get(self, "alarmFreeableMemory"))

    @builtins.property
    @jsii.member(jsii_name="alarmFreeLocalStorage")
    def alarm_free_local_storage(
        self,
    ) -> typing.Optional[RdsInstanceFreeLocalStorageAlarm]:
        '''The FreeLocalStorage alarm for the database instance.'''
        return typing.cast(typing.Optional[RdsInstanceFreeLocalStorageAlarm], jsii.get(self, "alarmFreeLocalStorage"))

    @builtins.property
    @jsii.member(jsii_name="alarmFreeStorageSpace")
    def alarm_free_storage_space(
        self,
    ) -> typing.Optional[RdsInstanceFreeStorageSpaceAlarm]:
        '''The FreeStorageSpace alarm for the database instance.'''
        return typing.cast(typing.Optional[RdsInstanceFreeStorageSpaceAlarm], jsii.get(self, "alarmFreeStorageSpace"))

    @builtins.property
    @jsii.member(jsii_name="alarmReadLatency")
    def alarm_read_latency(self) -> typing.Optional[RdsInstanceReadLatencyAlarm]:
        '''The ReadLatency alarm for the database instance.'''
        return typing.cast(typing.Optional[RdsInstanceReadLatencyAlarm], jsii.get(self, "alarmReadLatency"))

    @builtins.property
    @jsii.member(jsii_name="alarmWriteLatency")
    def alarm_write_latency(self) -> typing.Optional["RdsInstanceWriteLatencyAlarm"]:
        '''The WriteLatency alarm for the database instance.'''
        return typing.cast(typing.Optional["RdsInstanceWriteLatencyAlarm"], jsii.get(self, "alarmWriteLatency"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class RdsInstanceRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceRecommendedAlarmsAspect",
):
    '''An aspect that applies recommended alarms for RDS database instances.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#RDS
    '''

    def __init__(
        self,
        *,
        config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_read_latency_alarm: typing.Union["RdsReadLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_write_latency_alarm: typing.Union["RdsWriteLatencyAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["RdsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_database_connections_alarm: The configuration for the DatabaseConnections alarm.
        :param config_db_load_alarm: The configuration for the DbLoad alarm.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_local_storage_alarm: The configuration for the FreeLocalStorage alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_read_latency_alarm: The configuration for the ReadLatency alarm.
        :param config_write_latency_alarm: The configuration for the WriteLatency alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = RdsInstanceRecommendedAlarmsConfig(
            config_database_connections_alarm=config_database_connections_alarm,
            config_db_load_alarm=config_db_load_alarm,
            config_freeable_memory_alarm=config_freeable_memory_alarm,
            config_free_local_storage_alarm=config_free_local_storage_alarm,
            config_free_storage_space_alarm=config_free_storage_space_alarm,
            config_read_latency_alarm=config_read_latency_alarm,
            config_write_latency_alarm=config_write_latency_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d849723c72f0fe5d2475f9b0ac425270c7e53fd221dff1855afc357bdac7df27)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


class RdsInstanceWriteLatencyAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceWriteLatencyAlarm",
):
    '''An alarm that monitors the average amount of time taken per disk write I/O operation.

    This alarm is used to detect high write latency. Database disks normally have a low read/write latency,
    but they can have issues that can cause high latency operations.

    The alarm is triggered when the average amount of time per disk write operation (in milliseconds) is
    greater than threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param threshold: The value in milliseconds against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on your use case. Write latencies higher than 20 milliseconds are likely a cause for investigation. You can also set a higher threshold if your application can have a higher latency for write operations. Review the criticality and requirements of write latency and analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high write latency. Although database disks typically have low read/write latency, they may experience problems that cause high latency operations. Monitoring this will assure you the disk latency is as low as expected.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - WriteLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dfbac622217ae23c7bdc626b30f927496a8637475dc6499db45343e9ac41148c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = RdsInstanceWriteLatencyAlarmProps(
            database_instance=database_instance,
            instance_identifier=instance_identifier,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsReadLatencyAlarmConfig",
    jsii_struct_bases=[RdsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsReadLatencyAlarmConfig(RdsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the ReadLatency alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value in milliseconds against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on your use case. Read latencies higher than 20 milliseconds are likely a cause for investigation. You can also set a higher threshold if your application can have higher latency for read operations. Review the criticality and requirements of read latency and analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high read latency. Database disks normally have a low read/write latency, but they can have issues that can cause high latency operations.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - ReadLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__85c9318aa42634732b84705a471dfba43b191701d414a13b09dee6ab6d6fec32)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value in milliseconds against which the specified statistic is compared.

        The recommended threshold value for this alarm is highly dependent on your use case.
        Read latencies higher than 20 milliseconds are likely a cause for investigation.
        You can also set a higher threshold if your application can have higher latency for
        read operations. Review the criticality and requirements of read latency and analyze
        the historical behavior of this metric to determine sensible threshold levels.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high read latency. Database disks normally
        have a low read/write latency, but they can have issues that can cause high latency
        operations.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - ReadLatency'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsReadLatencyAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class RdsRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["RdsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configuration for RDS recommended alarms.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3419e18e5a8b513463ce39f2d9740d26444efc6a15f6813731950fdf75536d87)
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["RdsRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["RdsRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsRecommendedAlarmsMetrics"
)
class RdsRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for RDS alarms.'''

    INSTANCE_CPU_UTILIZATION = "INSTANCE_CPU_UTILIZATION"
    '''The percentage of CPU utilization for an RDS instance.'''
    INSTANCE_DATABASE_CONNECTIONS = "INSTANCE_DATABASE_CONNECTIONS"
    '''The number of client network connections to the database instance.'''
    INSTANCE_FREEABLE_MEMORY = "INSTANCE_FREEABLE_MEMORY"
    '''The amount of available memory (RAM) on the RDS instance.'''
    INSTANCE_FREE_LOCAL_STORAGE = "INSTANCE_FREE_LOCAL_STORAGE"
    '''The amount of available local storage space for an Aurora instance used for temporary files.'''
    INSTANCE_FREE_STORAGE_SPACE = "INSTANCE_FREE_STORAGE_SPACE"
    '''The amount of available storage space for an Aurora instance.'''
    INSTANCE_READ_LATENCY = "INSTANCE_READ_LATENCY"
    '''The average amount of time taken per disk read I/O operation.'''
    INSTANCE_WRITE_LATENCY = "INSTANCE_WRITE_LATENCY"
    '''The average amount of time taken per disk write I/O operation.'''
    INSTANCE_DB_LOAD = "INSTANCE_DB_LOAD"
    '''The average active sessions (AAS) for the DB instance which shows how many sessions are concurrently active on the database.'''
    AURORA_VOLUME_BYTES_LEFT_TOTAL = "AURORA_VOLUME_BYTES_LEFT_TOTAL"
    '''The remaining available space for the cluster volume.'''
    AURORA_BIN_LOG_REPLICATION_LAG = "AURORA_BIN_LOG_REPLICATION_LAG"
    '''The amount of time that a binary log replica DB cluster running on Aurora MySQL lags behind the binary log replication source.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsWriteLatencyAlarmConfig",
    jsii_struct_bases=[RdsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsWriteLatencyAlarmConfig(RdsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the WriteLatency alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value in milliseconds against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on your use case. Write latencies higher than 20 milliseconds are likely a cause for investigation. You can also set a higher threshold if your application can have a higher latency for write operations. Review the criticality and requirements of write latency and analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high write latency. Although database disks typically have low read/write latency, they may experience problems that cause high latency operations. Monitoring this will assure you the disk latency is as low as expected.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - WriteLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd4ca204870767586c42288107b2401f85cfb742bc6f7227988af75f40b987e2)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value in milliseconds against which the specified statistic is compared.

        The recommended threshold value for this alarm is highly dependent on your use case.
        Write latencies higher than 20 milliseconds are likely a cause for investigation.
        You can also set a higher threshold if your application can have a higher latency
        for write operations. Review the criticality and requirements of write latency and
        analyze the historical behavior of this metric to determine sensible threshold levels.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high write latency. Although database disks
        typically have low read/write latency, they may experience problems that cause high
        latency operations. Monitoring this will assure you the disk latency is as low as expected.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - WriteLatency'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsWriteLatencyAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class ReplicationInstance(
    _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ReplicationInstance",
):
    '''An extension for the CfnReplicationInstance construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        replication_instance_class: builtins.str,
        allocated_storage: typing.Optional[jsii.Number] = None,
        allow_major_version_upgrade: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        availability_zone: typing.Optional[builtins.str] = None,
        dns_name_servers: typing.Optional[builtins.str] = None,
        engine_version: typing.Optional[builtins.str] = None,
        kms_key_id: typing.Optional[builtins.str] = None,
        multi_az: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        network_type: typing.Optional[builtins.str] = None,
        preferred_maintenance_window: typing.Optional[builtins.str] = None,
        publicly_accessible: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        replication_instance_identifier: typing.Optional[builtins.str] = None,
        replication_subnet_group_identifier: typing.Optional[builtins.str] = None,
        resource_identifier: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_instance_class: The compute and memory capacity of the replication instance as defined for the specified replication instance class. For example, to specify the instance class dms.c4.large, set this parameter to ``"dms.c4.large"`` . For more information on the settings and capacities for the available replication instance classes, see `Selecting the right AWS DMS replication instance for your migration <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_ReplicationInstance.html#CHAP_ReplicationInstance.InDepth>`_ in the *AWS Database Migration Service User Guide* .
        :param allocated_storage: The amount of storage (in gigabytes) to be initially allocated for the replication instance.
        :param allow_major_version_upgrade: Indicates that major version upgrades are allowed. Changing this parameter does not result in an outage, and the change is asynchronously applied as soon as possible. This parameter must be set to ``true`` when specifying a value for the ``EngineVersion`` parameter that is a different major version than the replication instance's current version.
        :param auto_minor_version_upgrade: A value that indicates whether minor engine upgrades are applied automatically to the replication instance during the maintenance window. This parameter defaults to ``true`` . Default: ``true``
        :param availability_zone: The Availability Zone that the replication instance will be created in. The default value is a random, system-chosen Availability Zone in the endpoint's AWS Region , for example ``us-east-1d`` .
        :param dns_name_servers: A list of custom DNS name servers supported for the replication instance to access your on-premise source or target database. This list overrides the default name servers supported by the replication instance. You can specify a comma-separated list of internet addresses for up to four on-premise DNS name servers. For example: ``"1.1.1.1,2.2.2.2,3.3.3.3,4.4.4.4"``
        :param engine_version: The engine version number of the replication instance. If an engine version number is not specified when a replication instance is created, the default is the latest engine version available.
        :param kms_key_id: An AWS KMS key identifier that is used to encrypt the data on the replication instance. If you don't specify a value for the ``KmsKeyId`` parameter, AWS DMS uses your default encryption key. AWS KMS creates the default encryption key for your AWS account . Your AWS account has a different default encryption key for each AWS Region .
        :param multi_az: Specifies whether the replication instance is a Multi-AZ deployment. You can't set the ``AvailabilityZone`` parameter if the Multi-AZ parameter is set to ``true`` .
        :param network_type: The type of IP address protocol used by a replication instance, such as IPv4 only or Dual-stack that supports both IPv4 and IPv6 addressing. IPv6 only is not yet supported.
        :param preferred_maintenance_window: The weekly time range during which system maintenance can occur, in UTC. *Format* : ``ddd:hh24:mi-ddd:hh24:mi`` *Default* : A 30-minute window selected at random from an 8-hour block of time per AWS Region , occurring on a random day of the week. *Valid days* ( ``ddd`` ): ``Mon`` | ``Tue`` | ``Wed`` | ``Thu`` | ``Fri`` | ``Sat`` | ``Sun`` *Constraints* : Minimum 30-minute window.
        :param publicly_accessible: Specifies the accessibility options for the replication instance. A value of ``true`` represents an instance with a public IP address. A value of ``false`` represents an instance with a private IP address. The default value is ``true`` .
        :param replication_instance_identifier: The replication instance identifier. This parameter is stored as a lowercase string. Constraints: - Must contain 1-63 alphanumeric characters or hyphens. - First character must be a letter. - Can't end with a hyphen or contain two consecutive hyphens. Example: ``myrepinstance``
        :param replication_subnet_group_identifier: A subnet group to associate with the replication instance.
        :param resource_identifier: A display name for the resource identifier at the end of the ``EndpointArn`` response parameter that is returned in the created ``Endpoint`` object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as ``Example-App-ARN1`` . For example, this value might result in the ``EndpointArn`` value ``arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1`` . If you don't specify a ``ResourceIdentifier`` value, AWS DMS generates a default identifier value for the end of ``EndpointArn`` .
        :param tags: One or more tags to be assigned to the replication instance.
        :param vpc_security_group_ids: Specifies the virtual private cloud (VPC) security group to be used with the replication instance. The VPC security group must work with the VPC containing the replication instance.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c089713851f8f90249e8eb10526a74679042374ed0c194a9f4084ae41f83541b)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstanceProps(
            replication_instance_class=replication_instance_class,
            allocated_storage=allocated_storage,
            allow_major_version_upgrade=allow_major_version_upgrade,
            auto_minor_version_upgrade=auto_minor_version_upgrade,
            availability_zone=availability_zone,
            dns_name_servers=dns_name_servers,
            engine_version=engine_version,
            kms_key_id=kms_key_id,
            multi_az=multi_az,
            network_type=network_type,
            preferred_maintenance_window=preferred_maintenance_window,
            publicly_accessible=publicly_accessible,
            replication_instance_identifier=replication_instance_identifier,
            replication_subnet_group_identifier=replication_subnet_group_identifier,
            resource_identifier=resource_identifier,
            tags=tags,
            vpc_security_group_ids=vpc_security_group_ids,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmCpuUtilization")
    def alarm_cpu_utilization(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DmsReplicationInstanceCpuUtilizationAlarm:
        '''Creates an alarm that monitors the CPU utilization for the Replication Instance.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization for the DMS Replication Instance. Consistent high CPU utilization can indicate a resource bottleneck or application performance problems.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - CPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The percentage (0-100) value against which the specified statistic is compared. The service metrics for CPU utilization might exceed 100% utilization. However, we recommend that you monitor the metric for high CPU utilization to avoid impacting other services. Default: 90
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DmsCpuUtilizationAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DmsReplicationInstanceCpuUtilizationAlarm, jsii.invoke(self, "alarmCpuUtilization", [props]))

    @jsii.member(jsii_name="alarmFreeableMemory")
    def alarm_freeable_memory(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DmsReplicationInstanceFreeableMemoryAlarm:
        '''Creates an alarm that monitors the FreeableMemory for the Replication Instance.

        :param threshold: The amount in bytes against which the specified statistic is compared. Depending on the workload and instance class, different values for the threshold can be appropriate. Ideally, available memory should not go below 25% of total memory for prolonged periods.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to help prevent running out of memory.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - FreeableMemory'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DmsFreeableMemoryAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DmsReplicationInstanceFreeableMemoryAlarm, jsii.invoke(self, "alarmFreeableMemory", [props]))

    @jsii.member(jsii_name="alarmFreeStorageSpace")
    def alarm_free_storage_space(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DmsReplicationInstanceFreeStorageSpaceAlarm:
        '''Creates an alarm that monitors the Free Storage Space for the Replication Instance.

        :param threshold: The amount in bytes value against which the specified statistic is compared. The threshold value will depend on the currently allocated storage space. Typically, you should calculate the value of 10 percent of the allocated storage space and use that result as the threshold value.
        :param alarm_description: The description of the alarm. Default: - This alarm helps prevent storage full issues. This can prevent downtime that occurs when your replication instance runs out of storage.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - FreeStorageSpace'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DmsFreeStorageSpaceAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DmsReplicationInstanceFreeStorageSpaceAlarm, jsii.invoke(self, "alarmFreeStorageSpace", [props]))

    @jsii.member(jsii_name="alarmSwapUsage")
    def alarm_swap_usage(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        std_devs: typing.Optional[jsii.Number] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DmsReplicationInstanceSwapUsageAlarm:
        '''Creates an alarm that monitors the Swap Usage for the Replication Instance.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high swap usage for the DMS Replication Instance. High swap usage can indicate memory pressure or performance issues.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - SwapUsage'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_UPPER_THRESHOLD (for detecting high swap usage indicating memory pressure)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8 (standard deviation for anomaly detection)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DmsSwapUsageAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            std_devs=std_devs,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DmsReplicationInstanceSwapUsageAlarm, jsii.invoke(self, "alarmSwapUsage", [props]))

    @jsii.member(jsii_name="alarmWriteIops")
    def alarm_write_iops(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DmsReplicationInstanceWriteIopsAlarm:
        '''Creates an alarm that monitors the Write IOPS for the Replication Instance.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high write IOPS for the DMS Replication Instance. High write IOPS can indicate heavy write activity or potential I/O bottlenecks.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - WriteIOPS'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The number of write I/O operations per second against which the specified statistic is compared. High write IOPS can indicate heavy write activity or potential performance bottlenecks. Consider your normal workload patterns when setting this threshold. Default: 1000
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DmsWriteIopsAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DmsReplicationInstanceWriteIopsAlarm, jsii.invoke(self, "alarmWriteIops", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_freeable_memory_alarm: typing.Union[DmsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[DmsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[DmsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_swap_usage_alarm: typing.Optional[typing.Union[DmsSwapUsageAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_write_iops_alarm: typing.Optional[typing.Union[DmsWriteIopsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[DmsReplicationInstanceRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DmsReplicationInstanceRecommendedAlarms:
        '''Creates the recommended alarms for the DMS Replication Instance.

        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_swap_usage_alarm: The configuration for the SwapUsage alarm.
        :param config_write_iops_alarm: The configuration for the WriteIops alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://aws.amazon.com/blogs/database/setting-up-amazon-cloudwatch-alarms-for-aws-dms-resources-using-the-aws-cli/
        '''
        props = DmsReplicationInstanceRecommendedAlarmsConfig(
            config_freeable_memory_alarm=config_freeable_memory_alarm,
            config_free_storage_space_alarm=config_free_storage_space_alarm,
            config_cpu_utilization_alarm=config_cpu_utilization_alarm,
            config_swap_usage_alarm=config_swap_usage_alarm,
            config_write_iops_alarm=config_write_iops_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DmsReplicationInstanceRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))


class ReplicationTask(
    _aws_cdk_aws_dms_ceddda9d.CfnReplicationTask,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ReplicationTask",
):
    '''An extension for the CfnReplicationTask construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        replication_instance_identifier: builtins.str,
        migration_type: builtins.str,
        replication_instance_arn: builtins.str,
        source_endpoint_arn: builtins.str,
        table_mappings: builtins.str,
        target_endpoint_arn: builtins.str,
        cdc_start_position: typing.Optional[builtins.str] = None,
        cdc_start_time: typing.Optional[jsii.Number] = None,
        cdc_stop_position: typing.Optional[builtins.str] = None,
        replication_task_identifier: typing.Optional[builtins.str] = None,
        replication_task_settings: typing.Optional[builtins.str] = None,
        resource_identifier: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        task_data: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param replication_instance_identifier: The identifier of the replication instance.
        :param migration_type: The migration type. Valid values: ``full-load`` | ``cdc`` | ``full-load-and-cdc``
        :param replication_instance_arn: The Amazon Resource Name (ARN) of a replication instance.
        :param source_endpoint_arn: An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.
        :param table_mappings: The table mappings for the task, in JSON format. For more information, see `Using Table Mapping to Specify Task Settings <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html>`_ in the *AWS Database Migration Service User Guide* .
        :param target_endpoint_arn: An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.
        :param cdc_start_position: Indicates when you want a change data capture (CDC) operation to start. Use either ``CdcStartPosition`` or ``CdcStartTime`` to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, log sequence number (LSN), or system change number (SCN) format. Here is a date example: ``--cdc-start-position "2018-03-08T12:12:12"`` Here is a checkpoint example: ``--cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"`` Here is an LSN example: ``--cdc-start-position mysql-bin-changelog.000024:373`` .. epigraph:: When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the ``slotName`` extra connection attribute to the name of this logical replication slot. For more information, see `Extra Connection Attributes When Using PostgreSQL as a Source for AWS DMS <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib>`_ in the *AWS Database Migration Service User Guide* .
        :param cdc_start_time: Indicates the start time for a change data capture (CDC) operation.
        :param cdc_stop_position: Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Here is a server time example: ``--cdc-stop-position "server_time:2018-02-09T12:12:12"`` Here is a commit time example: ``--cdc-stop-position "commit_time: 2018-02-09T12:12:12"``
        :param replication_task_identifier: An identifier for the replication task. Constraints: - Must contain 1-255 alphanumeric characters or hyphens. - First character must be a letter. - Cannot end with a hyphen or contain two consecutive hyphens.
        :param replication_task_settings: Overall settings for the task, in JSON format. For more information, see `Specifying Task Settings for AWS Database Migration Service Tasks <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html>`_ in the *AWS Database Migration Service User Guide* .
        :param resource_identifier: A display name for the resource identifier at the end of the ``EndpointArn`` response parameter that is returned in the created ``Endpoint`` object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as ``Example-App-ARN1`` . For example, this value might result in the ``EndpointArn`` value ``arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1`` . If you don't specify a ``ResourceIdentifier`` value, AWS DMS generates a default identifier value for the end of ``EndpointArn`` .
        :param tags: One or more tags to be assigned to the replication task.
        :param task_data: Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see `Specifying Supplemental Data for Task Settings <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html>`_ in the *AWS Database Migration Service User Guide.*
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36768c7722e96eeb3e44eac0fd5128b954b5d3d67c145574fcf0e5c7b81f3fd3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = ReplicationTaskProps(
            replication_instance_identifier=replication_instance_identifier,
            migration_type=migration_type,
            replication_instance_arn=replication_instance_arn,
            source_endpoint_arn=source_endpoint_arn,
            table_mappings=table_mappings,
            target_endpoint_arn=target_endpoint_arn,
            cdc_start_position=cdc_start_position,
            cdc_start_time=cdc_start_time,
            cdc_stop_position=cdc_stop_position,
            replication_task_identifier=replication_task_identifier,
            replication_task_settings=replication_task_settings,
            resource_identifier=resource_identifier,
            tags=tags,
            task_data=task_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmCdcLatencySource")
    def alarm_cdc_latency_source(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DmsReplicationTaskCdcLatencySourceAlarm:
        '''Creates an alarm that monitors the CDC latency from the source for the Replication Task.

        :param alarm_description: The description of the alarm. Default: - This alarm monitors CDC latency from the source database. High values may indicate replication lag or source database performance issues. This can affect data freshness in real-time applications.
        :param alarm_name: The alarm name. Default: - replicationTaskIdentifier + ' - CDCLatencySource'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        :param threshold: The latency threshold in seconds. This alarm can be used to detect: - High latency indicating replication lag or source database performance issues - Potential data freshness problems affecting real-time applications Consider your application's tolerance for data lag when setting this threshold. Default: 300 (5 minutes - for detecting high latency issues)
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DmsCdcLatencySourceAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DmsReplicationTaskCdcLatencySourceAlarm, jsii.invoke(self, "alarmCdcLatencySource", [props]))

    @jsii.member(jsii_name="alarmCdcLatencyTarget")
    def alarm_cdc_latency_target(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DmsReplicationTaskCdcLatencyTargetAlarm:
        '''Creates an alarm that monitors the CDC latency to the target for the Replication Task.

        :param alarm_description: The description of the alarm. Default: - This alarm monitors CDC latency to the target database. High values may indicate replication lag or target database performance issues. This can affect data consistency in downstream applications.
        :param alarm_name: The alarm name. Default: - replicationTaskIdentifier + ' - CDCLatencyTarget'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_THRESHOLD (for detecting high latency issues)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        :param threshold: The latency threshold in seconds. This alarm can be used to detect: - High latency indicating target database performance issues or replication lag - Potential data consistency problems affecting downstream applications Consider your application's tolerance for data lag when setting this threshold. Default: 300 (5 minutes - for detecting high latency issues)
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DmsCdcLatencyTargetAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            comparison_operator=comparison_operator,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DmsReplicationTaskCdcLatencyTargetAlarm, jsii.invoke(self, "alarmCdcLatencyTarget", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_cdc_latency_source_alarm: typing.Optional[typing.Union[DmsCdcLatencySourceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_cdc_latency_target_alarm: typing.Optional[typing.Union[DmsCdcLatencyTargetAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[DmsReplicationTaskRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DmsReplicationTaskRecommendedAlarms:
        '''Creates the recommended alarms for the DMS Replication Task.

        :param config_cdc_latency_source_alarm: The configuration for the CDCLatencySource alarm.
        :param config_cdc_latency_target_alarm: The configuration for the CDCLatencyTarget alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://aws.amazon.com/blogs/database/setting-up-amazon-cloudwatch-alarms-for-aws-dms-resources-using-the-aws-cli/
        '''
        props = DmsReplicationTaskRecommendedAlarmsConfig(
            config_cdc_latency_source_alarm=config_cdc_latency_source_alarm,
            config_cdc_latency_target_alarm=config_cdc_latency_target_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DmsReplicationTaskRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))

    @builtins.property
    @jsii.member(jsii_name="replicationInstanceIdentifier")
    def replication_instance_identifier(self) -> builtins.str:
        return typing.cast(builtins.str, jsii.get(self, "replicationInstanceIdentifier"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ReplicationTaskProps",
    jsii_struct_bases=[_aws_cdk_aws_dms_ceddda9d.CfnReplicationTaskProps],
    name_mapping={
        "migration_type": "migrationType",
        "replication_instance_arn": "replicationInstanceArn",
        "source_endpoint_arn": "sourceEndpointArn",
        "table_mappings": "tableMappings",
        "target_endpoint_arn": "targetEndpointArn",
        "cdc_start_position": "cdcStartPosition",
        "cdc_start_time": "cdcStartTime",
        "cdc_stop_position": "cdcStopPosition",
        "replication_task_identifier": "replicationTaskIdentifier",
        "replication_task_settings": "replicationTaskSettings",
        "resource_identifier": "resourceIdentifier",
        "tags": "tags",
        "task_data": "taskData",
        "replication_instance_identifier": "replicationInstanceIdentifier",
    },
)
class ReplicationTaskProps(_aws_cdk_aws_dms_ceddda9d.CfnReplicationTaskProps):
    def __init__(
        self,
        *,
        migration_type: builtins.str,
        replication_instance_arn: builtins.str,
        source_endpoint_arn: builtins.str,
        table_mappings: builtins.str,
        target_endpoint_arn: builtins.str,
        cdc_start_position: typing.Optional[builtins.str] = None,
        cdc_start_time: typing.Optional[jsii.Number] = None,
        cdc_stop_position: typing.Optional[builtins.str] = None,
        replication_task_identifier: typing.Optional[builtins.str] = None,
        replication_task_settings: typing.Optional[builtins.str] = None,
        resource_identifier: typing.Optional[builtins.str] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        task_data: typing.Optional[builtins.str] = None,
        replication_instance_identifier: builtins.str,
    ) -> None:
        '''
        :param migration_type: The migration type. Valid values: ``full-load`` | ``cdc`` | ``full-load-and-cdc``
        :param replication_instance_arn: The Amazon Resource Name (ARN) of a replication instance.
        :param source_endpoint_arn: An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.
        :param table_mappings: The table mappings for the task, in JSON format. For more information, see `Using Table Mapping to Specify Task Settings <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html>`_ in the *AWS Database Migration Service User Guide* .
        :param target_endpoint_arn: An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.
        :param cdc_start_position: Indicates when you want a change data capture (CDC) operation to start. Use either ``CdcStartPosition`` or ``CdcStartTime`` to specify when you want a CDC operation to start. Specifying both values results in an error. The value can be in date, checkpoint, log sequence number (LSN), or system change number (SCN) format. Here is a date example: ``--cdc-start-position "2018-03-08T12:12:12"`` Here is a checkpoint example: ``--cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"`` Here is an LSN example: ``--cdc-start-position mysql-bin-changelog.000024:373`` .. epigraph:: When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the ``slotName`` extra connection attribute to the name of this logical replication slot. For more information, see `Extra Connection Attributes When Using PostgreSQL as a Source for AWS DMS <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib>`_ in the *AWS Database Migration Service User Guide* .
        :param cdc_start_time: Indicates the start time for a change data capture (CDC) operation.
        :param cdc_stop_position: Indicates when you want a change data capture (CDC) operation to stop. The value can be either server time or commit time. Here is a server time example: ``--cdc-stop-position "server_time:2018-02-09T12:12:12"`` Here is a commit time example: ``--cdc-stop-position "commit_time: 2018-02-09T12:12:12"``
        :param replication_task_identifier: An identifier for the replication task. Constraints: - Must contain 1-255 alphanumeric characters or hyphens. - First character must be a letter. - Cannot end with a hyphen or contain two consecutive hyphens.
        :param replication_task_settings: Overall settings for the task, in JSON format. For more information, see `Specifying Task Settings for AWS Database Migration Service Tasks <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html>`_ in the *AWS Database Migration Service User Guide* .
        :param resource_identifier: A display name for the resource identifier at the end of the ``EndpointArn`` response parameter that is returned in the created ``Endpoint`` object. The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as ``Example-App-ARN1`` . For example, this value might result in the ``EndpointArn`` value ``arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1`` . If you don't specify a ``ResourceIdentifier`` value, AWS DMS generates a default identifier value for the end of ``EndpointArn`` .
        :param tags: One or more tags to be assigned to the replication task.
        :param task_data: Supplemental information that the task requires to migrate the data for certain source and target endpoints. For more information, see `Specifying Supplemental Data for Task Settings <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html>`_ in the *AWS Database Migration Service User Guide.*
        :param replication_instance_identifier: The identifier of the replication instance.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__264931e44c29455be9e6e4e7d6a48e1d87a96c9d7aa593f183a7947dd3d3d3d1)
            check_type(argname="argument migration_type", value=migration_type, expected_type=type_hints["migration_type"])
            check_type(argname="argument replication_instance_arn", value=replication_instance_arn, expected_type=type_hints["replication_instance_arn"])
            check_type(argname="argument source_endpoint_arn", value=source_endpoint_arn, expected_type=type_hints["source_endpoint_arn"])
            check_type(argname="argument table_mappings", value=table_mappings, expected_type=type_hints["table_mappings"])
            check_type(argname="argument target_endpoint_arn", value=target_endpoint_arn, expected_type=type_hints["target_endpoint_arn"])
            check_type(argname="argument cdc_start_position", value=cdc_start_position, expected_type=type_hints["cdc_start_position"])
            check_type(argname="argument cdc_start_time", value=cdc_start_time, expected_type=type_hints["cdc_start_time"])
            check_type(argname="argument cdc_stop_position", value=cdc_stop_position, expected_type=type_hints["cdc_stop_position"])
            check_type(argname="argument replication_task_identifier", value=replication_task_identifier, expected_type=type_hints["replication_task_identifier"])
            check_type(argname="argument replication_task_settings", value=replication_task_settings, expected_type=type_hints["replication_task_settings"])
            check_type(argname="argument resource_identifier", value=resource_identifier, expected_type=type_hints["resource_identifier"])
            check_type(argname="argument tags", value=tags, expected_type=type_hints["tags"])
            check_type(argname="argument task_data", value=task_data, expected_type=type_hints["task_data"])
            check_type(argname="argument replication_instance_identifier", value=replication_instance_identifier, expected_type=type_hints["replication_instance_identifier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "migration_type": migration_type,
            "replication_instance_arn": replication_instance_arn,
            "source_endpoint_arn": source_endpoint_arn,
            "table_mappings": table_mappings,
            "target_endpoint_arn": target_endpoint_arn,
            "replication_instance_identifier": replication_instance_identifier,
        }
        if cdc_start_position is not None:
            self._values["cdc_start_position"] = cdc_start_position
        if cdc_start_time is not None:
            self._values["cdc_start_time"] = cdc_start_time
        if cdc_stop_position is not None:
            self._values["cdc_stop_position"] = cdc_stop_position
        if replication_task_identifier is not None:
            self._values["replication_task_identifier"] = replication_task_identifier
        if replication_task_settings is not None:
            self._values["replication_task_settings"] = replication_task_settings
        if resource_identifier is not None:
            self._values["resource_identifier"] = resource_identifier
        if tags is not None:
            self._values["tags"] = tags
        if task_data is not None:
            self._values["task_data"] = task_data

    @builtins.property
    def migration_type(self) -> builtins.str:
        '''The migration type.

        Valid values: ``full-load`` | ``cdc`` | ``full-load-and-cdc``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-migrationtype
        '''
        result = self._values.get("migration_type")
        assert result is not None, "Required property 'migration_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def replication_instance_arn(self) -> builtins.str:
        '''The Amazon Resource Name (ARN) of a replication instance.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-replicationinstancearn
        '''
        result = self._values.get("replication_instance_arn")
        assert result is not None, "Required property 'replication_instance_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def source_endpoint_arn(self) -> builtins.str:
        '''An Amazon Resource Name (ARN) that uniquely identifies the source endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-sourceendpointarn
        '''
        result = self._values.get("source_endpoint_arn")
        assert result is not None, "Required property 'source_endpoint_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def table_mappings(self) -> builtins.str:
        '''The table mappings for the task, in JSON format.

        For more information, see `Using Table Mapping to Specify Task Settings <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TableMapping.html>`_ in the *AWS Database Migration Service User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-tablemappings
        '''
        result = self._values.get("table_mappings")
        assert result is not None, "Required property 'table_mappings' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def target_endpoint_arn(self) -> builtins.str:
        '''An Amazon Resource Name (ARN) that uniquely identifies the target endpoint.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-targetendpointarn
        '''
        result = self._values.get("target_endpoint_arn")
        assert result is not None, "Required property 'target_endpoint_arn' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cdc_start_position(self) -> typing.Optional[builtins.str]:
        '''Indicates when you want a change data capture (CDC) operation to start.

        Use either ``CdcStartPosition`` or ``CdcStartTime`` to specify when you want a CDC operation to start. Specifying both values results in an error.

        The value can be in date, checkpoint, log sequence number (LSN), or system change number (SCN) format.

        Here is a date example: ``--cdc-start-position "2018-03-08T12:12:12"``

        Here is a checkpoint example: ``--cdc-start-position "checkpoint:V1#27#mysql-bin-changelog.157832:1975:-1:2002:677883278264080:mysql-bin-changelog.157832:1876#0#0#*#0#93"``

        Here is an LSN example: ``--cdc-start-position mysql-bin-changelog.000024:373``
        .. epigraph::

           When you use this task setting with a source PostgreSQL database, a logical replication slot should already be created and associated with the source endpoint. You can verify this by setting the ``slotName`` extra connection attribute to the name of this logical replication slot. For more information, see `Extra Connection Attributes When Using PostgreSQL as a Source for AWS DMS <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Source.PostgreSQL.html#CHAP_Source.PostgreSQL.ConnectionAttrib>`_ in the *AWS Database Migration Service User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-cdcstartposition
        '''
        result = self._values.get("cdc_start_position")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cdc_start_time(self) -> typing.Optional[jsii.Number]:
        '''Indicates the start time for a change data capture (CDC) operation.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-cdcstarttime
        '''
        result = self._values.get("cdc_start_time")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def cdc_stop_position(self) -> typing.Optional[builtins.str]:
        '''Indicates when you want a change data capture (CDC) operation to stop.

        The value can be either server time or commit time.

        Here is a server time example: ``--cdc-stop-position "server_time:2018-02-09T12:12:12"``

        Here is a commit time example: ``--cdc-stop-position "commit_time: 2018-02-09T12:12:12"``

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-cdcstopposition
        '''
        result = self._values.get("cdc_stop_position")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def replication_task_identifier(self) -> typing.Optional[builtins.str]:
        '''An identifier for the replication task.

        Constraints:

        - Must contain 1-255 alphanumeric characters or hyphens.
        - First character must be a letter.
        - Cannot end with a hyphen or contain two consecutive hyphens.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-replicationtaskidentifier
        '''
        result = self._values.get("replication_task_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def replication_task_settings(self) -> typing.Optional[builtins.str]:
        '''Overall settings for the task, in JSON format.

        For more information, see `Specifying Task Settings for AWS Database Migration Service Tasks <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.CustomizingTasks.TaskSettings.html>`_ in the *AWS Database Migration Service User Guide* .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-replicationtasksettings
        '''
        result = self._values.get("replication_task_settings")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def resource_identifier(self) -> typing.Optional[builtins.str]:
        '''A display name for the resource identifier at the end of the ``EndpointArn`` response parameter that is returned in the created ``Endpoint`` object.

        The value for this parameter can have up to 31 characters. It can contain only ASCII letters, digits, and hyphen ('-'). Also, it can't end with a hyphen or contain two consecutive hyphens, and can only begin with a letter, such as ``Example-App-ARN1`` .

        For example, this value might result in the ``EndpointArn`` value ``arn:aws:dms:eu-west-1:012345678901:rep:Example-App-ARN1`` . If you don't specify a ``ResourceIdentifier`` value, AWS DMS generates a default identifier value for the end of ``EndpointArn`` .

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-resourceidentifier
        '''
        result = self._values.get("resource_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def tags(self) -> typing.Optional[typing.List[_aws_cdk_ceddda9d.CfnTag]]:
        '''One or more tags to be assigned to the replication task.

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-tags
        '''
        result = self._values.get("tags")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_ceddda9d.CfnTag]], result)

    @builtins.property
    def task_data(self) -> typing.Optional[builtins.str]:
        '''Supplemental information that the task requires to migrate the data for certain source and target endpoints.

        For more information, see `Specifying Supplemental Data for Task Settings <https://docs.aws.amazon.com/dms/latest/userguide/CHAP_Tasks.TaskData.html>`_ in the *AWS Database Migration Service User Guide.*

        :see: http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dms-replicationtask.html#cfn-dms-replicationtask-taskdata
        '''
        result = self._values.get("task_data")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def replication_instance_identifier(self) -> builtins.str:
        '''The identifier of the replication instance.'''
        result = self._values.get("replication_instance_identifier")
        assert result is not None, "Required property 'replication_instance_identifier' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ReplicationTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class RestApi(
    _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RestApi",
):
    '''An extension for the RestApi construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        cloud_watch_role: typing.Optional[builtins.bool] = None,
        cloud_watch_role_removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        deploy: typing.Optional[builtins.bool] = None,
        deploy_options: typing.Optional[typing.Union[_aws_cdk_aws_apigateway_ceddda9d.StageOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        description: typing.Optional[builtins.str] = None,
        disable_execute_api_endpoint: typing.Optional[builtins.bool] = None,
        domain_name: typing.Optional[typing.Union[_aws_cdk_aws_apigateway_ceddda9d.DomainNameOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        endpoint_configuration: typing.Optional[typing.Union[_aws_cdk_aws_apigateway_ceddda9d.EndpointConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
        endpoint_export_name: typing.Optional[builtins.str] = None,
        endpoint_types: typing.Optional[typing.Sequence[_aws_cdk_aws_apigateway_ceddda9d.EndpointType]] = None,
        fail_on_warnings: typing.Optional[builtins.bool] = None,
        parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        policy: typing.Optional[_aws_cdk_aws_iam_ceddda9d.PolicyDocument] = None,
        rest_api_name: typing.Optional[builtins.str] = None,
        retain_deployments: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param cloud_watch_role: Automatically configure an AWS CloudWatch role for API Gateway. Default: - false if ``@aws-cdk/aws-apigateway:disableCloudWatchRole`` is enabled, true otherwise
        :param cloud_watch_role_removal_policy: The removal policy applied to the AWS CloudWatch role when this resource is removed from the application. Requires ``cloudWatchRole`` to be enabled. Default: - RemovalPolicy.RETAIN
        :param deploy: Indicates if a Deployment should be automatically created for this API, and recreated when the API model (resources, methods) changes. Since API Gateway deployments are immutable, When this option is enabled (by default), an AWS::ApiGateway::Deployment resource will automatically created with a logical ID that hashes the API model (methods, resources and options). This means that when the model changes, the logical ID of this CloudFormation resource will change, and a new deployment will be created. If this is set, ``latestDeployment`` will refer to the ``Deployment`` object and ``deploymentStage`` will refer to a ``Stage`` that points to this deployment. To customize the stage options, use the ``deployOptions`` property. A CloudFormation Output will also be defined with the root URL endpoint of this REST API. Default: true
        :param deploy_options: Options for the API Gateway stage that will always point to the latest deployment when ``deploy`` is enabled. If ``deploy`` is disabled, this value cannot be set. Default: - Based on defaults of ``StageOptions``.
        :param description: A description of the RestApi construct. Default: - 'Automatically created by the RestApi construct'
        :param disable_execute_api_endpoint: Specifies whether clients can invoke the API using the default execute-api endpoint. To require that clients use a custom domain name to invoke the API, disable the default endpoint. Default: false
        :param domain_name: Configure a custom domain name and map it to this API. Default: - no domain name is defined, use ``addDomainName`` or directly define a ``DomainName``.
        :param endpoint_configuration: The EndpointConfiguration property type specifies the endpoint types of a REST API. Default: EndpointType.EDGE
        :param endpoint_export_name: Export name for the CfnOutput containing the API endpoint. Default: - when no export name is given, output will be created without export
        :param endpoint_types: A list of the endpoint types of the API. Use this property when creating an API. Default: EndpointType.EDGE
        :param fail_on_warnings: Indicates whether to roll back the resource if a warning occurs while API Gateway is creating the RestApi resource. Default: false
        :param parameters: Custom header parameters for the request. Default: - No parameters.
        :param policy: A policy document that contains the permissions for this RestApi. Default: - No policy.
        :param rest_api_name: A name for the API Gateway RestApi resource. Default: - ID of the RestApi construct.
        :param retain_deployments: Retains old deployment resources when the API changes. This allows manually reverting stages to point to old deployments via the AWS Console. Default: false
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d2aeabda01e3b53e063d03be55fffeb13059b97f986baf1b3d0d180ef20005e6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_apigateway_ceddda9d.RestApiBaseProps(
            cloud_watch_role=cloud_watch_role,
            cloud_watch_role_removal_policy=cloud_watch_role_removal_policy,
            deploy=deploy,
            deploy_options=deploy_options,
            description=description,
            disable_execute_api_endpoint=disable_execute_api_endpoint,
            domain_name=domain_name,
            endpoint_configuration=endpoint_configuration,
            endpoint_export_name=endpoint_export_name,
            endpoint_types=endpoint_types,
            fail_on_warnings=fail_on_warnings,
            parameters=parameters,
            policy=policy,
            rest_api_name=rest_api_name,
            retain_deployments=retain_deployments,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarm4XXError")
    def alarm4_xx_error(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> ApiGatewayRestApi4XXErrorAlarm:
        '''Creates an alarm that monitors the number of client-side errors captured in a given period.

        :param threshold: The threshold value against which the specified statistic is compared.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect high rates of client-side errors for the API Gateway requests.
        :param alarm_name: The alarm name. Default: - apiName + ' - 4XXError'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. The unit is an absolute count of errors, not a percentage. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApiGateway4XXErrorAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(ApiGatewayRestApi4XXErrorAlarm, jsii.invoke(self, "alarm4XXError", [props]))

    @jsii.member(jsii_name="alarm5XXError")
    def alarm5_xx_error(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> ApiGatewayRestApi5XXErrorAlarm:
        '''Creates an alarm that monitors the number of server-side errors captured in a given period.

        :param threshold: The threshold value against which the specified statistic is compared.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect high rates of server-side errors for the API Gateway requests.
        :param alarm_name: The alarm name. Default: - apiName + ' - 5XXError'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. The unit is an absolute count of errors, not a percentage. Default: 3
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApiGateway5XXErrorAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(ApiGatewayRestApi5XXErrorAlarm, jsii.invoke(self, "alarm5XXError", [props]))

    @jsii.member(jsii_name="alarmDetailedLatency")
    def alarm_detailed_latency(
        self,
        props: typing.Sequence[typing.Union[ApiGatewayRestApiDetailedLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]],
    ) -> typing.List[ApiGatewayRestApiDetailedLatencyAlarm]:
        '''Creates a list of alarms the time between when API Gateway receives a request from a client and when it returns a response to the client for the methods and resources specified.

        :param props: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5145c360c3415cdde5a29a528c3d3bce79794f0947d78bca731a00768e8f89e5)
            check_type(argname="argument props", value=props, expected_type=type_hints["props"])
        return typing.cast(typing.List[ApiGatewayRestApiDetailedLatencyAlarm], jsii.invoke(self, "alarmDetailedLatency", [props]))

    @jsii.member(jsii_name="alarmLatency")
    def alarm_latency(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> ApiGatewayRestApiLatencyAlarm:
        '''Creates an alarm that monitors the time between when API Gateway receives a request from a client and when it returns a response to the client.

        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the API Gateway requests in a stage have high latency.
        :param alarm_name: The alarm name. Default: - apiName + ' - Latency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The value in milliseconds against which the specified statistic is compared. The suggested threshold value does not work for all API workloads. However, you can use it as a starting point for the threshold. You can then choose different threshold values based on the workload and acceptable latency, performance, and SLA requirements for the API. If it is acceptable for the API to have a higher latency in general, you can set a higher threshold value to make the alarm less sensitive. However, if the API is expected to provide near real-time responses, set a lower threshold value. You can also analyze historical data to determine what the expected baseline latency is for the application workload and then tune the threshold value accordingly. Default: 2500
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = ApiGatewayLatencyAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(ApiGatewayRestApiLatencyAlarm, jsii.invoke(self, "alarmLatency", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config4_xx_error_alarm: typing.Union["ApiGateway4XXErrorAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config5_xx_error_alarm: typing.Union["ApiGateway5XXErrorAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_detailed_latency_alarm_list: typing.Optional[typing.Sequence[typing.Union[ApiGatewayRestApiDetailedLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
        config_latency_alarm: typing.Optional[typing.Union[ApiGatewayLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[ApiGatewayRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> ApiGatewayRestApiRecommendedAlarms:
        '''Creates the recommended alarms for the ApiGateway api.

        :param config4_xx_error_alarm: The configuration for the 4XXError alarm.
        :param config5_xx_error_alarm: The configuration for the 5XXError alarm.
        :param config_detailed_latency_alarm_list: The configuration list for the detailed Latency alarm.
        :param config_latency_alarm: The configuration for the Latency alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#ApiGateway
        '''
        props = ApiGatewayRestApiRecommendedAlarmsConfig(
            config4_xx_error_alarm=config4_xx_error_alarm,
            config5_xx_error_alarm=config5_xx_error_alarm,
            config_detailed_latency_alarm_list=config_detailed_latency_alarm_list,
            config_latency_alarm=config_latency_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(ApiGatewayRestApiRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))


class S3Bucket4xxErrorsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3Bucket4xxErrorsAlarm",
):
    '''An alarm that monitors the 4xx errors for an S3 bucket.

    This alarm is used to create a baseline for typical 4xx error
    rates so that you can look into any abnormalities that might
    indicate a setup issue.

    The alarm is triggered when the 4xx error rate exceeds the % threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param bucket: The S3 bucket to monitor.
        :param alarm_description: The alarm description. Default: - This alarm helps us report the total number of 4xx error status codes that are made in response to client requests. 403 error codes might indicate an incorrect IAM policy, and 404 error codes might indicate mis-behaving client application, for example. Enabling S3 server access logging on a temporary basis will help you to pinpoint the issue's origin using the fields HTTP status and Error Code. To understand more about the error code, see Error Responses (https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html).
        :param alarm_name: The alarm name. Default: - bucket.bucketName + ' - 4xxErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. Default: 0.05
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b9d4f29388ca9807519ae0412e8634338d955302b834578576dc547f464049e6)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = S3Bucket4xxErrorsAlarmProps(
            bucket=bucket,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            threshold=threshold,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


class S3Bucket5xxErrorsAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3Bucket5xxErrorsAlarm",
):
    '''An alarm that monitors the 5xx errors for an S3 bucket.

    This alarm can help to detect if the application is
    experiencing issues due to 5xx errors.

    The alarm is triggered when the 5xx error rate exceeds the % threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param bucket: The S3 bucket to monitor.
        :param alarm_description: The alarm description. Default: - This alarm helps you detect a high number of server-side errors. These errors indicate that a client made a request that the server couldnt complete. This can help you correlate the issue your application is facing because of S3. For more information to help you efficiently handle or reduce errors, see Optimizing performance design patterns (https://docs.aws.amazon.com/AmazonS3/latest/userguide/optimizing-performance-design-patterns.html#optimizing-performance-timeouts-retries). Errors might also be caused by an the issue with S3, check AWS service health dashboard for the status of Amazon S3 in your Region.
        :param alarm_name: The alarm name. Default: - bucket.bucketName + ' - 5xxErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. Default: 0.05
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e32caa975316b8e881679f0e3ca0297c5c175dcc49fcb62b683c66bf9f5782bb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = S3Bucket5xxErrorsAlarmProps(
            bucket=bucket,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            threshold=threshold,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3BucketHttpErrorsAlarmConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
    },
)
class S3BucketHttpErrorsAlarmConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The optional configuration for the 4xx and 5xx error alarms for an S3 bucket.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. Default: 0.05
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c2fd29de3b481f2cfa00b9af24444e83bc204407864373f5dd40399adff9991d)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        :default: 0.05
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3BucketHttpErrorsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class S3RecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3RecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an S3 bucket.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#S3
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
        config4xx_errors_alarm: typing.Optional[typing.Union["S3Bucket4xxErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config5xx_errors_alarm: typing.Optional[typing.Union["S3Bucket5xxErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["S3RecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param bucket: The S3 bucket to apply the recommended alarms to.
        :param config4xx_errors_alarm: The configuration for the 4xx errors alarm.
        :param config5xx_errors_alarm: The configuration for the 5xx errors alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47bd74a1f4cc68aa49abcb9ddefc859f62a8d650ec660e1f1dc076405de12203)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = S3RecommendedAlarmsProps(
            bucket=bucket,
            config4xx_errors_alarm=config4xx_errors_alarm,
            config5xx_errors_alarm=config5xx_errors_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarm4xxErrors")
    def alarm4xx_errors(self) -> typing.Optional[S3Bucket4xxErrorsAlarm]:
        '''The 4xx errors alarm.'''
        return typing.cast(typing.Optional[S3Bucket4xxErrorsAlarm], jsii.get(self, "alarm4xxErrors"))

    @builtins.property
    @jsii.member(jsii_name="alarm5xxErrors")
    def alarm5xx_errors(self) -> typing.Optional[S3Bucket5xxErrorsAlarm]:
        '''The 5xx errors alarm.'''
        return typing.cast(typing.Optional[S3Bucket5xxErrorsAlarm], jsii.get(self, "alarm5xxErrors"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class S3RecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3RecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an S3 bucket.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#S3
    '''

    def __init__(
        self,
        *,
        config4xx_errors_alarm: typing.Optional[typing.Union["S3Bucket4xxErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config5xx_errors_alarm: typing.Optional[typing.Union["S3Bucket5xxErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["S3RecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config4xx_errors_alarm: The configuration for the 4xx errors alarm.
        :param config5xx_errors_alarm: The configuration for the 5xx errors alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = S3RecommendedAlarmsConfig(
            config4xx_errors_alarm=config4xx_errors_alarm,
            config5xx_errors_alarm=config5xx_errors_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__81cb56b973536fefe93bd8cdf5503a61b0f7a86c873b9ea667e56303d99c024b)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3RecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config4xx_errors_alarm": "config4xxErrorsAlarm",
        "config5xx_errors_alarm": "config5xxErrorsAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class S3RecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config4xx_errors_alarm: typing.Optional[typing.Union["S3Bucket4xxErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config5xx_errors_alarm: typing.Optional[typing.Union["S3Bucket5xxErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["S3RecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an S3 bucket.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config4xx_errors_alarm: The configuration for the 4xx errors alarm.
        :param config5xx_errors_alarm: The configuration for the 5xx errors alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config4xx_errors_alarm, dict):
            config4xx_errors_alarm = S3Bucket4xxErrorsAlarmConfig(**config4xx_errors_alarm)
        if isinstance(config5xx_errors_alarm, dict):
            config5xx_errors_alarm = S3Bucket5xxErrorsAlarmConfig(**config5xx_errors_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a54261617c599ef9e038be027b2446bed17b11cfdf8002aee30d2b71f6ea7868)
            check_type(argname="argument config4xx_errors_alarm", value=config4xx_errors_alarm, expected_type=type_hints["config4xx_errors_alarm"])
            check_type(argname="argument config5xx_errors_alarm", value=config5xx_errors_alarm, expected_type=type_hints["config5xx_errors_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config4xx_errors_alarm is not None:
            self._values["config4xx_errors_alarm"] = config4xx_errors_alarm
        if config5xx_errors_alarm is not None:
            self._values["config5xx_errors_alarm"] = config5xx_errors_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config4xx_errors_alarm(self) -> typing.Optional["S3Bucket4xxErrorsAlarmConfig"]:
        '''The configuration for the 4xx errors alarm.'''
        result = self._values.get("config4xx_errors_alarm")
        return typing.cast(typing.Optional["S3Bucket4xxErrorsAlarmConfig"], result)

    @builtins.property
    def config5xx_errors_alarm(self) -> typing.Optional["S3Bucket5xxErrorsAlarmConfig"]:
        '''The configuration for the 5xx errors alarm.'''
        result = self._values.get("config5xx_errors_alarm")
        return typing.cast(typing.Optional["S3Bucket5xxErrorsAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["S3RecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["S3RecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3RecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3RecommendedAlarmsMetrics"
)
class S3RecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for S3 bucket alarms.'''

    ERRORS_4XX = "ERRORS_4XX"
    '''4xxErrors are errors (4xx error codes) that are made in response to client requests.'''
    ERRORS_5XX = "ERRORS_5XX"
    '''5xxErrors are server errors (5xx error codes) that are made in response to client requests.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3RecommendedAlarmsProps",
    jsii_struct_bases=[S3RecommendedAlarmsConfig],
    name_mapping={
        "config4xx_errors_alarm": "config4xxErrorsAlarm",
        "config5xx_errors_alarm": "config5xxErrorsAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "bucket": "bucket",
    },
)
class S3RecommendedAlarmsProps(S3RecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config4xx_errors_alarm: typing.Optional[typing.Union["S3Bucket4xxErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config5xx_errors_alarm: typing.Optional[typing.Union["S3Bucket5xxErrorsAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[S3RecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
    ) -> None:
        '''
        :param config4xx_errors_alarm: The configuration for the 4xx errors alarm.
        :param config5xx_errors_alarm: The configuration for the 5xx errors alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param bucket: The S3 bucket to apply the recommended alarms to.
        '''
        if isinstance(config4xx_errors_alarm, dict):
            config4xx_errors_alarm = S3Bucket4xxErrorsAlarmConfig(**config4xx_errors_alarm)
        if isinstance(config5xx_errors_alarm, dict):
            config5xx_errors_alarm = S3Bucket5xxErrorsAlarmConfig(**config5xx_errors_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bffe2626f56a0b42370556b496eae7b36c626ba33a4d8d3b6ee7cf6c6e78caeb)
            check_type(argname="argument config4xx_errors_alarm", value=config4xx_errors_alarm, expected_type=type_hints["config4xx_errors_alarm"])
            check_type(argname="argument config5xx_errors_alarm", value=config5xx_errors_alarm, expected_type=type_hints["config5xx_errors_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bucket": bucket,
        }
        if config4xx_errors_alarm is not None:
            self._values["config4xx_errors_alarm"] = config4xx_errors_alarm
        if config5xx_errors_alarm is not None:
            self._values["config5xx_errors_alarm"] = config5xx_errors_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config4xx_errors_alarm(self) -> typing.Optional["S3Bucket4xxErrorsAlarmConfig"]:
        '''The configuration for the 4xx errors alarm.'''
        result = self._values.get("config4xx_errors_alarm")
        return typing.cast(typing.Optional["S3Bucket4xxErrorsAlarmConfig"], result)

    @builtins.property
    def config5xx_errors_alarm(self) -> typing.Optional["S3Bucket5xxErrorsAlarmConfig"]:
        '''The configuration for the 5xx errors alarm.'''
        result = self._values.get("config5xx_errors_alarm")
        return typing.cast(typing.Optional["S3Bucket5xxErrorsAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[S3RecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[S3RecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def bucket(self) -> _aws_cdk_aws_s3_ceddda9d.IBucket:
        '''The S3 bucket to apply the recommended alarms to.'''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(_aws_cdk_aws_s3_ceddda9d.IBucket, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3RecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class SfAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__66d865f305d7122fb5935c7fbc0759324302463befce7e670cd03e03120fbfe4)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class SfRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfRecommendedAlarmsAspect",
):
    '''Configures the alarms for an StepFunctions StateMachine.'''

    def __init__(
        self,
        *,
        config_execution_time_alarm: typing.Union["SfStateMachineExecutionTimeAlarmConfig", typing.Dict[builtins.str, typing.Any]],
        config_executions_failed_alarm: typing.Optional[typing.Union["SfStateMachineExecutionsFailedAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_executions_timed_out_alarm: typing.Optional[typing.Union["SfStateMachineExecutionsTimedOutAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_execution_throttled_alarm: typing.Optional[typing.Union["SfStateMachineExecutionThrottledAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["SfRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_execution_time_alarm: The configuration for the ExecutionTime alarm.
        :param config_executions_failed_alarm: The configuration for the ExecutionsFailed alarm.
        :param config_executions_timed_out_alarm: The configuration for the ExecutionsFailed alarm.
        :param config_execution_throttled_alarm: The configuration for the ExecutionThrottled alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SfStateMachineRecommendedAlarmsConfig(
            config_execution_time_alarm=config_execution_time_alarm,
            config_executions_failed_alarm=config_executions_failed_alarm,
            config_executions_timed_out_alarm=config_executions_timed_out_alarm,
            config_execution_throttled_alarm=config_execution_throttled_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__513ab9159140e995a2a69fd725c38191b82a9e2ff303888f3d29bbef42b4dc85)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfRecommendedAlarmsMetrics"
)
class SfRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for StepFunctions alarms.'''

    EXECUTION_TIME = "EXECUTION_TIME"
    '''Interval, in milliseconds, between the time the execution starts and the time it closes.'''
    EXECUTION_THROTTLED = "EXECUTION_THROTTLED"
    '''Number of StateEntered events and retries that have been throttled.

    This is related to
    StateTransition throttling. For more information, see Quotas related to state throttling.
    '''
    EXECUTIONS_FAILED = "EXECUTIONS_FAILED"
    '''Number of failed executions.'''
    EXECUTIONS_TIMED_OUT = "EXECUTIONS_TIMED_OUT"
    '''Number of executions that time out for any reason.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"state_machine": "stateMachine"},
)
class SfStateMachineAlarmProps:
    def __init__(
        self,
        *,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    ) -> None:
        '''The common properties for the StepFunctions StateMachine alarms.

        :param state_machine: The StateMachine to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9a52ea1e3e45dabc027956b755eb8370fbc9b0fa89ad1acfb58489dda8cf9627)
            check_type(argname="argument state_machine", value=state_machine, expected_type=type_hints["state_machine"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "state_machine": state_machine,
        }

    @builtins.property
    def state_machine(self) -> _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine:
        '''The StateMachine to monitor.'''
        result = self._values.get("state_machine")
        assert result is not None, "Required property 'state_machine' is missing"
        return typing.cast(_aws_cdk_aws_stepfunctions_ceddda9d.StateMachine, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SfStateMachineExecutionThrottledAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionThrottledAlarm",
):
    '''The ExecutionThrottled metric tracks the number of times state machine executions are throttled due to exceeding AWS service limits.

    Monitoring this can help you identify when you are hitting this limits, which could signal that adjustments need to be made either in
    the process design or in the service limits themselves.

    The alarm is triggered when the number of executions throttled exceed the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param state_machine: The StateMachine to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect throttled executions due to exceeding AWS service limits.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionThrottled'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The ExecutionThrottled metric tracks the number of times state machine executions are throttled due to exceeding AWS service limits. Monitoring this can help you identify when you are hitting this limits, which could signal that adjustments need to be made either in the process design or in the service limits themselves. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c21e18125d749306c3ebeee177cddfe4f037020046445fc6c15557df2d98e6ac)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SfStateMachineExecutionThrottledAlarmProps(
            state_machine=state_machine,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionThrottledAlarmConfig",
    jsii_struct_bases=[SfAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class SfStateMachineExecutionThrottledAlarmConfig(SfAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the ExecutionThrottled alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect throttled executions due to exceeding AWS service limits.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionThrottled'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The ExecutionThrottled metric tracks the number of times state machine executions are throttled due to exceeding AWS service limits. Monitoring this can help you identify when you are hitting this limits, which could signal that adjustments need to be made either in the process design or in the service limits themselves. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__669f1335be35c6b597602733d81a73570ea27f1742caf3b92c1d1bbc13825f57)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect throttled executions due to exceeding AWS service limits.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - stateMachineName + ' - ExecutionThrottled'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The ExecutionThrottled metric tracks the number of times state machine executions are throttled due to exceeding AWS service limits.

        Monitoring this can help you identify when you are hitting this limits, which could signal that adjustments need to be made either in
        the process design or in the service limits themselves.

        :default: 5
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineExecutionThrottledAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionThrottledAlarmProps",
    jsii_struct_bases=[
        SfStateMachineAlarmProps, SfStateMachineExecutionThrottledAlarmConfig
    ],
    name_mapping={
        "state_machine": "stateMachine",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class SfStateMachineExecutionThrottledAlarmProps(
    SfStateMachineAlarmProps,
    SfStateMachineExecutionThrottledAlarmConfig,
):
    def __init__(
        self,
        *,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the SfStateMachineExecutionThrottledAlarm construct.

        :param state_machine: The StateMachine to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect throttled executions due to exceeding AWS service limits.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionThrottled'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The ExecutionThrottled metric tracks the number of times state machine executions are throttled due to exceeding AWS service limits. Monitoring this can help you identify when you are hitting this limits, which could signal that adjustments need to be made either in the process design or in the service limits themselves. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0fde71b6806713dbe8039efea231f44aa4a2d8be3604e724d849903c4a6cefa0)
            check_type(argname="argument state_machine", value=state_machine, expected_type=type_hints["state_machine"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "state_machine": state_machine,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def state_machine(self) -> _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine:
        '''The StateMachine to monitor.'''
        result = self._values.get("state_machine")
        assert result is not None, "Required property 'state_machine' is missing"
        return typing.cast(_aws_cdk_aws_stepfunctions_ceddda9d.StateMachine, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect throttled executions due to exceeding AWS service limits.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - stateMachineName + ' - ExecutionThrottled'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The ExecutionThrottled metric tracks the number of times state machine executions are throttled due to exceeding AWS service limits.

        Monitoring this can help you identify when you are hitting this limits, which could signal that adjustments need to be made either in
        the process design or in the service limits themselves.

        :default: 5
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineExecutionThrottledAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SfStateMachineExecutionTimeAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionTimeAlarm",
):
    '''This metric can be a valuable tool for early detection of issues that might not be immediately apparent from other metrics.

    A sudden increase in execution time might indicate issues with the steps of the resources they interact with.

    The alarm is triggered when the time in milliseconds exceed the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param state_machine: The StateMachine to monitor.
        :param threshold: A sudden increase in execution time might indicate issues with the steps of the resources they interact with. Consider setting a threshold (in milliseconds) that is appropriate for the expected execution time of the state machine. Default: None
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect sudden increases in execution time..
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionTime'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a652ae052d92cbe7924f6027b90b48e50ac071e422565f8a2eff174dda835bfc)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SfStateMachineExecutionTimeAlarmProps(
            state_machine=state_machine,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionTimeAlarmConfig",
    jsii_struct_bases=[SfAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class SfStateMachineExecutionTimeAlarmConfig(SfAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the ExecutionTime alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: A sudden increase in execution time might indicate issues with the steps of the resources they interact with. Consider setting a threshold (in milliseconds) that is appropriate for the expected execution time of the state machine. Default: None
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect sudden increases in execution time..
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionTime'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d7e6887e76506d2e1ae1b27c62735f92c991fdfe14a5a89b268235047486a629)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''A sudden increase in execution time might indicate issues with the steps of the resources they interact with.

        Consider setting a threshold (in milliseconds) that is appropriate for the expected execution time of the state machine.

        :default: None
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect sudden increases in execution time..
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - stateMachineName + ' - ExecutionTime'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineExecutionTimeAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionTimeAlarmProps",
    jsii_struct_bases=[
        SfStateMachineAlarmProps, SfStateMachineExecutionTimeAlarmConfig
    ],
    name_mapping={
        "state_machine": "stateMachine",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class SfStateMachineExecutionTimeAlarmProps(
    SfStateMachineAlarmProps,
    SfStateMachineExecutionTimeAlarmConfig,
):
    def __init__(
        self,
        *,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the SfStateMachineExecutionTimeAlarm construct.

        :param state_machine: The StateMachine to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: A sudden increase in execution time might indicate issues with the steps of the resources they interact with. Consider setting a threshold (in milliseconds) that is appropriate for the expected execution time of the state machine. Default: None
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect sudden increases in execution time..
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionTime'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5437a5ddf7659c1b09f607e81ecdee898e68f8e9dd98dd250720df4b2b59c26b)
            check_type(argname="argument state_machine", value=state_machine, expected_type=type_hints["state_machine"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "state_machine": state_machine,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def state_machine(self) -> _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine:
        '''The StateMachine to monitor.'''
        result = self._values.get("state_machine")
        assert result is not None, "Required property 'state_machine' is missing"
        return typing.cast(_aws_cdk_aws_stepfunctions_ceddda9d.StateMachine, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''A sudden increase in execution time might indicate issues with the steps of the resources they interact with.

        Consider setting a threshold (in milliseconds) that is appropriate for the expected execution time of the state machine.

        :default: None
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect sudden increases in execution time..
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - stateMachineName + ' - ExecutionTime'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineExecutionTimeAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SfStateMachineExecutionsFailedAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionsFailedAlarm",
):
    '''It helps in tracking the number of executions that fail in AWS Step Functions.

    This is crucial for identifying workflows that are
    not performing as expected and require attention.

    By monitoring the failures, developers can proactively identify and resolve issues before they impact the business operations. This reduces
    downtime and improves the overall stability of applications.

    The alarm is triggered when the number of failed executions exceed the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param state_machine: The StateMachine to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect workflows that are not working as expected.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionsFailed'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: It helps in tracking the number of executions that fail in AWS Step Functions. This is crucial for identifying workflows that are not performing as expected and require attention. By monitoring the failures, developers can proactively identify and resolve issues before they impact the business operations. This reduces downtime and improves the overall stability of applications. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1af9afc85387ad2935d64783fa5c57721a579e9f10cee2f18d60afca6ca528e1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SfStateMachineExecutionsFailedAlarmProps(
            state_machine=state_machine,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionsFailedAlarmConfig",
    jsii_struct_bases=[SfAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class SfStateMachineExecutionsFailedAlarmConfig(SfAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the ExecutionsFailed alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect workflows that are not working as expected.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionsFailed'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: It helps in tracking the number of executions that fail in AWS Step Functions. This is crucial for identifying workflows that are not performing as expected and require attention. By monitoring the failures, developers can proactively identify and resolve issues before they impact the business operations. This reduces downtime and improves the overall stability of applications. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b9efbac082d2a3142fab08e7a993d5edcf25ace3d060d909292aaab0f702350a)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect workflows that are not working as expected.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - stateMachineName + ' - ExecutionsFailed'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''It helps in tracking the number of executions that fail in AWS Step Functions.

        This is crucial for identifying workflows that are
        not performing as expected and require attention. By monitoring the failures, developers can proactively identify and resolve issues
        before they impact the business operations. This reduces downtime and improves the overall stability of applications.

        :default: 5
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineExecutionsFailedAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionsFailedAlarmProps",
    jsii_struct_bases=[
        SfStateMachineAlarmProps, SfStateMachineExecutionsFailedAlarmConfig
    ],
    name_mapping={
        "state_machine": "stateMachine",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class SfStateMachineExecutionsFailedAlarmProps(
    SfStateMachineAlarmProps,
    SfStateMachineExecutionsFailedAlarmConfig,
):
    def __init__(
        self,
        *,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the SfStateMachineExecutionsFailedAlarm construct.

        :param state_machine: The StateMachine to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect workflows that are not working as expected.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionsFailed'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: It helps in tracking the number of executions that fail in AWS Step Functions. This is crucial for identifying workflows that are not performing as expected and require attention. By monitoring the failures, developers can proactively identify and resolve issues before they impact the business operations. This reduces downtime and improves the overall stability of applications. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__31982ff8d0e7df03482d17124a30d0a709178d1bbc6dd3402a61c4511d04627a)
            check_type(argname="argument state_machine", value=state_machine, expected_type=type_hints["state_machine"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "state_machine": state_machine,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def state_machine(self) -> _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine:
        '''The StateMachine to monitor.'''
        result = self._values.get("state_machine")
        assert result is not None, "Required property 'state_machine' is missing"
        return typing.cast(_aws_cdk_aws_stepfunctions_ceddda9d.StateMachine, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect workflows that are not working as expected.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - stateMachineName + ' - ExecutionsFailed'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''It helps in tracking the number of executions that fail in AWS Step Functions.

        This is crucial for identifying workflows that are
        not performing as expected and require attention. By monitoring the failures, developers can proactively identify and resolve issues
        before they impact the business operations. This reduces downtime and improves the overall stability of applications.

        :default: 5
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineExecutionsFailedAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SfStateMachineExecutionsTimedOutAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionsTimedOutAlarm",
):
    '''This alarm helps in identifying timeouts in state machine executions.

    This can indicate problems like poor configuration, inadequate resource allocation, or issues in the called services that need addressing.

    The alarm is triggered when the number of timed out executions exceed the threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param state_machine: The StateMachine to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm helps in identifying timeouts in state machine executions due to poor configuration, inadequate resource allocation, or issues in the called services that need addressing.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionsTimedOut'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: It helps in identifying timeouts in state machine executions, which can indicate problems like poor configuration, inadequate resource allocation, or issues in the called services that need addressing. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d8d47b36874bc2b7376685c830b8e3686f3e26a1afaff2ec7ea31e6622ad3f20)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SfStateMachineExecutionsTimedOutAlarmProps(
            state_machine=state_machine,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionsTimedOutAlarmConfig",
    jsii_struct_bases=[SfAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class SfStateMachineExecutionsTimedOutAlarmConfig(SfAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the ExecutionsTimedOut alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps in identifying timeouts in state machine executions due to poor configuration, inadequate resource allocation, or issues in the called services that need addressing.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionsTimedOut'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: It helps in identifying timeouts in state machine executions, which can indicate problems like poor configuration, inadequate resource allocation, or issues in the called services that need addressing. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__79f04417113dfb22c780aac29b056cada8488e5b8493523829d046b9f9130540)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps in identifying timeouts in state machine executions due to poor configuration, inadequate resource allocation,
        or issues in the called services that need addressing.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - stateMachineName + ' - ExecutionsTimedOut'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''It helps in identifying timeouts in state machine executions, which can indicate problems like poor configuration, inadequate resource allocation, or issues in the called services that need addressing.

        :default: 5
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineExecutionsTimedOutAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineExecutionsTimedOutAlarmProps",
    jsii_struct_bases=[
        SfStateMachineAlarmProps, SfStateMachineExecutionsTimedOutAlarmConfig
    ],
    name_mapping={
        "state_machine": "stateMachine",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class SfStateMachineExecutionsTimedOutAlarmProps(
    SfStateMachineAlarmProps,
    SfStateMachineExecutionsTimedOutAlarmConfig,
):
    def __init__(
        self,
        *,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the SfStateMachineExecutionsTimedOutAlarm construct.

        :param state_machine: The StateMachine to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps in identifying timeouts in state machine executions due to poor configuration, inadequate resource allocation, or issues in the called services that need addressing.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionsTimedOut'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: It helps in identifying timeouts in state machine executions, which can indicate problems like poor configuration, inadequate resource allocation, or issues in the called services that need addressing. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6bbc428c0299ecc897c8b6489e065900bca83c57a93f531af2218b73ae10f05a)
            check_type(argname="argument state_machine", value=state_machine, expected_type=type_hints["state_machine"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "state_machine": state_machine,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def state_machine(self) -> _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine:
        '''The StateMachine to monitor.'''
        result = self._values.get("state_machine")
        assert result is not None, "Required property 'state_machine' is missing"
        return typing.cast(_aws_cdk_aws_stepfunctions_ceddda9d.StateMachine, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps in identifying timeouts in state machine executions due to poor configuration, inadequate resource allocation,
        or issues in the called services that need addressing.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - stateMachineName + ' - ExecutionsTimedOut'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''It helps in identifying timeouts in state machine executions, which can indicate problems like poor configuration, inadequate resource allocation, or issues in the called services that need addressing.

        :default: 5
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineExecutionsTimedOutAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SfStateMachineRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an StepFunctions StateMachine.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
        config_execution_time_alarm: typing.Union[SfStateMachineExecutionTimeAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_executions_failed_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_executions_timed_out_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsTimedOutAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_execution_throttled_alarm: typing.Optional[typing.Union[SfStateMachineExecutionThrottledAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[SfRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param state_machine: The EFS StateMachine to monitor.
        :param config_execution_time_alarm: The configuration for the ExecutionTime alarm.
        :param config_executions_failed_alarm: The configuration for the ExecutionsFailed alarm.
        :param config_executions_timed_out_alarm: The configuration for the ExecutionsFailed alarm.
        :param config_execution_throttled_alarm: The configuration for the ExecutionThrottled alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__97367f27f00e0f166d219763a3d0150535c031767ba0c63659dc61e3d8c388f7)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SfStateMachineRecommendedAlarmsProps(
            state_machine=state_machine,
            config_execution_time_alarm=config_execution_time_alarm,
            config_executions_failed_alarm=config_executions_failed_alarm,
            config_executions_timed_out_alarm=config_executions_timed_out_alarm,
            config_execution_throttled_alarm=config_execution_throttled_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmExecutionsFailed")
    def alarm_executions_failed(
        self,
    ) -> typing.Optional[SfStateMachineExecutionsFailedAlarm]:
        '''The ExecutionsFailed alarm.'''
        return typing.cast(typing.Optional[SfStateMachineExecutionsFailedAlarm], jsii.get(self, "alarmExecutionsFailed"))

    @builtins.property
    @jsii.member(jsii_name="alarmExecutionsTimedOut")
    def alarm_executions_timed_out(
        self,
    ) -> typing.Optional[SfStateMachineExecutionsTimedOutAlarm]:
        '''The ExecutionsTimedOut alarm.'''
        return typing.cast(typing.Optional[SfStateMachineExecutionsTimedOutAlarm], jsii.get(self, "alarmExecutionsTimedOut"))

    @builtins.property
    @jsii.member(jsii_name="alarmExecutionThrottled")
    def alarm_execution_throttled(
        self,
    ) -> typing.Optional[SfStateMachineExecutionThrottledAlarm]:
        '''The ExecutionThrottled alarm.'''
        return typing.cast(typing.Optional[SfStateMachineExecutionThrottledAlarm], jsii.get(self, "alarmExecutionThrottled"))

    @builtins.property
    @jsii.member(jsii_name="alarmExecutionTime")
    def alarm_execution_time(self) -> typing.Optional[SfStateMachineExecutionTimeAlarm]:
        '''The ExecutionTime alarm.'''
        return typing.cast(typing.Optional[SfStateMachineExecutionTimeAlarm], jsii.get(self, "alarmExecutionTime"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_execution_time_alarm": "configExecutionTimeAlarm",
        "config_executions_failed_alarm": "configExecutionsFailedAlarm",
        "config_executions_timed_out_alarm": "configExecutionsTimedOutAlarm",
        "config_execution_throttled_alarm": "configExecutionThrottledAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class SfStateMachineRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_execution_time_alarm: typing.Union[SfStateMachineExecutionTimeAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_executions_failed_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_executions_timed_out_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsTimedOutAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_execution_throttled_alarm: typing.Optional[typing.Union[SfStateMachineExecutionThrottledAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[SfRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an StepFunctions Service.

        Default actions are overridden by the actions specified in the individual alarm configurations.

        :param config_execution_time_alarm: The configuration for the ExecutionTime alarm.
        :param config_executions_failed_alarm: The configuration for the ExecutionsFailed alarm.
        :param config_executions_timed_out_alarm: The configuration for the ExecutionsFailed alarm.
        :param config_execution_throttled_alarm: The configuration for the ExecutionThrottled alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_execution_time_alarm, dict):
            config_execution_time_alarm = SfStateMachineExecutionTimeAlarmConfig(**config_execution_time_alarm)
        if isinstance(config_executions_failed_alarm, dict):
            config_executions_failed_alarm = SfStateMachineExecutionsFailedAlarmConfig(**config_executions_failed_alarm)
        if isinstance(config_executions_timed_out_alarm, dict):
            config_executions_timed_out_alarm = SfStateMachineExecutionsTimedOutAlarmConfig(**config_executions_timed_out_alarm)
        if isinstance(config_execution_throttled_alarm, dict):
            config_execution_throttled_alarm = SfStateMachineExecutionThrottledAlarmConfig(**config_execution_throttled_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__cb25226c50759f4912961a3b998f0ee4cd7dabcd4d06e309c224c60db85ade46)
            check_type(argname="argument config_execution_time_alarm", value=config_execution_time_alarm, expected_type=type_hints["config_execution_time_alarm"])
            check_type(argname="argument config_executions_failed_alarm", value=config_executions_failed_alarm, expected_type=type_hints["config_executions_failed_alarm"])
            check_type(argname="argument config_executions_timed_out_alarm", value=config_executions_timed_out_alarm, expected_type=type_hints["config_executions_timed_out_alarm"])
            check_type(argname="argument config_execution_throttled_alarm", value=config_execution_throttled_alarm, expected_type=type_hints["config_execution_throttled_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_execution_time_alarm": config_execution_time_alarm,
        }
        if config_executions_failed_alarm is not None:
            self._values["config_executions_failed_alarm"] = config_executions_failed_alarm
        if config_executions_timed_out_alarm is not None:
            self._values["config_executions_timed_out_alarm"] = config_executions_timed_out_alarm
        if config_execution_throttled_alarm is not None:
            self._values["config_execution_throttled_alarm"] = config_execution_throttled_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_execution_time_alarm(self) -> SfStateMachineExecutionTimeAlarmConfig:
        '''The configuration for the ExecutionTime alarm.'''
        result = self._values.get("config_execution_time_alarm")
        assert result is not None, "Required property 'config_execution_time_alarm' is missing"
        return typing.cast(SfStateMachineExecutionTimeAlarmConfig, result)

    @builtins.property
    def config_executions_failed_alarm(
        self,
    ) -> typing.Optional[SfStateMachineExecutionsFailedAlarmConfig]:
        '''The configuration for the ExecutionsFailed alarm.'''
        result = self._values.get("config_executions_failed_alarm")
        return typing.cast(typing.Optional[SfStateMachineExecutionsFailedAlarmConfig], result)

    @builtins.property
    def config_executions_timed_out_alarm(
        self,
    ) -> typing.Optional[SfStateMachineExecutionsTimedOutAlarmConfig]:
        '''The configuration for the ExecutionsFailed alarm.'''
        result = self._values.get("config_executions_timed_out_alarm")
        return typing.cast(typing.Optional[SfStateMachineExecutionsTimedOutAlarmConfig], result)

    @builtins.property
    def config_execution_throttled_alarm(
        self,
    ) -> typing.Optional[SfStateMachineExecutionThrottledAlarmConfig]:
        '''The configuration for the ExecutionThrottled alarm.'''
        result = self._values.get("config_execution_throttled_alarm")
        return typing.cast(typing.Optional[SfStateMachineExecutionThrottledAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[SfRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[SfRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SfStateMachineRecommendedAlarmsProps",
    jsii_struct_bases=[SfStateMachineRecommendedAlarmsConfig],
    name_mapping={
        "config_execution_time_alarm": "configExecutionTimeAlarm",
        "config_executions_failed_alarm": "configExecutionsFailedAlarm",
        "config_executions_timed_out_alarm": "configExecutionsTimedOutAlarm",
        "config_execution_throttled_alarm": "configExecutionThrottledAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "state_machine": "stateMachine",
    },
)
class SfStateMachineRecommendedAlarmsProps(SfStateMachineRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config_execution_time_alarm: typing.Union[SfStateMachineExecutionTimeAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_executions_failed_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_executions_timed_out_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsTimedOutAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_execution_throttled_alarm: typing.Optional[typing.Union[SfStateMachineExecutionThrottledAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[SfRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    ) -> None:
        '''Properties for the SfStateMachineRecommendedAlarms construct.

        :param config_execution_time_alarm: The configuration for the ExecutionTime alarm.
        :param config_executions_failed_alarm: The configuration for the ExecutionsFailed alarm.
        :param config_executions_timed_out_alarm: The configuration for the ExecutionsFailed alarm.
        :param config_execution_throttled_alarm: The configuration for the ExecutionThrottled alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param state_machine: The EFS StateMachine to monitor.
        '''
        if isinstance(config_execution_time_alarm, dict):
            config_execution_time_alarm = SfStateMachineExecutionTimeAlarmConfig(**config_execution_time_alarm)
        if isinstance(config_executions_failed_alarm, dict):
            config_executions_failed_alarm = SfStateMachineExecutionsFailedAlarmConfig(**config_executions_failed_alarm)
        if isinstance(config_executions_timed_out_alarm, dict):
            config_executions_timed_out_alarm = SfStateMachineExecutionsTimedOutAlarmConfig(**config_executions_timed_out_alarm)
        if isinstance(config_execution_throttled_alarm, dict):
            config_execution_throttled_alarm = SfStateMachineExecutionThrottledAlarmConfig(**config_execution_throttled_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7b95545985abdc365dd9deea0270b2fe0cf5210d9f06afa71915911c20831f99)
            check_type(argname="argument config_execution_time_alarm", value=config_execution_time_alarm, expected_type=type_hints["config_execution_time_alarm"])
            check_type(argname="argument config_executions_failed_alarm", value=config_executions_failed_alarm, expected_type=type_hints["config_executions_failed_alarm"])
            check_type(argname="argument config_executions_timed_out_alarm", value=config_executions_timed_out_alarm, expected_type=type_hints["config_executions_timed_out_alarm"])
            check_type(argname="argument config_execution_throttled_alarm", value=config_execution_throttled_alarm, expected_type=type_hints["config_execution_throttled_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument state_machine", value=state_machine, expected_type=type_hints["state_machine"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_execution_time_alarm": config_execution_time_alarm,
            "state_machine": state_machine,
        }
        if config_executions_failed_alarm is not None:
            self._values["config_executions_failed_alarm"] = config_executions_failed_alarm
        if config_executions_timed_out_alarm is not None:
            self._values["config_executions_timed_out_alarm"] = config_executions_timed_out_alarm
        if config_execution_throttled_alarm is not None:
            self._values["config_execution_throttled_alarm"] = config_execution_throttled_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_execution_time_alarm(self) -> SfStateMachineExecutionTimeAlarmConfig:
        '''The configuration for the ExecutionTime alarm.'''
        result = self._values.get("config_execution_time_alarm")
        assert result is not None, "Required property 'config_execution_time_alarm' is missing"
        return typing.cast(SfStateMachineExecutionTimeAlarmConfig, result)

    @builtins.property
    def config_executions_failed_alarm(
        self,
    ) -> typing.Optional[SfStateMachineExecutionsFailedAlarmConfig]:
        '''The configuration for the ExecutionsFailed alarm.'''
        result = self._values.get("config_executions_failed_alarm")
        return typing.cast(typing.Optional[SfStateMachineExecutionsFailedAlarmConfig], result)

    @builtins.property
    def config_executions_timed_out_alarm(
        self,
    ) -> typing.Optional[SfStateMachineExecutionsTimedOutAlarmConfig]:
        '''The configuration for the ExecutionsFailed alarm.'''
        result = self._values.get("config_executions_timed_out_alarm")
        return typing.cast(typing.Optional[SfStateMachineExecutionsTimedOutAlarmConfig], result)

    @builtins.property
    def config_execution_throttled_alarm(
        self,
    ) -> typing.Optional[SfStateMachineExecutionThrottledAlarmConfig]:
        '''The configuration for the ExecutionThrottled alarm.'''
        result = self._values.get("config_execution_throttled_alarm")
        return typing.cast(typing.Optional[SfStateMachineExecutionThrottledAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[SfRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[SfRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def state_machine(self) -> _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine:
        '''The EFS StateMachine to monitor.'''
        result = self._values.get("state_machine")
        assert result is not None, "Required property 'state_machine' is missing"
        return typing.cast(_aws_cdk_aws_stepfunctions_ceddda9d.StateMachine, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SfStateMachineRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
    },
)
class SnsAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6357da9f37e3e6b457ad09023bb9b95a1d5a38c2f284fa206c1d1d7696f94317)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsNumberOfMessagesPublishedAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfMessagesPublishedAlarm",
):
    '''An alarm that monitors the number of messages published to an SNS topic.

    This alarm helps you proactively monitor and detect significant drops in
    notification publishing. This helps you identify potential issues with
    your application or business processes, so that you can take appropriate
    actions to maintain the expected flow of notifications. You should create
    this alarm if you expect your system to have a minimum traffic that it
    is serving.

    The alarm is triggered when the number of messages published to the topic
    is less than the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param topic: The SNS topic for which to create the alarm.
        :param threshold: The value against which the specified statistic is compared. The number of messages published should be in line with the expected number of published messages for your application. You can also analyze the historical data, trends and traffic to find the right threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of SNS messages published is too low. For troubleshooting, check why the publishers are sending less traffic.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfMessagesPublished'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98752834db6066573e1bc3fdef96ce5810035499b582fbd50205da8ca10e443a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SnsNumberOfMessagesPublishedAlarmProps(
            topic=topic,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfMessagesPublishedAlarmConfig",
    jsii_struct_bases=[SnsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
    },
)
class SnsNumberOfMessagesPublishedAlarmConfig(SnsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the NumberOfMessagesPublished alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The number of messages published should be in line with the expected number of published messages for your application. You can also analyze the historical data, trends and traffic to find the right threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of SNS messages published is too low. For troubleshooting, check why the publishers are sending less traffic.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfMessagesPublished'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__02d28bbf6430187b0f9eb1fb025b748f1a32141c7c491a091b9c54a910e6b18e)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The number of messages published should be in line with the expected number of
        published messages for your application. You can also analyze the historical data,
        trends and traffic to find the right threshold.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect when the number of SNS messages published is too low.
        For troubleshooting, check why the publishers are sending less traffic.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfMessagesPublished'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfMessagesPublishedAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfMessagesPublishedAlarmProps",
    jsii_struct_bases=[SnsNumberOfMessagesPublishedAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "topic": "topic",
    },
)
class SnsNumberOfMessagesPublishedAlarmProps(SnsNumberOfMessagesPublishedAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    ) -> None:
        '''Properties for the SnsNumberOfMessagesPublishedAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The number of messages published should be in line with the expected number of published messages for your application. You can also analyze the historical data, trends and traffic to find the right threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of SNS messages published is too low. For troubleshooting, check why the publishers are sending less traffic.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfMessagesPublished'
        :param topic: The SNS topic for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fff028ea41836c29985adfc761cb4e4d9d91324dab443383b2985d7174500a19)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
            "topic": topic,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The number of messages published should be in line with the expected number of
        published messages for your application. You can also analyze the historical data,
        trends and traffic to find the right threshold.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect when the number of SNS messages published is too low.
        For troubleshooting, check why the publishers are sending less traffic.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfMessagesPublished'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def topic(self) -> _aws_cdk_aws_sns_ceddda9d.ITopic:
        '''The SNS topic for which to create the alarm.'''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(_aws_cdk_aws_sns_ceddda9d.ITopic, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfMessagesPublishedAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsNumberOfNotificationsDeliveredAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsDeliveredAlarm",
):
    '''An alarm that monitors the number of notifications delivered by an SNS topic.

    This alarm helps you detect a drop in the volume of messages delivered.
    You should create this alarm if you expect your system to have a
    minimum traffic that it is serving.

    The alarm is triggered when the number of messages delivered by the topic
    is less than the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param topic: The SNS topic for which to create the alarm.
        :param threshold: The value against which the specified statistic is compared. The number of messages delivered should be in line with the expected number of messages produced and the number of consumers. You can also analyze the historical data, trends and traffic to find the right threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of SNS messages delivered is too low. This could be because of unintentional unsubscribing of an endpoint, or because of an SNS event that causes messages to experience delay.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsDelivered'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6373f947a105537f03e197d13ae190cc1b538074b51e0b7eccd8b7956fedc0f3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SnsNumberOfNotificationsDeliveredAlarmProps(
            topic=topic,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsDeliveredAlarmConfig",
    jsii_struct_bases=[SnsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
    },
)
class SnsNumberOfNotificationsDeliveredAlarmConfig(SnsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the NumberOfNotificationsDelivered alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The number of messages delivered should be in line with the expected number of messages produced and the number of consumers. You can also analyze the historical data, trends and traffic to find the right threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of SNS messages delivered is too low. This could be because of unintentional unsubscribing of an endpoint, or because of an SNS event that causes messages to experience delay.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsDelivered'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b868a50184ae2ac664cf01403a36fff774472e3686b89e5367994e98b89b7193)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The number of messages delivered should be in line with the expected number of
        messages produced and the number of consumers. You can also analyze the historical
        data, trends and traffic to find the right threshold.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect when the number of SNS messages delivered is too low.
        This could be because of unintentional unsubscribing of an endpoint, or because of
        an SNS event that causes messages to experience delay.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsDelivered'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsDeliveredAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsDeliveredAlarmProps",
    jsii_struct_bases=[SnsNumberOfNotificationsDeliveredAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "topic": "topic",
    },
)
class SnsNumberOfNotificationsDeliveredAlarmProps(
    SnsNumberOfNotificationsDeliveredAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    ) -> None:
        '''Properties for the SnsNumberOfNotificationsDeliveredAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The number of messages delivered should be in line with the expected number of messages produced and the number of consumers. You can also analyze the historical data, trends and traffic to find the right threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of SNS messages delivered is too low. This could be because of unintentional unsubscribing of an endpoint, or because of an SNS event that causes messages to experience delay.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsDelivered'
        :param topic: The SNS topic for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f42d7a4b791067bced9bc860e1f750a1ceba252cff97a6f74fd0c6a844a539e)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
            "topic": topic,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The number of messages delivered should be in line with the expected number of
        messages produced and the number of consumers. You can also analyze the historical
        data, trends and traffic to find the right threshold.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect when the number of SNS messages delivered is too low.
        This could be because of unintentional unsubscribing of an endpoint, or because of
        an SNS event that causes messages to experience delay.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsDelivered'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def topic(self) -> _aws_cdk_aws_sns_ceddda9d.ITopic:
        '''The SNS topic for which to create the alarm.'''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(_aws_cdk_aws_sns_ceddda9d.ITopic, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsDeliveredAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsNumberOfNotificationsFailedAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFailedAlarm",
):
    '''An alarm that monitors the number of notifications failed by an SNS topic.

    This alarm helps you proactively find issues with the delivery of notifications
    and take appropriate actions to address them.

    The alarm is triggered when the number of messages failed by the topic
    is greater than the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param topic: The SNS topic for which to create the alarm.
        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the impact of failed notifications. Review the SLAs provided to your end users, fault tolerance and criticality of notifications and analyze historical data, and then select a threshold accordingly. The number of notifications failed should be 0 for topics that have only SQS, Lambda or Firehose subscriptions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of failed SNS messages is too high. To troubleshoot failed notifications, enable logging to CloudWatch Logs. Checking the logs can help you find which subscribers are failing, as well as the status codes they are returning.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFailed'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__170e0b0914195c00ff510974ac188dcdce904364b454920cfa694a9c41aea277)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SnsNumberOfNotificationsFailedAlarmProps(
            topic=topic,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFailedAlarmConfig",
    jsii_struct_bases=[SnsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
    },
)
class SnsNumberOfNotificationsFailedAlarmConfig(SnsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the NumberOfNotificationsFailed alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the impact of failed notifications. Review the SLAs provided to your end users, fault tolerance and criticality of notifications and analyze historical data, and then select a threshold accordingly. The number of notifications failed should be 0 for topics that have only SQS, Lambda or Firehose subscriptions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of failed SNS messages is too high. To troubleshoot failed notifications, enable logging to CloudWatch Logs. Checking the logs can help you find which subscribers are failing, as well as the status codes they are returning.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFailed'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__49e12faa9093bf4d0205ccf60bc9d460839db4afed6958548942f1f348123faa)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The recommended threshold value for this alarm is highly dependent on the
        impact of failed notifications. Review the SLAs provided to your end users,
        fault tolerance and criticality of notifications and analyze historical data,
        and then select a threshold accordingly. The number of notifications failed
        should be 0 for topics that have only SQS, Lambda or Firehose subscriptions.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect when the number of failed SNS messages is too high.
        To troubleshoot failed notifications, enable logging to CloudWatch Logs. Checking
        the logs can help you find which subscribers are failing, as well as the status
        codes they are returning.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsFailed'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsFailedAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFailedAlarmProps",
    jsii_struct_bases=[SnsNumberOfNotificationsFailedAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "topic": "topic",
    },
)
class SnsNumberOfNotificationsFailedAlarmProps(
    SnsNumberOfNotificationsFailedAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    ) -> None:
        '''Properties for the SnsNumberOfNotificationsFailedAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the impact of failed notifications. Review the SLAs provided to your end users, fault tolerance and criticality of notifications and analyze historical data, and then select a threshold accordingly. The number of notifications failed should be 0 for topics that have only SQS, Lambda or Firehose subscriptions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of failed SNS messages is too high. To troubleshoot failed notifications, enable logging to CloudWatch Logs. Checking the logs can help you find which subscribers are failing, as well as the status codes they are returning.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFailed'
        :param topic: The SNS topic for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__892a2b84330c3cd2ff63a79b19f87b73eb88ccfb60ed575de749f562223b34f0)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
            "topic": topic,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The recommended threshold value for this alarm is highly dependent on the
        impact of failed notifications. Review the SLAs provided to your end users,
        fault tolerance and criticality of notifications and analyze historical data,
        and then select a threshold accordingly. The number of notifications failed
        should be 0 for topics that have only SQS, Lambda or Firehose subscriptions.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect when the number of failed SNS messages is too high.
        To troubleshoot failed notifications, enable logging to CloudWatch Logs. Checking
        the logs can help you find which subscribers are failing, as well as the status
        codes they are returning.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsFailed'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def topic(self) -> _aws_cdk_aws_sns_ceddda9d.ITopic:
        '''The SNS topic for which to create the alarm.'''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(_aws_cdk_aws_sns_ceddda9d.ITopic, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsFailedAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsNumberOfNotificationsFailedToRedriveToDlqAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFailedToRedriveToDlqAlarm",
):
    '''An alarm that monitors the number of notifications failed to redrive to the dead-letter queue.

    The alarm is used to detect messages that couldn't be moved to a dead-letter
    queue.

    The alarm is triggered when the number of messages failed to redrive to the
    dead-letter queue is greater than the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param topic: The SNS topic for which to create the alarm.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor messages that couldn't be moved to a dead-letter queue. Check whether your dead-letter queue exists and that it's configured correctly. Also, verify that SNS has permissions to access the dead-letter queue. Refer to the dead-letter queue documentation (https://docs.aws.amazon.com/sns/latest/dg/sns-dead-letter-queues.html) to learn more.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFailedToRedriveToDlq'
        :param threshold: The value against which the specified statistic is compared. It's almost always a mistake if messages can't be moved to the dead-letter queue. The recommendation for the threshold is 0, meaning all messages that fail processing must be able to reach the dead-letter queue when the queue has been configured. Default: 0
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__328952b7f137facf3708a3106b8d39dc7959798db5ba6df8bb7ee4ef4e058cfb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SnsNumberOfNotificationsFailedToRedriveToDlqAlarmProps(
            topic=topic,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            threshold=threshold,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig",
    jsii_struct_bases=[SnsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "threshold": "threshold",
    },
)
class SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig(SnsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the NumberOfNotificationsFailedToRedriveToDlq alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor messages that couldn't be moved to a dead-letter queue. Check whether your dead-letter queue exists and that it's configured correctly. Also, verify that SNS has permissions to access the dead-letter queue. Refer to the dead-letter queue documentation (https://docs.aws.amazon.com/sns/latest/dg/sns-dead-letter-queues.html) to learn more.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFailedToRedriveToDlq'
        :param threshold: The value against which the specified statistic is compared. It's almost always a mistake if messages can't be moved to the dead-letter queue. The recommendation for the threshold is 0, meaning all messages that fail processing must be able to reach the dead-letter queue when the queue has been configured. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__843a4ee9894a844d5695f53e1c878efbf75b200de41a577d4f371b236240f2e8)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to monitor messages that couldn't be moved to a dead-letter
        queue. Check whether your dead-letter queue exists and that it's configured correctly.
        Also, verify that SNS has permissions to access the dead-letter queue. Refer to the
        dead-letter queue documentation (https://docs.aws.amazon.com/sns/latest/dg/sns-dead-letter-queues.html)
        to learn more.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsFailedToRedriveToDlq'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        It's almost always a mistake if messages can't be moved to the dead-letter queue.
        The recommendation for the threshold is 0, meaning all messages that fail processing
        must be able to reach the dead-letter queue when the queue has been configured.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFailedToRedriveToDlqAlarmProps",
    jsii_struct_bases=[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "threshold": "threshold",
        "topic": "topic",
    },
)
class SnsNumberOfNotificationsFailedToRedriveToDlqAlarmProps(
    SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    ) -> None:
        '''Properties for the SnsNumberOfNotificationsFailedToRedriveToDlqAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor messages that couldn't be moved to a dead-letter queue. Check whether your dead-letter queue exists and that it's configured correctly. Also, verify that SNS has permissions to access the dead-letter queue. Refer to the dead-letter queue documentation (https://docs.aws.amazon.com/sns/latest/dg/sns-dead-letter-queues.html) to learn more.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFailedToRedriveToDlq'
        :param threshold: The value against which the specified statistic is compared. It's almost always a mistake if messages can't be moved to the dead-letter queue. The recommendation for the threshold is 0, meaning all messages that fail processing must be able to reach the dead-letter queue when the queue has been configured. Default: 0
        :param topic: The SNS topic for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d3739e80c1d6309d7906dad7d9e84785a3a83e15921d956349e5a35ee350151b)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topic": topic,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to monitor messages that couldn't be moved to a dead-letter
        queue. Check whether your dead-letter queue exists and that it's configured correctly.
        Also, verify that SNS has permissions to access the dead-letter queue. Refer to the
        dead-letter queue documentation (https://docs.aws.amazon.com/sns/latest/dg/sns-dead-letter-queues.html)
        to learn more.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsFailedToRedriveToDlq'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        It's almost always a mistake if messages can't be moved to the dead-letter queue.
        The recommendation for the threshold is 0, meaning all messages that fail processing
        must be able to reach the dead-letter queue when the queue has been configured.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def topic(self) -> _aws_cdk_aws_sns_ceddda9d.ITopic:
        '''The SNS topic for which to create the alarm.'''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(_aws_cdk_aws_sns_ceddda9d.ITopic, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsFailedToRedriveToDlqAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarm",
):
    '''An alarm that monitors the number of notifications filtered out due to invalid attributes.

    The alarm is used to detect if the published messages are not valid or
    if inappropriate filters have been applied to a subscriber.

    The alarm is triggered when the number of messages filtered out due to
    invalid attributes is greater than the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param topic: The SNS topic for which to create the alarm.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor and resolve potential problems with the publisher or subscribers. Check if a publisher is publishing messages with invalid attributes or if an inappropriate filter is applied to a subscriber. You can also analyze CloudWatch Logs to help find the root cause of the issue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidAttributes'
        :param threshold: The value against which the specified statistic is compared. Invalid attributes are almost always a mistake by the publisher. We recommend to set the threshold to 0 because invalid attributes are not expected in a healthy system. Default: 0
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43139b7affdf7f55134351c485459ce357015c4e7c697ae842d1c8d514b65565)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmProps(
            topic=topic,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            threshold=threshold,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig",
    jsii_struct_bases=[SnsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "threshold": "threshold",
    },
)
class SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig(
    SnsAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the NumberOfNotificationsFilteredOutInvalidAttributes alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor and resolve potential problems with the publisher or subscribers. Check if a publisher is publishing messages with invalid attributes or if an inappropriate filter is applied to a subscriber. You can also analyze CloudWatch Logs to help find the root cause of the issue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidAttributes'
        :param threshold: The value against which the specified statistic is compared. Invalid attributes are almost always a mistake by the publisher. We recommend to set the threshold to 0 because invalid attributes are not expected in a healthy system. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ec0121c20b9a0c13a285aa11cf4f02cfa52f0fa656d8e6a0359dce149cf04fcf)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to monitor and resolve potential problems with the publisher or subscribers.
        Check if a publisher is publishing messages with invalid attributes or if an inappropriate filter is
        applied to a subscriber. You can also analyze CloudWatch Logs to help find the root cause of the issue.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidAttributes'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        Invalid attributes are almost always a mistake by the publisher. We recommend
        to set the threshold to 0 because invalid attributes are not expected in a
        healthy system.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmProps",
    jsii_struct_bases=[
        SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig
    ],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "threshold": "threshold",
        "topic": "topic",
    },
)
class SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmProps(
    SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    ) -> None:
        '''Properties for the SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor and resolve potential problems with the publisher or subscribers. Check if a publisher is publishing messages with invalid attributes or if an inappropriate filter is applied to a subscriber. You can also analyze CloudWatch Logs to help find the root cause of the issue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidAttributes'
        :param threshold: The value against which the specified statistic is compared. Invalid attributes are almost always a mistake by the publisher. We recommend to set the threshold to 0 because invalid attributes are not expected in a healthy system. Default: 0
        :param topic: The SNS topic for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__75001c0fbc3b728c4c377f661f9af34f7b2005073f8201f295eda55eecf79ff2)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topic": topic,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to monitor and resolve potential problems with the publisher or subscribers.
        Check if a publisher is publishing messages with invalid attributes or if an inappropriate filter is
        applied to a subscriber. You can also analyze CloudWatch Logs to help find the root cause of the issue.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidAttributes'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        Invalid attributes are almost always a mistake by the publisher. We recommend
        to set the threshold to 0 because invalid attributes are not expected in a
        healthy system.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def topic(self) -> _aws_cdk_aws_sns_ceddda9d.ITopic:
        '''The SNS topic for which to create the alarm.'''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(_aws_cdk_aws_sns_ceddda9d.ITopic, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarm",
):
    '''An alarm that monitors the number of notifications filtered out due to invalid message body.

    The alarm is used to detect if the published messages are not valid or
    if inappropriate filters have been applied to a subscriber.

    The alarm is triggered when the number of messages filtered out due to
    invalid message body is greater than the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param topic: The SNS topic for which to create the alarm.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor and resolve potential problems with the publisher or subscribers. Check if a publisher is publishing messages with invalid message bodies, or if an inappropriate filter is applied to a subscriber. You can also analyze CloudWatch Logs to help find the root cause of the issue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidMessageBody'
        :param threshold: The value against which the specified statistic is compared. Invalid message bodies are almost always a mistake by the publisher. We recommend to set the threshold to 0 because invalid message bodies are not expected in a healthy system. Default: 0
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8b0eb47a2c3fa8f34233ebb68267787d38ab91e5dbd2e593d54eb6b6833c21bb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmProps(
            topic=topic,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            threshold=threshold,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig",
    jsii_struct_bases=[SnsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "threshold": "threshold",
    },
)
class SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig(
    SnsAlarmBaseConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the NumberOfNotificationsFilteredOutInvalidMessageBody alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor and resolve potential problems with the publisher or subscribers. Check if a publisher is publishing messages with invalid message bodies, or if an inappropriate filter is applied to a subscriber. You can also analyze CloudWatch Logs to help find the root cause of the issue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidMessageBody'
        :param threshold: The value against which the specified statistic is compared. Invalid message bodies are almost always a mistake by the publisher. We recommend to set the threshold to 0 because invalid message bodies are not expected in a healthy system. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7144b6b471d3381a8a22ad7e1411624239d41faade4130e5d45a811d5546fe73)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to monitor and resolve potential problems with the
        publisher or subscribers. Check if a publisher is publishing messages with
        invalid message bodies, or if an inappropriate filter is applied to a subscriber.
        You can also analyze CloudWatch Logs to help find the root cause of the issue.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidMessageBody'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        Invalid message bodies are almost always a mistake by the publisher.
        We recommend to set the threshold to 0 because invalid message bodies
        are not expected in a healthy system.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmProps",
    jsii_struct_bases=[
        SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig
    ],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "threshold": "threshold",
        "topic": "topic",
    },
)
class SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmProps(
    SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    ) -> None:
        '''Properties for the SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor and resolve potential problems with the publisher or subscribers. Check if a publisher is publishing messages with invalid message bodies, or if an inappropriate filter is applied to a subscriber. You can also analyze CloudWatch Logs to help find the root cause of the issue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidMessageBody'
        :param threshold: The value against which the specified statistic is compared. Invalid message bodies are almost always a mistake by the publisher. We recommend to set the threshold to 0 because invalid message bodies are not expected in a healthy system. Default: 0
        :param topic: The SNS topic for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__68a91c07dfcbd0aacb0e3c594d36678ba3a1e134a863504ce2a39c87c7da0221)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topic": topic,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to monitor and resolve potential problems with the
        publisher or subscribers. Check if a publisher is publishing messages with
        invalid message bodies, or if an inappropriate filter is applied to a subscriber.
        You can also analyze CloudWatch Logs to help find the root cause of the issue.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidMessageBody'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        Invalid message bodies are almost always a mistake by the publisher.
        We recommend to set the threshold to 0 because invalid message bodies
        are not expected in a healthy system.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def topic(self) -> _aws_cdk_aws_sns_ceddda9d.ITopic:
        '''The SNS topic for which to create the alarm.'''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(_aws_cdk_aws_sns_ceddda9d.ITopic, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsNumberOfNotificationsRedrivenToDlqAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsRedrivenToDlqAlarm",
):
    '''An alarm that monitors the number of notifications redriven to the dead-letter queue.

    The alarm is used to detect messages that moved to a dead-letter
    queue. We recommend that you create this alarm when SNS is coupled
    with SQS, Lambda or Firehose.

    The alarm is triggered when the number of messages redriven to the
    dead-letter queue is greater than the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param topic: The SNS topic for which to create the alarm.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor the number of messages that are moved to a dead-letter queue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsRedrivenToDlq'
        :param threshold: The value against which the specified statistic is compared. In a healthy system of any subscriber type, messages should not be moved to the dead-letter queue. We recommend that you be notified if any messages land in the queue, so that you can identify and address the root cause, and potentially redrive the messages in the dead-letter queue to prevent data loss. Default: 0
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5333c0338ea3e3f055d2c8daafb1ec07493b232256425a8befa7dc813db863eb)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SnsNumberOfNotificationsRedrivenToDlqAlarmProps(
            topic=topic,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            threshold=threshold,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsRedrivenToDlqAlarmConfig",
    jsii_struct_bases=[SnsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "threshold": "threshold",
    },
)
class SnsNumberOfNotificationsRedrivenToDlqAlarmConfig(SnsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the NumberOfNotificationsRedrivenToDlq alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor the number of messages that are moved to a dead-letter queue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsRedrivenToDlq'
        :param threshold: The value against which the specified statistic is compared. In a healthy system of any subscriber type, messages should not be moved to the dead-letter queue. We recommend that you be notified if any messages land in the queue, so that you can identify and address the root cause, and potentially redrive the messages in the dead-letter queue to prevent data loss. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__62b63074ae7184f232bd0e5938c481c0494ea3e231fea4a6974e72aca3250ee9)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm helps to monitor the number of messages that are moved to a dead-letter queue.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsRedrivenToDlq'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        In a healthy system of any subscriber type, messages should not be moved
        to the dead-letter queue. We recommend that you be notified if any messages
        land in the queue, so that you can identify and address the root cause,
        and potentially redrive the messages in the dead-letter queue to prevent
        data loss.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsRedrivenToDlqAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsNumberOfNotificationsRedrivenToDlqAlarmProps",
    jsii_struct_bases=[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "threshold": "threshold",
        "topic": "topic",
    },
)
class SnsNumberOfNotificationsRedrivenToDlqAlarmProps(
    SnsNumberOfNotificationsRedrivenToDlqAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    ) -> None:
        '''Properties for the SnsNumberOfNotificationsRedrivenToDlqAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor the number of messages that are moved to a dead-letter queue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsRedrivenToDlq'
        :param threshold: The value against which the specified statistic is compared. In a healthy system of any subscriber type, messages should not be moved to the dead-letter queue. We recommend that you be notified if any messages land in the queue, so that you can identify and address the root cause, and potentially redrive the messages in the dead-letter queue to prevent data loss. Default: 0
        :param topic: The SNS topic for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e2f1df38bb641261070fb8b92d0e55844593ac7973d092bf2fd4d6763627299e)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "topic": topic,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm helps to monitor the number of messages that are moved to a dead-letter queue.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - topic.topicName + ' - NumberOfNotificationsRedrivenToDlq'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        In a healthy system of any subscriber type, messages should not be moved
        to the dead-letter queue. We recommend that you be notified if any messages
        land in the queue, so that you can identify and address the root cause,
        and potentially redrive the messages in the dead-letter queue to prevent
        data loss.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def topic(self) -> _aws_cdk_aws_sns_ceddda9d.ITopic:
        '''The SNS topic for which to create the alarm.'''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(_aws_cdk_aws_sns_ceddda9d.ITopic, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsNumberOfNotificationsRedrivenToDlqAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SnsRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsRecommendedAlarms",
):
    '''A construct that creates recommended alarms for an SNS topic.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#SNS
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
        config_number_of_messages_published_alarm: typing.Union[SnsNumberOfMessagesPublishedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_delivered_alarm: typing.Union[SnsNumberOfNotificationsDeliveredAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_failed_alarm: typing.Union[SnsNumberOfNotificationsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_failed_to_redrive_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_filtered_out_invalid_attributes_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_filtered_out_invalid_message_body_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_redriven_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["SnsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param topic: The SNS topic for which to create the alarms.
        :param config_number_of_messages_published_alarm: The configuration for the NumberOfMessagesPublished alarm.
        :param config_number_of_notifications_delivered_alarm: The configuration for the NumberOfNotificationsDelivered alarm.
        :param config_number_of_notifications_failed_alarm: The configuration for the NumberOfNotificationsFailed alarm.
        :param config_number_of_notifications_failed_to_redrive_to_dlq_alarm: The configuration for the NumberOfNotificationsFailedToRedriveToDlq alarm.
        :param config_number_of_notifications_filtered_out_invalid_attributes_alarm: The configuration for the NumberOfNotificationsFilteredOutInvalidAttributes alarm.
        :param config_number_of_notifications_filtered_out_invalid_message_body_alarm: The configuration for the NumberOfNotificationsFilteredOutInvalidMessageBody alarm.
        :param config_number_of_notifications_redriven_to_dlq_alarm: The configuration for the NumberOfNotificationsRedrivenToDlq alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98630e12118de7c882d18933f387c3a322a8c8af12b4b511ecf7e03804a5775d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SnsRecommendedAlarmsProps(
            topic=topic,
            config_number_of_messages_published_alarm=config_number_of_messages_published_alarm,
            config_number_of_notifications_delivered_alarm=config_number_of_notifications_delivered_alarm,
            config_number_of_notifications_failed_alarm=config_number_of_notifications_failed_alarm,
            config_number_of_notifications_failed_to_redrive_to_dlq_alarm=config_number_of_notifications_failed_to_redrive_to_dlq_alarm,
            config_number_of_notifications_filtered_out_invalid_attributes_alarm=config_number_of_notifications_filtered_out_invalid_attributes_alarm,
            config_number_of_notifications_filtered_out_invalid_message_body_alarm=config_number_of_notifications_filtered_out_invalid_message_body_alarm,
            config_number_of_notifications_redriven_to_dlq_alarm=config_number_of_notifications_redriven_to_dlq_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmNumberOfMessagesPublished")
    def alarm_number_of_messages_published(
        self,
    ) -> typing.Optional[SnsNumberOfMessagesPublishedAlarm]:
        '''The NumberOfMessagesPublished alarm.'''
        return typing.cast(typing.Optional[SnsNumberOfMessagesPublishedAlarm], jsii.get(self, "alarmNumberOfMessagesPublished"))

    @builtins.property
    @jsii.member(jsii_name="alarmNumberOfNotificationsDelivered")
    def alarm_number_of_notifications_delivered(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsDeliveredAlarm]:
        '''The NumberOfNotificationsDelivered alarm.'''
        return typing.cast(typing.Optional[SnsNumberOfNotificationsDeliveredAlarm], jsii.get(self, "alarmNumberOfNotificationsDelivered"))

    @builtins.property
    @jsii.member(jsii_name="alarmNumberOfNotificationsFailed")
    def alarm_number_of_notifications_failed(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsFailedAlarm]:
        '''The NumberOfNotificationsFailed alarm.'''
        return typing.cast(typing.Optional[SnsNumberOfNotificationsFailedAlarm], jsii.get(self, "alarmNumberOfNotificationsFailed"))

    @builtins.property
    @jsii.member(jsii_name="alarmNumberOfNotificationsFailedToRedriveToDlq")
    def alarm_number_of_notifications_failed_to_redrive_to_dlq(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsFailedToRedriveToDlqAlarm]:
        '''The NumberOfNotificationsFailedToRedriveToDlq alarm.'''
        return typing.cast(typing.Optional[SnsNumberOfNotificationsFailedToRedriveToDlqAlarm], jsii.get(self, "alarmNumberOfNotificationsFailedToRedriveToDlq"))

    @builtins.property
    @jsii.member(jsii_name="alarmNumberOfNotificationsFilteredOutInvalidAttributes")
    def alarm_number_of_notifications_filtered_out_invalid_attributes(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarm]:
        '''The NumberOfNotificationsFilteredOutInvalidAttributes alarm.'''
        return typing.cast(typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarm], jsii.get(self, "alarmNumberOfNotificationsFilteredOutInvalidAttributes"))

    @builtins.property
    @jsii.member(jsii_name="alarmNumberOfNotificationsFilteredOutInvalidMessageBody")
    def alarm_number_of_notifications_filtered_out_invalid_message_body(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarm]:
        '''The NumberOfNotificationsFilteredOutInvalidMessageBody alarm.'''
        return typing.cast(typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarm], jsii.get(self, "alarmNumberOfNotificationsFilteredOutInvalidMessageBody"))

    @builtins.property
    @jsii.member(jsii_name="alarmNumberOfNotificationsRedrivenToDlq")
    def alarm_number_of_notifications_redriven_to_dlq(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsRedrivenToDlqAlarm]:
        '''The NumberOfNotificationsRedrivenToDlq alarm.'''
        return typing.cast(typing.Optional[SnsNumberOfNotificationsRedrivenToDlqAlarm], jsii.get(self, "alarmNumberOfNotificationsRedrivenToDlq"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class SnsRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsRecommendedAlarmsAspect",
):
    '''An aspect that applies recommended alarms to SNS topics.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#SNS
    '''

    def __init__(
        self,
        *,
        config_number_of_messages_published_alarm: typing.Union[SnsNumberOfMessagesPublishedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_delivered_alarm: typing.Union[SnsNumberOfNotificationsDeliveredAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_failed_alarm: typing.Union[SnsNumberOfNotificationsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_failed_to_redrive_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_filtered_out_invalid_attributes_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_filtered_out_invalid_message_body_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_redriven_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["SnsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_number_of_messages_published_alarm: The configuration for the NumberOfMessagesPublished alarm.
        :param config_number_of_notifications_delivered_alarm: The configuration for the NumberOfNotificationsDelivered alarm.
        :param config_number_of_notifications_failed_alarm: The configuration for the NumberOfNotificationsFailed alarm.
        :param config_number_of_notifications_failed_to_redrive_to_dlq_alarm: The configuration for the NumberOfNotificationsFailedToRedriveToDlq alarm.
        :param config_number_of_notifications_filtered_out_invalid_attributes_alarm: The configuration for the NumberOfNotificationsFilteredOutInvalidAttributes alarm.
        :param config_number_of_notifications_filtered_out_invalid_message_body_alarm: The configuration for the NumberOfNotificationsFilteredOutInvalidMessageBody alarm.
        :param config_number_of_notifications_redriven_to_dlq_alarm: The configuration for the NumberOfNotificationsRedrivenToDlq alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SnsRecommendedAlarmsConfig(
            config_number_of_messages_published_alarm=config_number_of_messages_published_alarm,
            config_number_of_notifications_delivered_alarm=config_number_of_notifications_delivered_alarm,
            config_number_of_notifications_failed_alarm=config_number_of_notifications_failed_alarm,
            config_number_of_notifications_failed_to_redrive_to_dlq_alarm=config_number_of_notifications_failed_to_redrive_to_dlq_alarm,
            config_number_of_notifications_filtered_out_invalid_attributes_alarm=config_number_of_notifications_filtered_out_invalid_attributes_alarm,
            config_number_of_notifications_filtered_out_invalid_message_body_alarm=config_number_of_notifications_filtered_out_invalid_message_body_alarm,
            config_number_of_notifications_redriven_to_dlq_alarm=config_number_of_notifications_redriven_to_dlq_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__47c92495ab390db59ffeb1ec15eb639c4bda7f2e6fcc6ab00f48d384d9c0898d)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_number_of_messages_published_alarm": "configNumberOfMessagesPublishedAlarm",
        "config_number_of_notifications_delivered_alarm": "configNumberOfNotificationsDeliveredAlarm",
        "config_number_of_notifications_failed_alarm": "configNumberOfNotificationsFailedAlarm",
        "config_number_of_notifications_failed_to_redrive_to_dlq_alarm": "configNumberOfNotificationsFailedToRedriveToDlqAlarm",
        "config_number_of_notifications_filtered_out_invalid_attributes_alarm": "configNumberOfNotificationsFilteredOutInvalidAttributesAlarm",
        "config_number_of_notifications_filtered_out_invalid_message_body_alarm": "configNumberOfNotificationsFilteredOutInvalidMessageBodyAlarm",
        "config_number_of_notifications_redriven_to_dlq_alarm": "configNumberOfNotificationsRedrivenToDlqAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class SnsRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_number_of_messages_published_alarm: typing.Union[SnsNumberOfMessagesPublishedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_delivered_alarm: typing.Union[SnsNumberOfNotificationsDeliveredAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_failed_alarm: typing.Union[SnsNumberOfNotificationsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_failed_to_redrive_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_filtered_out_invalid_attributes_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_filtered_out_invalid_message_body_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_redriven_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["SnsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_number_of_messages_published_alarm: The configuration for the NumberOfMessagesPublished alarm.
        :param config_number_of_notifications_delivered_alarm: The configuration for the NumberOfNotificationsDelivered alarm.
        :param config_number_of_notifications_failed_alarm: The configuration for the NumberOfNotificationsFailed alarm.
        :param config_number_of_notifications_failed_to_redrive_to_dlq_alarm: The configuration for the NumberOfNotificationsFailedToRedriveToDlq alarm.
        :param config_number_of_notifications_filtered_out_invalid_attributes_alarm: The configuration for the NumberOfNotificationsFilteredOutInvalidAttributes alarm.
        :param config_number_of_notifications_filtered_out_invalid_message_body_alarm: The configuration for the NumberOfNotificationsFilteredOutInvalidMessageBody alarm.
        :param config_number_of_notifications_redriven_to_dlq_alarm: The configuration for the NumberOfNotificationsRedrivenToDlq alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_number_of_messages_published_alarm, dict):
            config_number_of_messages_published_alarm = SnsNumberOfMessagesPublishedAlarmConfig(**config_number_of_messages_published_alarm)
        if isinstance(config_number_of_notifications_delivered_alarm, dict):
            config_number_of_notifications_delivered_alarm = SnsNumberOfNotificationsDeliveredAlarmConfig(**config_number_of_notifications_delivered_alarm)
        if isinstance(config_number_of_notifications_failed_alarm, dict):
            config_number_of_notifications_failed_alarm = SnsNumberOfNotificationsFailedAlarmConfig(**config_number_of_notifications_failed_alarm)
        if isinstance(config_number_of_notifications_failed_to_redrive_to_dlq_alarm, dict):
            config_number_of_notifications_failed_to_redrive_to_dlq_alarm = SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig(**config_number_of_notifications_failed_to_redrive_to_dlq_alarm)
        if isinstance(config_number_of_notifications_filtered_out_invalid_attributes_alarm, dict):
            config_number_of_notifications_filtered_out_invalid_attributes_alarm = SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig(**config_number_of_notifications_filtered_out_invalid_attributes_alarm)
        if isinstance(config_number_of_notifications_filtered_out_invalid_message_body_alarm, dict):
            config_number_of_notifications_filtered_out_invalid_message_body_alarm = SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig(**config_number_of_notifications_filtered_out_invalid_message_body_alarm)
        if isinstance(config_number_of_notifications_redriven_to_dlq_alarm, dict):
            config_number_of_notifications_redriven_to_dlq_alarm = SnsNumberOfNotificationsRedrivenToDlqAlarmConfig(**config_number_of_notifications_redriven_to_dlq_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fecc7466425a3fd89d5693837b979038b44222e821924f36e33e1aea20e4236a)
            check_type(argname="argument config_number_of_messages_published_alarm", value=config_number_of_messages_published_alarm, expected_type=type_hints["config_number_of_messages_published_alarm"])
            check_type(argname="argument config_number_of_notifications_delivered_alarm", value=config_number_of_notifications_delivered_alarm, expected_type=type_hints["config_number_of_notifications_delivered_alarm"])
            check_type(argname="argument config_number_of_notifications_failed_alarm", value=config_number_of_notifications_failed_alarm, expected_type=type_hints["config_number_of_notifications_failed_alarm"])
            check_type(argname="argument config_number_of_notifications_failed_to_redrive_to_dlq_alarm", value=config_number_of_notifications_failed_to_redrive_to_dlq_alarm, expected_type=type_hints["config_number_of_notifications_failed_to_redrive_to_dlq_alarm"])
            check_type(argname="argument config_number_of_notifications_filtered_out_invalid_attributes_alarm", value=config_number_of_notifications_filtered_out_invalid_attributes_alarm, expected_type=type_hints["config_number_of_notifications_filtered_out_invalid_attributes_alarm"])
            check_type(argname="argument config_number_of_notifications_filtered_out_invalid_message_body_alarm", value=config_number_of_notifications_filtered_out_invalid_message_body_alarm, expected_type=type_hints["config_number_of_notifications_filtered_out_invalid_message_body_alarm"])
            check_type(argname="argument config_number_of_notifications_redriven_to_dlq_alarm", value=config_number_of_notifications_redriven_to_dlq_alarm, expected_type=type_hints["config_number_of_notifications_redriven_to_dlq_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_number_of_messages_published_alarm": config_number_of_messages_published_alarm,
            "config_number_of_notifications_delivered_alarm": config_number_of_notifications_delivered_alarm,
            "config_number_of_notifications_failed_alarm": config_number_of_notifications_failed_alarm,
        }
        if config_number_of_notifications_failed_to_redrive_to_dlq_alarm is not None:
            self._values["config_number_of_notifications_failed_to_redrive_to_dlq_alarm"] = config_number_of_notifications_failed_to_redrive_to_dlq_alarm
        if config_number_of_notifications_filtered_out_invalid_attributes_alarm is not None:
            self._values["config_number_of_notifications_filtered_out_invalid_attributes_alarm"] = config_number_of_notifications_filtered_out_invalid_attributes_alarm
        if config_number_of_notifications_filtered_out_invalid_message_body_alarm is not None:
            self._values["config_number_of_notifications_filtered_out_invalid_message_body_alarm"] = config_number_of_notifications_filtered_out_invalid_message_body_alarm
        if config_number_of_notifications_redriven_to_dlq_alarm is not None:
            self._values["config_number_of_notifications_redriven_to_dlq_alarm"] = config_number_of_notifications_redriven_to_dlq_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_number_of_messages_published_alarm(
        self,
    ) -> SnsNumberOfMessagesPublishedAlarmConfig:
        '''The configuration for the NumberOfMessagesPublished alarm.'''
        result = self._values.get("config_number_of_messages_published_alarm")
        assert result is not None, "Required property 'config_number_of_messages_published_alarm' is missing"
        return typing.cast(SnsNumberOfMessagesPublishedAlarmConfig, result)

    @builtins.property
    def config_number_of_notifications_delivered_alarm(
        self,
    ) -> SnsNumberOfNotificationsDeliveredAlarmConfig:
        '''The configuration for the NumberOfNotificationsDelivered alarm.'''
        result = self._values.get("config_number_of_notifications_delivered_alarm")
        assert result is not None, "Required property 'config_number_of_notifications_delivered_alarm' is missing"
        return typing.cast(SnsNumberOfNotificationsDeliveredAlarmConfig, result)

    @builtins.property
    def config_number_of_notifications_failed_alarm(
        self,
    ) -> SnsNumberOfNotificationsFailedAlarmConfig:
        '''The configuration for the NumberOfNotificationsFailed alarm.'''
        result = self._values.get("config_number_of_notifications_failed_alarm")
        assert result is not None, "Required property 'config_number_of_notifications_failed_alarm' is missing"
        return typing.cast(SnsNumberOfNotificationsFailedAlarmConfig, result)

    @builtins.property
    def config_number_of_notifications_failed_to_redrive_to_dlq_alarm(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig]:
        '''The configuration for the NumberOfNotificationsFailedToRedriveToDlq alarm.'''
        result = self._values.get("config_number_of_notifications_failed_to_redrive_to_dlq_alarm")
        return typing.cast(typing.Optional[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig], result)

    @builtins.property
    def config_number_of_notifications_filtered_out_invalid_attributes_alarm(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig]:
        '''The configuration for the NumberOfNotificationsFilteredOutInvalidAttributes alarm.'''
        result = self._values.get("config_number_of_notifications_filtered_out_invalid_attributes_alarm")
        return typing.cast(typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig], result)

    @builtins.property
    def config_number_of_notifications_filtered_out_invalid_message_body_alarm(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig]:
        '''The configuration for the NumberOfNotificationsFilteredOutInvalidMessageBody alarm.'''
        result = self._values.get("config_number_of_notifications_filtered_out_invalid_message_body_alarm")
        return typing.cast(typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig], result)

    @builtins.property
    def config_number_of_notifications_redriven_to_dlq_alarm(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig]:
        '''The configuration for the NumberOfNotificationsRedrivenToDlq alarm.'''
        result = self._values.get("config_number_of_notifications_redriven_to_dlq_alarm")
        return typing.cast(typing.Optional[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["SnsRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["SnsRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsRecommendedAlarmsMetrics"
)
class SnsRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for SNS topic alarms.'''

    NUMBER_OF_MESSAGES_PUBLISHED = "NUMBER_OF_MESSAGES_PUBLISHED"
    '''The number of messages published to the topic.'''
    NUMBER_OF_NOTIFICATIONS_DELIVERED = "NUMBER_OF_NOTIFICATIONS_DELIVERED"
    '''The number of notifications delivered.'''
    NUMBER_OF_NOTIFICATIONS_FAILED = "NUMBER_OF_NOTIFICATIONS_FAILED"
    '''The number of notifications failed.'''
    NUMBER_OF_NOTIFICATIONS_FILTERED_OUT_INVALID_ATTRIBUTES = "NUMBER_OF_NOTIFICATIONS_FILTERED_OUT_INVALID_ATTRIBUTES"
    '''The number of notifications filtered out due to invalid attributes.'''
    NUMBER_OF_NOTIFICATIONS_FILTERED_OUT_INVALID_MESSAGE_BODY = "NUMBER_OF_NOTIFICATIONS_FILTERED_OUT_INVALID_MESSAGE_BODY"
    '''The number of notifications filtered out due to invalid message body.'''
    NUMBER_OF_NOTIFICATIONS_REDRIVEN_TO_DLQ = "NUMBER_OF_NOTIFICATIONS_REDRIVEN_TO_DLQ"
    '''The number of notifications redriven to the dead-letter queue.'''
    NUMBER_OF_NOTIFICATIONS_FAILED_TO_REDRIVE_TO_DLQ = "NUMBER_OF_NOTIFICATIONS_FAILED_TO_REDRIVE_TO_DLQ"
    '''The number of notifications failed to redrive to the dead-letter queue.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SnsRecommendedAlarmsProps",
    jsii_struct_bases=[SnsRecommendedAlarmsConfig],
    name_mapping={
        "config_number_of_messages_published_alarm": "configNumberOfMessagesPublishedAlarm",
        "config_number_of_notifications_delivered_alarm": "configNumberOfNotificationsDeliveredAlarm",
        "config_number_of_notifications_failed_alarm": "configNumberOfNotificationsFailedAlarm",
        "config_number_of_notifications_failed_to_redrive_to_dlq_alarm": "configNumberOfNotificationsFailedToRedriveToDlqAlarm",
        "config_number_of_notifications_filtered_out_invalid_attributes_alarm": "configNumberOfNotificationsFilteredOutInvalidAttributesAlarm",
        "config_number_of_notifications_filtered_out_invalid_message_body_alarm": "configNumberOfNotificationsFilteredOutInvalidMessageBodyAlarm",
        "config_number_of_notifications_redriven_to_dlq_alarm": "configNumberOfNotificationsRedrivenToDlqAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "topic": "topic",
    },
)
class SnsRecommendedAlarmsProps(SnsRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config_number_of_messages_published_alarm: typing.Union[SnsNumberOfMessagesPublishedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_delivered_alarm: typing.Union[SnsNumberOfNotificationsDeliveredAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_failed_alarm: typing.Union[SnsNumberOfNotificationsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_failed_to_redrive_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_filtered_out_invalid_attributes_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_filtered_out_invalid_message_body_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_redriven_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[SnsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    ) -> None:
        '''
        :param config_number_of_messages_published_alarm: The configuration for the NumberOfMessagesPublished alarm.
        :param config_number_of_notifications_delivered_alarm: The configuration for the NumberOfNotificationsDelivered alarm.
        :param config_number_of_notifications_failed_alarm: The configuration for the NumberOfNotificationsFailed alarm.
        :param config_number_of_notifications_failed_to_redrive_to_dlq_alarm: The configuration for the NumberOfNotificationsFailedToRedriveToDlq alarm.
        :param config_number_of_notifications_filtered_out_invalid_attributes_alarm: The configuration for the NumberOfNotificationsFilteredOutInvalidAttributes alarm.
        :param config_number_of_notifications_filtered_out_invalid_message_body_alarm: The configuration for the NumberOfNotificationsFilteredOutInvalidMessageBody alarm.
        :param config_number_of_notifications_redriven_to_dlq_alarm: The configuration for the NumberOfNotificationsRedrivenToDlq alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param topic: The SNS topic for which to create the alarms.
        '''
        if isinstance(config_number_of_messages_published_alarm, dict):
            config_number_of_messages_published_alarm = SnsNumberOfMessagesPublishedAlarmConfig(**config_number_of_messages_published_alarm)
        if isinstance(config_number_of_notifications_delivered_alarm, dict):
            config_number_of_notifications_delivered_alarm = SnsNumberOfNotificationsDeliveredAlarmConfig(**config_number_of_notifications_delivered_alarm)
        if isinstance(config_number_of_notifications_failed_alarm, dict):
            config_number_of_notifications_failed_alarm = SnsNumberOfNotificationsFailedAlarmConfig(**config_number_of_notifications_failed_alarm)
        if isinstance(config_number_of_notifications_failed_to_redrive_to_dlq_alarm, dict):
            config_number_of_notifications_failed_to_redrive_to_dlq_alarm = SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig(**config_number_of_notifications_failed_to_redrive_to_dlq_alarm)
        if isinstance(config_number_of_notifications_filtered_out_invalid_attributes_alarm, dict):
            config_number_of_notifications_filtered_out_invalid_attributes_alarm = SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig(**config_number_of_notifications_filtered_out_invalid_attributes_alarm)
        if isinstance(config_number_of_notifications_filtered_out_invalid_message_body_alarm, dict):
            config_number_of_notifications_filtered_out_invalid_message_body_alarm = SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig(**config_number_of_notifications_filtered_out_invalid_message_body_alarm)
        if isinstance(config_number_of_notifications_redriven_to_dlq_alarm, dict):
            config_number_of_notifications_redriven_to_dlq_alarm = SnsNumberOfNotificationsRedrivenToDlqAlarmConfig(**config_number_of_notifications_redriven_to_dlq_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__168fe991294b441d2405431f15f9275f6ff942b8e21e0e325a0459bc7773caf2)
            check_type(argname="argument config_number_of_messages_published_alarm", value=config_number_of_messages_published_alarm, expected_type=type_hints["config_number_of_messages_published_alarm"])
            check_type(argname="argument config_number_of_notifications_delivered_alarm", value=config_number_of_notifications_delivered_alarm, expected_type=type_hints["config_number_of_notifications_delivered_alarm"])
            check_type(argname="argument config_number_of_notifications_failed_alarm", value=config_number_of_notifications_failed_alarm, expected_type=type_hints["config_number_of_notifications_failed_alarm"])
            check_type(argname="argument config_number_of_notifications_failed_to_redrive_to_dlq_alarm", value=config_number_of_notifications_failed_to_redrive_to_dlq_alarm, expected_type=type_hints["config_number_of_notifications_failed_to_redrive_to_dlq_alarm"])
            check_type(argname="argument config_number_of_notifications_filtered_out_invalid_attributes_alarm", value=config_number_of_notifications_filtered_out_invalid_attributes_alarm, expected_type=type_hints["config_number_of_notifications_filtered_out_invalid_attributes_alarm"])
            check_type(argname="argument config_number_of_notifications_filtered_out_invalid_message_body_alarm", value=config_number_of_notifications_filtered_out_invalid_message_body_alarm, expected_type=type_hints["config_number_of_notifications_filtered_out_invalid_message_body_alarm"])
            check_type(argname="argument config_number_of_notifications_redriven_to_dlq_alarm", value=config_number_of_notifications_redriven_to_dlq_alarm, expected_type=type_hints["config_number_of_notifications_redriven_to_dlq_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument topic", value=topic, expected_type=type_hints["topic"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_number_of_messages_published_alarm": config_number_of_messages_published_alarm,
            "config_number_of_notifications_delivered_alarm": config_number_of_notifications_delivered_alarm,
            "config_number_of_notifications_failed_alarm": config_number_of_notifications_failed_alarm,
            "topic": topic,
        }
        if config_number_of_notifications_failed_to_redrive_to_dlq_alarm is not None:
            self._values["config_number_of_notifications_failed_to_redrive_to_dlq_alarm"] = config_number_of_notifications_failed_to_redrive_to_dlq_alarm
        if config_number_of_notifications_filtered_out_invalid_attributes_alarm is not None:
            self._values["config_number_of_notifications_filtered_out_invalid_attributes_alarm"] = config_number_of_notifications_filtered_out_invalid_attributes_alarm
        if config_number_of_notifications_filtered_out_invalid_message_body_alarm is not None:
            self._values["config_number_of_notifications_filtered_out_invalid_message_body_alarm"] = config_number_of_notifications_filtered_out_invalid_message_body_alarm
        if config_number_of_notifications_redriven_to_dlq_alarm is not None:
            self._values["config_number_of_notifications_redriven_to_dlq_alarm"] = config_number_of_notifications_redriven_to_dlq_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_number_of_messages_published_alarm(
        self,
    ) -> SnsNumberOfMessagesPublishedAlarmConfig:
        '''The configuration for the NumberOfMessagesPublished alarm.'''
        result = self._values.get("config_number_of_messages_published_alarm")
        assert result is not None, "Required property 'config_number_of_messages_published_alarm' is missing"
        return typing.cast(SnsNumberOfMessagesPublishedAlarmConfig, result)

    @builtins.property
    def config_number_of_notifications_delivered_alarm(
        self,
    ) -> SnsNumberOfNotificationsDeliveredAlarmConfig:
        '''The configuration for the NumberOfNotificationsDelivered alarm.'''
        result = self._values.get("config_number_of_notifications_delivered_alarm")
        assert result is not None, "Required property 'config_number_of_notifications_delivered_alarm' is missing"
        return typing.cast(SnsNumberOfNotificationsDeliveredAlarmConfig, result)

    @builtins.property
    def config_number_of_notifications_failed_alarm(
        self,
    ) -> SnsNumberOfNotificationsFailedAlarmConfig:
        '''The configuration for the NumberOfNotificationsFailed alarm.'''
        result = self._values.get("config_number_of_notifications_failed_alarm")
        assert result is not None, "Required property 'config_number_of_notifications_failed_alarm' is missing"
        return typing.cast(SnsNumberOfNotificationsFailedAlarmConfig, result)

    @builtins.property
    def config_number_of_notifications_failed_to_redrive_to_dlq_alarm(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig]:
        '''The configuration for the NumberOfNotificationsFailedToRedriveToDlq alarm.'''
        result = self._values.get("config_number_of_notifications_failed_to_redrive_to_dlq_alarm")
        return typing.cast(typing.Optional[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig], result)

    @builtins.property
    def config_number_of_notifications_filtered_out_invalid_attributes_alarm(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig]:
        '''The configuration for the NumberOfNotificationsFilteredOutInvalidAttributes alarm.'''
        result = self._values.get("config_number_of_notifications_filtered_out_invalid_attributes_alarm")
        return typing.cast(typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig], result)

    @builtins.property
    def config_number_of_notifications_filtered_out_invalid_message_body_alarm(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig]:
        '''The configuration for the NumberOfNotificationsFilteredOutInvalidMessageBody alarm.'''
        result = self._values.get("config_number_of_notifications_filtered_out_invalid_message_body_alarm")
        return typing.cast(typing.Optional[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig], result)

    @builtins.property
    def config_number_of_notifications_redriven_to_dlq_alarm(
        self,
    ) -> typing.Optional[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig]:
        '''The configuration for the NumberOfNotificationsRedrivenToDlq alarm.'''
        result = self._values.get("config_number_of_notifications_redriven_to_dlq_alarm")
        return typing.cast(typing.Optional[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[SnsRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[SnsRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def topic(self) -> _aws_cdk_aws_sns_ceddda9d.ITopic:
        '''The SNS topic for which to create the alarms.'''
        result = self._values.get("topic")
        assert result is not None, "Required property 'topic' is missing"
        return typing.cast(_aws_cdk_aws_sns_ceddda9d.ITopic, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SnsRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
    },
)
class SqsAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c20302d0dce277cc07fd49ad99fdc8325c29e5d392842004761577330967cdf9)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SqsApproximateAgeOfOldestMessageAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsApproximateAgeOfOldestMessageAlarm",
):
    '''An alarm that watches the age of the oldest message in the queue.

    This alarm is used to detect whether the age of the oldest message
    in the QueueName queue is too high. High age can be an indication
    that messages are not processed quickly enough or that there are
    some poison-pill messages that are stuck in the queue and can't
    be processed.

    This alarm is triggered when the age of the oldest message in the
    queue exceeds or is equal to the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param queue: The SQS queue for which to create the alarm.
        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the expected message processing time. You can use historical data to calculate the average message processing time, and then set the threshold to 50% higher than the maximum expected SQS message processing time by queue consumers.
        :param alarm_description: The description of the alarm. Default: - This alarm watches the age of the oldest message in the queue. You can use this alarm to monitor if your consumers are processing SQS messages at the desired speed. Consider increasing the consumer count or consumer throughput to reduce message age. This metric can be used in combination with ApproximateNumberOfMessagesVisible to determine how big the queue backlog is and how quickly messages are being processed. To prevent messages from being deleted before processed, consider configuring the dead-letter queue to sideline potential poison pill messages.
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateAgeOfOldestMessage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c269e40750c6097ce5a8155e6a89289661005b40532df53de2f6994ca311128c)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SqsApproximateAgeOfOldestMessageAlarmProps(
            queue=queue,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsApproximateAgeOfOldestMessageAlarmConfig",
    jsii_struct_bases=[SqsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
    },
)
class SqsApproximateAgeOfOldestMessageAlarmConfig(SqsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the ApproximateAgeOfOldestMessage alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the expected message processing time. You can use historical data to calculate the average message processing time, and then set the threshold to 50% higher than the maximum expected SQS message processing time by queue consumers.
        :param alarm_description: The description of the alarm. Default: - This alarm watches the age of the oldest message in the queue. You can use this alarm to monitor if your consumers are processing SQS messages at the desired speed. Consider increasing the consumer count or consumer throughput to reduce message age. This metric can be used in combination with ApproximateNumberOfMessagesVisible to determine how big the queue backlog is and how quickly messages are being processed. To prevent messages from being deleted before processed, consider configuring the dead-letter queue to sideline potential poison pill messages.
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateAgeOfOldestMessage'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2aad26aa3cbe4aee8036df6b618af2e6ad6d3e4a19515aee9606ee50dd9af390)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The recommended threshold value for this alarm is highly dependent on the expected message
        processing time. You can use historical data to calculate the average message processing time,
        and then set the threshold to 50% higher than the maximum expected SQS message processing
        time by queue consumers.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm watches the age of the oldest message in the queue. You can use this alarm
        to monitor if your consumers are processing SQS messages at the desired speed. Consider increasing
        the consumer count or consumer throughput to reduce message age. This metric can be used in
        combination with ApproximateNumberOfMessagesVisible to determine how big the queue backlog is
        and how quickly messages are being processed. To prevent messages from being deleted before processed,
        consider configuring the dead-letter queue to sideline potential poison pill messages.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - queue.queueName + ' - ApproximateAgeOfOldestMessage'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsApproximateAgeOfOldestMessageAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsApproximateAgeOfOldestMessageAlarmProps",
    jsii_struct_bases=[SqsApproximateAgeOfOldestMessageAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "queue": "queue",
    },
)
class SqsApproximateAgeOfOldestMessageAlarmProps(
    SqsApproximateAgeOfOldestMessageAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
    ) -> None:
        '''Properties for the SqsApproximateAgeOfOldestMessageAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the expected message processing time. You can use historical data to calculate the average message processing time, and then set the threshold to 50% higher than the maximum expected SQS message processing time by queue consumers.
        :param alarm_description: The description of the alarm. Default: - This alarm watches the age of the oldest message in the queue. You can use this alarm to monitor if your consumers are processing SQS messages at the desired speed. Consider increasing the consumer count or consumer throughput to reduce message age. This metric can be used in combination with ApproximateNumberOfMessagesVisible to determine how big the queue backlog is and how quickly messages are being processed. To prevent messages from being deleted before processed, consider configuring the dead-letter queue to sideline potential poison pill messages.
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateAgeOfOldestMessage'
        :param queue: The SQS queue for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__74ca6057ea5178302f3aef8ed4d21ecf4774c7eab9442af8f511543718ffcd83)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
            "queue": queue,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The recommended threshold value for this alarm is highly dependent on the expected message
        processing time. You can use historical data to calculate the average message processing time,
        and then set the threshold to 50% higher than the maximum expected SQS message processing
        time by queue consumers.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm watches the age of the oldest message in the queue. You can use this alarm
        to monitor if your consumers are processing SQS messages at the desired speed. Consider increasing
        the consumer count or consumer throughput to reduce message age. This metric can be used in
        combination with ApproximateNumberOfMessagesVisible to determine how big the queue backlog is
        and how quickly messages are being processed. To prevent messages from being deleted before processed,
        consider configuring the dead-letter queue to sideline potential poison pill messages.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - queue.queueName + ' - ApproximateAgeOfOldestMessage'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def queue(self) -> _aws_cdk_aws_sqs_ceddda9d.IQueue:
        '''The SQS queue for which to create the alarm.'''
        result = self._values.get("queue")
        assert result is not None, "Required property 'queue' is missing"
        return typing.cast(_aws_cdk_aws_sqs_ceddda9d.IQueue, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsApproximateAgeOfOldestMessageAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SqsApproximateNumberOfMessagesNotVisibleAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsApproximateNumberOfMessagesNotVisibleAlarm",
):
    '''An alarm that watches the number of messages that are in flight.

    This alarm is used to detect a high number of in-flight messages
    in the queue. If consumers do not delete messages within the
    visibility timeout period, when the queue is polled, messages
    reappear in the queue. For FIFO queues, there can be a maximum
    of 20,000 in-flight messages. If you reach this quota, SQS returns
    no error messages. A FIFO queue looks through the first 20k
    messages to determine available message groups. This means that
    if you have a backlog of messages in a single message group,
    you cannot consume messages from other message groups that were
    sent to the queue at a later time until you successfully
    consume the messages from the backlog.

    This alarm is triggered when the number of messages that are in
    flight exceeds or is equal to the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param queue: The SQS queue for which to create the alarm.
        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the expected number of messages in flight. You can use historical data to calculate the maximum expected number of messages in flight and set the threshold to 50% over this value. If consumers of the queue are processing but not deleting messages from the queue, this number will suddenly increase.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateNumberOfMessagesNotVisible'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8815dfd941d4ca8bcecc45ab9b5be4fc29cb8548dfe235cadc57ffe548606090)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SqsApproximateNumberOfMessagesNotVisibleAlarmProps(
            queue=queue,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsApproximateNumberOfMessagesNotVisibleAlarmConfig",
    jsii_struct_bases=[SqsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
    },
)
class SqsApproximateNumberOfMessagesNotVisibleAlarmConfig(SqsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the ApproximateNumberOfMessagesNotVisible alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the expected number of messages in flight. You can use historical data to calculate the maximum expected number of messages in flight and set the threshold to 50% over this value. If consumers of the queue are processing but not deleting messages from the queue, this number will suddenly increase.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateNumberOfMessagesNotVisible'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c35ed35809a4360f095271f551791be67f6ca04c5462fdaec844342d7ed06514)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The recommended threshold value for this alarm is highly dependent on the expected number
        of messages in flight. You can use historical data to calculate the maximum expected
        number of messages in flight and set the threshold to 50% over this value. If consumers
        of the queue are processing but not deleting messages from the queue, this number will
        suddenly increase.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to detect a high number of in-flight messages with respect to QueueName.
        For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - queue.queueName + ' - ApproximateNumberOfMessagesNotVisible'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsApproximateNumberOfMessagesNotVisibleAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsApproximateNumberOfMessagesNotVisibleAlarmProps",
    jsii_struct_bases=[SqsApproximateNumberOfMessagesNotVisibleAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "queue": "queue",
    },
)
class SqsApproximateNumberOfMessagesNotVisibleAlarmProps(
    SqsApproximateNumberOfMessagesNotVisibleAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
    ) -> None:
        '''Properties for the SqsApproximateNumberOfMessagesNotVisibleAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the expected number of messages in flight. You can use historical data to calculate the maximum expected number of messages in flight and set the threshold to 50% over this value. If consumers of the queue are processing but not deleting messages from the queue, this number will suddenly increase.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateNumberOfMessagesNotVisible'
        :param queue: The SQS queue for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9376fa81f847d50cbcd5a89d6f568da884875f0f5dae5fa27c75a88325d354eb)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
            "queue": queue,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        The recommended threshold value for this alarm is highly dependent on the expected number
        of messages in flight. You can use historical data to calculate the maximum expected
        number of messages in flight and set the threshold to 50% over this value. If consumers
        of the queue are processing but not deleting messages from the queue, this number will
        suddenly increase.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to detect a high number of in-flight messages with respect to QueueName.
        For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - queue.queueName + ' - ApproximateNumberOfMessagesNotVisible'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def queue(self) -> _aws_cdk_aws_sqs_ceddda9d.IQueue:
        '''The SQS queue for which to create the alarm.'''
        result = self._values.get("queue")
        assert result is not None, "Required property 'queue' is missing"
        return typing.cast(_aws_cdk_aws_sqs_ceddda9d.IQueue, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsApproximateNumberOfMessagesNotVisibleAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SqsApproximateNumberOfMessagesVisibleAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsApproximateNumberOfMessagesVisibleAlarm",
):
    '''An alarm that watches the number of messages that are visible in the queue.

    This alarm is used to detect whether the message
    count of the active queue is too high and consumers
    are slow to process the messages or there are not
    enough consumers to process them.

    This alarm is triggered when the number of messages
    that are visible in the queue exceeds or is equal to
    the specified threshold.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param queue: The SQS queue for which to create the alarm.
        :param threshold: The value against which the specified statistic is compared. An unexpectedly high number of messages visible indicates that messages are not being processed by a consumer at the expected rate. You should consider historical data when you set this threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateNumberOfMessagesVisible'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8a9188694cd82c03a9454a0975930ea6195f10816b6b12711ce2f5521c048ecc)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SqsApproximateNumberOfMessagesVisibleAlarmProps(
            queue=queue,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsApproximateNumberOfMessagesVisibleAlarmConfig",
    jsii_struct_bases=[SqsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
    },
)
class SqsApproximateNumberOfMessagesVisibleAlarmConfig(SqsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the ApproximateNumberOfMessagesVisible alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. An unexpectedly high number of messages visible indicates that messages are not being processed by a consumer at the expected rate. You should consider historical data when you set this threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateNumberOfMessagesVisible'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9416ae2be0a787ae40fb821ebed1c680e9e73112ef095bf0b4590229ef4ce402)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        An unexpectedly high number of messages visible indicates that messages are not being
        processed by a consumer at the expected rate. You should consider historical data when
        you set this threshold.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to detect a high number of in-flight messages with respect to QueueName.
        For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - queue.queueName + ' - ApproximateNumberOfMessagesVisible'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsApproximateNumberOfMessagesVisibleAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsApproximateNumberOfMessagesVisibleAlarmProps",
    jsii_struct_bases=[SqsApproximateNumberOfMessagesVisibleAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "queue": "queue",
    },
)
class SqsApproximateNumberOfMessagesVisibleAlarmProps(
    SqsApproximateNumberOfMessagesVisibleAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
    ) -> None:
        '''Properties for the SqsApproximateNumberOfMessagesVisibleAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. An unexpectedly high number of messages visible indicates that messages are not being processed by a consumer at the expected rate. You should consider historical data when you set this threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - ApproximateNumberOfMessagesVisible'
        :param queue: The SQS queue for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8fb5bc4d73a65dccff1e81a21bd7c4c930f37e13143da72353844ec71b54e125)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
            "queue": queue,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value against which the specified statistic is compared.

        An unexpectedly high number of messages visible indicates that messages are not being
        processed by a consumer at the expected rate. You should consider historical data when
        you set this threshold.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to detect a high number of in-flight messages with respect to QueueName.
        For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - queue.queueName + ' - ApproximateNumberOfMessagesVisible'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def queue(self) -> _aws_cdk_aws_sqs_ceddda9d.IQueue:
        '''The SQS queue for which to create the alarm.'''
        result = self._values.get("queue")
        assert result is not None, "Required property 'queue' is missing"
        return typing.cast(_aws_cdk_aws_sqs_ceddda9d.IQueue, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsApproximateNumberOfMessagesVisibleAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SqsNumberOfMessagesSentAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsNumberOfMessagesSentAlarm",
):
    '''An alarm that watches the number of messages that are sent.

    This alarm is used to detect when a producer stops sending messages.

    This alarm is triggered when the number of messages sent is less than
    or equal to the specified threshold. By default, 0.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param queue: The SQS queue for which to create the alarm.
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - NumberOfMessagesSent'
        :param threshold: The value against which the specified statistic is compared. If the number of messages sent is 0, the producer is not sending any messages. If this queue has a low TPS, increase the number of EvaluationPeriods accordingly. Default: 0
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c83cc6f93b61287db8574d8fe0172a074b7e233a8e19487d23a436aadfc46237)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SqsNumberOfMessagesSentAlarmProps(
            queue=queue,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            threshold=threshold,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsNumberOfMessagesSentAlarmConfig",
    jsii_struct_bases=[SqsAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "threshold": "threshold",
    },
)
class SqsNumberOfMessagesSentAlarmConfig(SqsAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the NumberOfMessagesSent alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - NumberOfMessagesSent'
        :param threshold: The value against which the specified statistic is compared. If the number of messages sent is 0, the producer is not sending any messages. If this queue has a low TPS, increase the number of EvaluationPeriods accordingly. Default: 0
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a5a27b809a4469882ad8e6a5ad6df46efd97d656d0a63ccc9ef71906dc194139)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to detect a high number of in-flight messages with respect
        to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - queue.queueName + ' - NumberOfMessagesSent'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        If the number of messages sent is 0, the producer is not sending any messages.
        If this queue has a low TPS, increase the number of EvaluationPeriods accordingly.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsNumberOfMessagesSentAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsNumberOfMessagesSentAlarmProps",
    jsii_struct_bases=[SqsNumberOfMessagesSentAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "threshold": "threshold",
        "queue": "queue",
    },
)
class SqsNumberOfMessagesSentAlarmProps(SqsNumberOfMessagesSentAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
    ) -> None:
        '''Properties for the SqsNumberOfMessagesSentAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm helps to detect a high number of in-flight messages with respect to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        :param alarm_name: The alarm name. Default: - queue.queueName + ' - NumberOfMessagesSent'
        :param threshold: The value against which the specified statistic is compared. If the number of messages sent is 0, the producer is not sending any messages. If this queue has a low TPS, increase the number of EvaluationPeriods accordingly. Default: 0
        :param queue: The SQS queue for which to create the alarm.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0793f6ef8158a82e9718505397a2f6f689150450cf683f7dc859408933d841e7)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "queue": queue,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm helps to detect a high number of in-flight messages with respect
        to QueueName. For troubleshooting, check message backlog decreasing (https://repost.aws/knowledge-center/sqs-message-backlog).
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - queue.queueName + ' - NumberOfMessagesSent'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        If the number of messages sent is 0, the producer is not sending any messages.
        If this queue has a low TPS, increase the number of EvaluationPeriods accordingly.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def queue(self) -> _aws_cdk_aws_sqs_ceddda9d.IQueue:
        '''The SQS queue for which to create the alarm.'''
        result = self._values.get("queue")
        assert result is not None, "Required property 'queue' is missing"
        return typing.cast(_aws_cdk_aws_sqs_ceddda9d.IQueue, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsNumberOfMessagesSentAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class SqsRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsRecommendedAlarms",
):
    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
        config_approximate_age_of_oldest_message_alarm: typing.Union[SqsApproximateAgeOfOldestMessageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_approximate_number_of_messages_not_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesNotVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_approximate_number_of_messages_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_dlq_approximate_number_of_messages_visible_alarm: typing.Optional[typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_messages_sent_alarm: typing.Optional[typing.Union[SqsNumberOfMessagesSentAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        dlqs_get_full_recommended_alarms: typing.Optional[builtins.bool] = None,
        exclude_alarms: typing.Optional[typing.Sequence["SqsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param queue: The SQS queue for which to create the alarms.
        :param config_approximate_age_of_oldest_message_alarm: The configuration for the approximate age of oldest message alarm.
        :param config_approximate_number_of_messages_not_visible_alarm: The configuration for the approximate number of messages not visible alarm.
        :param config_approximate_number_of_messages_visible_alarm: The configuration for the approximate number of messages visible alarm.
        :param config_dlq_approximate_number_of_messages_visible_alarm: The configuration for the approximate number of messages visible alarm for DLQs. This is used for dead letter queues only. The threshold is set to 0 by default.
        :param config_number_of_messages_sent_alarm: The configuration for the number of messages sent alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param dlqs_get_full_recommended_alarms: Whether to apply the usual recommended alarms to dead letter queues. If true, the dead letter queues will have the same alarms as normal queues. If false, the dead letter queues will only have the ApproximateNumberOfMessagesVisible alarm with a default threshold of 0. Default: false
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__7a37434be382ee9bdf1fa47a726cbedf3dab305255578301f29d8d0427d0ed9d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = SqsRecommendedAlarmsProps(
            queue=queue,
            config_approximate_age_of_oldest_message_alarm=config_approximate_age_of_oldest_message_alarm,
            config_approximate_number_of_messages_not_visible_alarm=config_approximate_number_of_messages_not_visible_alarm,
            config_approximate_number_of_messages_visible_alarm=config_approximate_number_of_messages_visible_alarm,
            config_dlq_approximate_number_of_messages_visible_alarm=config_dlq_approximate_number_of_messages_visible_alarm,
            config_number_of_messages_sent_alarm=config_number_of_messages_sent_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            dlqs_get_full_recommended_alarms=dlqs_get_full_recommended_alarms,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmApproximateAgeOfOldestMessage")
    def alarm_approximate_age_of_oldest_message(
        self,
    ) -> typing.Optional[SqsApproximateAgeOfOldestMessageAlarm]:
        '''The approximate age of oldest message alarm.'''
        return typing.cast(typing.Optional[SqsApproximateAgeOfOldestMessageAlarm], jsii.get(self, "alarmApproximateAgeOfOldestMessage"))

    @builtins.property
    @jsii.member(jsii_name="alarmApproximateNumberOfMessagesNotVisible")
    def alarm_approximate_number_of_messages_not_visible(
        self,
    ) -> typing.Optional[SqsApproximateNumberOfMessagesNotVisibleAlarm]:
        '''The approximate number of messages not visible alarm.'''
        return typing.cast(typing.Optional[SqsApproximateNumberOfMessagesNotVisibleAlarm], jsii.get(self, "alarmApproximateNumberOfMessagesNotVisible"))

    @builtins.property
    @jsii.member(jsii_name="alarmApproximateNumberOfMessagesVisible")
    def alarm_approximate_number_of_messages_visible(
        self,
    ) -> typing.Optional[SqsApproximateNumberOfMessagesVisibleAlarm]:
        '''The approximate number of messages visible alarm.'''
        return typing.cast(typing.Optional[SqsApproximateNumberOfMessagesVisibleAlarm], jsii.get(self, "alarmApproximateNumberOfMessagesVisible"))

    @builtins.property
    @jsii.member(jsii_name="alarmNumberOfMessagesSent")
    def alarm_number_of_messages_sent(
        self,
    ) -> typing.Optional[SqsNumberOfMessagesSentAlarm]:
        '''The number of messages sent alarm.'''
        return typing.cast(typing.Optional[SqsNumberOfMessagesSentAlarm], jsii.get(self, "alarmNumberOfMessagesSent"))


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class SqsRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsRecommendedAlarmsAspect",
):
    '''Configured the recommended alarms for an SQS queue.

    Requires defining thresholds for some alarms.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#SQS
    '''

    def __init__(
        self,
        *,
        config_approximate_age_of_oldest_message_alarm: typing.Union[SqsApproximateAgeOfOldestMessageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_approximate_number_of_messages_not_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesNotVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_approximate_number_of_messages_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_dlq_approximate_number_of_messages_visible_alarm: typing.Optional[typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_messages_sent_alarm: typing.Optional[typing.Union[SqsNumberOfMessagesSentAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        dlqs_get_full_recommended_alarms: typing.Optional[builtins.bool] = None,
        exclude_alarms: typing.Optional[typing.Sequence["SqsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_approximate_age_of_oldest_message_alarm: The configuration for the approximate age of oldest message alarm.
        :param config_approximate_number_of_messages_not_visible_alarm: The configuration for the approximate number of messages not visible alarm.
        :param config_approximate_number_of_messages_visible_alarm: The configuration for the approximate number of messages visible alarm.
        :param config_dlq_approximate_number_of_messages_visible_alarm: The configuration for the approximate number of messages visible alarm for DLQs. This is used for dead letter queues only. The threshold is set to 0 by default.
        :param config_number_of_messages_sent_alarm: The configuration for the number of messages sent alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param dlqs_get_full_recommended_alarms: Whether to apply the usual recommended alarms to dead letter queues. If true, the dead letter queues will have the same alarms as normal queues. If false, the dead letter queues will only have the ApproximateNumberOfMessagesVisible alarm with a default threshold of 0. Default: false
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SqsRecommendedAlarmsConfig(
            config_approximate_age_of_oldest_message_alarm=config_approximate_age_of_oldest_message_alarm,
            config_approximate_number_of_messages_not_visible_alarm=config_approximate_number_of_messages_not_visible_alarm,
            config_approximate_number_of_messages_visible_alarm=config_approximate_number_of_messages_visible_alarm,
            config_dlq_approximate_number_of_messages_visible_alarm=config_dlq_approximate_number_of_messages_visible_alarm,
            config_number_of_messages_sent_alarm=config_number_of_messages_sent_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            dlqs_get_full_recommended_alarms=dlqs_get_full_recommended_alarms,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f45c71a79fad93ee92684dc7ebe5ea477b90eedb43380589ebe7c41ecb444281)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))

    @builtins.property
    @jsii.member(jsii_name="deadLetterQueues")
    def dead_letter_queues(self) -> typing.List[builtins.str]:
        '''A list of dead letter queues discovered in the scope.

        We exclude these from the recommended alarms
        because they don't make sense.
        '''
        return typing.cast(typing.List[builtins.str], jsii.get(self, "deadLetterQueues"))

    @dead_letter_queues.setter
    def dead_letter_queues(self, value: typing.List[builtins.str]) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__8c678fa9be1dcd6d4347df821d14deb2ed1343e6e74541d15ee2c5175544bc20)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deadLetterQueues", value) # pyright: ignore[reportArgumentType]

    @builtins.property
    @jsii.member(jsii_name="deadLetterQueuesDiscovered")
    def dead_letter_queues_discovered(self) -> builtins.bool:
        '''A flag to indicate whether dead letter queues have been discovered.

        This is used to prevent running the discovery logic on every call to ``visit``.
        '''
        return typing.cast(builtins.bool, jsii.get(self, "deadLetterQueuesDiscovered"))

    @dead_letter_queues_discovered.setter
    def dead_letter_queues_discovered(self, value: builtins.bool) -> None:
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e486874f28bb3264a44a71dba7087b0c891a7fb880e21b2c6a66b837f0a351a1)
            check_type(argname="argument value", value=value, expected_type=type_hints["value"])
        jsii.set(self, "deadLetterQueuesDiscovered", value) # pyright: ignore[reportArgumentType]


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_approximate_age_of_oldest_message_alarm": "configApproximateAgeOfOldestMessageAlarm",
        "config_approximate_number_of_messages_not_visible_alarm": "configApproximateNumberOfMessagesNotVisibleAlarm",
        "config_approximate_number_of_messages_visible_alarm": "configApproximateNumberOfMessagesVisibleAlarm",
        "config_dlq_approximate_number_of_messages_visible_alarm": "configDlqApproximateNumberOfMessagesVisibleAlarm",
        "config_number_of_messages_sent_alarm": "configNumberOfMessagesSentAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "dlqs_get_full_recommended_alarms": "dlqsGetFullRecommendedAlarms",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class SqsRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_approximate_age_of_oldest_message_alarm: typing.Union[SqsApproximateAgeOfOldestMessageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_approximate_number_of_messages_not_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesNotVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_approximate_number_of_messages_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_dlq_approximate_number_of_messages_visible_alarm: typing.Optional[typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_messages_sent_alarm: typing.Optional[typing.Union[SqsNumberOfMessagesSentAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        dlqs_get_full_recommended_alarms: typing.Optional[builtins.bool] = None,
        exclude_alarms: typing.Optional[typing.Sequence["SqsRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configuration for the recommended alarms for an SQS queue.

        :param config_approximate_age_of_oldest_message_alarm: The configuration for the approximate age of oldest message alarm.
        :param config_approximate_number_of_messages_not_visible_alarm: The configuration for the approximate number of messages not visible alarm.
        :param config_approximate_number_of_messages_visible_alarm: The configuration for the approximate number of messages visible alarm.
        :param config_dlq_approximate_number_of_messages_visible_alarm: The configuration for the approximate number of messages visible alarm for DLQs. This is used for dead letter queues only. The threshold is set to 0 by default.
        :param config_number_of_messages_sent_alarm: The configuration for the number of messages sent alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param dlqs_get_full_recommended_alarms: Whether to apply the usual recommended alarms to dead letter queues. If true, the dead letter queues will have the same alarms as normal queues. If false, the dead letter queues will only have the ApproximateNumberOfMessagesVisible alarm with a default threshold of 0. Default: false
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_approximate_age_of_oldest_message_alarm, dict):
            config_approximate_age_of_oldest_message_alarm = SqsApproximateAgeOfOldestMessageAlarmConfig(**config_approximate_age_of_oldest_message_alarm)
        if isinstance(config_approximate_number_of_messages_not_visible_alarm, dict):
            config_approximate_number_of_messages_not_visible_alarm = SqsApproximateNumberOfMessagesNotVisibleAlarmConfig(**config_approximate_number_of_messages_not_visible_alarm)
        if isinstance(config_approximate_number_of_messages_visible_alarm, dict):
            config_approximate_number_of_messages_visible_alarm = SqsApproximateNumberOfMessagesVisibleAlarmConfig(**config_approximate_number_of_messages_visible_alarm)
        if isinstance(config_dlq_approximate_number_of_messages_visible_alarm, dict):
            config_dlq_approximate_number_of_messages_visible_alarm = SqsApproximateNumberOfMessagesVisibleAlarmConfig(**config_dlq_approximate_number_of_messages_visible_alarm)
        if isinstance(config_number_of_messages_sent_alarm, dict):
            config_number_of_messages_sent_alarm = SqsNumberOfMessagesSentAlarmConfig(**config_number_of_messages_sent_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__407cc33cddff7246efd0e7d0b66c4c79e9d85a4263615880ce742c9bc4fc1820)
            check_type(argname="argument config_approximate_age_of_oldest_message_alarm", value=config_approximate_age_of_oldest_message_alarm, expected_type=type_hints["config_approximate_age_of_oldest_message_alarm"])
            check_type(argname="argument config_approximate_number_of_messages_not_visible_alarm", value=config_approximate_number_of_messages_not_visible_alarm, expected_type=type_hints["config_approximate_number_of_messages_not_visible_alarm"])
            check_type(argname="argument config_approximate_number_of_messages_visible_alarm", value=config_approximate_number_of_messages_visible_alarm, expected_type=type_hints["config_approximate_number_of_messages_visible_alarm"])
            check_type(argname="argument config_dlq_approximate_number_of_messages_visible_alarm", value=config_dlq_approximate_number_of_messages_visible_alarm, expected_type=type_hints["config_dlq_approximate_number_of_messages_visible_alarm"])
            check_type(argname="argument config_number_of_messages_sent_alarm", value=config_number_of_messages_sent_alarm, expected_type=type_hints["config_number_of_messages_sent_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument dlqs_get_full_recommended_alarms", value=dlqs_get_full_recommended_alarms, expected_type=type_hints["dlqs_get_full_recommended_alarms"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_approximate_age_of_oldest_message_alarm": config_approximate_age_of_oldest_message_alarm,
            "config_approximate_number_of_messages_not_visible_alarm": config_approximate_number_of_messages_not_visible_alarm,
            "config_approximate_number_of_messages_visible_alarm": config_approximate_number_of_messages_visible_alarm,
        }
        if config_dlq_approximate_number_of_messages_visible_alarm is not None:
            self._values["config_dlq_approximate_number_of_messages_visible_alarm"] = config_dlq_approximate_number_of_messages_visible_alarm
        if config_number_of_messages_sent_alarm is not None:
            self._values["config_number_of_messages_sent_alarm"] = config_number_of_messages_sent_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if dlqs_get_full_recommended_alarms is not None:
            self._values["dlqs_get_full_recommended_alarms"] = dlqs_get_full_recommended_alarms
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_approximate_age_of_oldest_message_alarm(
        self,
    ) -> SqsApproximateAgeOfOldestMessageAlarmConfig:
        '''The configuration for the approximate age of oldest message alarm.'''
        result = self._values.get("config_approximate_age_of_oldest_message_alarm")
        assert result is not None, "Required property 'config_approximate_age_of_oldest_message_alarm' is missing"
        return typing.cast(SqsApproximateAgeOfOldestMessageAlarmConfig, result)

    @builtins.property
    def config_approximate_number_of_messages_not_visible_alarm(
        self,
    ) -> SqsApproximateNumberOfMessagesNotVisibleAlarmConfig:
        '''The configuration for the approximate number of messages not visible alarm.'''
        result = self._values.get("config_approximate_number_of_messages_not_visible_alarm")
        assert result is not None, "Required property 'config_approximate_number_of_messages_not_visible_alarm' is missing"
        return typing.cast(SqsApproximateNumberOfMessagesNotVisibleAlarmConfig, result)

    @builtins.property
    def config_approximate_number_of_messages_visible_alarm(
        self,
    ) -> SqsApproximateNumberOfMessagesVisibleAlarmConfig:
        '''The configuration for the approximate number of messages visible alarm.'''
        result = self._values.get("config_approximate_number_of_messages_visible_alarm")
        assert result is not None, "Required property 'config_approximate_number_of_messages_visible_alarm' is missing"
        return typing.cast(SqsApproximateNumberOfMessagesVisibleAlarmConfig, result)

    @builtins.property
    def config_dlq_approximate_number_of_messages_visible_alarm(
        self,
    ) -> typing.Optional[SqsApproximateNumberOfMessagesVisibleAlarmConfig]:
        '''The configuration for the approximate number of messages visible alarm for DLQs.

        This is used for dead letter queues only. The threshold is set to 0 by default.
        '''
        result = self._values.get("config_dlq_approximate_number_of_messages_visible_alarm")
        return typing.cast(typing.Optional[SqsApproximateNumberOfMessagesVisibleAlarmConfig], result)

    @builtins.property
    def config_number_of_messages_sent_alarm(
        self,
    ) -> typing.Optional[SqsNumberOfMessagesSentAlarmConfig]:
        '''The configuration for the number of messages sent alarm.'''
        result = self._values.get("config_number_of_messages_sent_alarm")
        return typing.cast(typing.Optional[SqsNumberOfMessagesSentAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def dlqs_get_full_recommended_alarms(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply the usual recommended alarms to dead letter queues.

        If true, the dead letter queues will have the same alarms as normal queues.
        If false, the dead letter queues will only have the ApproximateNumberOfMessagesVisible
        alarm with a default threshold of 0.

        :default: false
        '''
        result = self._values.get("dlqs_get_full_recommended_alarms")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["SqsRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["SqsRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsRecommendedAlarmsMetrics"
)
class SqsRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for SQS queue alarms.'''

    APPROXIMATE_AGE_OF_OLDEST_MESSAGE = "APPROXIMATE_AGE_OF_OLDEST_MESSAGE"
    APPROXIMATE_NUMBER_OF_MESSAGES_NOT_VISIBLE = "APPROXIMATE_NUMBER_OF_MESSAGES_NOT_VISIBLE"
    APPROXIMATE_NUMBER_OF_MESSAGES_VISIBLE = "APPROXIMATE_NUMBER_OF_MESSAGES_VISIBLE"
    NUMBER_OF_MESSAGES_SENT = "NUMBER_OF_MESSAGES_SENT"


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.SqsRecommendedAlarmsProps",
    jsii_struct_bases=[SqsRecommendedAlarmsConfig],
    name_mapping={
        "config_approximate_age_of_oldest_message_alarm": "configApproximateAgeOfOldestMessageAlarm",
        "config_approximate_number_of_messages_not_visible_alarm": "configApproximateNumberOfMessagesNotVisibleAlarm",
        "config_approximate_number_of_messages_visible_alarm": "configApproximateNumberOfMessagesVisibleAlarm",
        "config_dlq_approximate_number_of_messages_visible_alarm": "configDlqApproximateNumberOfMessagesVisibleAlarm",
        "config_number_of_messages_sent_alarm": "configNumberOfMessagesSentAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "dlqs_get_full_recommended_alarms": "dlqsGetFullRecommendedAlarms",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "queue": "queue",
    },
)
class SqsRecommendedAlarmsProps(SqsRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config_approximate_age_of_oldest_message_alarm: typing.Union[SqsApproximateAgeOfOldestMessageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_approximate_number_of_messages_not_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesNotVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_approximate_number_of_messages_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_dlq_approximate_number_of_messages_visible_alarm: typing.Optional[typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_messages_sent_alarm: typing.Optional[typing.Union[SqsNumberOfMessagesSentAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        dlqs_get_full_recommended_alarms: typing.Optional[builtins.bool] = None,
        exclude_alarms: typing.Optional[typing.Sequence[SqsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
    ) -> None:
        '''Properties for the SqsRecommendedAlarms construct.

        :param config_approximate_age_of_oldest_message_alarm: The configuration for the approximate age of oldest message alarm.
        :param config_approximate_number_of_messages_not_visible_alarm: The configuration for the approximate number of messages not visible alarm.
        :param config_approximate_number_of_messages_visible_alarm: The configuration for the approximate number of messages visible alarm.
        :param config_dlq_approximate_number_of_messages_visible_alarm: The configuration for the approximate number of messages visible alarm for DLQs. This is used for dead letter queues only. The threshold is set to 0 by default.
        :param config_number_of_messages_sent_alarm: The configuration for the number of messages sent alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param dlqs_get_full_recommended_alarms: Whether to apply the usual recommended alarms to dead letter queues. If true, the dead letter queues will have the same alarms as normal queues. If false, the dead letter queues will only have the ApproximateNumberOfMessagesVisible alarm with a default threshold of 0. Default: false
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param queue: The SQS queue for which to create the alarms.
        '''
        if isinstance(config_approximate_age_of_oldest_message_alarm, dict):
            config_approximate_age_of_oldest_message_alarm = SqsApproximateAgeOfOldestMessageAlarmConfig(**config_approximate_age_of_oldest_message_alarm)
        if isinstance(config_approximate_number_of_messages_not_visible_alarm, dict):
            config_approximate_number_of_messages_not_visible_alarm = SqsApproximateNumberOfMessagesNotVisibleAlarmConfig(**config_approximate_number_of_messages_not_visible_alarm)
        if isinstance(config_approximate_number_of_messages_visible_alarm, dict):
            config_approximate_number_of_messages_visible_alarm = SqsApproximateNumberOfMessagesVisibleAlarmConfig(**config_approximate_number_of_messages_visible_alarm)
        if isinstance(config_dlq_approximate_number_of_messages_visible_alarm, dict):
            config_dlq_approximate_number_of_messages_visible_alarm = SqsApproximateNumberOfMessagesVisibleAlarmConfig(**config_dlq_approximate_number_of_messages_visible_alarm)
        if isinstance(config_number_of_messages_sent_alarm, dict):
            config_number_of_messages_sent_alarm = SqsNumberOfMessagesSentAlarmConfig(**config_number_of_messages_sent_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__32e30f379dd47a0ddb371ae48cd5f2d74faa779b4377f94f691abc36732d99fc)
            check_type(argname="argument config_approximate_age_of_oldest_message_alarm", value=config_approximate_age_of_oldest_message_alarm, expected_type=type_hints["config_approximate_age_of_oldest_message_alarm"])
            check_type(argname="argument config_approximate_number_of_messages_not_visible_alarm", value=config_approximate_number_of_messages_not_visible_alarm, expected_type=type_hints["config_approximate_number_of_messages_not_visible_alarm"])
            check_type(argname="argument config_approximate_number_of_messages_visible_alarm", value=config_approximate_number_of_messages_visible_alarm, expected_type=type_hints["config_approximate_number_of_messages_visible_alarm"])
            check_type(argname="argument config_dlq_approximate_number_of_messages_visible_alarm", value=config_dlq_approximate_number_of_messages_visible_alarm, expected_type=type_hints["config_dlq_approximate_number_of_messages_visible_alarm"])
            check_type(argname="argument config_number_of_messages_sent_alarm", value=config_number_of_messages_sent_alarm, expected_type=type_hints["config_number_of_messages_sent_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument dlqs_get_full_recommended_alarms", value=dlqs_get_full_recommended_alarms, expected_type=type_hints["dlqs_get_full_recommended_alarms"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument queue", value=queue, expected_type=type_hints["queue"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_approximate_age_of_oldest_message_alarm": config_approximate_age_of_oldest_message_alarm,
            "config_approximate_number_of_messages_not_visible_alarm": config_approximate_number_of_messages_not_visible_alarm,
            "config_approximate_number_of_messages_visible_alarm": config_approximate_number_of_messages_visible_alarm,
            "queue": queue,
        }
        if config_dlq_approximate_number_of_messages_visible_alarm is not None:
            self._values["config_dlq_approximate_number_of_messages_visible_alarm"] = config_dlq_approximate_number_of_messages_visible_alarm
        if config_number_of_messages_sent_alarm is not None:
            self._values["config_number_of_messages_sent_alarm"] = config_number_of_messages_sent_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if dlqs_get_full_recommended_alarms is not None:
            self._values["dlqs_get_full_recommended_alarms"] = dlqs_get_full_recommended_alarms
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_approximate_age_of_oldest_message_alarm(
        self,
    ) -> SqsApproximateAgeOfOldestMessageAlarmConfig:
        '''The configuration for the approximate age of oldest message alarm.'''
        result = self._values.get("config_approximate_age_of_oldest_message_alarm")
        assert result is not None, "Required property 'config_approximate_age_of_oldest_message_alarm' is missing"
        return typing.cast(SqsApproximateAgeOfOldestMessageAlarmConfig, result)

    @builtins.property
    def config_approximate_number_of_messages_not_visible_alarm(
        self,
    ) -> SqsApproximateNumberOfMessagesNotVisibleAlarmConfig:
        '''The configuration for the approximate number of messages not visible alarm.'''
        result = self._values.get("config_approximate_number_of_messages_not_visible_alarm")
        assert result is not None, "Required property 'config_approximate_number_of_messages_not_visible_alarm' is missing"
        return typing.cast(SqsApproximateNumberOfMessagesNotVisibleAlarmConfig, result)

    @builtins.property
    def config_approximate_number_of_messages_visible_alarm(
        self,
    ) -> SqsApproximateNumberOfMessagesVisibleAlarmConfig:
        '''The configuration for the approximate number of messages visible alarm.'''
        result = self._values.get("config_approximate_number_of_messages_visible_alarm")
        assert result is not None, "Required property 'config_approximate_number_of_messages_visible_alarm' is missing"
        return typing.cast(SqsApproximateNumberOfMessagesVisibleAlarmConfig, result)

    @builtins.property
    def config_dlq_approximate_number_of_messages_visible_alarm(
        self,
    ) -> typing.Optional[SqsApproximateNumberOfMessagesVisibleAlarmConfig]:
        '''The configuration for the approximate number of messages visible alarm for DLQs.

        This is used for dead letter queues only. The threshold is set to 0 by default.
        '''
        result = self._values.get("config_dlq_approximate_number_of_messages_visible_alarm")
        return typing.cast(typing.Optional[SqsApproximateNumberOfMessagesVisibleAlarmConfig], result)

    @builtins.property
    def config_number_of_messages_sent_alarm(
        self,
    ) -> typing.Optional[SqsNumberOfMessagesSentAlarmConfig]:
        '''The configuration for the number of messages sent alarm.'''
        result = self._values.get("config_number_of_messages_sent_alarm")
        return typing.cast(typing.Optional[SqsNumberOfMessagesSentAlarmConfig], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def dlqs_get_full_recommended_alarms(self) -> typing.Optional[builtins.bool]:
        '''Whether to apply the usual recommended alarms to dead letter queues.

        If true, the dead letter queues will have the same alarms as normal queues.
        If false, the dead letter queues will only have the ApproximateNumberOfMessagesVisible
        alarm with a default threshold of 0.

        :default: false
        '''
        result = self._values.get("dlqs_get_full_recommended_alarms")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[SqsRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[SqsRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def queue(self) -> _aws_cdk_aws_sqs_ceddda9d.IQueue:
        '''The SQS queue for which to create the alarms.'''
        result = self._values.get("queue")
        assert result is not None, "Required property 'queue' is missing"
        return typing.cast(_aws_cdk_aws_sqs_ceddda9d.IQueue, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "SqsRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StateMachine(
    _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.StateMachine",
):
    '''An extension for the StateMachine construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        comment: typing.Optional[builtins.str] = None,
        definition: typing.Optional[_aws_cdk_aws_stepfunctions_ceddda9d.IChainable] = None,
        definition_body: typing.Optional[_aws_cdk_aws_stepfunctions_ceddda9d.DefinitionBody] = None,
        definition_substitutions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        encryption_configuration: typing.Optional[_aws_cdk_aws_stepfunctions_ceddda9d.EncryptionConfiguration] = None,
        logs: typing.Optional[typing.Union[_aws_cdk_aws_stepfunctions_ceddda9d.LogOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        query_language: typing.Optional[_aws_cdk_aws_stepfunctions_ceddda9d.QueryLanguage] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        state_machine_name: typing.Optional[builtins.str] = None,
        state_machine_type: typing.Optional[_aws_cdk_aws_stepfunctions_ceddda9d.StateMachineType] = None,
        timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        tracing_enabled: typing.Optional[builtins.bool] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param comment: Comment that describes this state machine. Default: - No comment
        :param definition: (deprecated) Definition for this state machine.
        :param definition_body: Definition for this state machine.
        :param definition_substitutions: substitutions for the definition body as a key-value map.
        :param encryption_configuration: Configures server-side encryption of the state machine definition and execution history. Default: - data is transparently encrypted using an AWS owned key
        :param logs: Defines what execution history events are logged and where they are logged. Default: No logging
        :param query_language: The name of the query language used by the state machine. If the state does not contain a ``queryLanguage`` field, then it will use the query language specified in this ``queryLanguage`` field. Default: - JSON_PATH
        :param removal_policy: The removal policy to apply to state machine. Default: RemovalPolicy.DESTROY
        :param role: The execution role for the state machine service. Default: A role is automatically created
        :param state_machine_name: A name for the state machine. Default: A name is automatically generated
        :param state_machine_type: Type of the state machine. Default: StateMachineType.STANDARD
        :param timeout: Maximum run time for this state machine. Default: No timeout
        :param tracing_enabled: Specifies whether Amazon X-Ray tracing is enabled for this state machine. Default: false
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c1488e71ddba9444ff382477fe0ab220c0f046bbe7f54454c01b2797376287e8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_stepfunctions_ceddda9d.StateMachineProps(
            comment=comment,
            definition=definition,
            definition_body=definition_body,
            definition_substitutions=definition_substitutions,
            encryption_configuration=encryption_configuration,
            logs=logs,
            query_language=query_language,
            removal_policy=removal_policy,
            role=role,
            state_machine_name=state_machine_name,
            state_machine_type=state_machine_type,
            timeout=timeout,
            tracing_enabled=tracing_enabled,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmExecutionsFailed")
    def alarm_executions_failed(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SfStateMachineExecutionsFailedAlarm:
        '''Creates an alarm that monitors the ExecutionsFailed for the StepFunctions stateMachine.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect workflows that are not working as expected.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionsFailed'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: It helps in tracking the number of executions that fail in AWS Step Functions. This is crucial for identifying workflows that are not performing as expected and require attention. By monitoring the failures, developers can proactively identify and resolve issues before they impact the business operations. This reduces downtime and improves the overall stability of applications. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SfStateMachineExecutionsFailedAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SfStateMachineExecutionsFailedAlarm, jsii.invoke(self, "alarmExecutionsFailed", [props]))

    @jsii.member(jsii_name="alarmExecutionsTimedOut")
    def alarm_executions_timed_out(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SfStateMachineExecutionsTimedOutAlarm:
        '''Creates an alarm that monitors the ExecutionsTimedOut for the StepFunctions stateMachine.

        :param alarm_description: The description of the alarm. Default: - This alarm helps in identifying timeouts in state machine executions due to poor configuration, inadequate resource allocation, or issues in the called services that need addressing.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionsTimedOut'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: It helps in identifying timeouts in state machine executions, which can indicate problems like poor configuration, inadequate resource allocation, or issues in the called services that need addressing. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SfStateMachineExecutionsTimedOutAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SfStateMachineExecutionsTimedOutAlarm, jsii.invoke(self, "alarmExecutionsTimedOut", [props]))

    @jsii.member(jsii_name="alarmExecutionThrottled")
    def alarm_execution_throttled(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SfStateMachineExecutionThrottledAlarm:
        '''Creates an alarm that monitors the ExecutionThrottled for the StepFunctions stateMachine.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect throttled executions due to exceeding AWS service limits.
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionThrottled'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The ExecutionThrottled metric tracks the number of times state machine executions are throttled due to exceeding AWS service limits. Monitoring this can help you identify when you are hitting this limits, which could signal that adjustments need to be made either in the process design or in the service limits themselves. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SfStateMachineExecutionThrottledAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SfStateMachineExecutionThrottledAlarm, jsii.invoke(self, "alarmExecutionThrottled", [props]))

    @jsii.member(jsii_name="alarmExecutionTime")
    def alarm_execution_time(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SfStateMachineExecutionTimeAlarm:
        '''Creates an alarm that monitors the ExecutionTime for the StepFunctions stateMachine.

        :param threshold: A sudden increase in execution time might indicate issues with the steps of the resources they interact with. Consider setting a threshold (in milliseconds) that is appropriate for the expected execution time of the state machine. Default: None
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect sudden increases in execution time..
        :param alarm_name: The alarm name. Default: - stateMachineName + ' - ExecutionTime'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SfStateMachineExecutionTimeAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SfStateMachineExecutionTimeAlarm, jsii.invoke(self, "alarmExecutionTime", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_execution_time_alarm: typing.Union[SfStateMachineExecutionTimeAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_executions_failed_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_executions_timed_out_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsTimedOutAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_execution_throttled_alarm: typing.Optional[typing.Union[SfStateMachineExecutionThrottledAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[SfRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SfStateMachineRecommendedAlarms:
        '''Creates the recommended alarms for the StepFunctions StateMachine.

        :param config_execution_time_alarm: The configuration for the ExecutionTime alarm.
        :param config_executions_failed_alarm: The configuration for the ExecutionsFailed alarm.
        :param config_executions_timed_out_alarm: The configuration for the ExecutionsFailed alarm.
        :param config_execution_throttled_alarm: The configuration for the ExecutionThrottled alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SfStateMachineRecommendedAlarmsConfig(
            config_execution_time_alarm=config_execution_time_alarm,
            config_executions_failed_alarm=config_executions_failed_alarm,
            config_executions_timed_out_alarm=config_executions_timed_out_alarm,
            config_execution_throttled_alarm=config_execution_throttled_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SfStateMachineRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))


class Table(
    _aws_cdk_aws_dynamodb_ceddda9d.Table,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Table",
):
    '''An extension for the Table construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        kinesis_precision_timestamp: typing.Optional[_aws_cdk_aws_dynamodb_ceddda9d.ApproximateCreationDateTimePrecision] = None,
        kinesis_stream: typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream] = None,
        table_name: typing.Optional[builtins.str] = None,
        billing_mode: typing.Optional[_aws_cdk_aws_dynamodb_ceddda9d.BillingMode] = None,
        contributor_insights_enabled: typing.Optional[builtins.bool] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        encryption: typing.Optional[_aws_cdk_aws_dynamodb_ceddda9d.TableEncryption] = None,
        encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        import_source: typing.Optional[typing.Union[_aws_cdk_aws_dynamodb_ceddda9d.ImportSourceSpecification, typing.Dict[builtins.str, typing.Any]]] = None,
        max_read_request_units: typing.Optional[jsii.Number] = None,
        max_write_request_units: typing.Optional[jsii.Number] = None,
        point_in_time_recovery: typing.Optional[builtins.bool] = None,
        point_in_time_recovery_specification: typing.Optional[typing.Union[_aws_cdk_aws_dynamodb_ceddda9d.PointInTimeRecoverySpecification, typing.Dict[builtins.str, typing.Any]]] = None,
        read_capacity: typing.Optional[jsii.Number] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        replica_removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        replication_regions: typing.Optional[typing.Sequence[builtins.str]] = None,
        replication_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        resource_policy: typing.Optional[_aws_cdk_aws_iam_ceddda9d.PolicyDocument] = None,
        stream: typing.Optional[_aws_cdk_aws_dynamodb_ceddda9d.StreamViewType] = None,
        table_class: typing.Optional[_aws_cdk_aws_dynamodb_ceddda9d.TableClass] = None,
        time_to_live_attribute: typing.Optional[builtins.str] = None,
        wait_for_replication_to_finish: typing.Optional[builtins.bool] = None,
        warm_throughput: typing.Optional[typing.Union[_aws_cdk_aws_dynamodb_ceddda9d.WarmThroughput, typing.Dict[builtins.str, typing.Any]]] = None,
        write_capacity: typing.Optional[jsii.Number] = None,
        partition_key: typing.Union[_aws_cdk_aws_dynamodb_ceddda9d.Attribute, typing.Dict[builtins.str, typing.Any]],
        sort_key: typing.Optional[typing.Union[_aws_cdk_aws_dynamodb_ceddda9d.Attribute, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param kinesis_precision_timestamp: Kinesis Data Stream approximate creation timestamp precision. Default: ApproximateCreationDateTimePrecision.MICROSECOND
        :param kinesis_stream: Kinesis Data Stream to capture item-level changes for the table. Default: - no Kinesis Data Stream
        :param table_name: Enforces a particular physical table name. Default: 
        :param billing_mode: Specify how you are charged for read and write throughput and how you manage capacity. Default: PROVISIONED if ``replicationRegions`` is not specified, PAY_PER_REQUEST otherwise
        :param contributor_insights_enabled: Whether CloudWatch contributor insights is enabled. Default: false
        :param deletion_protection: Enables deletion protection for the table. Default: false
        :param encryption: Whether server-side encryption with an AWS managed customer master key is enabled. This property cannot be set if ``serverSideEncryption`` is set. .. epigraph:: **NOTE**: if you set this to ``CUSTOMER_MANAGED`` and ``encryptionKey`` is not specified, the key that the Tablet generates for you will be created with default permissions. If you are using CDKv2, these permissions will be sufficient to enable the key for use with DynamoDB tables. If you are using CDKv1, make sure the feature flag ``@aws-cdk/aws-kms:defaultKeyPolicies`` is set to ``true`` in your ``cdk.json``. Default: - The table is encrypted with an encryption key managed by DynamoDB, and you are not charged any fee for using it.
        :param encryption_key: External KMS key to use for table encryption. This property can only be set if ``encryption`` is set to ``TableEncryption.CUSTOMER_MANAGED``. Default: - If ``encryption`` is set to ``TableEncryption.CUSTOMER_MANAGED`` and this property is undefined, a new KMS key will be created and associated with this table. If ``encryption`` and this property are both undefined, then the table is encrypted with an encryption key managed by DynamoDB, and you are not charged any fee for using it.
        :param import_source: The properties of data being imported from the S3 bucket source to the table. Default: - no data import from the S3 bucket
        :param max_read_request_units: The maximum read request units for the table. Careful if you add Global Secondary Indexes, as those will share the table's maximum on-demand throughput. Can only be provided if billingMode is PAY_PER_REQUEST. Default: - on-demand throughput is disabled
        :param max_write_request_units: The write request units for the table. Careful if you add Global Secondary Indexes, as those will share the table's maximum on-demand throughput. Can only be provided if billingMode is PAY_PER_REQUEST. Default: - on-demand throughput is disabled
        :param point_in_time_recovery: (deprecated) Whether point-in-time recovery is enabled. Default: false - point in time recovery is not enabled.
        :param point_in_time_recovery_specification: Whether point-in-time recovery is enabled and recoveryPeriodInDays is set. Default: - point in time recovery is not enabled.
        :param read_capacity: The read capacity for the table. Careful if you add Global Secondary Indexes, as those will share the table's provisioned throughput. Can only be provided if billingMode is Provisioned. Default: 5
        :param removal_policy: The removal policy to apply to the DynamoDB Table. Default: RemovalPolicy.RETAIN
        :param replica_removal_policy: The removal policy to apply to the DynamoDB replica tables. Default: undefined - use DynamoDB Table's removal policy
        :param replication_regions: Regions where replica tables will be created. Default: - no replica tables are created
        :param replication_timeout: The timeout for a table replication operation in a single region. Default: Duration.minutes(30)
        :param resource_policy: Resource policy to assign to table. Default: - No resource policy statement
        :param stream: When an item in the table is modified, StreamViewType determines what information is written to the stream for this table. Default: - streams are disabled unless ``replicationRegions`` is specified
        :param table_class: Specify the table class. Default: STANDARD
        :param time_to_live_attribute: The name of TTL attribute. Default: - TTL is disabled
        :param wait_for_replication_to_finish: [WARNING: Use this flag with caution, misusing this flag may cause deleting existing replicas, refer to the detailed documentation for more information] Indicates whether CloudFormation stack waits for replication to finish. If set to false, the CloudFormation resource will mark the resource as created and replication will be completed asynchronously. This property is ignored if replicationRegions property is not set. WARNING: DO NOT UNSET this property if adding/removing multiple replicationRegions in one deployment, as CloudFormation only supports one region replication at a time. CDK overcomes this limitation by waiting for replication to finish before starting new replicationRegion. If the custom resource which handles replication has a physical resource ID with the format ``region`` instead of ``tablename-region`` (this would happen if the custom resource hasn't received an event since v1.91.0), DO NOT SET this property to false without making a change to the table name. This will cause the existing replicas to be deleted. Default: true
        :param warm_throughput: Specify values to pre-warm you DynamoDB Table Warm Throughput feature is not available for Global Table replicas using the ``Table`` construct. To enable Warm Throughput, use the ``TableV2`` construct instead. Default: - warm throughput is not configured
        :param write_capacity: The write capacity for the table. Careful if you add Global Secondary Indexes, as those will share the table's provisioned throughput. Can only be provided if billingMode is Provisioned. Default: 5
        :param partition_key: Partition key attribute definition.
        :param sort_key: Sort key attribute definition. Default: no sort key
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__664a9c0a874f8f8cd8b72ac0153f5e19d4b791dd65cb8b898f3d5f8b617ac83a)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_dynamodb_ceddda9d.TableProps(
            kinesis_precision_timestamp=kinesis_precision_timestamp,
            kinesis_stream=kinesis_stream,
            table_name=table_name,
            billing_mode=billing_mode,
            contributor_insights_enabled=contributor_insights_enabled,
            deletion_protection=deletion_protection,
            encryption=encryption,
            encryption_key=encryption_key,
            import_source=import_source,
            max_read_request_units=max_read_request_units,
            max_write_request_units=max_write_request_units,
            point_in_time_recovery=point_in_time_recovery,
            point_in_time_recovery_specification=point_in_time_recovery_specification,
            read_capacity=read_capacity,
            removal_policy=removal_policy,
            replica_removal_policy=replica_removal_policy,
            replication_regions=replication_regions,
            replication_timeout=replication_timeout,
            resource_policy=resource_policy,
            stream=stream,
            table_class=table_class,
            time_to_live_attribute=time_to_live_attribute,
            wait_for_replication_to_finish=wait_for_replication_to_finish,
            warm_throughput=warm_throughput,
            write_capacity=write_capacity,
            partition_key=partition_key,
            sort_key=sort_key,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmAgeOfOldestUnreplicatedRecord")
    def alarm_age_of_oldest_unreplicated_record(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DynamoDbTableAgeOfOldestUnreplicatedRecordAlarm:
        '''Creates an alarm that monitors the AgeOfOldestUnreplicatedRecord for the DynamoDb table.

        :param threshold: Set the threshold according to the desired replication delay measured in milliseconds. This value depends on your workload's requirements and expected performance.
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor unsuccessful replication attempts and the resulting delay in replication to the Kinesis data stream.
        :param alarm_name: The alarm name. Default: - tableName + ' - AgeOfOldestUnreplicatedRecord'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DynamoDbTableAgeOfOldestUnreplicatedRecordAlarm, jsii.invoke(self, "alarmAgeOfOldestUnreplicatedRecord", [props]))

    @jsii.member(jsii_name="alarmFailedToReplicateRecordCount")
    def alarm_failed_to_replicate_record_count(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DynamoDbTableFailedToReplicateRecordCountAlarm:
        '''Creates an alarm that monitors the FailedToReplicateRecordCount for the DynamoDb table.

        :param alarm_description: The description of the alarm. Default: - This alarm can monitor the number of records that DynamoDB failed to replicate to your Kinesis data stream because of the item size limit of Kinesis Data Streams.
        :param alarm_name: The alarm name. Default: - tableName + ' - FailedToReplicateRecordCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 1
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 1
        :param threshold: Set the threshold to 0 to detect any records that DynamoDB failed to replicate.
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DynamoDbFailedToReplicateRecordCountAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DynamoDbTableFailedToReplicateRecordCountAlarm, jsii.invoke(self, "alarmFailedToReplicateRecordCount", [props]))

    @jsii.member(jsii_name="alarmReadThrottleEvents")
    def alarm_read_throttle_events(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DynamoDbTableReadThrottleEventsAlarm:
        '''Creates an alarm that monitors the ReadThrottleEvents for the DynamoDb table.

        :param threshold: Set the threshold according to the expected read traffic for the DynamoDB table, accounting for an acceptable level of throttling. It is important to monitor whether you are under provisioned and not causing consistent throttling. You can also analyze historical data to find the acceptable throttling level for the application workload, and then tune the threshold to be higher than your usual throttling level. Throttled requests should be retried by the application or service as they are transient. Therefore, a very low threshold may cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained throttling for read requests to the DynamoDB table. Sustained throttling of read requests can negatively impact your workload read operations and reduce the overall efficiency of the system.
        :param alarm_name: The alarm name. Default: - tableName + ' - ReadThrottleEvents'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DynamoDbReadThrottleEventsAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DynamoDbTableReadThrottleEventsAlarm, jsii.invoke(self, "alarmReadThrottleEvents", [props]))

    @jsii.member(jsii_name="alarmSystemErrors")
    def alarm_system_errors(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DynamoDbTableSystemErrorsAlarm:
        '''Creates an alarm that monitors the SystemErrors for the DynamoDb table.

        :param threshold: Set the threshold according to the expected traffic, accounting for an acceptable level of system errors. You can also analyze historical data to find the acceptable error count for the application workload, and then tune the threshold accordingly. System errors should be retried by the application/service as they are transient. Therefore, a very low threshold might cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained system errors for the DynamoDB table requests. System errors indicate internal service errors from DynamoDB and helps correlate to the issue that the client is having.
        :param alarm_name: The alarm name. Default: - tableName + ' - SystemErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DynamoDbSystemErrorsAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DynamoDbTableSystemErrorsAlarm, jsii.invoke(self, "alarmSystemErrors", [props]))

    @jsii.member(jsii_name="alarmThrottledPutRecordCount")
    def alarm_throttled_put_record_count(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DynamoDbTableThrottledPutRecordCountAlarm:
        '''Creates an alarm that monitors the ThrottledPutRecordCount for the DynamoDb table.

        :param threshold: You might experience some throttling during exceptional usage peaks, but throttled records should remain as low as possible to avoid higher replication latency (DynamoDB retries sending throttled records to the Kinesis data stream). Set the threshold to a number which can help you catch regular excessive throttling. You can also analyze historical data of this metric to find the acceptable throttling rates for the application workload. Tune the threshold to a value that the application can tolerate based on your use case.
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor the number of records that that were throttled by your Kinesis data stream because of insufficient Kinesis data stream capacity.
        :param alarm_name: The alarm name. Default: - tableName + ' - ThrottledPutRecordCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DynamoDbThrottledPutRecordCountAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DynamoDbTableThrottledPutRecordCountAlarm, jsii.invoke(self, "alarmThrottledPutRecordCount", [props]))

    @jsii.member(jsii_name="alarmWriteThrottleEvents")
    def alarm_write_throttle_events(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DynamoDbTableWriteThrottleEventsAlarm:
        '''Creates an alarm that monitors the WriteThrottleEvents for the DynamoDb table.

        :param threshold: Set the threshold according to the expected write traffic for the DynamoDB table, accounting for an acceptable level of throttling. It is important to monitor if you are under provisioned and not causing consistent throttling. You can also analyze historical data to find the acceptable level of throttling for the application workload, and then tune the threshold to a value higher than your usual acceptable throttling level. Throttled requests should be retried by the application/service as they are transient. Therefore, a very low threshold might cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained throttling for write requests to the DynamoDB table. Sustained throttling of write requests can negatively impact your workload write operations and reduce the overall efficiency of the system.
        :param alarm_name: The alarm name. Default: - tableName + ' - WriteThrottleEvents'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = DynamoDbWriteThrottleEventsAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DynamoDbTableWriteThrottleEventsAlarm, jsii.invoke(self, "alarmWriteThrottleEvents", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_read_throttle_events_alarm: typing.Union[DynamoDbReadThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_system_errors_alarm: typing.Union[DynamoDbSystemErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_write_throttle_events_alarm: typing.Union[DynamoDbWriteThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_age_of_oldest_unreplicated_record_alarm: typing.Optional[typing.Union["DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        config_failed_to_replicate_record_count_alarm: typing.Optional[typing.Union[DynamoDbFailedToReplicateRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_throttled_put_record_count_alarm: typing.Optional[typing.Union[DynamoDbThrottledPutRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[DynamoDbRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> DynamoDbTableRecommendedAlarms:
        '''Creates the recommended alarms for the DynamoDb Table.

        :param config_read_throttle_events_alarm: The configuration for the ReadThrottleEvents alarm.
        :param config_system_errors_alarm: The configuration for the SystemErrors alarm.
        :param config_write_throttle_events_alarm: The configuration for the WriteThrottleEvents alarm.
        :param config_age_of_oldest_unreplicated_record_alarm: The configuration for the AgeOfOldestUnreplicatedRecord alarm.
        :param config_failed_to_replicate_record_count_alarm: The configuration for the FailedToReplicateRecordCount alarm.
        :param config_throttled_put_record_count_alarm: The configuration for the ThrottledPutRecordCount alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#DynamoDB
        '''
        props = DynamoDbTableRecommendedAlarmsConfig(
            config_read_throttle_events_alarm=config_read_throttle_events_alarm,
            config_system_errors_alarm=config_system_errors_alarm,
            config_write_throttle_events_alarm=config_write_throttle_events_alarm,
            config_age_of_oldest_unreplicated_record_alarm=config_age_of_oldest_unreplicated_record_alarm,
            config_failed_to_replicate_record_count_alarm=config_failed_to_replicate_record_count_alarm,
            config_throttled_put_record_count_alarm=config_throttled_put_record_count_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(DynamoDbTableRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))


class Topic(
    _aws_cdk_aws_sns_ceddda9d.Topic,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Topic",
):
    '''An extension of the SNS topic construct that provides helper methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        content_based_deduplication: typing.Optional[builtins.bool] = None,
        display_name: typing.Optional[builtins.str] = None,
        enforce_ssl: typing.Optional[builtins.bool] = None,
        fifo: typing.Optional[builtins.bool] = None,
        fifo_throughput_scope: typing.Optional[_aws_cdk_aws_sns_ceddda9d.FifoThroughputScope] = None,
        logging_configs: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_sns_ceddda9d.LoggingConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
        master_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        message_retention_period_in_days: typing.Optional[jsii.Number] = None,
        signature_version: typing.Optional[builtins.str] = None,
        topic_name: typing.Optional[builtins.str] = None,
        tracing_config: typing.Optional[_aws_cdk_aws_sns_ceddda9d.TracingConfig] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param content_based_deduplication: Enables content-based deduplication for FIFO topics. Default: None
        :param display_name: A developer-defined string that can be used to identify this SNS topic. The display name must be maximum 100 characters long, including hyphens (-), underscores (_), spaces, and tabs. Default: None
        :param enforce_ssl: Adds a statement to enforce encryption of data in transit when publishing to the topic. Default: false
        :param fifo: Set to true to create a FIFO topic. Default: None
        :param fifo_throughput_scope: Specifies the throughput quota and deduplication behavior to apply for the FIFO topic. You can only set this property when ``fifo`` is ``true``. Default: undefined - SNS default setting is FifoThroughputScope.TOPIC
        :param logging_configs: The list of delivery status logging configurations for the topic. Default: None
        :param master_key: A KMS Key, either managed by this CDK app, or imported. Default: None
        :param message_retention_period_in_days: The number of days Amazon SNS retains messages. It can only be set for FIFO topics. Default: - do not archive messages
        :param signature_version: The signature version corresponds to the hashing algorithm used while creating the signature of the notifications, subscription confirmations, or unsubscribe confirmation messages sent by Amazon SNS. Default: 1
        :param topic_name: A name for the topic. If you don't specify a name, AWS CloudFormation generates a unique physical ID and uses that ID for the topic name. For more information, see Name Type. Default: Generated name
        :param tracing_config: Tracing mode of an Amazon SNS topic. Default: TracingConfig.PASS_THROUGH
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__70e505f14a1afa0f6a7236955dba568672dc67b4c2ceacb436fde882a2d66c49)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_sns_ceddda9d.TopicProps(
            content_based_deduplication=content_based_deduplication,
            display_name=display_name,
            enforce_ssl=enforce_ssl,
            fifo=fifo,
            fifo_throughput_scope=fifo_throughput_scope,
            logging_configs=logging_configs,
            master_key=master_key,
            message_retention_period_in_days=message_retention_period_in_days,
            signature_version=signature_version,
            topic_name=topic_name,
            tracing_config=tracing_config,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmNumberOfMessagesPublished")
    def alarm_number_of_messages_published(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SnsNumberOfMessagesPublishedAlarm:
        '''Creates an alarm for the NumberOfMessagesPublished metric.

        :param threshold: The value against which the specified statistic is compared. The number of messages published should be in line with the expected number of published messages for your application. You can also analyze the historical data, trends and traffic to find the right threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of SNS messages published is too low. For troubleshooting, check why the publishers are sending less traffic.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfMessagesPublished'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SnsNumberOfMessagesPublishedAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SnsNumberOfMessagesPublishedAlarm, jsii.invoke(self, "alarmNumberOfMessagesPublished", [props]))

    @jsii.member(jsii_name="alarmNumberOfNotificationsDelivered")
    def alarm_number_of_notifications_delivered(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SnsNumberOfNotificationsDeliveredAlarm:
        '''Creates an alarm for the NumberOfNotificationsDelivered metric.

        :param threshold: The value against which the specified statistic is compared. The number of messages delivered should be in line with the expected number of messages produced and the number of consumers. You can also analyze the historical data, trends and traffic to find the right threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of SNS messages delivered is too low. This could be because of unintentional unsubscribing of an endpoint, or because of an SNS event that causes messages to experience delay.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsDelivered'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SnsNumberOfNotificationsDeliveredAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SnsNumberOfNotificationsDeliveredAlarm, jsii.invoke(self, "alarmNumberOfNotificationsDelivered", [props]))

    @jsii.member(jsii_name="alarmNumberOfNotificationsFailed")
    def alarm_number_of_notifications_failed(
        self,
        *,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SnsNumberOfNotificationsFailedAlarm:
        '''Creates an alarm for the NumberOfNotificationsFailed metric.

        :param threshold: The value against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on the impact of failed notifications. Review the SLAs provided to your end users, fault tolerance and criticality of notifications and analyze historical data, and then select a threshold accordingly. The number of notifications failed should be 0 for topics that have only SQS, Lambda or Firehose subscriptions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when the number of failed SNS messages is too high. To troubleshoot failed notifications, enable logging to CloudWatch Logs. Checking the logs can help you find which subscribers are failing, as well as the status codes they are returning.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFailed'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SnsNumberOfNotificationsFailedAlarmConfig(
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SnsNumberOfNotificationsFailedAlarm, jsii.invoke(self, "alarmNumberOfNotificationsFailed", [props]))

    @jsii.member(jsii_name="alarmNumberOfNotificationsFailedToRedriveToDlq")
    def alarm_number_of_notifications_failed_to_redrive_to_dlq(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SnsNumberOfNotificationsFailedToRedriveToDlqAlarm:
        '''Creates an alarm for the NumberOfNotificationsFailedToRedriveToDlq metric.

        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor messages that couldn't be moved to a dead-letter queue. Check whether your dead-letter queue exists and that it's configured correctly. Also, verify that SNS has permissions to access the dead-letter queue. Refer to the dead-letter queue documentation (https://docs.aws.amazon.com/sns/latest/dg/sns-dead-letter-queues.html) to learn more.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFailedToRedriveToDlq'
        :param threshold: The value against which the specified statistic is compared. It's almost always a mistake if messages can't be moved to the dead-letter queue. The recommendation for the threshold is 0, meaning all messages that fail processing must be able to reach the dead-letter queue when the queue has been configured. Default: 0
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            threshold=threshold,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SnsNumberOfNotificationsFailedToRedriveToDlqAlarm, jsii.invoke(self, "alarmNumberOfNotificationsFailedToRedriveToDlq", [props]))

    @jsii.member(jsii_name="alarmNumberOfNotificationsFilteredOutInvalidAttributes")
    def alarm_number_of_notifications_filtered_out_invalid_attributes(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarm:
        '''Creates an alarm for the NumberOfNotificationsFilteredOutInvalidAttributes metric.

        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor and resolve potential problems with the publisher or subscribers. Check if a publisher is publishing messages with invalid attributes or if an inappropriate filter is applied to a subscriber. You can also analyze CloudWatch Logs to help find the root cause of the issue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidAttributes'
        :param threshold: The value against which the specified statistic is compared. Invalid attributes are almost always a mistake by the publisher. We recommend to set the threshold to 0 because invalid attributes are not expected in a healthy system. Default: 0
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            threshold=threshold,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarm, jsii.invoke(self, "alarmNumberOfNotificationsFilteredOutInvalidAttributes", [props]))

    @jsii.member(jsii_name="alarmNumberOfNotificationsFilteredOutInvalidMessageBody")
    def alarm_number_of_notifications_filtered_out_invalid_message_body(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarm:
        '''Creates an alarm for the NumberOfNotificationsFilteredOutInvalidMessageBody metric.

        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor and resolve potential problems with the publisher or subscribers. Check if a publisher is publishing messages with invalid message bodies, or if an inappropriate filter is applied to a subscriber. You can also analyze CloudWatch Logs to help find the root cause of the issue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsFilteredOut-InvalidMessageBody'
        :param threshold: The value against which the specified statistic is compared. Invalid message bodies are almost always a mistake by the publisher. We recommend to set the threshold to 0 because invalid message bodies are not expected in a healthy system. Default: 0
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            threshold=threshold,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarm, jsii.invoke(self, "alarmNumberOfNotificationsFilteredOutInvalidMessageBody", [props]))

    @jsii.member(jsii_name="alarmNumberOfNotificationsRedrivenToDlq")
    def alarm_number_of_notifications_redriven_to_dlq(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        threshold: typing.Optional[jsii.Number] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SnsNumberOfNotificationsRedrivenToDlqAlarm:
        '''Creates an alarm for the NumberOfNotificationsRedrivenToDlq metric.

        :param alarm_description: The description of the alarm. Default: - This alarm helps to monitor the number of messages that are moved to a dead-letter queue.
        :param alarm_name: The alarm name. Default: - topic.topicName + ' - NumberOfNotificationsRedrivenToDlq'
        :param threshold: The value against which the specified statistic is compared. In a healthy system of any subscriber type, messages should not be moved to the dead-letter queue. We recommend that you be notified if any messages land in the queue, so that you can identify and address the root cause, and potentially redrive the messages in the dead-letter queue to prevent data loss. Default: 0
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = SnsNumberOfNotificationsRedrivenToDlqAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            threshold=threshold,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SnsNumberOfNotificationsRedrivenToDlqAlarm, jsii.invoke(self, "alarmNumberOfNotificationsRedrivenToDlq", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_number_of_messages_published_alarm: typing.Union[SnsNumberOfMessagesPublishedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_delivered_alarm: typing.Union[SnsNumberOfNotificationsDeliveredAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_failed_alarm: typing.Union[SnsNumberOfNotificationsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_number_of_notifications_failed_to_redrive_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_filtered_out_invalid_attributes_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_filtered_out_invalid_message_body_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_number_of_notifications_redriven_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[SnsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> SnsRecommendedAlarms:
        '''Creates recommended alarms for the SNS topic.

        :param config_number_of_messages_published_alarm: The configuration for the NumberOfMessagesPublished alarm.
        :param config_number_of_notifications_delivered_alarm: The configuration for the NumberOfNotificationsDelivered alarm.
        :param config_number_of_notifications_failed_alarm: The configuration for the NumberOfNotificationsFailed alarm.
        :param config_number_of_notifications_failed_to_redrive_to_dlq_alarm: The configuration for the NumberOfNotificationsFailedToRedriveToDlq alarm.
        :param config_number_of_notifications_filtered_out_invalid_attributes_alarm: The configuration for the NumberOfNotificationsFilteredOutInvalidAttributes alarm.
        :param config_number_of_notifications_filtered_out_invalid_message_body_alarm: The configuration for the NumberOfNotificationsFilteredOutInvalidMessageBody alarm.
        :param config_number_of_notifications_redriven_to_dlq_alarm: The configuration for the NumberOfNotificationsRedrivenToDlq alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#SNS
        '''
        props = SnsRecommendedAlarmsConfig(
            config_number_of_messages_published_alarm=config_number_of_messages_published_alarm,
            config_number_of_notifications_delivered_alarm=config_number_of_notifications_delivered_alarm,
            config_number_of_notifications_failed_alarm=config_number_of_notifications_failed_alarm,
            config_number_of_notifications_failed_to_redrive_to_dlq_alarm=config_number_of_notifications_failed_to_redrive_to_dlq_alarm,
            config_number_of_notifications_filtered_out_invalid_attributes_alarm=config_number_of_notifications_filtered_out_invalid_attributes_alarm,
            config_number_of_notifications_filtered_out_invalid_message_body_alarm=config_number_of_notifications_filtered_out_invalid_message_body_alarm,
            config_number_of_notifications_redriven_to_dlq_alarm=config_number_of_notifications_redriven_to_dlq_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(SnsRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))


class VpcEndpointService(
    _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpcEndpointService",
):
    '''An extension for the VpcEndpointService construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        vpc_endpoint_service_load_balancers: typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.IVpcEndpointServiceLoadBalancer],
        acceptance_required: typing.Optional[builtins.bool] = None,
        allowed_principals: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.ArnPrincipal]] = None,
        allowed_regions: typing.Optional[typing.Sequence[builtins.str]] = None,
        contributor_insights: typing.Optional[builtins.bool] = None,
        supported_ip_address_types: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.IpAddressType]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpc_endpoint_service_load_balancers: One or more load balancers to host the VPC Endpoint Service.
        :param acceptance_required: Whether requests from service consumers to connect to the service through an endpoint must be accepted. Default: true
        :param allowed_principals: IAM users, IAM roles, or AWS accounts to allow inbound connections from. These principals can connect to your service using VPC endpoints. Takes a list of one or more ArnPrincipal. Default: - no principals
        :param allowed_regions: The Regions from which service consumers can access the service. Default: - No Region restrictions
        :param contributor_insights: Indicates whether to enable the built-in Contributor Insights rules provided by AWS PrivateLink. Default: false
        :param supported_ip_address_types: Specify which IP address types are supported for VPC endpoint service. Default: - No specific IP address types configured
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9aff1dc734cefac7c53c37e39518798e6756b2ee6950403693f8ed549919fcf1)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_ec2_ceddda9d.VpcEndpointServiceProps(
            vpc_endpoint_service_load_balancers=vpc_endpoint_service_load_balancers,
            acceptance_required=acceptance_required,
            allowed_principals=allowed_principals,
            allowed_regions=allowed_regions,
            contributor_insights=contributor_insights,
            supported_ip_address_types=supported_ip_address_types,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmRstPacketsSent")
    def alarm_rst_packets_sent(
        self,
        *,
        load_balancer_arn: builtins.str,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        azs: typing.Optional[typing.Sequence[builtins.str]] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> typing.List[PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarm]:
        '''Creates an alarm that monitors the RstPacketsSent for the PrivateLink endpoint.

        :param load_balancer_arn: The load balancer ARN of the PrivateLink VpcEndpointService.
        :param threshold: The threshold depends on the use case. If your use case can tolerate targets being unhealthy, you can set the threshold high. If the use case cant tolerate unhealthy targets you can set the threshold very low.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect unhealthy targets of an endpoint service.
        :param alarm_name: The alarm name. Default: - endpointServiceName + ' - ' + az + ' - RstPacketsSent'
        :param azs: The availability zone of the PrivateLink VpcEndpointService.
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = PrivateLinkServicesRstPacketsSentAlarmConfig(
            load_balancer_arn=load_balancer_arn,
            threshold=threshold,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            azs=azs,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(typing.List[PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarm], jsii.invoke(self, "alarmRstPacketsSent", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_rst_packets_sent_alarm: typing.Union[PrivateLinkServicesRstPacketsSentAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[PrivateLinkServicesRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> PrivateLinkServicesVpcEndpointServiceRecommendedAlarms:
        '''Creates the recommended alarms for the PrivateLink VpcEndpointService.

        :param config_rst_packets_sent_alarm: The configuration for the RstPacketsSent alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#PrivateLinkServices
        '''
        props = PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsConfig(
            config_rst_packets_sent_alarm=config_rst_packets_sent_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast(PrivateLinkServicesVpcEndpointServiceRecommendedAlarms, jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnAlarmBaseConfig",
    jsii_struct_bases=[AlarmBaseProps],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
    },
)
class VpnAlarmBaseConfig(AlarmBaseProps):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ) -> None:
        '''The common optional configuration for the alarms.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__71cc4528f4654e83d1b4dc2a90096d0356c91685310092722027a36d0189f911)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(5)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnAlarmBaseConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VpnConnection(
    _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnConnection",
):
    '''An extension for the CfnVPNConnection construct that provides methods to create recommended alarms.'''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        customer_gateway_id: builtins.str,
        type: builtins.str,
        enable_acceleration: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        local_ipv4_network_cidr: typing.Optional[builtins.str] = None,
        local_ipv6_network_cidr: typing.Optional[builtins.str] = None,
        outside_ip_address_type: typing.Optional[builtins.str] = None,
        remote_ipv4_network_cidr: typing.Optional[builtins.str] = None,
        remote_ipv6_network_cidr: typing.Optional[builtins.str] = None,
        static_routes_only: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
        tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
        transit_gateway_id: typing.Optional[builtins.str] = None,
        transport_transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
        tunnel_inside_ip_version: typing.Optional[builtins.str] = None,
        vpn_gateway_id: typing.Optional[builtins.str] = None,
        vpn_tunnel_options_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection.VpnTunnelOptionsSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param customer_gateway_id: The ID of the customer gateway at your end of the VPN connection.
        :param type: The type of VPN connection.
        :param enable_acceleration: Indicate whether to enable acceleration for the VPN connection. Default: ``false``
        :param local_ipv4_network_cidr: The IPv4 CIDR on the customer gateway (on-premises) side of the VPN connection. Default: ``0.0.0.0/0``
        :param local_ipv6_network_cidr: The IPv6 CIDR on the customer gateway (on-premises) side of the VPN connection. Default: ``::/0``
        :param outside_ip_address_type: The type of IP address assigned to the outside interface of the customer gateway device. Valid values: ``PrivateIpv4`` | ``PublicIpv4`` | ``Ipv6`` Default: ``PublicIpv4``
        :param remote_ipv4_network_cidr: The IPv4 CIDR on the AWS side of the VPN connection. Default: ``0.0.0.0/0``
        :param remote_ipv6_network_cidr: The IPv6 CIDR on the AWS side of the VPN connection. Default: ``::/0``
        :param static_routes_only: Indicates whether the VPN connection uses static routes only. Static routes must be used for devices that don't support BGP. If you are creating a VPN connection for a device that does not support Border Gateway Protocol (BGP), you must specify ``true`` .
        :param tags: Any tags assigned to the VPN connection.
        :param transit_gateway_id: The ID of the transit gateway associated with the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.
        :param transport_transit_gateway_attachment_id: The transit gateway attachment ID to use for the VPN tunnel. Required if ``OutsideIpAddressType`` is set to ``PrivateIpv4`` .
        :param tunnel_inside_ip_version: Indicate whether the VPN tunnels process IPv4 or IPv6 traffic. Default: ``ipv4``
        :param vpn_gateway_id: The ID of the virtual private gateway at the AWS side of the VPN connection. You must specify either ``TransitGatewayId`` or ``VpnGatewayId`` , but not both.
        :param vpn_tunnel_options_specifications: The tunnel options for the VPN connection.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a8d50a3f4d65cc339209d9b99ea4646ed1ff7e8ccf3269341560529e3d6585b8)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnectionProps(
            customer_gateway_id=customer_gateway_id,
            type=type,
            enable_acceleration=enable_acceleration,
            local_ipv4_network_cidr=local_ipv4_network_cidr,
            local_ipv6_network_cidr=local_ipv6_network_cidr,
            outside_ip_address_type=outside_ip_address_type,
            remote_ipv4_network_cidr=remote_ipv4_network_cidr,
            remote_ipv6_network_cidr=remote_ipv6_network_cidr,
            static_routes_only=static_routes_only,
            tags=tags,
            transit_gateway_id=transit_gateway_id,
            transport_transit_gateway_attachment_id=transport_transit_gateway_attachment_id,
            tunnel_inside_ip_version=tunnel_inside_ip_version,
            vpn_gateway_id=vpn_gateway_id,
            vpn_tunnel_options_specifications=vpn_tunnel_options_specifications,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @jsii.member(jsii_name="alarmTunnelState")
    def alarm_tunnel_state(
        self,
        *,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "VpnConnectionTunnelStateAlarm":
        '''Creates an alarm that monitors the TunnelState for the VPN vpnConnection.

        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect if at least one tunnel is in the DOWN state for this VPN, so that you can troubleshoot the impacted VPN. This alarm will always be in the ALARM state for networks that only have a single tunnel configured.
        :param alarm_name: The alarm name. Default: - vpnConnectionId + ' - TunnelState'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: A value less than 1 indicates that at least one tunnel is in DOWN state. Default: 1
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = VpnTunnelStateAlarmConfig(
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("VpnConnectionTunnelStateAlarm", jsii.invoke(self, "alarmTunnelState", [props]))

    @jsii.member(jsii_name="applyRecommendedAlarms")
    def apply_recommended_alarms(
        self,
        *,
        config_tunnel_state_alarm: typing.Optional[typing.Union["VpnTunnelStateAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["VpnRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> "VpnConnectionRecommendedAlarms":
        '''Creates the recommended alarms for the VpnConnection.

        :param config_tunnel_state_alarm: The configuration for the TunnelState alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING

        :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#VPN
        '''
        props = VpnConnectionRecommendedAlarmsConfig(
            config_tunnel_state_alarm=config_tunnel_state_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        return typing.cast("VpnConnectionRecommendedAlarms", jsii.invoke(self, "applyRecommendedAlarms", [props]))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnConnectionAlarmProps",
    jsii_struct_bases=[],
    name_mapping={"vpn_connection": "vpnConnection"},
)
class VpnConnectionAlarmProps:
    def __init__(
        self,
        *,
        vpn_connection: _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
    ) -> None:
        '''The common properties for the VpnConnection alarms.

        :param vpn_connection: The VpnConnection to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e0b8c3310f917d3819bf2b78010f052d96ebd46b690cd1cf6741824595e30e42)
            check_type(argname="argument vpn_connection", value=vpn_connection, expected_type=type_hints["vpn_connection"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpn_connection": vpn_connection,
        }

    @builtins.property
    def vpn_connection(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection:
        '''The VpnConnection to monitor.'''
        result = self._values.get("vpn_connection")
        assert result is not None, "Required property 'vpn_connection' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnConnectionAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VpnConnectionRecommendedAlarms(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnConnectionRecommendedAlarms",
):
    '''A construct that creates the recommended alarms for an VpnConnection.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#VPN
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        vpn_connection: _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
        config_tunnel_state_alarm: typing.Optional[typing.Union["VpnTunnelStateAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["VpnRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpn_connection: The VpnConnection to monitor.
        :param config_tunnel_state_alarm: The configuration for the TunnelState alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__64d6f016a04ac6217769664164322160eee7aab082a4a0bee6df7a78e9a0e034)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = VpnConnectionRecommendedAlarmsProps(
            vpn_connection=vpn_connection,
            config_tunnel_state_alarm=config_tunnel_state_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="alarmTunnelState")
    def alarm_tunnel_state(self) -> typing.Optional["VpnConnectionTunnelStateAlarm"]:
        '''The TunnelState alarm.'''
        return typing.cast(typing.Optional["VpnConnectionTunnelStateAlarm"], jsii.get(self, "alarmTunnelState"))


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnConnectionRecommendedAlarmsConfig",
    jsii_struct_bases=[],
    name_mapping={
        "config_tunnel_state_alarm": "configTunnelStateAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
    },
)
class VpnConnectionRecommendedAlarmsConfig:
    def __init__(
        self,
        *,
        config_tunnel_state_alarm: typing.Optional[typing.Union["VpnTunnelStateAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["VpnRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''Configurations for the recommended alarms for an VPN Service.

        Default actions are overridden by the actions specified in the
        individual alarm configurations.

        :param config_tunnel_state_alarm: The configuration for the TunnelState alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if isinstance(config_tunnel_state_alarm, dict):
            config_tunnel_state_alarm = VpnTunnelStateAlarmConfig(**config_tunnel_state_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__86d645e9faa36b9be6b632a0255e17e95f10afe1dd685f2c2d7689bc214b632d)
            check_type(argname="argument config_tunnel_state_alarm", value=config_tunnel_state_alarm, expected_type=type_hints["config_tunnel_state_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if config_tunnel_state_alarm is not None:
            self._values["config_tunnel_state_alarm"] = config_tunnel_state_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_tunnel_state_alarm(self) -> typing.Optional["VpnTunnelStateAlarmConfig"]:
        '''The configuration for the TunnelState alarm.'''
        result = self._values.get("config_tunnel_state_alarm")
        return typing.cast(typing.Optional["VpnTunnelStateAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["VpnRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["VpnRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnConnectionRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnConnectionRecommendedAlarmsProps",
    jsii_struct_bases=[VpnConnectionRecommendedAlarmsConfig],
    name_mapping={
        "config_tunnel_state_alarm": "configTunnelStateAlarm",
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "vpn_connection": "vpnConnection",
    },
)
class VpnConnectionRecommendedAlarmsProps(VpnConnectionRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        config_tunnel_state_alarm: typing.Optional[typing.Union["VpnTunnelStateAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["VpnRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        vpn_connection: _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
    ) -> None:
        '''Properties for the VpnConnectionRecommendedAlarms construct.

        :param config_tunnel_state_alarm: The configuration for the TunnelState alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param vpn_connection: The VpnConnection to monitor.
        '''
        if isinstance(config_tunnel_state_alarm, dict):
            config_tunnel_state_alarm = VpnTunnelStateAlarmConfig(**config_tunnel_state_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2eea57a58f5a3bf0e9a970d530b98886836cd9e7781dd9d779adc93223939b6f)
            check_type(argname="argument config_tunnel_state_alarm", value=config_tunnel_state_alarm, expected_type=type_hints["config_tunnel_state_alarm"])
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument vpn_connection", value=vpn_connection, expected_type=type_hints["vpn_connection"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpn_connection": vpn_connection,
        }
        if config_tunnel_state_alarm is not None:
            self._values["config_tunnel_state_alarm"] = config_tunnel_state_alarm
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data

    @builtins.property
    def config_tunnel_state_alarm(self) -> typing.Optional["VpnTunnelStateAlarmConfig"]:
        '''The configuration for the TunnelState alarm.'''
        result = self._values.get("config_tunnel_state_alarm")
        return typing.cast(typing.Optional["VpnTunnelStateAlarmConfig"], result)

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List["VpnRecommendedAlarmsMetrics"]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List["VpnRecommendedAlarmsMetrics"]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def vpn_connection(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection:
        '''The VpnConnection to monitor.'''
        result = self._values.get("vpn_connection")
        assert result is not None, "Required property 'vpn_connection' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnConnectionRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class VpnConnectionTunnelStateAlarm(
    _aws_cdk_aws_cloudwatch_ceddda9d.Alarm,
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnConnectionTunnelStateAlarm",
):
    '''This alarm helps you understand if the state of one or more tunnels is DOWN.

    For troubleshooting, see VPN tunnel troubleshooting.

    The alarm is triggered when the monitored value is less than 1.
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.IConstruct,
        id: builtins.str,
        *,
        vpn_connection: _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param vpn_connection: The VpnConnection to monitor.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect if at least one tunnel is in the DOWN state for this VPN, so that you can troubleshoot the impacted VPN. This alarm will always be in the ALARM state for networks that only have a single tunnel configured.
        :param alarm_name: The alarm name. Default: - vpnConnectionId + ' - TunnelState'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: A value less than 1 indicates that at least one tunnel is in DOWN state. Default: 1
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aaada650ca8bc3d15077cca07dcff38752d339b88a6fb052fb46c87121708a90)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = VpnConnectionTunnelStateAlarmProps(
            vpn_connection=vpn_connection,
            alarm_description=alarm_description,
            alarm_name=alarm_name,
            datapoints_to_alarm=datapoints_to_alarm,
            evaluation_periods=evaluation_periods,
            threshold=threshold,
            period=period,
            alarm_action=alarm_action,
            insufficient_data_action=insufficient_data_action,
            ok_action=ok_action,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [scope, id, props])


@jsii.implements(_aws_cdk_ceddda9d.IAspect)
class VpnRecommendedAlarmsAspect(
    metaclass=jsii.JSIIMeta,
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnRecommendedAlarmsAspect",
):
    '''Configures the recommended alarms for an VpnConnection.

    :see: https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Best_Practice_Recommended_Alarms_AWS_Services.html#VPN
    '''

    def __init__(
        self,
        *,
        config_tunnel_state_alarm: typing.Optional[typing.Union["VpnTunnelStateAlarmConfig", typing.Dict[builtins.str, typing.Any]]] = None,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence["VpnRecommendedAlarmsMetrics"]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    ) -> None:
        '''
        :param config_tunnel_state_alarm: The configuration for the TunnelState alarm.
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        '''
        props = VpnConnectionRecommendedAlarmsConfig(
            config_tunnel_state_alarm=config_tunnel_state_alarm,
            default_alarm_action=default_alarm_action,
            default_insufficient_data_action=default_insufficient_data_action,
            default_ok_action=default_ok_action,
            exclude_alarms=exclude_alarms,
            exclude_resources=exclude_resources,
            treat_missing_data=treat_missing_data,
        )

        jsii.create(self.__class__, self, [props])

    @jsii.member(jsii_name="visit")
    def visit(self, node: _constructs_77d1e7e8.IConstruct) -> None:
        '''All aspects can visit an IConstruct.

        :param node: -
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3e9399e035a439b22cdb17c73504d44fd97fd7224321c312f4e2911ccb32ec5f)
            check_type(argname="argument node", value=node, expected_type=type_hints["node"])
        return typing.cast(None, jsii.invoke(self, "visit", [node]))


@jsii.enum(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnRecommendedAlarmsMetrics"
)
class VpnRecommendedAlarmsMetrics(enum.Enum):
    '''The recommended metrics for VPN alarms.'''

    TUNNEL_STATE = "TUNNEL_STATE"
    '''Percentage of how close a file system is to reaching the I/O limit of the General Purpose performance mode.'''


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnTunnelStateAlarmConfig",
    jsii_struct_bases=[VpnAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class VpnTunnelStateAlarmConfig(VpnAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the TunnelState alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect if at least one tunnel is in the DOWN state for this VPN, so that you can troubleshoot the impacted VPN. This alarm will always be in the ALARM state for networks that only have a single tunnel configured.
        :param alarm_name: The alarm name. Default: - vpnConnectionId + ' - TunnelState'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: A value less than 1 indicates that at least one tunnel is in DOWN state. Default: 1
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__43aa4128b80db6a4cfb8b8f947dd24a17914928d99c5ccd3edcd5ace69a1e249)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(5)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect if at least one tunnel is in the DOWN state for this VPN, so that you can troubleshoot
        the impacted VPN. This alarm will always be in the ALARM state for networks that only have a single tunnel configured.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - vpnConnectionId + ' - TunnelState'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''A value less than 1 indicates that at least one tunnel is in DOWN state.

        :default: 1
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnTunnelStateAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGateway4XXErrorAlarmConfig",
    jsii_struct_bases=[ApiGatewayAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class ApiGateway4XXErrorAlarmConfig(ApiGatewayAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the 4XXError alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The threshold value against which the specified statistic is compared.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect high rates of client-side errors for the API Gateway requests.
        :param alarm_name: The alarm name. Default: - apiName + ' - 4XXError'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. The unit is an absolute count of errors, not a percentage. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c42a6db4e9cc7b7514f67bbdb6b00049c42d9794121f4a4c7f7ff61acb11a6af)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The threshold value against which the specified statistic is compared.'''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm can detect high rates of client-side errors for the API Gateway requests.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - apiName + ' - 4XXError'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        The unit is an absolute count of errors, not a percentage.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGateway4XXErrorAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGateway5XXErrorAlarmConfig",
    jsii_struct_bases=[ApiGatewayAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class ApiGateway5XXErrorAlarmConfig(ApiGatewayAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the 5XXError alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The threshold value against which the specified statistic is compared.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect high rates of server-side errors for the API Gateway requests.
        :param alarm_name: The alarm name. Default: - apiName + ' - 5XXError'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. The unit is an absolute count of errors, not a percentage. Default: 3
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__3a6a8b0d6dd7536abb15fe4726626a61ffd0b027b30d55ab6ef61777b10c2360)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The threshold value against which the specified statistic is compared.'''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm can detect high rates of server-side errors for the API Gateway requests.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - apiName + ' - 5XXError'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        The unit is an absolute count of errors, not a percentage.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGateway5XXErrorAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApi4XXErrorAlarmProps",
    jsii_struct_bases=[ApiGatewayRestApiAlarmProps, ApiGateway4XXErrorAlarmConfig],
    name_mapping={
        "api": "api",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class ApiGatewayRestApi4XXErrorAlarmProps(
    ApiGatewayRestApiAlarmProps,
    ApiGateway4XXErrorAlarmConfig,
):
    def __init__(
        self,
        *,
        api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ApiGatewayRestApi4XXErrorAlarm construct.

        :param api: The ApiGateway api to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The threshold value against which the specified statistic is compared.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect high rates of client-side errors for the API Gateway requests.
        :param alarm_name: The alarm name. Default: - apiName + ' - 4XXError'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. The unit is an absolute count of errors, not a percentage. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__795a01868868981fcaacf11798c53c030c8d2f28785d4990e9c7cc5ec6070157)
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api": api,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def api(self) -> _aws_cdk_aws_apigateway_ceddda9d.RestApi:
        '''The ApiGateway api to monitor.'''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(_aws_cdk_aws_apigateway_ceddda9d.RestApi, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The threshold value against which the specified statistic is compared.'''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm can detect high rates of client-side errors for the API Gateway requests.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - apiName + ' - 4XXError'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        The unit is an absolute count of errors, not a percentage.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayRestApi4XXErrorAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ApiGatewayRestApi5XXErrorAlarmProps",
    jsii_struct_bases=[ApiGatewayRestApiAlarmProps, ApiGateway5XXErrorAlarmConfig],
    name_mapping={
        "api": "api",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class ApiGatewayRestApi5XXErrorAlarmProps(
    ApiGatewayRestApiAlarmProps,
    ApiGateway5XXErrorAlarmConfig,
):
    def __init__(
        self,
        *,
        api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ApiGatewayRestApi5XXErrorAlarm construct.

        :param api: The ApiGateway api to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The threshold value against which the specified statistic is compared.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect high rates of server-side errors for the API Gateway requests.
        :param alarm_name: The alarm name. Default: - apiName + ' - 5XXError'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. The unit is an absolute count of errors, not a percentage. Default: 3
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__48227e9c87f0058e774d98bd2f009c8fde08a7280810c0b3c060595ccd03b410)
            check_type(argname="argument api", value=api, expected_type=type_hints["api"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "api": api,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def api(self) -> _aws_cdk_aws_apigateway_ceddda9d.RestApi:
        '''The ApiGateway api to monitor.'''
        result = self._values.get("api")
        assert result is not None, "Required property 'api' is missing"
        return typing.cast(_aws_cdk_aws_apigateway_ceddda9d.RestApi, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The threshold value against which the specified statistic is compared.'''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm can detect high rates of server-side errors for the API Gateway requests.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - apiName + ' - 5XXError'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        The unit is an absolute count of errors, not a percentage.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ApiGatewayRestApi5XXErrorAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.AutoScalingGroupGroupInServiceCapacityAlarmProps",
    jsii_struct_bases=[
        AutoScalingGroupAlarmProps, AutoScalingGroupInServiceCapacityAlarmConfig
    ],
    name_mapping={
        "auto_scaling_group": "autoScalingGroup",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class AutoScalingGroupGroupInServiceCapacityAlarmProps(
    AutoScalingGroupAlarmProps,
    AutoScalingGroupInServiceCapacityAlarmConfig,
):
    def __init__(
        self,
        *,
        auto_scaling_group: _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the AutoScalingGroupGroupInServiceCapacityAlarm construct.

        :param auto_scaling_group: The EC2 AutoScalingGroup to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The threshold value should be the minimum capacity required to run your workload. In most cases, you can set this to match the GroupDesiredCapacity metric.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect a low availability in your auto scaling group because of launch failures or suspended launches.
        :param alarm_name: The alarm name. Default: - autoScalingGroupName + ' - GroupInServiceCapacity'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9157b059ccea61ff17ab492547ee8636697379e269766bb4aded19d9cda0841a)
            check_type(argname="argument auto_scaling_group", value=auto_scaling_group, expected_type=type_hints["auto_scaling_group"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "auto_scaling_group": auto_scaling_group,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def auto_scaling_group(self) -> _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup:
        '''The EC2 AutoScalingGroup to monitor.'''
        result = self._values.get("auto_scaling_group")
        assert result is not None, "Required property 'auto_scaling_group' is missing"
        return typing.cast(_aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The threshold value should be the minimum capacity required to run your workload.

        In most cases,
        you can set this to match the GroupDesiredCapacity metric.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect a low availability in your auto scaling group because of launch failures
        or suspended launches.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - autoScalingGroupName + ' - GroupInServiceCapacity'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 10
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 10
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "AutoScalingGroupGroupInServiceCapacityAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFront5xxErrorRateAlarmConfig",
    jsii_struct_bases=[CloudFrontAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class CloudFront5xxErrorRateAlarmConfig(CloudFrontAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the 5xxErrorRate alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The recommended threshold value for this alarm is highly dependent on the tolerance for 5xx responses. You can analyze historical data and trends, and then set the threshold accordingly. Because 5xx errors can be caused by transient issues, we recommend that you set the threshold to a value greater than 0 so that the alarm is not too sensitive.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect problems with serving requests from the origin server, or problems with communication between CloudFront and your origin server.
        :param alarm_name: The alarm name. Default: - distributionId + ' - 5xxErrorRate'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6c8c5ff5e7c2844bcf1c5d45f4493f50ec3267e8839854d2605212965d416869)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The recommended threshold value for this alarm is highly dependent on the tolerance for 5xx responses.

        You can analyze historical data and trends, and then set the threshold
        accordingly. Because 5xx errors can be caused by transient issues, we recommend that you
        set the threshold to a value greater than 0 so that the alarm is not too sensitive.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect problems with serving requests from the origin server,
        or problems with communication between CloudFront and your origin server.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - 5xxErrorRate'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFront5xxErrorRateAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistribution5xxErrorRateAlarmProps",
    jsii_struct_bases=[
        CloudFrontDistributionAlarmProps, CloudFront5xxErrorRateAlarmConfig
    ],
    name_mapping={
        "distribution": "distribution",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class CloudFrontDistribution5xxErrorRateAlarmProps(
    CloudFrontDistributionAlarmProps,
    CloudFront5xxErrorRateAlarmConfig,
):
    def __init__(
        self,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the CloudFrontDistribution5xxErrorRateAlarm construct.

        :param distribution: The CloudFront Distribution to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The recommended threshold value for this alarm is highly dependent on the tolerance for 5xx responses. You can analyze historical data and trends, and then set the threshold accordingly. Because 5xx errors can be caused by transient issues, we recommend that you set the threshold to a value greater than 0 so that the alarm is not too sensitive.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect problems with serving requests from the origin server, or problems with communication between CloudFront and your origin server.
        :param alarm_name: The alarm name. Default: - distributionId + ' - 5xxErrorRate'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0f58a19ff3f4f857d89a603930dc32445d234f186866e8c823e2453416510682)
            check_type(argname="argument distribution", value=distribution, expected_type=type_hints["distribution"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "distribution": distribution,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def distribution(self) -> _aws_cdk_aws_cloudfront_ceddda9d.Distribution:
        '''The CloudFront Distribution to monitor.'''
        result = self._values.get("distribution")
        assert result is not None, "Required property 'distribution' is missing"
        return typing.cast(_aws_cdk_aws_cloudfront_ceddda9d.Distribution, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The recommended threshold value for this alarm is highly dependent on the tolerance for 5xx responses.

        You can analyze historical data and trends, and then set the threshold
        accordingly. Because 5xx errors can be caused by transient issues, we recommend that you
        set the threshold to a value greater than 0 so that the alarm is not too sensitive.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect problems with serving requests from the origin server,
        or problems with communication between CloudFront and your origin server.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - 5xxErrorRate'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistribution5xxErrorRateAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig",
    jsii_struct_bases=[
        CloudFrontFunctionExecutionErrorsAlarmConfig, CloudFrontDetailedAlarmConfig
    ],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "function_name": "functionName",
    },
)
class CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig(
    CloudFrontFunctionExecutionErrorsAlarmConfig,
    CloudFrontDetailedAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        function_name: builtins.str,
    ) -> None:
        '''Configuration for the FunctionExecutionErrors alarm when monitoring resource and method dimensions.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect execution errors from CloudFront functions.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionExecutionErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: We recommend to set the threshold to 0 because an execution error indicates a problem with the code that occurs at runtime. Default: 0
        :param function_name: The name of the function to monitor, used as a discriminator in the alarm name.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__06894f95ad06c2efc2ac67a29130078f4259f45c856be072e661e8443b4e1dfe)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "function_name": function_name,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect execution errors from CloudFront functions.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - ' + functionName + ' - FunctionExecutionErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''We recommend to set the threshold to 0 because an execution error indicates a problem with the code that occurs at runtime.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def function_name(self) -> builtins.str:
        '''The name of the function to monitor, used as a discriminator in the alarm name.'''
        result = self._values.get("function_name")
        assert result is not None, "Required property 'function_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmProps",
    jsii_struct_bases=[
        CloudFrontDistributionAlarmProps,
        CloudFrontFunctionExecutionErrorsAlarmConfig,
        CloudFrontDetailedAlarmConfig,
    ],
    name_mapping={
        "distribution": "distribution",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "function_name": "functionName",
    },
)
class CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmProps(
    CloudFrontDistributionAlarmProps,
    CloudFrontFunctionExecutionErrorsAlarmConfig,
    CloudFrontDetailedAlarmConfig,
):
    def __init__(
        self,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        function_name: builtins.str,
    ) -> None:
        '''The properties for the CloudFrontDistributionDetailedFunctionExecutionErrorsAlarm construct.

        :param distribution: The CloudFront Distribution to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect execution errors from CloudFront functions.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionExecutionErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: We recommend to set the threshold to 0 because an execution error indicates a problem with the code that occurs at runtime. Default: 0
        :param function_name: The name of the function to monitor, used as a discriminator in the alarm name.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e80875639a198dc421ffc093725f52a9cb4d14a38ddb28ad178a959df65e20df)
            check_type(argname="argument distribution", value=distribution, expected_type=type_hints["distribution"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "distribution": distribution,
            "function_name": function_name,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def distribution(self) -> _aws_cdk_aws_cloudfront_ceddda9d.Distribution:
        '''The CloudFront Distribution to monitor.'''
        result = self._values.get("distribution")
        assert result is not None, "Required property 'distribution' is missing"
        return typing.cast(_aws_cdk_aws_cloudfront_ceddda9d.Distribution, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect execution errors from CloudFront functions.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - ' + functionName + ' - FunctionExecutionErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''We recommend to set the threshold to 0 because an execution error indicates a problem with the code that occurs at runtime.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def function_name(self) -> builtins.str:
        '''The name of the function to monitor, used as a discriminator in the alarm name.'''
        result = self._values.get("function_name")
        assert result is not None, "Required property 'function_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig",
    jsii_struct_bases=[
        CloudFrontFunctionThrottlesAlarmConfig, CloudFrontDetailedAlarmConfig
    ],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "function_name": "functionName",
    },
)
class CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig(
    CloudFrontFunctionThrottlesAlarmConfig,
    CloudFrontDetailedAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        function_name: builtins.str,
    ) -> None:
        '''Configuration for the FunctionThrottles alarm when monitoring resource and method dimensions.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when your CloudFront function is throttled so that you can react and resolve the issue for a smooth customer experience.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionThrottles'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: We recommend setting the threshold to 0, to allow quicker resolution of the function throttles. Default: 0
        :param function_name: The name of the function to monitor, used as a discriminator in the alarm name.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f4fb235bb1b4032f75af33b36700d43916361d2be7f99d95259cdff4531b482b)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "function_name": function_name,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect when your CloudFront function is throttled so that you can
        react and resolve the issue for a smooth customer experience.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - ' + functionName + ' - FunctionThrottles'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''We recommend setting the threshold to 0, to allow quicker resolution of the function throttles.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def function_name(self) -> builtins.str:
        '''The name of the function to monitor, used as a discriminator in the alarm name.'''
        result = self._values.get("function_name")
        assert result is not None, "Required property 'function_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionDetailedFunctionThrottlesAlarmProps",
    jsii_struct_bases=[
        CloudFrontDistributionAlarmProps,
        CloudFrontFunctionThrottlesAlarmConfig,
        CloudFrontDetailedAlarmConfig,
    ],
    name_mapping={
        "distribution": "distribution",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "function_name": "functionName",
    },
)
class CloudFrontDistributionDetailedFunctionThrottlesAlarmProps(
    CloudFrontDistributionAlarmProps,
    CloudFrontFunctionThrottlesAlarmConfig,
    CloudFrontDetailedAlarmConfig,
):
    def __init__(
        self,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        function_name: builtins.str,
    ) -> None:
        '''The properties for the CloudFrontDistributionDetailedFunctionThrottlesAlarm construct.

        :param distribution: The CloudFront Distribution to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm can detect when your CloudFront function is throttled so that you can react and resolve the issue for a smooth customer experience.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionThrottles'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: We recommend setting the threshold to 0, to allow quicker resolution of the function throttles. Default: 0
        :param function_name: The name of the function to monitor, used as a discriminator in the alarm name.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__25e79a958cf26cc27370701d54e4c50f716d92329c11e6503f1abaa4bec9599c)
            check_type(argname="argument distribution", value=distribution, expected_type=type_hints["distribution"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "distribution": distribution,
            "function_name": function_name,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def distribution(self) -> _aws_cdk_aws_cloudfront_ceddda9d.Distribution:
        '''The CloudFront Distribution to monitor.'''
        result = self._values.get("distribution")
        assert result is not None, "Required property 'distribution' is missing"
        return typing.cast(_aws_cdk_aws_cloudfront_ceddda9d.Distribution, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect when your CloudFront function is throttled so that you can
        react and resolve the issue for a smooth customer experience.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - ' + functionName + ' - FunctionThrottles'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''We recommend setting the threshold to 0, to allow quicker resolution of the function throttles.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def function_name(self) -> builtins.str:
        '''The name of the function to monitor, used as a discriminator in the alarm name.'''
        result = self._values.get("function_name")
        assert result is not None, "Required property 'function_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionDetailedFunctionThrottlesAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig",
    jsii_struct_bases=[
        CloudFrontFunctionValidationErrorsAlarmConfig, CloudFrontDetailedAlarmConfig
    ],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "function_name": "functionName",
    },
)
class CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig(
    CloudFrontFunctionValidationErrorsAlarmConfig,
    CloudFrontDetailedAlarmConfig,
):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        function_name: builtins.str,
    ) -> None:
        '''Configuration for the FunctionValidationErrors alarm when monitoring resource and method dimensions.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect validation errors from CloudFront functions.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionValidationErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: A value greater than 0 indicates a validation error. We recommend setting the threshold to 0 because validation errors imply a problem when CloudFront functions hand off back to CloudFront. For example, CloudFront needs the HTTP Host header in order to process a request. There is nothing stopping a user from deleting the Host header in their CloudFront functions code. But when CloudFront gets the response back and the Host header is missing, CloudFront throws a validation error. Default: 0
        :param function_name: The name of the function to monitor, used as a discriminator in the alarm name.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a1c69e97db54744fefff7f85fc0b6fb6d2d7471b38e06c79d5c7bef808aee151)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "function_name": function_name,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect validation errors from CloudFront functions.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - ' + functionName + ' - FunctionValidationErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 2
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''A value greater than 0 indicates a validation error.

        We recommend setting the threshold to 0 because
        validation errors imply a problem when CloudFront functions hand off back to CloudFront. For example,
        CloudFront needs the HTTP Host header in order to process a request. There is nothing stopping a user
        from deleting the Host header in their CloudFront functions code. But when CloudFront gets the response
        back and the Host header is missing, CloudFront throws a validation error.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def function_name(self) -> builtins.str:
        '''The name of the function to monitor, used as a discriminator in the alarm name.'''
        result = self._values.get("function_name")
        assert result is not None, "Required property 'function_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionDetailedFunctionValidationErrorsAlarmProps",
    jsii_struct_bases=[
        CloudFrontDistributionAlarmProps,
        CloudFrontFunctionValidationErrorsAlarmConfig,
        CloudFrontDetailedAlarmConfig,
    ],
    name_mapping={
        "distribution": "distribution",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
        "function_name": "functionName",
    },
)
class CloudFrontDistributionDetailedFunctionValidationErrorsAlarmProps(
    CloudFrontDistributionAlarmProps,
    CloudFrontFunctionValidationErrorsAlarmConfig,
    CloudFrontDetailedAlarmConfig,
):
    def __init__(
        self,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
        function_name: builtins.str,
    ) -> None:
        '''The properties for the CloudFrontDistributionDetailedFunctionValidationErrorsAlarm construct.

        :param distribution: The CloudFront Distribution to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect validation errors from CloudFront functions.
        :param alarm_name: The alarm name. Default: - distributionId + ' - ' + functionName + ' - FunctionValidationErrors'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: A value greater than 0 indicates a validation error. We recommend setting the threshold to 0 because validation errors imply a problem when CloudFront functions hand off back to CloudFront. For example, CloudFront needs the HTTP Host header in order to process a request. There is nothing stopping a user from deleting the Host header in their CloudFront functions code. But when CloudFront gets the response back and the Host header is missing, CloudFront throws a validation error. Default: 0
        :param function_name: The name of the function to monitor, used as a discriminator in the alarm name.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__f9907e234cf8087c29c6a457699033018d6e5278d083b27b650852ed125db4a8)
            check_type(argname="argument distribution", value=distribution, expected_type=type_hints["distribution"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument function_name", value=function_name, expected_type=type_hints["function_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "distribution": distribution,
            "function_name": function_name,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def distribution(self) -> _aws_cdk_aws_cloudfront_ceddda9d.Distribution:
        '''The CloudFront Distribution to monitor.'''
        result = self._values.get("distribution")
        assert result is not None, "Required property 'distribution' is missing"
        return typing.cast(_aws_cdk_aws_cloudfront_ceddda9d.Distribution, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect validation errors from CloudFront functions.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - ' + functionName + ' - FunctionValidationErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 2
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''A value greater than 0 indicates a validation error.

        We recommend setting the threshold to 0 because
        validation errors imply a problem when CloudFront functions hand off back to CloudFront. For example,
        CloudFront needs the HTTP Host header in order to process a request. There is nothing stopping a user
        from deleting the Host header in their CloudFront functions code. But when CloudFront gets the response
        back and the Host header is missing, CloudFront throws a validation error.

        :default: 0
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def function_name(self) -> builtins.str:
        '''The name of the function to monitor, used as a discriminator in the alarm name.'''
        result = self._values.get("function_name")
        assert result is not None, "Required property 'function_name' is missing"
        return typing.cast(builtins.str, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionDetailedFunctionValidationErrorsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.CloudFrontDistributionOriginLatencyAlarmProps",
    jsii_struct_bases=[
        CloudFrontDistributionAlarmProps, CloudFrontOriginLatencyAlarmConfig
    ],
    name_mapping={
        "distribution": "distribution",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class CloudFrontDistributionOriginLatencyAlarmProps(
    CloudFrontDistributionAlarmProps,
    CloudFrontOriginLatencyAlarmConfig,
):
    def __init__(
        self,
        *,
        distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the CloudFrontDistributionOriginLatencyAlarm construct.

        :param distribution: The CloudFront Distribution to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: You should calculate the value of about 80% of the origin response timeout, and use the result as the threshold value. If this metric is consistently close to the origin response timeout value, you might start experiencing 504 errors.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect problems with the origin server taking too long to respond.
        :param alarm_name: The alarm name. Default: - distributionId + ' - OriginLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__50c4b813330e543843cf0a2cd36da2462ea5958bf321939e822cdd934e73996f)
            check_type(argname="argument distribution", value=distribution, expected_type=type_hints["distribution"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "distribution": distribution,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def distribution(self) -> _aws_cdk_aws_cloudfront_ceddda9d.Distribution:
        '''The CloudFront Distribution to monitor.'''
        result = self._values.get("distribution")
        assert result is not None, "Required property 'distribution' is missing"
        return typing.cast(_aws_cdk_aws_cloudfront_ceddda9d.Distribution, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''You should calculate the value of about 80% of the origin response timeout, and use the result as the threshold value.

        If this metric is consistently close to the origin response timeout value,
        you might start experiencing 504 errors.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect problems with the origin server taking too long to respond.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - distributionId + ' - OriginLatency'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionOriginLatencyAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceSwapUsageAlarmProps",
    jsii_struct_bases=[DmsReplicationInstanceAlarmProps, DmsSwapUsageAlarmConfig],
    name_mapping={
        "replication_instance": "replicationInstance",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "std_devs": "stdDevs",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "comparison_operator": "comparisonOperator",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DmsReplicationInstanceSwapUsageAlarmProps(
    DmsReplicationInstanceAlarmProps,
    DmsSwapUsageAlarmConfig,
):
    def __init__(
        self,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        std_devs: typing.Optional[jsii.Number] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DmsReplicationInstanceSwapUsageAlarm construct.

        :param replication_instance: The DMS Replication Instance to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param std_devs: The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean. Default: 8 (standard deviation for anomaly detection)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high swap usage for the DMS Replication Instance. High swap usage can indicate memory pressure or performance issues.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - SwapUsage'
        :param comparison_operator: The comparison operator to use for the alarm. Default: GREATER_THAN_UPPER_THRESHOLD (for detecting high swap usage indicating memory pressure)
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2 (allow for some variance while still detecting issues)
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3 (to avoid false alarms from temporary fluctuations)
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__2906764d9aeabfae4d07ae06ac58fe269a1555b729a400645ab82607c5008b64)
            check_type(argname="argument replication_instance", value=replication_instance, expected_type=type_hints["replication_instance"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument std_devs", value=std_devs, expected_type=type_hints["std_devs"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument comparison_operator", value=comparison_operator, expected_type=type_hints["comparison_operator"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "replication_instance": replication_instance,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if std_devs is not None:
            self._values["std_devs"] = std_devs
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if comparison_operator is not None:
            self._values["comparison_operator"] = comparison_operator
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def replication_instance(self) -> _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance:
        '''The DMS Replication Instance to monitor.'''
        result = self._values.get("replication_instance")
        assert result is not None, "Required property 'replication_instance' is missing"
        return typing.cast(_aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def std_devs(self) -> typing.Optional[jsii.Number]:
        '''The width of the anomaly detection band, expressed as a number of standard deviations from the metric's mean.

        :default: 8 (standard deviation for anomaly detection)
        '''
        result = self._values.get("std_devs")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high swap usage for the DMS Replication Instance.
        High swap usage can indicate memory pressure or performance issues.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationInstanceIdentifier + ' - SwapUsage'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def comparison_operator(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator]:
        '''The comparison operator to use for the alarm.

        :default: GREATER_THAN_UPPER_THRESHOLD (for detecting high swap usage indicating memory pressure)
        '''
        result = self._values.get("comparison_operator")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2 (allow for some variance while still detecting issues)
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3 (to avoid false alarms from temporary fluctuations)
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationInstanceSwapUsageAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DmsReplicationInstanceWriteIopsAlarmProps",
    jsii_struct_bases=[DmsReplicationInstanceAlarmProps, DmsWriteIopsAlarmConfig],
    name_mapping={
        "replication_instance": "replicationInstance",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class DmsReplicationInstanceWriteIopsAlarmProps(
    DmsReplicationInstanceAlarmProps,
    DmsWriteIopsAlarmConfig,
):
    def __init__(
        self,
        *,
        replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DmsReplicationInstanceWriteIopsAlarm construct.

        :param replication_instance: The DMS Replication Instance to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Different alarm types may have different optimal default periods: - Regular alarms: 1 minute (for responsive monitoring) - Anomaly detection alarms: 5 minutes (for stable ML model training) - CDC/throughput alarms: 5 minutes (for trend analysis) Default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high write IOPS for the DMS Replication Instance. High write IOPS can indicate heavy write activity or potential I/O bottlenecks.
        :param alarm_name: The alarm name. Default: - replicationInstanceIdentifier + ' - WriteIOPS'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: The number of write I/O operations per second against which the specified statistic is compared. High write IOPS can indicate heavy write activity or potential performance bottlenecks. Consider your normal workload patterns when setting this threshold. Default: 1000
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dbe512c114a0598d43f25bd69a3b35067906b97c59ef14738ea2ad65d808bac9)
            check_type(argname="argument replication_instance", value=replication_instance, expected_type=type_hints["replication_instance"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "replication_instance": replication_instance,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def replication_instance(self) -> _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance:
        '''The DMS Replication Instance to monitor.'''
        result = self._values.get("replication_instance")
        assert result is not None, "Required property 'replication_instance' is missing"
        return typing.cast(_aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        Different alarm types may have different optimal default periods:

        - Regular alarms: 1 minute (for responsive monitoring)
        - Anomaly detection alarms: 5 minutes (for stable ML model training)
        - CDC/throughput alarms: 5 minutes (for trend analysis)

        :default: Duration.minutes(1) for regular alarms, Duration.minutes(5) for anomaly detection and throughput alarms
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high write IOPS for the DMS Replication
        Instance. High write IOPS can indicate heavy write activity or potential I/O bottlenecks.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - replicationInstanceIdentifier + ' - WriteIOPS'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The number of write I/O operations per second against which the specified statistic is compared.

        High write IOPS can indicate heavy write activity or potential performance bottlenecks.
        Consider your normal workload patterns when setting this threshold.

        :default: 1000
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DmsReplicationInstanceWriteIopsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig",
    jsii_struct_bases=[DynamoDbAlarmBaseConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig(DynamoDbAlarmBaseConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''Configuration for the AgeOfOldestUnreplicatedRecord alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to the desired replication delay measured in milliseconds. This value depends on your workload's requirements and expected performance.
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor unsuccessful replication attempts and the resulting delay in replication to the Kinesis data stream.
        :param alarm_name: The alarm name. Default: - tableName + ' - AgeOfOldestUnreplicatedRecord'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b0a860bd7f9eabbe3f99f7754f0107166a4032441cb20d2698c4d7efc48ea4a8)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to the desired replication delay measured in milliseconds.

        This value depends on your workload's requirements and expected performance.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can monitor unsuccessful replication attempts and the resulting delay
        in replication to the Kinesis data stream.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - AgeOfOldestUnreplicatedRecord'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableAgeOfOldestUnreplicatedRecordAlarmProps",
    jsii_struct_bases=[
        DynamoDbTableAlarmProps, DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig
    ],
    name_mapping={
        "table": "table",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DynamoDbTableAgeOfOldestUnreplicatedRecordAlarmProps(
    DynamoDbTableAlarmProps,
    DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig,
):
    def __init__(
        self,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DynamoDbTableAgeOfOldestUnreplicatedRecordAlarm construct.

        :param table: The DynamoDb Table to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to the desired replication delay measured in milliseconds. This value depends on your workload's requirements and expected performance.
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor unsuccessful replication attempts and the resulting delay in replication to the Kinesis data stream.
        :param alarm_name: The alarm name. Default: - tableName + ' - AgeOfOldestUnreplicatedRecord'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__9f348f8b78a34083d95fe7e7df621441fa0bde91f2c6fc46b838da11e7b8f83e)
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "table": table,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def table(self) -> _aws_cdk_aws_dynamodb_ceddda9d.Table:
        '''The DynamoDb Table to monitor.'''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_aws_cdk_aws_dynamodb_ceddda9d.Table, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to the desired replication delay measured in milliseconds.

        This value depends on your workload's requirements and expected performance.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can monitor unsuccessful replication attempts and the resulting delay
        in replication to the Kinesis data stream.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - AgeOfOldestUnreplicatedRecord'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbTableAgeOfOldestUnreplicatedRecordAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableThrottledPutRecordCountAlarmProps",
    jsii_struct_bases=[
        DynamoDbTableAlarmProps, DynamoDbThrottledPutRecordCountAlarmConfig
    ],
    name_mapping={
        "table": "table",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DynamoDbTableThrottledPutRecordCountAlarmProps(
    DynamoDbTableAlarmProps,
    DynamoDbThrottledPutRecordCountAlarmConfig,
):
    def __init__(
        self,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DynamoDbTableThrottledPutRecordCountAlarm construct.

        :param table: The DynamoDb Table to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: You might experience some throttling during exceptional usage peaks, but throttled records should remain as low as possible to avoid higher replication latency (DynamoDB retries sending throttled records to the Kinesis data stream). Set the threshold to a number which can help you catch regular excessive throttling. You can also analyze historical data of this metric to find the acceptable throttling rates for the application workload. Tune the threshold to a value that the application can tolerate based on your use case.
        :param alarm_description: The description of the alarm. Default: - This alarm can monitor the number of records that that were throttled by your Kinesis data stream because of insufficient Kinesis data stream capacity.
        :param alarm_name: The alarm name. Default: - tableName + ' - ThrottledPutRecordCount'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 10
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 10
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98efecbd95f367374d4314f3a5a468d5dfffed68dc321f2ab0f27ed31008c4c9)
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "table": table,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def table(self) -> _aws_cdk_aws_dynamodb_ceddda9d.Table:
        '''The DynamoDb Table to monitor.'''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_aws_cdk_aws_dynamodb_ceddda9d.Table, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''You might experience some throttling during exceptional usage peaks, but throttled records should remain as low as possible to avoid higher replication latency (DynamoDB retries sending throttled records to the Kinesis data stream).

        Set the threshold to a number which can help you
        catch regular excessive throttling. You can also analyze historical data of this metric to find
        the acceptable throttling rates for the application workload. Tune the threshold to a value that
        the application can tolerate based on your use case.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can monitor the number of records that that were throttled by your Kinesis
        data stream because of insufficient Kinesis data stream capacity.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - ThrottledPutRecordCount'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 10
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 10
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbTableThrottledPutRecordCountAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.DynamoDbTableWriteThrottleEventsAlarmProps",
    jsii_struct_bases=[
        DynamoDbTableAlarmProps, DynamoDbWriteThrottleEventsAlarmConfig
    ],
    name_mapping={
        "table": "table",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class DynamoDbTableWriteThrottleEventsAlarmProps(
    DynamoDbTableAlarmProps,
    DynamoDbWriteThrottleEventsAlarmConfig,
):
    def __init__(
        self,
        *,
        table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the DynamoDbTableWriteThrottleEventsAlarm construct.

        :param table: The DynamoDb Table to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to the expected write traffic for the DynamoDB table, accounting for an acceptable level of throttling. It is important to monitor if you are under provisioned and not causing consistent throttling. You can also analyze historical data to find the acceptable level of throttling for the application workload, and then tune the threshold to a value higher than your usual acceptable throttling level. Throttled requests should be retried by the application/service as they are transient. Therefore, a very low threshold might cause the alarm to be too sensitive, causing unwanted state transitions.
        :param alarm_description: The description of the alarm. Default: - This alarm can detect sustained throttling for write requests to the DynamoDB table. Sustained throttling of write requests can negatively impact your workload write operations and reduce the overall efficiency of the system.
        :param alarm_name: The alarm name. Default: - tableName + ' - WriteThrottleEvents'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__98da88178305cce5dbc06633d2b934d9ea7adb35424648c86fc6d217c4c9eccc)
            check_type(argname="argument table", value=table, expected_type=type_hints["table"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "table": table,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def table(self) -> _aws_cdk_aws_dynamodb_ceddda9d.Table:
        '''The DynamoDb Table to monitor.'''
        result = self._values.get("table")
        assert result is not None, "Required property 'table' is missing"
        return typing.cast(_aws_cdk_aws_dynamodb_ceddda9d.Table, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to the expected write traffic for the DynamoDB table, accounting for an acceptable level of throttling.

        It is important to monitor if you
        are under provisioned and not causing consistent throttling. You can also analyze
        historical data to find the acceptable level of throttling for the application workload,
        and then tune the threshold to a value higher than your usual acceptable throttling level.
        Throttled requests should be retried by the application/service as they are transient.
        Therefore, a very low threshold might cause the alarm to be too sensitive, causing
        unwanted state transitions.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm can detect sustained throttling for write requests to the DynamoDB table.
        Sustained throttling of write requests can negatively impact your workload write operations and
        reduce the overall efficiency of the system.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - tableName + ' - WriteThrottleEvents'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DynamoDbTableWriteThrottleEventsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.Ec2InstanceStatusCheckFailedAlarmProps",
    jsii_struct_bases=[Ec2InstanceAlarmProps, Ec2StatusCheckFailedAlarmConfig],
    name_mapping={
        "instance": "instance",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class Ec2InstanceStatusCheckFailedAlarmProps(
    Ec2InstanceAlarmProps,
    Ec2StatusCheckFailedAlarmConfig,
):
    def __init__(
        self,
        *,
        instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the Ec2InstanceStatusCheckFailedAlarm construct.

        :param instance: The EC2 Instance to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect the underlying problems with instances, including both system status check failures and instance status check failures.
        :param alarm_name: The alarm name. Default: - instanceId + ' - StatusCheckFailed'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 2
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 2
        :param threshold: When a status check fails, the value of this metric is 1. The threshold is set so that whenever the status check fails, the alarm is in ALARM state. Default: 1
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b33eba2c5ad4ba561b1c26f8bc71fefb78fc5741ff81d3654641260b9994141b)
            check_type(argname="argument instance", value=instance, expected_type=type_hints["instance"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "instance": instance,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def instance(self) -> _aws_cdk_aws_ec2_ceddda9d.Instance:
        '''The EC2 Instance to monitor.'''
        result = self._values.get("instance")
        assert result is not None, "Required property 'instance' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.Instance, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect the underlying problems with instances, including both system
        status check failures and instance status check failures.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - instanceId + ' - StatusCheckFailed'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 2
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 2
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''When a status check fails, the value of this metric is 1.

        The threshold is set so that whenever the
        status check fails, the alarm is in ALARM state.

        :default: 1
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "Ec2InstanceStatusCheckFailedAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.EfsFileSystemPercentIOLimitAlarmProps",
    jsii_struct_bases=[EfsFileSystemAlarmProps, EfsPercentIOLimitAlarmConfig],
    name_mapping={
        "file_system": "fileSystem",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class EfsFileSystemPercentIOLimitAlarmProps(
    EfsFileSystemAlarmProps,
    EfsPercentIOLimitAlarmConfig,
):
    def __init__(
        self,
        *,
        file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the EfsFileSystemPercentIOLimitAlarm construct.

        :param file_system: The EFS FileSystem to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect how close the file system is to reach the I/O limit of the General Purpose performance mode. Consistent high I/O percentage can be an indicator of the file system cannot scale with respect to I/O requests enough and the file system can be a resource bottleneck for the applications that use the file system.
        :param alarm_name: The alarm name. Default: - fileSystemId + ' - PercentIOLimit'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param threshold: When the file system reaches its I/O limit, it may respond to read and write requests slower. Therefore, it is recommended that the metric is monitored to avoid impacting applications that use the file system. The threshold can be set around 100%. However, this value can be adjusted to a lower value based on file system characteristics. Default: 100
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__08931903547dea16bff3263184394b49fb1f550cbe3a0da8fbf53312f5ea7144)
            check_type(argname="argument file_system", value=file_system, expected_type=type_hints["file_system"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "file_system": file_system,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def file_system(self) -> _aws_cdk_aws_efs_ceddda9d.FileSystem:
        '''The EFS FileSystem to monitor.'''
        result = self._values.get("file_system")
        assert result is not None, "Required property 'file_system' is missing"
        return typing.cast(_aws_cdk_aws_efs_ceddda9d.FileSystem, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect how close the file system is to reach the I/O limit of the General
        Purpose performance mode. Consistent high I/O percentage can be an indicator of the file system cannot scale
        with respect to I/O requests enough and the file system can be a resource bottleneck for the applications
        that use the file system.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - fileSystemId + ' - PercentIOLimit'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''When the file system reaches its I/O limit, it may respond to read and write requests slower.

        Therefore, it is recommended that the metric is monitored to avoid impacting applications that
        use the file system. The threshold can be set around 100%. However, this value can be adjusted
        to a lower value based on file system characteristics.

        :default: 100
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EfsFileSystemPercentIOLimitAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterDatabaseMemoryUsagePercentageAlarmProps",
    jsii_struct_bases=[
        ElastiCacheClusterAlarmProps,
        ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig,
    ],
    name_mapping={
        "cache_cluster": "cacheCluster",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class ElastiCacheClusterDatabaseMemoryUsagePercentageAlarmProps(
    ElastiCacheClusterAlarmProps,
    ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig,
):
    def __init__(
        self,
        *,
        cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ElastiCacheClusterDatabaseMemoryUsagePercentageAlarm construct.

        :param cache_cluster: The ElastiCache CfnCacheCluster to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Depending on your application's memory requirements and the memory capacity of your ElastiCache cluster, you should set the threshold to the percentage that reflects the critical level of memory usage of the cluster. You can use historical memory usage data as reference for acceptable memory usage threshold.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high memory utilization of your cluster so that you can avoid failures when writing to your cluster. It is useful to know when you will need to scale up your cluster if your application does not expect to experience evictions.
        :param alarm_name: The alarm name. Default: - logicalId + ' - DatabaseMemoryUsagePercentage'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1eb86189fd2410b545bda060312fc7d8d4328aa2d11687ace0843fb407cfe7dc)
            check_type(argname="argument cache_cluster", value=cache_cluster, expected_type=type_hints["cache_cluster"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cache_cluster": cache_cluster,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def cache_cluster(self) -> _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster:
        '''The ElastiCache CfnCacheCluster to monitor.'''
        result = self._values.get("cache_cluster")
        assert result is not None, "Required property 'cache_cluster' is missing"
        return typing.cast(_aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Depending on your application's memory requirements and the memory capacity of your ElastiCache cluster, you should set the threshold to the percentage that reflects the critical level of memory usage of the cluster.

        You can use historical memory usage data as reference for acceptable memory usage threshold.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high memory utilization of your cluster so that you can avoid failures when writing to
        your cluster. It is useful to know when you will need to scale up your cluster if your application does not expect to experience
        evictions.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - logicalId + ' - DatabaseMemoryUsagePercentage'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheClusterDatabaseMemoryUsagePercentageAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterEngineCpuUtilizationAlarmProps",
    jsii_struct_bases=[
        ElastiCacheClusterAlarmProps, ElastiCacheEngineCpuUtilizationAlarmConfig
    ],
    name_mapping={
        "cache_cluster": "cacheCluster",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class ElastiCacheClusterEngineCpuUtilizationAlarmProps(
    ElastiCacheClusterAlarmProps,
    ElastiCacheEngineCpuUtilizationAlarmConfig,
):
    def __init__(
        self,
        *,
        cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ElastiCacheClusterEngineCpuUtilizationAlarm construct.

        :param cache_cluster: The ElastiCache CfnCacheCluster to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high CPU utilization of the Redis OSS engine thread. It is useful if you want to monitor the CPU usage of the database engine itself.
        :param alarm_name: The alarm name. Default: - logicalId + ' - EngineCPUUtilization'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param threshold: Set the threshold to a percentage that reflects the critical engine CPU utilization level for your application. You can benchmark your cluster using your application and expected workload to correlate EngineCPUUtilization and performance as a reference, and then set the threshold accordingly. In most cases, you can set the threshold to about 90% of your available CPU. Default: 90
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c0a19aec1269a335c7710e9debe18cb272fc11d853adcdb8455bf19946c75ad0)
            check_type(argname="argument cache_cluster", value=cache_cluster, expected_type=type_hints["cache_cluster"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cache_cluster": cache_cluster,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def cache_cluster(self) -> _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster:
        '''The ElastiCache CfnCacheCluster to monitor.'''
        result = self._values.get("cache_cluster")
        assert result is not None, "Required property 'cache_cluster' is missing"
        return typing.cast(_aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high CPU utilization of the Redis OSS engine thread. It is useful if you want
        to monitor the CPU usage of the database engine itself.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - logicalId + ' - EngineCPUUtilization'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''Set the threshold to a percentage that reflects the critical engine CPU utilization level for your application.

        You can benchmark your cluster using your application and expected workload to correlate EngineCPUUtilization and
        performance as a reference, and then set the threshold accordingly. In most cases, you can set the threshold to
        about 90% of your available CPU.

        :default: 90
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheClusterEngineCpuUtilizationAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheClusterReplicationLagAlarmProps",
    jsii_struct_bases=[
        ElastiCacheClusterAlarmProps, ElastiCacheReplicationLagAlarmConfig
    ],
    name_mapping={
        "cache_cluster": "cacheCluster",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class ElastiCacheClusterReplicationLagAlarmProps(
    ElastiCacheClusterAlarmProps,
    ElastiCacheReplicationLagAlarmConfig,
):
    def __init__(
        self,
        *,
        cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ElastiCacheClusterReplicationLagAlarm construct.

        :param cache_cluster: The ElastiCache CfnCacheCluster to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to your application's requirements and the potential impact of replication lag. You should consider your application's expected write rates and network conditions for the acceptable replication lag.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a delay between data updates on the primary node and their synchronization to replica node. It helps to ensure data consistency of a read replica cluster node.
        :param alarm_name: The alarm name. Default: - logicalId + ' - ReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__6bacb9d6a2a0e5811a29c8afafe616efd3e9486c5d853fe1ee51a0288a821884)
            check_type(argname="argument cache_cluster", value=cache_cluster, expected_type=type_hints["cache_cluster"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cache_cluster": cache_cluster,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def cache_cluster(self) -> _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster:
        '''The ElastiCache CfnCacheCluster to monitor.'''
        result = self._values.get("cache_cluster")
        assert result is not None, "Required property 'cache_cluster' is missing"
        return typing.cast(_aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to your application's requirements and the potential impact of replication lag.

        You should
        consider your application's expected write rates and network conditions for the acceptable replication lag.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect a delay between data updates on the primary node and their synchronization to replica node.
        It helps to ensure data consistency of a read replica cluster node.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - logicalId + ' - ReplicationLag'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheClusterReplicationLagAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.ElastiCacheReplicationGroupReplicationLagAlarmProps",
    jsii_struct_bases=[
        ElastiCacheReplicationGroupAlarmProps, ElastiCacheReplicationLagAlarmConfig
    ],
    name_mapping={
        "cache_replication_group": "cacheReplicationGroup",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class ElastiCacheReplicationGroupReplicationLagAlarmProps(
    ElastiCacheReplicationGroupAlarmProps,
    ElastiCacheReplicationLagAlarmConfig,
):
    def __init__(
        self,
        *,
        cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the ElastiCacheReplicationGroupReplicationLagAlarm construct.

        :param cache_replication_group: The ElastiCache CfnReplicationGroup to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to your application's requirements and the potential impact of replication lag. You should consider your application's expected write rates and network conditions for the acceptable replication lag.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect a delay between data updates on the primary node and their synchronization to replica node. It helps to ensure data consistency of a read replica cluster node.
        :param alarm_name: The alarm name. Default: - logicalId + ' - ReplicationLag'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b73985d171d9bd90c38b1885632619bfa49461782b0b16b2ba76aa01ddd27899)
            check_type(argname="argument cache_replication_group", value=cache_replication_group, expected_type=type_hints["cache_replication_group"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "cache_replication_group": cache_replication_group,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def cache_replication_group(
        self,
    ) -> _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup:
        '''The ElastiCache CfnReplicationGroup to monitor.'''
        result = self._values.get("cache_replication_group")
        assert result is not None, "Required property 'cache_replication_group' is missing"
        return typing.cast(_aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to your application's requirements and the potential impact of replication lag.

        You should
        consider your application's expected write rates and network conditions for the acceptable replication lag.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect a delay between data updates on the primary node and their synchronization to replica node.
        It helps to ensure data consistency of a read replica cluster node.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - logicalId + ' - ReplicationLag'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ElastiCacheReplicationGroupReplicationLagAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarmProps",
    jsii_struct_bases=[
        PrivateLinkEndpointsInterfaceVpcEndpointAlarmProps,
        PrivateLinkEndpointsPacketsDroppedAlarmConfig,
    ],
    name_mapping={
        "endpoint": "endpoint",
        "endpoint_type": "endpointType",
        "service_name": "serviceName",
        "subnet_id": "subnetId",
        "vpc_id": "vpcId",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "subnets": "subnets",
    },
)
class PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarmProps(
    PrivateLinkEndpointsInterfaceVpcEndpointAlarmProps,
    PrivateLinkEndpointsPacketsDroppedAlarmConfig,
):
    def __init__(
        self,
        *,
        endpoint: _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
        endpoint_type: builtins.str,
        service_name: builtins.str,
        subnet_id: builtins.str,
        vpc_id: builtins.str,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        subnets: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISubnet]] = None,
    ) -> None:
        '''The properties for the PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarm construct.

        :param endpoint: The PrivateLink InterfaceVpcEndpoint to monitor.
        :param endpoint_type: The type of the PrivateLink InterfaceVpcEndpoint.
        :param service_name: The service name of the PrivateLink InterfaceVpcEndpoint.
        :param subnet_id: The subnet ID of the PrivateLink InterfaceVpcEndpoint.
        :param vpc_id: The VPC ID of the PrivateLink InterfaceVpcEndpoint.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: Set the threshold according to the use case. If you want to be aware of the unhealthy status of the endpoint or endpoint service, you should set the threshold low so that you get a chance to fix the issue before a huge data loss. You can use historical data to understand the tolerance for dropped packets and set the threshold accordingly.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect if the endpoint or endpoint service is unhealthy.
        :param alarm_name: The alarm name. Default: - endpointId + ' - ' + subnetId + ' - PacketsDropped'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        :param subnets: The subnets of the PrivateLink InterfaceVpcEndpoint.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1c39cdc17e5d760eca4f81a609afea81c16937c48f2a8bb492c8b721818a6a69)
            check_type(argname="argument endpoint", value=endpoint, expected_type=type_hints["endpoint"])
            check_type(argname="argument endpoint_type", value=endpoint_type, expected_type=type_hints["endpoint_type"])
            check_type(argname="argument service_name", value=service_name, expected_type=type_hints["service_name"])
            check_type(argname="argument subnet_id", value=subnet_id, expected_type=type_hints["subnet_id"])
            check_type(argname="argument vpc_id", value=vpc_id, expected_type=type_hints["vpc_id"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument subnets", value=subnets, expected_type=type_hints["subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "endpoint": endpoint,
            "endpoint_type": endpoint_type,
            "service_name": service_name,
            "subnet_id": subnet_id,
            "vpc_id": vpc_id,
            "threshold": threshold,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if subnets is not None:
            self._values["subnets"] = subnets

    @builtins.property
    def endpoint(self) -> _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint:
        '''The PrivateLink InterfaceVpcEndpoint to monitor.'''
        result = self._values.get("endpoint")
        assert result is not None, "Required property 'endpoint' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint, result)

    @builtins.property
    def endpoint_type(self) -> builtins.str:
        '''The type of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("endpoint_type")
        assert result is not None, "Required property 'endpoint_type' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def service_name(self) -> builtins.str:
        '''The service name of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("service_name")
        assert result is not None, "Required property 'service_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def subnet_id(self) -> builtins.str:
        '''The subnet ID of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("subnet_id")
        assert result is not None, "Required property 'subnet_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def vpc_id(self) -> builtins.str:
        '''The VPC ID of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("vpc_id")
        assert result is not None, "Required property 'vpc_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''Set the threshold according to the use case.

        If you want to be aware of the unhealthy status of the endpoint or endpoint service,
        you should set the threshold low so that you get a chance to fix the issue before a huge data loss. You can use historical data to
        understand the tolerance for dropped packets and set the threshold accordingly.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default: - This alarm is used to detect if the endpoint or endpoint service is unhealthy.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - endpointId + ' - ' + subnetId + ' - PacketsDropped'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def subnets(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISubnet]]:
        '''The subnets of the PrivateLink InterfaceVpcEndpoint.'''
        result = self._values.get("subnets")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISubnet]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceReadLatencyAlarmProps",
    jsii_struct_bases=[RdsInstanceAlarmProps, RdsReadLatencyAlarmConfig],
    name_mapping={
        "database_instance": "databaseInstance",
        "instance_identifier": "instanceIdentifier",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsInstanceReadLatencyAlarmProps(
    RdsInstanceAlarmProps,
    RdsReadLatencyAlarmConfig,
):
    def __init__(
        self,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the RdsInstanceReadLatencyAlarm construct.

        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value in milliseconds against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on your use case. Read latencies higher than 20 milliseconds are likely a cause for investigation. You can also set a higher threshold if your application can have higher latency for read operations. Review the criticality and requirements of read latency and analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high read latency. Database disks normally have a low read/write latency, but they can have issues that can cause high latency operations.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - ReadLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__beb18f34f2021412d98d34314718d66664fa027d213689ff6f0428261cc9a071)
            check_type(argname="argument database_instance", value=database_instance, expected_type=type_hints["database_instance"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if database_instance is not None:
            self._values["database_instance"] = database_instance
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def database_instance(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance]:
        '''The database instance to monitor.'''
        result = self._values.get("database_instance")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''The database instance identifier to monitor.'''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value in milliseconds against which the specified statistic is compared.

        The recommended threshold value for this alarm is highly dependent on your use case.
        Read latencies higher than 20 milliseconds are likely a cause for investigation.
        You can also set a higher threshold if your application can have higher latency for
        read operations. Review the criticality and requirements of read latency and analyze
        the historical behavior of this metric to determine sensible threshold levels.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high read latency. Database disks normally
        have a low read/write latency, but they can have issues that can cause high latency
        operations.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - ReadLatency'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceReadLatencyAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceRecommendedAlarmsConfig",
    jsii_struct_bases=[RdsRecommendedAlarmsConfig],
    name_mapping={
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "config_database_connections_alarm": "configDatabaseConnectionsAlarm",
        "config_db_load_alarm": "configDbLoadAlarm",
        "config_freeable_memory_alarm": "configFreeableMemoryAlarm",
        "config_free_local_storage_alarm": "configFreeLocalStorageAlarm",
        "config_free_storage_space_alarm": "configFreeStorageSpaceAlarm",
        "config_read_latency_alarm": "configReadLatencyAlarm",
        "config_write_latency_alarm": "configWriteLatencyAlarm",
        "config_cpu_utilization_alarm": "configCpuUtilizationAlarm",
    },
)
class RdsInstanceRecommendedAlarmsConfig(RdsRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_read_latency_alarm: typing.Union[RdsReadLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_write_latency_alarm: typing.Union[RdsWriteLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param config_database_connections_alarm: The configuration for the DatabaseConnections alarm.
        :param config_db_load_alarm: The configuration for the DbLoad alarm.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_local_storage_alarm: The configuration for the FreeLocalStorage alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_read_latency_alarm: The configuration for the ReadLatency alarm.
        :param config_write_latency_alarm: The configuration for the WriteLatency alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        '''
        if isinstance(config_database_connections_alarm, dict):
            config_database_connections_alarm = RdsDatabaseConnectionsAlarmConfig(**config_database_connections_alarm)
        if isinstance(config_db_load_alarm, dict):
            config_db_load_alarm = RdsDbLoadAlarmConfig(**config_db_load_alarm)
        if isinstance(config_freeable_memory_alarm, dict):
            config_freeable_memory_alarm = RdsFreeableMemoryAlarmConfig(**config_freeable_memory_alarm)
        if isinstance(config_free_local_storage_alarm, dict):
            config_free_local_storage_alarm = RdsFreeLocalStorageAlarmConfig(**config_free_local_storage_alarm)
        if isinstance(config_free_storage_space_alarm, dict):
            config_free_storage_space_alarm = RdsFreeStorageSpaceAlarmConfig(**config_free_storage_space_alarm)
        if isinstance(config_read_latency_alarm, dict):
            config_read_latency_alarm = RdsReadLatencyAlarmConfig(**config_read_latency_alarm)
        if isinstance(config_write_latency_alarm, dict):
            config_write_latency_alarm = RdsWriteLatencyAlarmConfig(**config_write_latency_alarm)
        if isinstance(config_cpu_utilization_alarm, dict):
            config_cpu_utilization_alarm = RdsCpuUtilizationAlarmConfig(**config_cpu_utilization_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__e30b9328441cd94f01a1d615db5780f69ca0ca1af46f6a8a08e4a79ac1beebdc)
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument config_database_connections_alarm", value=config_database_connections_alarm, expected_type=type_hints["config_database_connections_alarm"])
            check_type(argname="argument config_db_load_alarm", value=config_db_load_alarm, expected_type=type_hints["config_db_load_alarm"])
            check_type(argname="argument config_freeable_memory_alarm", value=config_freeable_memory_alarm, expected_type=type_hints["config_freeable_memory_alarm"])
            check_type(argname="argument config_free_local_storage_alarm", value=config_free_local_storage_alarm, expected_type=type_hints["config_free_local_storage_alarm"])
            check_type(argname="argument config_free_storage_space_alarm", value=config_free_storage_space_alarm, expected_type=type_hints["config_free_storage_space_alarm"])
            check_type(argname="argument config_read_latency_alarm", value=config_read_latency_alarm, expected_type=type_hints["config_read_latency_alarm"])
            check_type(argname="argument config_write_latency_alarm", value=config_write_latency_alarm, expected_type=type_hints["config_write_latency_alarm"])
            check_type(argname="argument config_cpu_utilization_alarm", value=config_cpu_utilization_alarm, expected_type=type_hints["config_cpu_utilization_alarm"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_database_connections_alarm": config_database_connections_alarm,
            "config_db_load_alarm": config_db_load_alarm,
            "config_freeable_memory_alarm": config_freeable_memory_alarm,
            "config_free_local_storage_alarm": config_free_local_storage_alarm,
            "config_free_storage_space_alarm": config_free_storage_space_alarm,
            "config_read_latency_alarm": config_read_latency_alarm,
            "config_write_latency_alarm": config_write_latency_alarm,
        }
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if config_cpu_utilization_alarm is not None:
            self._values["config_cpu_utilization_alarm"] = config_cpu_utilization_alarm

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[RdsRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[RdsRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def config_database_connections_alarm(self) -> RdsDatabaseConnectionsAlarmConfig:
        '''The configuration for the DatabaseConnections alarm.'''
        result = self._values.get("config_database_connections_alarm")
        assert result is not None, "Required property 'config_database_connections_alarm' is missing"
        return typing.cast(RdsDatabaseConnectionsAlarmConfig, result)

    @builtins.property
    def config_db_load_alarm(self) -> RdsDbLoadAlarmConfig:
        '''The configuration for the DbLoad alarm.'''
        result = self._values.get("config_db_load_alarm")
        assert result is not None, "Required property 'config_db_load_alarm' is missing"
        return typing.cast(RdsDbLoadAlarmConfig, result)

    @builtins.property
    def config_freeable_memory_alarm(self) -> RdsFreeableMemoryAlarmConfig:
        '''The configuration for the FreeableMemory alarm.'''
        result = self._values.get("config_freeable_memory_alarm")
        assert result is not None, "Required property 'config_freeable_memory_alarm' is missing"
        return typing.cast(RdsFreeableMemoryAlarmConfig, result)

    @builtins.property
    def config_free_local_storage_alarm(self) -> RdsFreeLocalStorageAlarmConfig:
        '''The configuration for the FreeLocalStorage alarm.'''
        result = self._values.get("config_free_local_storage_alarm")
        assert result is not None, "Required property 'config_free_local_storage_alarm' is missing"
        return typing.cast(RdsFreeLocalStorageAlarmConfig, result)

    @builtins.property
    def config_free_storage_space_alarm(self) -> RdsFreeStorageSpaceAlarmConfig:
        '''The configuration for the FreeStorageSpace alarm.'''
        result = self._values.get("config_free_storage_space_alarm")
        assert result is not None, "Required property 'config_free_storage_space_alarm' is missing"
        return typing.cast(RdsFreeStorageSpaceAlarmConfig, result)

    @builtins.property
    def config_read_latency_alarm(self) -> RdsReadLatencyAlarmConfig:
        '''The configuration for the ReadLatency alarm.'''
        result = self._values.get("config_read_latency_alarm")
        assert result is not None, "Required property 'config_read_latency_alarm' is missing"
        return typing.cast(RdsReadLatencyAlarmConfig, result)

    @builtins.property
    def config_write_latency_alarm(self) -> RdsWriteLatencyAlarmConfig:
        '''The configuration for the WriteLatency alarm.'''
        result = self._values.get("config_write_latency_alarm")
        assert result is not None, "Required property 'config_write_latency_alarm' is missing"
        return typing.cast(RdsWriteLatencyAlarmConfig, result)

    @builtins.property
    def config_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[RdsCpuUtilizationAlarmConfig]:
        '''The configuration for the CpuUtilization alarm.'''
        result = self._values.get("config_cpu_utilization_alarm")
        return typing.cast(typing.Optional[RdsCpuUtilizationAlarmConfig], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceRecommendedAlarmsProps",
    jsii_struct_bases=[RdsInstanceRecommendedAlarmsConfig],
    name_mapping={
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "config_database_connections_alarm": "configDatabaseConnectionsAlarm",
        "config_db_load_alarm": "configDbLoadAlarm",
        "config_freeable_memory_alarm": "configFreeableMemoryAlarm",
        "config_free_local_storage_alarm": "configFreeLocalStorageAlarm",
        "config_free_storage_space_alarm": "configFreeStorageSpaceAlarm",
        "config_read_latency_alarm": "configReadLatencyAlarm",
        "config_write_latency_alarm": "configWriteLatencyAlarm",
        "config_cpu_utilization_alarm": "configCpuUtilizationAlarm",
        "database_instance": "databaseInstance",
        "instance_identifier": "instanceIdentifier",
    },
)
class RdsInstanceRecommendedAlarmsProps(RdsInstanceRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_read_latency_alarm: typing.Union[RdsReadLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_write_latency_alarm: typing.Union[RdsWriteLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param config_database_connections_alarm: The configuration for the DatabaseConnections alarm.
        :param config_db_load_alarm: The configuration for the DbLoad alarm.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_local_storage_alarm: The configuration for the FreeLocalStorage alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_read_latency_alarm: The configuration for the ReadLatency alarm.
        :param config_write_latency_alarm: The configuration for the WriteLatency alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param database_instance: The cluster instance to apply the recommended alarms.
        :param instance_identifier: The cluster instance identifier to apply the recommended alarms.
        '''
        if isinstance(config_database_connections_alarm, dict):
            config_database_connections_alarm = RdsDatabaseConnectionsAlarmConfig(**config_database_connections_alarm)
        if isinstance(config_db_load_alarm, dict):
            config_db_load_alarm = RdsDbLoadAlarmConfig(**config_db_load_alarm)
        if isinstance(config_freeable_memory_alarm, dict):
            config_freeable_memory_alarm = RdsFreeableMemoryAlarmConfig(**config_freeable_memory_alarm)
        if isinstance(config_free_local_storage_alarm, dict):
            config_free_local_storage_alarm = RdsFreeLocalStorageAlarmConfig(**config_free_local_storage_alarm)
        if isinstance(config_free_storage_space_alarm, dict):
            config_free_storage_space_alarm = RdsFreeStorageSpaceAlarmConfig(**config_free_storage_space_alarm)
        if isinstance(config_read_latency_alarm, dict):
            config_read_latency_alarm = RdsReadLatencyAlarmConfig(**config_read_latency_alarm)
        if isinstance(config_write_latency_alarm, dict):
            config_write_latency_alarm = RdsWriteLatencyAlarmConfig(**config_write_latency_alarm)
        if isinstance(config_cpu_utilization_alarm, dict):
            config_cpu_utilization_alarm = RdsCpuUtilizationAlarmConfig(**config_cpu_utilization_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__bd4d89a7589c4d9c1cf7355f265d70509d02ad61effc55d4cbb9a18bad7374fb)
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument config_database_connections_alarm", value=config_database_connections_alarm, expected_type=type_hints["config_database_connections_alarm"])
            check_type(argname="argument config_db_load_alarm", value=config_db_load_alarm, expected_type=type_hints["config_db_load_alarm"])
            check_type(argname="argument config_freeable_memory_alarm", value=config_freeable_memory_alarm, expected_type=type_hints["config_freeable_memory_alarm"])
            check_type(argname="argument config_free_local_storage_alarm", value=config_free_local_storage_alarm, expected_type=type_hints["config_free_local_storage_alarm"])
            check_type(argname="argument config_free_storage_space_alarm", value=config_free_storage_space_alarm, expected_type=type_hints["config_free_storage_space_alarm"])
            check_type(argname="argument config_read_latency_alarm", value=config_read_latency_alarm, expected_type=type_hints["config_read_latency_alarm"])
            check_type(argname="argument config_write_latency_alarm", value=config_write_latency_alarm, expected_type=type_hints["config_write_latency_alarm"])
            check_type(argname="argument config_cpu_utilization_alarm", value=config_cpu_utilization_alarm, expected_type=type_hints["config_cpu_utilization_alarm"])
            check_type(argname="argument database_instance", value=database_instance, expected_type=type_hints["database_instance"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_database_connections_alarm": config_database_connections_alarm,
            "config_db_load_alarm": config_db_load_alarm,
            "config_freeable_memory_alarm": config_freeable_memory_alarm,
            "config_free_local_storage_alarm": config_free_local_storage_alarm,
            "config_free_storage_space_alarm": config_free_storage_space_alarm,
            "config_read_latency_alarm": config_read_latency_alarm,
            "config_write_latency_alarm": config_write_latency_alarm,
        }
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if config_cpu_utilization_alarm is not None:
            self._values["config_cpu_utilization_alarm"] = config_cpu_utilization_alarm
        if database_instance is not None:
            self._values["database_instance"] = database_instance
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[RdsRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[RdsRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def config_database_connections_alarm(self) -> RdsDatabaseConnectionsAlarmConfig:
        '''The configuration for the DatabaseConnections alarm.'''
        result = self._values.get("config_database_connections_alarm")
        assert result is not None, "Required property 'config_database_connections_alarm' is missing"
        return typing.cast(RdsDatabaseConnectionsAlarmConfig, result)

    @builtins.property
    def config_db_load_alarm(self) -> RdsDbLoadAlarmConfig:
        '''The configuration for the DbLoad alarm.'''
        result = self._values.get("config_db_load_alarm")
        assert result is not None, "Required property 'config_db_load_alarm' is missing"
        return typing.cast(RdsDbLoadAlarmConfig, result)

    @builtins.property
    def config_freeable_memory_alarm(self) -> RdsFreeableMemoryAlarmConfig:
        '''The configuration for the FreeableMemory alarm.'''
        result = self._values.get("config_freeable_memory_alarm")
        assert result is not None, "Required property 'config_freeable_memory_alarm' is missing"
        return typing.cast(RdsFreeableMemoryAlarmConfig, result)

    @builtins.property
    def config_free_local_storage_alarm(self) -> RdsFreeLocalStorageAlarmConfig:
        '''The configuration for the FreeLocalStorage alarm.'''
        result = self._values.get("config_free_local_storage_alarm")
        assert result is not None, "Required property 'config_free_local_storage_alarm' is missing"
        return typing.cast(RdsFreeLocalStorageAlarmConfig, result)

    @builtins.property
    def config_free_storage_space_alarm(self) -> RdsFreeStorageSpaceAlarmConfig:
        '''The configuration for the FreeStorageSpace alarm.'''
        result = self._values.get("config_free_storage_space_alarm")
        assert result is not None, "Required property 'config_free_storage_space_alarm' is missing"
        return typing.cast(RdsFreeStorageSpaceAlarmConfig, result)

    @builtins.property
    def config_read_latency_alarm(self) -> RdsReadLatencyAlarmConfig:
        '''The configuration for the ReadLatency alarm.'''
        result = self._values.get("config_read_latency_alarm")
        assert result is not None, "Required property 'config_read_latency_alarm' is missing"
        return typing.cast(RdsReadLatencyAlarmConfig, result)

    @builtins.property
    def config_write_latency_alarm(self) -> RdsWriteLatencyAlarmConfig:
        '''The configuration for the WriteLatency alarm.'''
        result = self._values.get("config_write_latency_alarm")
        assert result is not None, "Required property 'config_write_latency_alarm' is missing"
        return typing.cast(RdsWriteLatencyAlarmConfig, result)

    @builtins.property
    def config_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[RdsCpuUtilizationAlarmConfig]:
        '''The configuration for the CpuUtilization alarm.'''
        result = self._values.get("config_cpu_utilization_alarm")
        return typing.cast(typing.Optional[RdsCpuUtilizationAlarmConfig], result)

    @builtins.property
    def database_instance(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance]:
        '''The cluster instance to apply the recommended alarms.'''
        result = self._values.get("database_instance")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''The cluster instance identifier to apply the recommended alarms.'''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsInstanceWriteLatencyAlarmProps",
    jsii_struct_bases=[RdsInstanceAlarmProps, RdsWriteLatencyAlarmConfig],
    name_mapping={
        "database_instance": "databaseInstance",
        "instance_identifier": "instanceIdentifier",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
    },
)
class RdsInstanceWriteLatencyAlarmProps(
    RdsInstanceAlarmProps,
    RdsWriteLatencyAlarmConfig,
):
    def __init__(
        self,
        *,
        database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
        instance_identifier: typing.Optional[builtins.str] = None,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: jsii.Number,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the RdsInstanceWriteLatencyAlarm construct.

        :param database_instance: The database instance to monitor.
        :param instance_identifier: The database instance identifier to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value in milliseconds against which the specified statistic is compared. The recommended threshold value for this alarm is highly dependent on your use case. Write latencies higher than 20 milliseconds are likely a cause for investigation. You can also set a higher threshold if your application can have a higher latency for write operations. Review the criticality and requirements of write latency and analyze the historical behavior of this metric to determine sensible threshold levels.
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect high write latency. Although database disks typically have low read/write latency, they may experience problems that cause high latency operations. Monitoring this will assure you the disk latency is as low as expected.
        :param alarm_name: The alarm name. Default: - database.instanceIdentifiers[*] + ' - WriteLatency'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 5
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 5
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__0aa5f8fb9093ada52badeda4a61c6d8a7be4621dceffc9f90f256b103ee891fe)
            check_type(argname="argument database_instance", value=database_instance, expected_type=type_hints["database_instance"])
            check_type(argname="argument instance_identifier", value=instance_identifier, expected_type=type_hints["instance_identifier"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "threshold": threshold,
        }
        if database_instance is not None:
            self._values["database_instance"] = database_instance
        if instance_identifier is not None:
            self._values["instance_identifier"] = instance_identifier
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods

    @builtins.property
    def database_instance(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance]:
        '''The database instance to monitor.'''
        result = self._values.get("database_instance")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance], result)

    @builtins.property
    def instance_identifier(self) -> typing.Optional[builtins.str]:
        '''The database instance identifier to monitor.'''
        result = self._values.get("instance_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> jsii.Number:
        '''The value in milliseconds against which the specified statistic is compared.

        The recommended threshold value for this alarm is highly dependent on your use case.
        Write latencies higher than 20 milliseconds are likely a cause for investigation.
        You can also set a higher threshold if your application can have a higher latency
        for write operations. Review the criticality and requirements of write latency and
        analyze the historical behavior of this metric to determine sensible threshold levels.
        '''
        result = self._values.get("threshold")
        assert result is not None, "Required property 'threshold' is missing"
        return typing.cast(jsii.Number, result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect high write latency. Although database disks
        typically have low read/write latency, they may experience problems that cause high
        latency operations. Monitoring this will assure you the disk latency is as low as expected.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - database.instanceIdentifiers[*] + ' - WriteLatency'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 5
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 5
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsInstanceWriteLatencyAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3Bucket4xxErrorsAlarmConfig",
    jsii_struct_bases=[S3BucketHttpErrorsAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
    },
)
class S3Bucket4xxErrorsAlarmConfig(S3BucketHttpErrorsAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the 4xx errors alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. Default: 0.05
        :param alarm_description: The alarm description. Default: - This alarm helps us report the total number of 4xx error status codes that are made in response to client requests. 403 error codes might indicate an incorrect IAM policy, and 404 error codes might indicate mis-behaving client application, for example. Enabling S3 server access logging on a temporary basis will help you to pinpoint the issue's origin using the fields HTTP status and Error Code. To understand more about the error code, see Error Responses (https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html).
        :param alarm_name: The alarm name. Default: - bucket.bucketName + ' - 4xxErrors'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__d45cfb8defe415c756707cf35150f504c3ca42a23dece0314de672338d762779)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if threshold is not None:
            self._values["threshold"] = threshold
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        :default: 0.05
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The alarm description.

        :default:

        - This alarm helps us report the total number of 4xx error status codes
        that are made in response to client requests. 403 error codes might indicate an
        incorrect IAM policy, and 404 error codes might indicate mis-behaving client application,
        for example. Enabling S3 server access logging on a temporary basis will help you to
        pinpoint the issue's origin using the fields HTTP status and Error Code. To understand
        more about the error code, see Error Responses
        (https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html).
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - bucket.bucketName + ' - 4xxErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3Bucket4xxErrorsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3Bucket4xxErrorsAlarmProps",
    jsii_struct_bases=[S3Bucket4xxErrorsAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "bucket": "bucket",
    },
)
class S3Bucket4xxErrorsAlarmProps(S3Bucket4xxErrorsAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
    ) -> None:
        '''Properties for the S3Bucket4xxErrorsAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. Default: 0.05
        :param alarm_description: The alarm description. Default: - This alarm helps us report the total number of 4xx error status codes that are made in response to client requests. 403 error codes might indicate an incorrect IAM policy, and 404 error codes might indicate mis-behaving client application, for example. Enabling S3 server access logging on a temporary basis will help you to pinpoint the issue's origin using the fields HTTP status and Error Code. To understand more about the error code, see Error Responses (https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html).
        :param alarm_name: The alarm name. Default: - bucket.bucketName + ' - 4xxErrors'
        :param bucket: The S3 bucket to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__42ecd95425c9d23d522911d78398932e1d8493d1db2971c7b392f778fbcdb03f)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bucket": bucket,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if threshold is not None:
            self._values["threshold"] = threshold
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        :default: 0.05
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The alarm description.

        :default:

        - This alarm helps us report the total number of 4xx error status codes
        that are made in response to client requests. 403 error codes might indicate an
        incorrect IAM policy, and 404 error codes might indicate mis-behaving client application,
        for example. Enabling S3 server access logging on a temporary basis will help you to
        pinpoint the issue's origin using the fields HTTP status and Error Code. To understand
        more about the error code, see Error Responses
        (https://docs.aws.amazon.com/AmazonS3/latest/API/ErrorResponses.html).
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - bucket.bucketName + ' - 4xxErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def bucket(self) -> _aws_cdk_aws_s3_ceddda9d.IBucket:
        '''The S3 bucket to monitor.'''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(_aws_cdk_aws_s3_ceddda9d.IBucket, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3Bucket4xxErrorsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3Bucket5xxErrorsAlarmConfig",
    jsii_struct_bases=[S3BucketHttpErrorsAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
    },
)
class S3Bucket5xxErrorsAlarmConfig(S3BucketHttpErrorsAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
    ) -> None:
        '''Configuration for the 5xx errors alarm.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. Default: 0.05
        :param alarm_description: The alarm description. Default: - This alarm helps you detect a high number of server-side errors. These errors indicate that a client made a request that the server couldnt complete. This can help you correlate the issue your application is facing because of S3. For more information to help you efficiently handle or reduce errors, see Optimizing performance design patterns (https://docs.aws.amazon.com/AmazonS3/latest/userguide/optimizing-performance-design-patterns.html#optimizing-performance-timeouts-retries). Errors might also be caused by an the issue with S3, check AWS service health dashboard for the status of Amazon S3 in your Region.
        :param alarm_name: The alarm name. Default: - bucket.bucketName + ' - 5xxErrors'
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1679196b0a9e5117c7a636cfb7f006fee301925d2a4605be64b230bdd8dd1a0a)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if threshold is not None:
            self._values["threshold"] = threshold
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        :default: 0.05
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The alarm description.

        :default:

        - This alarm helps you detect a high number of server-side errors. These errors indicate
        that a client made a request that the server couldnt complete. This can help you correlate the
        issue your application is facing because of S3. For more information to help you efficiently
        handle or reduce errors, see Optimizing performance design patterns
        (https://docs.aws.amazon.com/AmazonS3/latest/userguide/optimizing-performance-design-patterns.html#optimizing-performance-timeouts-retries).
        Errors might also be caused by an the issue with S3, check AWS service health dashboard for the status of Amazon S3 in your Region.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - bucket.bucketName + ' - 5xxErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3Bucket5xxErrorsAlarmConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.S3Bucket5xxErrorsAlarmProps",
    jsii_struct_bases=[S3Bucket5xxErrorsAlarmConfig],
    name_mapping={
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "period": "period",
        "threshold": "threshold",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "bucket": "bucket",
    },
)
class S3Bucket5xxErrorsAlarmProps(S3Bucket5xxErrorsAlarmConfig):
    def __init__(
        self,
        *,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        threshold: typing.Optional[jsii.Number] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
    ) -> None:
        '''Properties for the S3Bucket5xxErrorsAlarm construct.

        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 15
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 15
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(1)
        :param threshold: The value against which the specified statistic is compared. Default: 0.05
        :param alarm_description: The alarm description. Default: - This alarm helps you detect a high number of server-side errors. These errors indicate that a client made a request that the server couldnt complete. This can help you correlate the issue your application is facing because of S3. For more information to help you efficiently handle or reduce errors, see Optimizing performance design patterns (https://docs.aws.amazon.com/AmazonS3/latest/userguide/optimizing-performance-design-patterns.html#optimizing-performance-timeouts-retries). Errors might also be caused by an the issue with S3, check AWS service health dashboard for the status of Amazon S3 in your Region.
        :param alarm_name: The alarm name. Default: - bucket.bucketName + ' - 5xxErrors'
        :param bucket: The S3 bucket to monitor.
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1804ab3695bf52f69bd745c3d4ab5e213eb7fb6b4cc260c31532a53abb2b3d7f)
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument bucket", value=bucket, expected_type=type_hints["bucket"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "bucket": bucket,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if period is not None:
            self._values["period"] = period
        if threshold is not None:
            self._values["threshold"] = threshold
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 15
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 15
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(1)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''The value against which the specified statistic is compared.

        :default: 0.05
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The alarm description.

        :default:

        - This alarm helps you detect a high number of server-side errors. These errors indicate
        that a client made a request that the server couldnt complete. This can help you correlate the
        issue your application is facing because of S3. For more information to help you efficiently
        handle or reduce errors, see Optimizing performance design patterns
        (https://docs.aws.amazon.com/AmazonS3/latest/userguide/optimizing-performance-design-patterns.html#optimizing-performance-timeouts-retries).
        Errors might also be caused by an the issue with S3, check AWS service health dashboard for the status of Amazon S3 in your Region.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - bucket.bucketName + ' - 5xxErrors'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def bucket(self) -> _aws_cdk_aws_s3_ceddda9d.IBucket:
        '''The S3 bucket to monitor.'''
        result = self._values.get("bucket")
        assert result is not None, "Required property 'bucket' is missing"
        return typing.cast(_aws_cdk_aws_s3_ceddda9d.IBucket, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "S3Bucket5xxErrorsAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.VpnConnectionTunnelStateAlarmProps",
    jsii_struct_bases=[VpnConnectionAlarmProps, VpnTunnelStateAlarmConfig],
    name_mapping={
        "vpn_connection": "vpnConnection",
        "alarm_action": "alarmAction",
        "insufficient_data_action": "insufficientDataAction",
        "ok_action": "okAction",
        "treat_missing_data": "treatMissingData",
        "period": "period",
        "alarm_description": "alarmDescription",
        "alarm_name": "alarmName",
        "datapoints_to_alarm": "datapointsToAlarm",
        "evaluation_periods": "evaluationPeriods",
        "threshold": "threshold",
    },
)
class VpnConnectionTunnelStateAlarmProps(
    VpnConnectionAlarmProps,
    VpnTunnelStateAlarmConfig,
):
    def __init__(
        self,
        *,
        vpn_connection: _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
        alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        alarm_description: typing.Optional[builtins.str] = None,
        alarm_name: typing.Optional[builtins.str] = None,
        datapoints_to_alarm: typing.Optional[jsii.Number] = None,
        evaluation_periods: typing.Optional[jsii.Number] = None,
        threshold: typing.Optional[jsii.Number] = None,
    ) -> None:
        '''The properties for the VpnConnectionTunnelStateAlarm construct.

        :param vpn_connection: The VpnConnection to monitor.
        :param alarm_action: The action to take when an alarm is triggered. Default: - None
        :param insufficient_data_action: The action to take when an alarm has insufficient data. Default: - None
        :param ok_action: The action to take when an alarm enters the ok state. Default: - None
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param period: The period over which the specified statistic is applied. Default: Duration.minutes(5)
        :param alarm_description: The description of the alarm. Default: - This alarm is used to detect if at least one tunnel is in the DOWN state for this VPN, so that you can troubleshoot the impacted VPN. This alarm will always be in the ALARM state for networks that only have a single tunnel configured.
        :param alarm_name: The alarm name. Default: - vpnConnectionId + ' - TunnelState'
        :param datapoints_to_alarm: The number of data points that must be breaching to trigger the alarm. Default: 3
        :param evaluation_periods: The number of periods over which data is compared to the specified threshold. Default: 3
        :param threshold: A value less than 1 indicates that at least one tunnel is in DOWN state. Default: 1
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__36a080b3ced5485b186a02c11eda8fb698e21b38bf5e471567f541ddeb2e1def)
            check_type(argname="argument vpn_connection", value=vpn_connection, expected_type=type_hints["vpn_connection"])
            check_type(argname="argument alarm_action", value=alarm_action, expected_type=type_hints["alarm_action"])
            check_type(argname="argument insufficient_data_action", value=insufficient_data_action, expected_type=type_hints["insufficient_data_action"])
            check_type(argname="argument ok_action", value=ok_action, expected_type=type_hints["ok_action"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument period", value=period, expected_type=type_hints["period"])
            check_type(argname="argument alarm_description", value=alarm_description, expected_type=type_hints["alarm_description"])
            check_type(argname="argument alarm_name", value=alarm_name, expected_type=type_hints["alarm_name"])
            check_type(argname="argument datapoints_to_alarm", value=datapoints_to_alarm, expected_type=type_hints["datapoints_to_alarm"])
            check_type(argname="argument evaluation_periods", value=evaluation_periods, expected_type=type_hints["evaluation_periods"])
            check_type(argname="argument threshold", value=threshold, expected_type=type_hints["threshold"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "vpn_connection": vpn_connection,
        }
        if alarm_action is not None:
            self._values["alarm_action"] = alarm_action
        if insufficient_data_action is not None:
            self._values["insufficient_data_action"] = insufficient_data_action
        if ok_action is not None:
            self._values["ok_action"] = ok_action
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if period is not None:
            self._values["period"] = period
        if alarm_description is not None:
            self._values["alarm_description"] = alarm_description
        if alarm_name is not None:
            self._values["alarm_name"] = alarm_name
        if datapoints_to_alarm is not None:
            self._values["datapoints_to_alarm"] = datapoints_to_alarm
        if evaluation_periods is not None:
            self._values["evaluation_periods"] = evaluation_periods
        if threshold is not None:
            self._values["threshold"] = threshold

    @builtins.property
    def vpn_connection(self) -> _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection:
        '''The VpnConnection to monitor.'''
        result = self._values.get("vpn_connection")
        assert result is not None, "Required property 'vpn_connection' is missing"
        return typing.cast(_aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection, result)

    @builtins.property
    def alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period over which the specified statistic is applied.

        :default: Duration.minutes(5)
        '''
        result = self._values.get("period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def alarm_description(self) -> typing.Optional[builtins.str]:
        '''The description of the alarm.

        :default:

        - This alarm is used to detect if at least one tunnel is in the DOWN state for this VPN, so that you can troubleshoot
        the impacted VPN. This alarm will always be in the ALARM state for networks that only have a single tunnel configured.
        '''
        result = self._values.get("alarm_description")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def alarm_name(self) -> typing.Optional[builtins.str]:
        '''The alarm name.

        :default: - vpnConnectionId + ' - TunnelState'
        '''
        result = self._values.get("alarm_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def datapoints_to_alarm(self) -> typing.Optional[jsii.Number]:
        '''The number of data points that must be breaching to trigger the alarm.

        :default: 3
        '''
        result = self._values.get("datapoints_to_alarm")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def evaluation_periods(self) -> typing.Optional[jsii.Number]:
        '''The number of periods over which data is compared to the specified threshold.

        :default: 3
        '''
        result = self._values.get("evaluation_periods")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def threshold(self) -> typing.Optional[jsii.Number]:
        '''A value less than 1 indicates that at least one tunnel is in DOWN state.

        :default: 1
        '''
        result = self._values.get("threshold")
        return typing.cast(typing.Optional[jsii.Number], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "VpnConnectionTunnelStateAlarmProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAuroraRecommendedAlarmsConfig",
    jsii_struct_bases=[RdsInstanceRecommendedAlarmsConfig],
    name_mapping={
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "config_database_connections_alarm": "configDatabaseConnectionsAlarm",
        "config_db_load_alarm": "configDbLoadAlarm",
        "config_freeable_memory_alarm": "configFreeableMemoryAlarm",
        "config_free_local_storage_alarm": "configFreeLocalStorageAlarm",
        "config_free_storage_space_alarm": "configFreeStorageSpaceAlarm",
        "config_read_latency_alarm": "configReadLatencyAlarm",
        "config_write_latency_alarm": "configWriteLatencyAlarm",
        "config_cpu_utilization_alarm": "configCpuUtilizationAlarm",
        "config_aurora_bin_log_replication_lag_alarm": "configAuroraBinLogReplicationLagAlarm",
        "config_aurora_volume_bytes_left_total_alarm": "configAuroraVolumeBytesLeftTotalAlarm",
    },
)
class RdsAuroraRecommendedAlarmsConfig(RdsInstanceRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_read_latency_alarm: typing.Union[RdsReadLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_write_latency_alarm: typing.Union[RdsWriteLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_aurora_bin_log_replication_lag_alarm: typing.Optional[typing.Union[RdsAuroraBinLogReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_aurora_volume_bytes_left_total_alarm: typing.Optional[typing.Union[RdsAuroraVolumeBytesLeftTotalAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param config_database_connections_alarm: The configuration for the DatabaseConnections alarm.
        :param config_db_load_alarm: The configuration for the DbLoad alarm.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_local_storage_alarm: The configuration for the FreeLocalStorage alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_read_latency_alarm: The configuration for the ReadLatency alarm.
        :param config_write_latency_alarm: The configuration for the WriteLatency alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_aurora_bin_log_replication_lag_alarm: The configuration for the AuroraBinLogReplicationLag alarm.
        :param config_aurora_volume_bytes_left_total_alarm: The configuration for the AuroraVolumeBytesLeftTotal alarm.
        '''
        if isinstance(config_database_connections_alarm, dict):
            config_database_connections_alarm = RdsDatabaseConnectionsAlarmConfig(**config_database_connections_alarm)
        if isinstance(config_db_load_alarm, dict):
            config_db_load_alarm = RdsDbLoadAlarmConfig(**config_db_load_alarm)
        if isinstance(config_freeable_memory_alarm, dict):
            config_freeable_memory_alarm = RdsFreeableMemoryAlarmConfig(**config_freeable_memory_alarm)
        if isinstance(config_free_local_storage_alarm, dict):
            config_free_local_storage_alarm = RdsFreeLocalStorageAlarmConfig(**config_free_local_storage_alarm)
        if isinstance(config_free_storage_space_alarm, dict):
            config_free_storage_space_alarm = RdsFreeStorageSpaceAlarmConfig(**config_free_storage_space_alarm)
        if isinstance(config_read_latency_alarm, dict):
            config_read_latency_alarm = RdsReadLatencyAlarmConfig(**config_read_latency_alarm)
        if isinstance(config_write_latency_alarm, dict):
            config_write_latency_alarm = RdsWriteLatencyAlarmConfig(**config_write_latency_alarm)
        if isinstance(config_cpu_utilization_alarm, dict):
            config_cpu_utilization_alarm = RdsCpuUtilizationAlarmConfig(**config_cpu_utilization_alarm)
        if isinstance(config_aurora_bin_log_replication_lag_alarm, dict):
            config_aurora_bin_log_replication_lag_alarm = RdsAuroraBinLogReplicationLagAlarmConfig(**config_aurora_bin_log_replication_lag_alarm)
        if isinstance(config_aurora_volume_bytes_left_total_alarm, dict):
            config_aurora_volume_bytes_left_total_alarm = RdsAuroraVolumeBytesLeftTotalAlarmConfig(**config_aurora_volume_bytes_left_total_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__a71dbce57fbd57d8a1ba34a788a96fd859f3325b1855297784cf40b2a1e37abe)
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument config_database_connections_alarm", value=config_database_connections_alarm, expected_type=type_hints["config_database_connections_alarm"])
            check_type(argname="argument config_db_load_alarm", value=config_db_load_alarm, expected_type=type_hints["config_db_load_alarm"])
            check_type(argname="argument config_freeable_memory_alarm", value=config_freeable_memory_alarm, expected_type=type_hints["config_freeable_memory_alarm"])
            check_type(argname="argument config_free_local_storage_alarm", value=config_free_local_storage_alarm, expected_type=type_hints["config_free_local_storage_alarm"])
            check_type(argname="argument config_free_storage_space_alarm", value=config_free_storage_space_alarm, expected_type=type_hints["config_free_storage_space_alarm"])
            check_type(argname="argument config_read_latency_alarm", value=config_read_latency_alarm, expected_type=type_hints["config_read_latency_alarm"])
            check_type(argname="argument config_write_latency_alarm", value=config_write_latency_alarm, expected_type=type_hints["config_write_latency_alarm"])
            check_type(argname="argument config_cpu_utilization_alarm", value=config_cpu_utilization_alarm, expected_type=type_hints["config_cpu_utilization_alarm"])
            check_type(argname="argument config_aurora_bin_log_replication_lag_alarm", value=config_aurora_bin_log_replication_lag_alarm, expected_type=type_hints["config_aurora_bin_log_replication_lag_alarm"])
            check_type(argname="argument config_aurora_volume_bytes_left_total_alarm", value=config_aurora_volume_bytes_left_total_alarm, expected_type=type_hints["config_aurora_volume_bytes_left_total_alarm"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_database_connections_alarm": config_database_connections_alarm,
            "config_db_load_alarm": config_db_load_alarm,
            "config_freeable_memory_alarm": config_freeable_memory_alarm,
            "config_free_local_storage_alarm": config_free_local_storage_alarm,
            "config_free_storage_space_alarm": config_free_storage_space_alarm,
            "config_read_latency_alarm": config_read_latency_alarm,
            "config_write_latency_alarm": config_write_latency_alarm,
        }
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if config_cpu_utilization_alarm is not None:
            self._values["config_cpu_utilization_alarm"] = config_cpu_utilization_alarm
        if config_aurora_bin_log_replication_lag_alarm is not None:
            self._values["config_aurora_bin_log_replication_lag_alarm"] = config_aurora_bin_log_replication_lag_alarm
        if config_aurora_volume_bytes_left_total_alarm is not None:
            self._values["config_aurora_volume_bytes_left_total_alarm"] = config_aurora_volume_bytes_left_total_alarm

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[RdsRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[RdsRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def config_database_connections_alarm(self) -> RdsDatabaseConnectionsAlarmConfig:
        '''The configuration for the DatabaseConnections alarm.'''
        result = self._values.get("config_database_connections_alarm")
        assert result is not None, "Required property 'config_database_connections_alarm' is missing"
        return typing.cast(RdsDatabaseConnectionsAlarmConfig, result)

    @builtins.property
    def config_db_load_alarm(self) -> RdsDbLoadAlarmConfig:
        '''The configuration for the DbLoad alarm.'''
        result = self._values.get("config_db_load_alarm")
        assert result is not None, "Required property 'config_db_load_alarm' is missing"
        return typing.cast(RdsDbLoadAlarmConfig, result)

    @builtins.property
    def config_freeable_memory_alarm(self) -> RdsFreeableMemoryAlarmConfig:
        '''The configuration for the FreeableMemory alarm.'''
        result = self._values.get("config_freeable_memory_alarm")
        assert result is not None, "Required property 'config_freeable_memory_alarm' is missing"
        return typing.cast(RdsFreeableMemoryAlarmConfig, result)

    @builtins.property
    def config_free_local_storage_alarm(self) -> RdsFreeLocalStorageAlarmConfig:
        '''The configuration for the FreeLocalStorage alarm.'''
        result = self._values.get("config_free_local_storage_alarm")
        assert result is not None, "Required property 'config_free_local_storage_alarm' is missing"
        return typing.cast(RdsFreeLocalStorageAlarmConfig, result)

    @builtins.property
    def config_free_storage_space_alarm(self) -> RdsFreeStorageSpaceAlarmConfig:
        '''The configuration for the FreeStorageSpace alarm.'''
        result = self._values.get("config_free_storage_space_alarm")
        assert result is not None, "Required property 'config_free_storage_space_alarm' is missing"
        return typing.cast(RdsFreeStorageSpaceAlarmConfig, result)

    @builtins.property
    def config_read_latency_alarm(self) -> RdsReadLatencyAlarmConfig:
        '''The configuration for the ReadLatency alarm.'''
        result = self._values.get("config_read_latency_alarm")
        assert result is not None, "Required property 'config_read_latency_alarm' is missing"
        return typing.cast(RdsReadLatencyAlarmConfig, result)

    @builtins.property
    def config_write_latency_alarm(self) -> RdsWriteLatencyAlarmConfig:
        '''The configuration for the WriteLatency alarm.'''
        result = self._values.get("config_write_latency_alarm")
        assert result is not None, "Required property 'config_write_latency_alarm' is missing"
        return typing.cast(RdsWriteLatencyAlarmConfig, result)

    @builtins.property
    def config_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[RdsCpuUtilizationAlarmConfig]:
        '''The configuration for the CpuUtilization alarm.'''
        result = self._values.get("config_cpu_utilization_alarm")
        return typing.cast(typing.Optional[RdsCpuUtilizationAlarmConfig], result)

    @builtins.property
    def config_aurora_bin_log_replication_lag_alarm(
        self,
    ) -> typing.Optional[RdsAuroraBinLogReplicationLagAlarmConfig]:
        '''The configuration for the AuroraBinLogReplicationLag alarm.'''
        result = self._values.get("config_aurora_bin_log_replication_lag_alarm")
        return typing.cast(typing.Optional[RdsAuroraBinLogReplicationLagAlarmConfig], result)

    @builtins.property
    def config_aurora_volume_bytes_left_total_alarm(
        self,
    ) -> typing.Optional[RdsAuroraVolumeBytesLeftTotalAlarmConfig]:
        '''The configuration for the AuroraVolumeBytesLeftTotal alarm.'''
        result = self._values.get("config_aurora_volume_bytes_left_total_alarm")
        return typing.cast(typing.Optional[RdsAuroraVolumeBytesLeftTotalAlarmConfig], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsAuroraRecommendedAlarmsConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@renovosolutions/cdk-library-cloudwatch-alarms.RdsAuroraRecommendedAlarmsProps",
    jsii_struct_bases=[RdsAuroraRecommendedAlarmsConfig],
    name_mapping={
        "default_alarm_action": "defaultAlarmAction",
        "default_insufficient_data_action": "defaultInsufficientDataAction",
        "default_ok_action": "defaultOkAction",
        "exclude_alarms": "excludeAlarms",
        "exclude_resources": "excludeResources",
        "treat_missing_data": "treatMissingData",
        "config_database_connections_alarm": "configDatabaseConnectionsAlarm",
        "config_db_load_alarm": "configDbLoadAlarm",
        "config_freeable_memory_alarm": "configFreeableMemoryAlarm",
        "config_free_local_storage_alarm": "configFreeLocalStorageAlarm",
        "config_free_storage_space_alarm": "configFreeStorageSpaceAlarm",
        "config_read_latency_alarm": "configReadLatencyAlarm",
        "config_write_latency_alarm": "configWriteLatencyAlarm",
        "config_cpu_utilization_alarm": "configCpuUtilizationAlarm",
        "config_aurora_bin_log_replication_lag_alarm": "configAuroraBinLogReplicationLagAlarm",
        "config_aurora_volume_bytes_left_total_alarm": "configAuroraVolumeBytesLeftTotalAlarm",
        "database_cluster": "databaseCluster",
    },
)
class RdsAuroraRecommendedAlarmsProps(RdsAuroraRecommendedAlarmsConfig):
    def __init__(
        self,
        *,
        default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
        exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
        exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
        config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_read_latency_alarm: typing.Union[RdsReadLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_write_latency_alarm: typing.Union[RdsWriteLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
        config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_aurora_bin_log_replication_lag_alarm: typing.Optional[typing.Union[RdsAuroraBinLogReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        config_aurora_volume_bytes_left_total_alarm: typing.Optional[typing.Union[RdsAuroraVolumeBytesLeftTotalAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
    ) -> None:
        '''
        :param default_alarm_action: The default action to take when an alarm is triggered. Default: - None
        :param default_insufficient_data_action: The default action to take when an alarm has insufficient data. Default: - None
        :param default_ok_action: The default action to take when an alarm enters the ok state. Default: - None
        :param exclude_alarms: Alarm metrics to exclude from the recommended alarms. Default: - None
        :param exclude_resources: The resources to exclude from the recommended alarms. Use a resources id to exclude a specific resource.
        :param treat_missing_data: How to handle missing data for this alarm. Default: TreatMissingData.MISSING
        :param config_database_connections_alarm: The configuration for the DatabaseConnections alarm.
        :param config_db_load_alarm: The configuration for the DbLoad alarm.
        :param config_freeable_memory_alarm: The configuration for the FreeableMemory alarm.
        :param config_free_local_storage_alarm: The configuration for the FreeLocalStorage alarm.
        :param config_free_storage_space_alarm: The configuration for the FreeStorageSpace alarm.
        :param config_read_latency_alarm: The configuration for the ReadLatency alarm.
        :param config_write_latency_alarm: The configuration for the WriteLatency alarm.
        :param config_cpu_utilization_alarm: The configuration for the CpuUtilization alarm.
        :param config_aurora_bin_log_replication_lag_alarm: The configuration for the AuroraBinLogReplicationLag alarm.
        :param config_aurora_volume_bytes_left_total_alarm: The configuration for the AuroraVolumeBytesLeftTotal alarm.
        :param database_cluster: The database cluster to apply the recommended alarms.
        '''
        if isinstance(config_database_connections_alarm, dict):
            config_database_connections_alarm = RdsDatabaseConnectionsAlarmConfig(**config_database_connections_alarm)
        if isinstance(config_db_load_alarm, dict):
            config_db_load_alarm = RdsDbLoadAlarmConfig(**config_db_load_alarm)
        if isinstance(config_freeable_memory_alarm, dict):
            config_freeable_memory_alarm = RdsFreeableMemoryAlarmConfig(**config_freeable_memory_alarm)
        if isinstance(config_free_local_storage_alarm, dict):
            config_free_local_storage_alarm = RdsFreeLocalStorageAlarmConfig(**config_free_local_storage_alarm)
        if isinstance(config_free_storage_space_alarm, dict):
            config_free_storage_space_alarm = RdsFreeStorageSpaceAlarmConfig(**config_free_storage_space_alarm)
        if isinstance(config_read_latency_alarm, dict):
            config_read_latency_alarm = RdsReadLatencyAlarmConfig(**config_read_latency_alarm)
        if isinstance(config_write_latency_alarm, dict):
            config_write_latency_alarm = RdsWriteLatencyAlarmConfig(**config_write_latency_alarm)
        if isinstance(config_cpu_utilization_alarm, dict):
            config_cpu_utilization_alarm = RdsCpuUtilizationAlarmConfig(**config_cpu_utilization_alarm)
        if isinstance(config_aurora_bin_log_replication_lag_alarm, dict):
            config_aurora_bin_log_replication_lag_alarm = RdsAuroraBinLogReplicationLagAlarmConfig(**config_aurora_bin_log_replication_lag_alarm)
        if isinstance(config_aurora_volume_bytes_left_total_alarm, dict):
            config_aurora_volume_bytes_left_total_alarm = RdsAuroraVolumeBytesLeftTotalAlarmConfig(**config_aurora_volume_bytes_left_total_alarm)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__03520ed9c6cccb284644107e0618ddcd022893247791a1f6732aff5f34120fb3)
            check_type(argname="argument default_alarm_action", value=default_alarm_action, expected_type=type_hints["default_alarm_action"])
            check_type(argname="argument default_insufficient_data_action", value=default_insufficient_data_action, expected_type=type_hints["default_insufficient_data_action"])
            check_type(argname="argument default_ok_action", value=default_ok_action, expected_type=type_hints["default_ok_action"])
            check_type(argname="argument exclude_alarms", value=exclude_alarms, expected_type=type_hints["exclude_alarms"])
            check_type(argname="argument exclude_resources", value=exclude_resources, expected_type=type_hints["exclude_resources"])
            check_type(argname="argument treat_missing_data", value=treat_missing_data, expected_type=type_hints["treat_missing_data"])
            check_type(argname="argument config_database_connections_alarm", value=config_database_connections_alarm, expected_type=type_hints["config_database_connections_alarm"])
            check_type(argname="argument config_db_load_alarm", value=config_db_load_alarm, expected_type=type_hints["config_db_load_alarm"])
            check_type(argname="argument config_freeable_memory_alarm", value=config_freeable_memory_alarm, expected_type=type_hints["config_freeable_memory_alarm"])
            check_type(argname="argument config_free_local_storage_alarm", value=config_free_local_storage_alarm, expected_type=type_hints["config_free_local_storage_alarm"])
            check_type(argname="argument config_free_storage_space_alarm", value=config_free_storage_space_alarm, expected_type=type_hints["config_free_storage_space_alarm"])
            check_type(argname="argument config_read_latency_alarm", value=config_read_latency_alarm, expected_type=type_hints["config_read_latency_alarm"])
            check_type(argname="argument config_write_latency_alarm", value=config_write_latency_alarm, expected_type=type_hints["config_write_latency_alarm"])
            check_type(argname="argument config_cpu_utilization_alarm", value=config_cpu_utilization_alarm, expected_type=type_hints["config_cpu_utilization_alarm"])
            check_type(argname="argument config_aurora_bin_log_replication_lag_alarm", value=config_aurora_bin_log_replication_lag_alarm, expected_type=type_hints["config_aurora_bin_log_replication_lag_alarm"])
            check_type(argname="argument config_aurora_volume_bytes_left_total_alarm", value=config_aurora_volume_bytes_left_total_alarm, expected_type=type_hints["config_aurora_volume_bytes_left_total_alarm"])
            check_type(argname="argument database_cluster", value=database_cluster, expected_type=type_hints["database_cluster"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "config_database_connections_alarm": config_database_connections_alarm,
            "config_db_load_alarm": config_db_load_alarm,
            "config_freeable_memory_alarm": config_freeable_memory_alarm,
            "config_free_local_storage_alarm": config_free_local_storage_alarm,
            "config_free_storage_space_alarm": config_free_storage_space_alarm,
            "config_read_latency_alarm": config_read_latency_alarm,
            "config_write_latency_alarm": config_write_latency_alarm,
            "database_cluster": database_cluster,
        }
        if default_alarm_action is not None:
            self._values["default_alarm_action"] = default_alarm_action
        if default_insufficient_data_action is not None:
            self._values["default_insufficient_data_action"] = default_insufficient_data_action
        if default_ok_action is not None:
            self._values["default_ok_action"] = default_ok_action
        if exclude_alarms is not None:
            self._values["exclude_alarms"] = exclude_alarms
        if exclude_resources is not None:
            self._values["exclude_resources"] = exclude_resources
        if treat_missing_data is not None:
            self._values["treat_missing_data"] = treat_missing_data
        if config_cpu_utilization_alarm is not None:
            self._values["config_cpu_utilization_alarm"] = config_cpu_utilization_alarm
        if config_aurora_bin_log_replication_lag_alarm is not None:
            self._values["config_aurora_bin_log_replication_lag_alarm"] = config_aurora_bin_log_replication_lag_alarm
        if config_aurora_volume_bytes_left_total_alarm is not None:
            self._values["config_aurora_volume_bytes_left_total_alarm"] = config_aurora_volume_bytes_left_total_alarm

    @builtins.property
    def default_alarm_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm is triggered.

        :default: - None
        '''
        result = self._values.get("default_alarm_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_insufficient_data_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm has insufficient data.

        :default: - None
        '''
        result = self._values.get("default_insufficient_data_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def default_ok_action(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction]:
        '''The default action to take when an alarm enters the ok state.

        :default: - None
        '''
        result = self._values.get("default_ok_action")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction], result)

    @builtins.property
    def exclude_alarms(
        self,
    ) -> typing.Optional[typing.List[RdsRecommendedAlarmsMetrics]]:
        '''Alarm metrics to exclude from the recommended alarms.

        :default: - None
        '''
        result = self._values.get("exclude_alarms")
        return typing.cast(typing.Optional[typing.List[RdsRecommendedAlarmsMetrics]], result)

    @builtins.property
    def exclude_resources(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The resources to exclude from the recommended alarms.

        Use a resources id to exclude a specific resource.
        '''
        result = self._values.get("exclude_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def treat_missing_data(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData]:
        '''How to handle missing data for this alarm.

        :default: TreatMissingData.MISSING
        '''
        result = self._values.get("treat_missing_data")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData], result)

    @builtins.property
    def config_database_connections_alarm(self) -> RdsDatabaseConnectionsAlarmConfig:
        '''The configuration for the DatabaseConnections alarm.'''
        result = self._values.get("config_database_connections_alarm")
        assert result is not None, "Required property 'config_database_connections_alarm' is missing"
        return typing.cast(RdsDatabaseConnectionsAlarmConfig, result)

    @builtins.property
    def config_db_load_alarm(self) -> RdsDbLoadAlarmConfig:
        '''The configuration for the DbLoad alarm.'''
        result = self._values.get("config_db_load_alarm")
        assert result is not None, "Required property 'config_db_load_alarm' is missing"
        return typing.cast(RdsDbLoadAlarmConfig, result)

    @builtins.property
    def config_freeable_memory_alarm(self) -> RdsFreeableMemoryAlarmConfig:
        '''The configuration for the FreeableMemory alarm.'''
        result = self._values.get("config_freeable_memory_alarm")
        assert result is not None, "Required property 'config_freeable_memory_alarm' is missing"
        return typing.cast(RdsFreeableMemoryAlarmConfig, result)

    @builtins.property
    def config_free_local_storage_alarm(self) -> RdsFreeLocalStorageAlarmConfig:
        '''The configuration for the FreeLocalStorage alarm.'''
        result = self._values.get("config_free_local_storage_alarm")
        assert result is not None, "Required property 'config_free_local_storage_alarm' is missing"
        return typing.cast(RdsFreeLocalStorageAlarmConfig, result)

    @builtins.property
    def config_free_storage_space_alarm(self) -> RdsFreeStorageSpaceAlarmConfig:
        '''The configuration for the FreeStorageSpace alarm.'''
        result = self._values.get("config_free_storage_space_alarm")
        assert result is not None, "Required property 'config_free_storage_space_alarm' is missing"
        return typing.cast(RdsFreeStorageSpaceAlarmConfig, result)

    @builtins.property
    def config_read_latency_alarm(self) -> RdsReadLatencyAlarmConfig:
        '''The configuration for the ReadLatency alarm.'''
        result = self._values.get("config_read_latency_alarm")
        assert result is not None, "Required property 'config_read_latency_alarm' is missing"
        return typing.cast(RdsReadLatencyAlarmConfig, result)

    @builtins.property
    def config_write_latency_alarm(self) -> RdsWriteLatencyAlarmConfig:
        '''The configuration for the WriteLatency alarm.'''
        result = self._values.get("config_write_latency_alarm")
        assert result is not None, "Required property 'config_write_latency_alarm' is missing"
        return typing.cast(RdsWriteLatencyAlarmConfig, result)

    @builtins.property
    def config_cpu_utilization_alarm(
        self,
    ) -> typing.Optional[RdsCpuUtilizationAlarmConfig]:
        '''The configuration for the CpuUtilization alarm.'''
        result = self._values.get("config_cpu_utilization_alarm")
        return typing.cast(typing.Optional[RdsCpuUtilizationAlarmConfig], result)

    @builtins.property
    def config_aurora_bin_log_replication_lag_alarm(
        self,
    ) -> typing.Optional[RdsAuroraBinLogReplicationLagAlarmConfig]:
        '''The configuration for the AuroraBinLogReplicationLag alarm.'''
        result = self._values.get("config_aurora_bin_log_replication_lag_alarm")
        return typing.cast(typing.Optional[RdsAuroraBinLogReplicationLagAlarmConfig], result)

    @builtins.property
    def config_aurora_volume_bytes_left_total_alarm(
        self,
    ) -> typing.Optional[RdsAuroraVolumeBytesLeftTotalAlarmConfig]:
        '''The configuration for the AuroraVolumeBytesLeftTotal alarm.'''
        result = self._values.get("config_aurora_volume_bytes_left_total_alarm")
        return typing.cast(typing.Optional[RdsAuroraVolumeBytesLeftTotalAlarmConfig], result)

    @builtins.property
    def database_cluster(self) -> _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster:
        '''The database cluster to apply the recommended alarms.'''
        result = self._values.get("database_cluster")
        assert result is not None, "Required property 'database_cluster' is missing"
        return typing.cast(_aws_cdk_aws_rds_ceddda9d.IDatabaseCluster, result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "RdsAuroraRecommendedAlarmsProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "AlarmBaseProps",
    "ApiGateway4XXErrorAlarmConfig",
    "ApiGateway5XXErrorAlarmConfig",
    "ApiGatewayAlarmBaseConfig",
    "ApiGatewayDetailedAlarmConfig",
    "ApiGatewayLatencyAlarmConfig",
    "ApiGatewayRecommendedAlarmsAspect",
    "ApiGatewayRecommendedAlarmsMetrics",
    "ApiGatewayRestApi4XXErrorAlarm",
    "ApiGatewayRestApi4XXErrorAlarmProps",
    "ApiGatewayRestApi5XXErrorAlarm",
    "ApiGatewayRestApi5XXErrorAlarmProps",
    "ApiGatewayRestApiAlarmProps",
    "ApiGatewayRestApiDetailedLatencyAlarm",
    "ApiGatewayRestApiDetailedLatencyAlarmConfig",
    "ApiGatewayRestApiDetailedLatencyAlarmProps",
    "ApiGatewayRestApiLatencyAlarm",
    "ApiGatewayRestApiLatencyAlarmProps",
    "ApiGatewayRestApiRecommendedAlarms",
    "ApiGatewayRestApiRecommendedAlarmsConfig",
    "ApiGatewayRestApiRecommendedAlarmsProps",
    "ApplicationLoadBalancer",
    "ApplicationLoadBalancerAlarmBaseConfig",
    "ApplicationLoadBalancerAlarmProps",
    "ApplicationLoadBalancerHttpCode4xxCountAlarm",
    "ApplicationLoadBalancerHttpCode4xxCountAlarmConfig",
    "ApplicationLoadBalancerHttpCode4xxCountAlarmProps",
    "ApplicationLoadBalancerHttpCode5xxCountAlarm",
    "ApplicationLoadBalancerHttpCode5xxCountAlarmConfig",
    "ApplicationLoadBalancerHttpCode5xxCountAlarmProps",
    "ApplicationLoadBalancerHttpCodeTarget5xxCountAlarm",
    "ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig",
    "ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmProps",
    "ApplicationLoadBalancerRecommendedAlarms",
    "ApplicationLoadBalancerRecommendedAlarmsAspect",
    "ApplicationLoadBalancerRecommendedAlarmsConfig",
    "ApplicationLoadBalancerRecommendedAlarmsMetrics",
    "ApplicationLoadBalancerRecommendedAlarmsProps",
    "ApplicationLoadBalancerRejectedConnectionCountAlarm",
    "ApplicationLoadBalancerRejectedConnectionCountAlarmConfig",
    "ApplicationLoadBalancerRejectedConnectionCountAlarmProps",
    "ApplicationTargetGroup",
    "ApplicationTargetGroupAlarmBaseConfig",
    "ApplicationTargetGroupAlarmProps",
    "ApplicationTargetGroupHealthyHostCountAlarm",
    "ApplicationTargetGroupHealthyHostCountAlarmConfig",
    "ApplicationTargetGroupHealthyHostCountAlarmProps",
    "ApplicationTargetGroupRecommendedAlarms",
    "ApplicationTargetGroupRecommendedAlarmsAspect",
    "ApplicationTargetGroupRecommendedAlarmsConfig",
    "ApplicationTargetGroupRecommendedAlarmsMetrics",
    "ApplicationTargetGroupRecommendedAlarmsProps",
    "ApplicationTargetGroupUnHealthyHostCountAlarm",
    "ApplicationTargetGroupUnHealthyHostCountAlarmConfig",
    "ApplicationTargetGroupUnHealthyHostCountAlarmProps",
    "AutoScalingAlarmBaseConfig",
    "AutoScalingGroup",
    "AutoScalingGroupAlarmProps",
    "AutoScalingGroupGroupInServiceCapacityAlarm",
    "AutoScalingGroupGroupInServiceCapacityAlarmProps",
    "AutoScalingGroupInServiceCapacityAlarmConfig",
    "AutoScalingGroupRecommendedAlarms",
    "AutoScalingGroupRecommendedAlarmsConfig",
    "AutoScalingGroupRecommendedAlarmsProps",
    "AutoScalingRecommendedAlarmsAspect",
    "AutoScalingRecommendedAlarmsMetrics",
    "Bucket",
    "CfnCacheCluster",
    "CfnReplicationGroup",
    "CloudFront5xxErrorRateAlarmConfig",
    "CloudFrontAlarmBaseConfig",
    "CloudFrontDetailedAlarmConfig",
    "CloudFrontDistribution5xxErrorRateAlarm",
    "CloudFrontDistribution5xxErrorRateAlarmProps",
    "CloudFrontDistributionAlarmProps",
    "CloudFrontDistributionDetailedFunctionExecutionErrorsAlarm",
    "CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig",
    "CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmProps",
    "CloudFrontDistributionDetailedFunctionThrottlesAlarm",
    "CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig",
    "CloudFrontDistributionDetailedFunctionThrottlesAlarmProps",
    "CloudFrontDistributionDetailedFunctionValidationErrorsAlarm",
    "CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig",
    "CloudFrontDistributionDetailedFunctionValidationErrorsAlarmProps",
    "CloudFrontDistributionOriginLatencyAlarm",
    "CloudFrontDistributionOriginLatencyAlarmProps",
    "CloudFrontDistributionRecommendedAlarms",
    "CloudFrontDistributionRecommendedAlarmsConfig",
    "CloudFrontDistributionRecommendedAlarmsProps",
    "CloudFrontFunctionExecutionErrorsAlarmConfig",
    "CloudFrontFunctionThrottlesAlarmConfig",
    "CloudFrontFunctionValidationErrorsAlarmConfig",
    "CloudFrontOriginLatencyAlarmConfig",
    "CloudFrontRecommendedAlarmsAspect",
    "CloudFrontRecommendedAlarmsMetrics",
    "DatabaseCluster",
    "DatabaseInstance",
    "Distribution",
    "DmsAlarmBaseConfig",
    "DmsAnomalyDetectionAlarmBaseConfig",
    "DmsCdcLatencySourceAlarmConfig",
    "DmsCdcLatencyTargetAlarmConfig",
    "DmsCpuUtilizationAlarmConfig",
    "DmsFreeStorageSpaceAlarmConfig",
    "DmsFreeableMemoryAlarmConfig",
    "DmsReplicationInstanceAlarmProps",
    "DmsReplicationInstanceCpuUtilizationAlarm",
    "DmsReplicationInstanceCpuUtilizationAlarmProps",
    "DmsReplicationInstanceFreeStorageSpaceAlarm",
    "DmsReplicationInstanceFreeStorageSpaceAlarmProps",
    "DmsReplicationInstanceFreeableMemoryAlarm",
    "DmsReplicationInstanceFreeableMemoryAlarmProps",
    "DmsReplicationInstanceRecommendedAlarms",
    "DmsReplicationInstanceRecommendedAlarmsAspect",
    "DmsReplicationInstanceRecommendedAlarmsConfig",
    "DmsReplicationInstanceRecommendedAlarmsMetrics",
    "DmsReplicationInstanceRecommendedAlarmsProps",
    "DmsReplicationInstanceSwapUsageAlarm",
    "DmsReplicationInstanceSwapUsageAlarmProps",
    "DmsReplicationInstanceWriteIopsAlarm",
    "DmsReplicationInstanceWriteIopsAlarmProps",
    "DmsReplicationTaskAlarmProps",
    "DmsReplicationTaskCdcLatencySourceAlarm",
    "DmsReplicationTaskCdcLatencySourceAlarmProps",
    "DmsReplicationTaskCdcLatencyTargetAlarm",
    "DmsReplicationTaskCdcLatencyTargetAlarmProps",
    "DmsReplicationTaskMigrationType",
    "DmsReplicationTaskRecommendedAlarms",
    "DmsReplicationTaskRecommendedAlarmsAspect",
    "DmsReplicationTaskRecommendedAlarmsConfig",
    "DmsReplicationTaskRecommendedAlarmsMetrics",
    "DmsReplicationTaskRecommendedAlarmsProps",
    "DmsSwapUsageAlarmConfig",
    "DmsWriteIopsAlarmConfig",
    "DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig",
    "DynamoDbAlarmBaseConfig",
    "DynamoDbFailedToReplicateRecordCountAlarmConfig",
    "DynamoDbReadThrottleEventsAlarmConfig",
    "DynamoDbRecommendedAlarmsAspect",
    "DynamoDbRecommendedAlarmsMetrics",
    "DynamoDbSystemErrorsAlarmConfig",
    "DynamoDbTableAgeOfOldestUnreplicatedRecordAlarm",
    "DynamoDbTableAgeOfOldestUnreplicatedRecordAlarmProps",
    "DynamoDbTableAlarmProps",
    "DynamoDbTableFailedToReplicateRecordCountAlarm",
    "DynamoDbTableFailedToReplicateRecordCountAlarmProps",
    "DynamoDbTableReadThrottleEventsAlarm",
    "DynamoDbTableReadThrottleEventsAlarmProps",
    "DynamoDbTableRecommendedAlarms",
    "DynamoDbTableRecommendedAlarmsConfig",
    "DynamoDbTableRecommendedAlarmsProps",
    "DynamoDbTableSystemErrorsAlarm",
    "DynamoDbTableSystemErrorsAlarmProps",
    "DynamoDbTableThrottledPutRecordCountAlarm",
    "DynamoDbTableThrottledPutRecordCountAlarmProps",
    "DynamoDbTableWriteThrottleEventsAlarm",
    "DynamoDbTableWriteThrottleEventsAlarmProps",
    "DynamoDbThrottledPutRecordCountAlarmConfig",
    "DynamoDbWriteThrottleEventsAlarmConfig",
    "Ec2AlarmBaseConfig",
    "Ec2CpuUtilizationAlarmConfig",
    "Ec2InstanceAlarmProps",
    "Ec2InstanceCpuUtilizationAlarm",
    "Ec2InstanceCpuUtilizationAlarmProps",
    "Ec2InstanceRecommendedAlarms",
    "Ec2InstanceRecommendedAlarmsConfig",
    "Ec2InstanceRecommendedAlarmsProps",
    "Ec2InstanceStatusCheckFailedAlarm",
    "Ec2InstanceStatusCheckFailedAlarmProps",
    "Ec2RecommendedAlarmsAspect",
    "Ec2RecommendedAlarmsMetrics",
    "Ec2StatusCheckFailedAlarmConfig",
    "EcsAlarmBaseConfig",
    "EcsCpuUtilizationAlarmConfig",
    "EcsEphemeralStorageUtilizedAlarmConfig",
    "EcsMemoryUtilizationAlarmConfig",
    "EcsRecommendedAlarmsAspect",
    "EcsRecommendedAlarmsMetrics",
    "EcsRunningTaskCountAlarmConfig",
    "EcsServiceAlarmProps",
    "EcsServiceCpuUtilizationAlarm",
    "EcsServiceCpuUtilizationAlarmProps",
    "EcsServiceEphemeralStorageUtilizedAlarm",
    "EcsServiceEphemeralStorageUtilizedAlarmProps",
    "EcsServiceMemoryUtilizationAlarm",
    "EcsServiceMemoryUtilizationAlarmProps",
    "EcsServiceRecommendedAlarms",
    "EcsServiceRecommendedAlarmsConfig",
    "EcsServiceRecommendedAlarmsProps",
    "EcsServiceRunningTaskCountAlarm",
    "EcsServiceRunningTaskCountAlarmProps",
    "EfsAlarmBaseConfig",
    "EfsBurstCreditBalanceAlarmConfig",
    "EfsFileSystemAlarmProps",
    "EfsFileSystemBurstCreditBalanceAlarm",
    "EfsFileSystemBurstCreditBalanceAlarmProps",
    "EfsFileSystemPercentIOLimitAlarm",
    "EfsFileSystemPercentIOLimitAlarmProps",
    "EfsFileSystemRecommendedAlarms",
    "EfsFileSystemRecommendedAlarmsConfig",
    "EfsFileSystemRecommendedAlarmsProps",
    "EfsPercentIOLimitAlarmConfig",
    "EfsRecommendedAlarmsAspect",
    "EfsRecommendedAlarmsMetrics",
    "ElastiCacheAlarmBaseConfig",
    "ElastiCacheClusterAlarmProps",
    "ElastiCacheClusterDatabaseMemoryUsagePercentageAlarm",
    "ElastiCacheClusterDatabaseMemoryUsagePercentageAlarmProps",
    "ElastiCacheClusterEngineCpuUtilizationAlarm",
    "ElastiCacheClusterEngineCpuUtilizationAlarmProps",
    "ElastiCacheClusterRecommendedAlarms",
    "ElastiCacheClusterRecommendedAlarmsAspect",
    "ElastiCacheClusterRecommendedAlarmsConfig",
    "ElastiCacheClusterRecommendedAlarmsProps",
    "ElastiCacheClusterReplicationLagAlarm",
    "ElastiCacheClusterReplicationLagAlarmProps",
    "ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig",
    "ElastiCacheEngineCpuUtilizationAlarmConfig",
    "ElastiCacheRecommendedAlarmsMetrics",
    "ElastiCacheReplicationGroupAlarmProps",
    "ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarm",
    "ElastiCacheReplicationGroupDatabaseMemoryUsagePercentageAlarmProps",
    "ElastiCacheReplicationGroupEngineCpuUtilizationAlarm",
    "ElastiCacheReplicationGroupEngineCpuUtilizationAlarmProps",
    "ElastiCacheReplicationGroupRecommendedAlarms",
    "ElastiCacheReplicationGroupRecommendedAlarmsAspect",
    "ElastiCacheReplicationGroupRecommendedAlarmsConfig",
    "ElastiCacheReplicationGroupRecommendedAlarmsProps",
    "ElastiCacheReplicationGroupReplicationLagAlarm",
    "ElastiCacheReplicationGroupReplicationLagAlarmProps",
    "ElastiCacheReplicationLagAlarmConfig",
    "FargateService",
    "FileSystem",
    "Function",
    "Instance",
    "InterfaceVpcEndpoint",
    "LambdaAlarmBaseConfig",
    "LambdaConcurrentExecutionsAlarm",
    "LambdaConcurrentExecutionsAlarmConfig",
    "LambdaConcurrentExecutionsAlarmProps",
    "LambdaDurationAlarm",
    "LambdaDurationAlarmConfig",
    "LambdaDurationAlarmProps",
    "LambdaErrorsAlarm",
    "LambdaErrorsAlarmConfig",
    "LambdaErrorsAlarmProps",
    "LambdaRecommendedAlarms",
    "LambdaRecommendedAlarmsAspect",
    "LambdaRecommendedAlarmsConfig",
    "LambdaRecommendedAlarmsMetrics",
    "LambdaRecommendedAlarmsProps",
    "LambdaThrottlesAlarm",
    "LambdaThrottlesAlarmConfig",
    "LambdaThrottlesAlarmProps",
    "NetworkLoadBalancer",
    "NetworkLoadBalancerAlarmBaseConfig",
    "NetworkLoadBalancerAlarmProps",
    "NetworkLoadBalancerRecommendedAlarms",
    "NetworkLoadBalancerRecommendedAlarmsAspect",
    "NetworkLoadBalancerRecommendedAlarmsConfig",
    "NetworkLoadBalancerRecommendedAlarmsMetrics",
    "NetworkLoadBalancerRecommendedAlarmsProps",
    "NetworkLoadBalancerTcpElbResetCountAlarm",
    "NetworkLoadBalancerTcpElbResetCountAlarmConfig",
    "NetworkLoadBalancerTcpElbResetCountAlarmProps",
    "NetworkLoadBalancerTcpTargetResetCountAlarm",
    "NetworkLoadBalancerTcpTargetResetCountAlarmConfig",
    "NetworkLoadBalancerTcpTargetResetCountAlarmProps",
    "NetworkTargetGroup",
    "NetworkTargetGroupAlarmBaseConfig",
    "NetworkTargetGroupAlarmProps",
    "NetworkTargetGroupHealthyHostCountAlarm",
    "NetworkTargetGroupHealthyHostCountAlarmConfig",
    "NetworkTargetGroupHealthyHostCountAlarmProps",
    "NetworkTargetGroupRecommendedAlarms",
    "NetworkTargetGroupRecommendedAlarmsAspect",
    "NetworkTargetGroupRecommendedAlarmsConfig",
    "NetworkTargetGroupRecommendedAlarmsMetrics",
    "NetworkTargetGroupRecommendedAlarmsProps",
    "NetworkTargetGroupUnHealthyHostCountAlarm",
    "NetworkTargetGroupUnHealthyHostCountAlarmConfig",
    "NetworkTargetGroupUnHealthyHostCountAlarmProps",
    "PrivateLinkEndpointsAlarmBaseConfig",
    "PrivateLinkEndpointsInterfaceVpcEndpointAlarmProps",
    "PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarm",
    "PrivateLinkEndpointsInterfaceVpcEndpointPacketsDroppedAlarmProps",
    "PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarms",
    "PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsConfig",
    "PrivateLinkEndpointsInterfaceVpcEndpointRecommendedAlarmsProps",
    "PrivateLinkEndpointsPacketsDroppedAlarmConfig",
    "PrivateLinkEndpointsRecommendedAlarmsMetrics",
    "PrivateLinkServicesAlarmBaseConfig",
    "PrivateLinkServicesRecommendedAlarmsMetrics",
    "PrivateLinkServicesRstPacketsSentAlarmConfig",
    "PrivateLinkServicesVpcEndpointServiceAlarmProps",
    "PrivateLinkServicesVpcEndpointServiceRecommendedAlarms",
    "PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsConfig",
    "PrivateLinkServicesVpcEndpointServiceRecommendedAlarmsProps",
    "PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarm",
    "PrivateLinkServicesVpcEndpointServiceRstPacketsSentAlarmProps",
    "Queue",
    "RdsAlarmBaseConfig",
    "RdsAuroraBinLogReplicationLagAlarm",
    "RdsAuroraBinLogReplicationLagAlarmConfig",
    "RdsAuroraBinLogReplicationLagAlarmProps",
    "RdsAuroraRecommendedAlarms",
    "RdsAuroraRecommendedAlarmsAspect",
    "RdsAuroraRecommendedAlarmsConfig",
    "RdsAuroraRecommendedAlarmsProps",
    "RdsAuroraVolumeBytesLeftTotalAlarm",
    "RdsAuroraVolumeBytesLeftTotalAlarmConfig",
    "RdsAuroraVolumeBytesLeftTotalAlarmProps",
    "RdsCpuUtilizationAlarmConfig",
    "RdsDatabaseConnectionsAlarmConfig",
    "RdsDbLoadAlarmConfig",
    "RdsFreeLocalStorageAlarmConfig",
    "RdsFreeStorageSpaceAlarmConfig",
    "RdsFreeableMemoryAlarmConfig",
    "RdsInstanceAlarmProps",
    "RdsInstanceCpuUtilizationAlarm",
    "RdsInstanceCpuUtilizationAlarmProps",
    "RdsInstanceDatabaseConnectionsAlarm",
    "RdsInstanceDatabaseConnectionsAlarmProps",
    "RdsInstanceDbLoadAlarm",
    "RdsInstanceDbLoadAlarmProps",
    "RdsInstanceFreeLocalStorageAlarm",
    "RdsInstanceFreeLocalStorageAlarmProps",
    "RdsInstanceFreeStorageSpaceAlarm",
    "RdsInstanceFreeStorageSpaceAlarmProps",
    "RdsInstanceFreeableMemoryAlarm",
    "RdsInstanceFreeableMemoryAlarmProps",
    "RdsInstanceReadLatencyAlarm",
    "RdsInstanceReadLatencyAlarmProps",
    "RdsInstanceRecommendedAlarms",
    "RdsInstanceRecommendedAlarmsAspect",
    "RdsInstanceRecommendedAlarmsConfig",
    "RdsInstanceRecommendedAlarmsProps",
    "RdsInstanceWriteLatencyAlarm",
    "RdsInstanceWriteLatencyAlarmProps",
    "RdsReadLatencyAlarmConfig",
    "RdsRecommendedAlarmsConfig",
    "RdsRecommendedAlarmsMetrics",
    "RdsWriteLatencyAlarmConfig",
    "ReplicationInstance",
    "ReplicationTask",
    "ReplicationTaskProps",
    "RestApi",
    "S3Bucket4xxErrorsAlarm",
    "S3Bucket4xxErrorsAlarmConfig",
    "S3Bucket4xxErrorsAlarmProps",
    "S3Bucket5xxErrorsAlarm",
    "S3Bucket5xxErrorsAlarmConfig",
    "S3Bucket5xxErrorsAlarmProps",
    "S3BucketHttpErrorsAlarmConfig",
    "S3RecommendedAlarms",
    "S3RecommendedAlarmsAspect",
    "S3RecommendedAlarmsConfig",
    "S3RecommendedAlarmsMetrics",
    "S3RecommendedAlarmsProps",
    "SfAlarmBaseConfig",
    "SfRecommendedAlarmsAspect",
    "SfRecommendedAlarmsMetrics",
    "SfStateMachineAlarmProps",
    "SfStateMachineExecutionThrottledAlarm",
    "SfStateMachineExecutionThrottledAlarmConfig",
    "SfStateMachineExecutionThrottledAlarmProps",
    "SfStateMachineExecutionTimeAlarm",
    "SfStateMachineExecutionTimeAlarmConfig",
    "SfStateMachineExecutionTimeAlarmProps",
    "SfStateMachineExecutionsFailedAlarm",
    "SfStateMachineExecutionsFailedAlarmConfig",
    "SfStateMachineExecutionsFailedAlarmProps",
    "SfStateMachineExecutionsTimedOutAlarm",
    "SfStateMachineExecutionsTimedOutAlarmConfig",
    "SfStateMachineExecutionsTimedOutAlarmProps",
    "SfStateMachineRecommendedAlarms",
    "SfStateMachineRecommendedAlarmsConfig",
    "SfStateMachineRecommendedAlarmsProps",
    "SnsAlarmBaseConfig",
    "SnsNumberOfMessagesPublishedAlarm",
    "SnsNumberOfMessagesPublishedAlarmConfig",
    "SnsNumberOfMessagesPublishedAlarmProps",
    "SnsNumberOfNotificationsDeliveredAlarm",
    "SnsNumberOfNotificationsDeliveredAlarmConfig",
    "SnsNumberOfNotificationsDeliveredAlarmProps",
    "SnsNumberOfNotificationsFailedAlarm",
    "SnsNumberOfNotificationsFailedAlarmConfig",
    "SnsNumberOfNotificationsFailedAlarmProps",
    "SnsNumberOfNotificationsFailedToRedriveToDlqAlarm",
    "SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig",
    "SnsNumberOfNotificationsFailedToRedriveToDlqAlarmProps",
    "SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarm",
    "SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig",
    "SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmProps",
    "SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarm",
    "SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig",
    "SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmProps",
    "SnsNumberOfNotificationsRedrivenToDlqAlarm",
    "SnsNumberOfNotificationsRedrivenToDlqAlarmConfig",
    "SnsNumberOfNotificationsRedrivenToDlqAlarmProps",
    "SnsRecommendedAlarms",
    "SnsRecommendedAlarmsAspect",
    "SnsRecommendedAlarmsConfig",
    "SnsRecommendedAlarmsMetrics",
    "SnsRecommendedAlarmsProps",
    "SqsAlarmBaseConfig",
    "SqsApproximateAgeOfOldestMessageAlarm",
    "SqsApproximateAgeOfOldestMessageAlarmConfig",
    "SqsApproximateAgeOfOldestMessageAlarmProps",
    "SqsApproximateNumberOfMessagesNotVisibleAlarm",
    "SqsApproximateNumberOfMessagesNotVisibleAlarmConfig",
    "SqsApproximateNumberOfMessagesNotVisibleAlarmProps",
    "SqsApproximateNumberOfMessagesVisibleAlarm",
    "SqsApproximateNumberOfMessagesVisibleAlarmConfig",
    "SqsApproximateNumberOfMessagesVisibleAlarmProps",
    "SqsNumberOfMessagesSentAlarm",
    "SqsNumberOfMessagesSentAlarmConfig",
    "SqsNumberOfMessagesSentAlarmProps",
    "SqsRecommendedAlarms",
    "SqsRecommendedAlarmsAspect",
    "SqsRecommendedAlarmsConfig",
    "SqsRecommendedAlarmsMetrics",
    "SqsRecommendedAlarmsProps",
    "StateMachine",
    "Table",
    "Topic",
    "VpcEndpointService",
    "VpnAlarmBaseConfig",
    "VpnConnection",
    "VpnConnectionAlarmProps",
    "VpnConnectionRecommendedAlarms",
    "VpnConnectionRecommendedAlarmsConfig",
    "VpnConnectionRecommendedAlarmsProps",
    "VpnConnectionTunnelStateAlarm",
    "VpnConnectionTunnelStateAlarmProps",
    "VpnRecommendedAlarmsAspect",
    "VpnRecommendedAlarmsMetrics",
    "VpnTunnelStateAlarmConfig",
]

publication.publish()

def _typecheckingstub__dc8826645a1e265ceca74e67c468d47f270a951fd40c4c3bcf8922d80e34f685(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e54942d9ca84322e711834f10d9871f12b5b1db8f6c7ba78a04be36a6ef964d3(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b738b8ed888082c8147d9927f30bb1527cd7d2adae3d35bc55db2497661cb734(
    *,
    alias: builtins.str,
    method: builtins.str,
    resource: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af66f83026ae14035872eb925fb9762936db50a2d9af5223e9a1999fef40b564(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e62e04f8ba2a25d8da7c4c62dc069c586365c7f82dc177931df4e3c001a96bc(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70d8eae524a7a121a49e99ed70fd871aeaf2f0e077a7ce674545b16491c88c70(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31e0f1eee097369efcdc8a765f803822803c1eab334220d1367cd756cb2b0f90(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f45987f7120127b2029405a7439b3c1968587a38de51a9ddff363c437b24af70(
    *,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__907876ec7b8663cb34d1f68a7f0cfab1c1fbf1d076e9607bc6c75ee71476dff9(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    alias: builtins.str,
    method: builtins.str,
    resource: builtins.str,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__272a823eefdc7c57c3297274c586f57a5195c082b12c99716ece42fdd6dfd594(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    alias: builtins.str,
    method: builtins.str,
    resource: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__989b217b8af1ca5f08f13aa258cacc5cd6766752e60e13096e54cad84dcf6f63(
    *,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    alias: builtins.str,
    method: builtins.str,
    resource: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__de91c2b09391ec79296065ae871d152b40ed0f28d13a8fcf6419f3d8e1ddf5b3(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9ee1d1edb07c07944b7c95bd346b97adda30b8cd0384bb14eac0166e5eab7f7b(
    *,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28abc7e5840007e0028c59fe29eea994ec8b37de9da1462a8e2d5c99313a1f2b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    config4_xx_error_alarm: typing.Union[ApiGateway4XXErrorAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config5_xx_error_alarm: typing.Union[ApiGateway5XXErrorAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_detailed_latency_alarm_list: typing.Optional[typing.Sequence[typing.Union[ApiGatewayRestApiDetailedLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    config_latency_alarm: typing.Optional[typing.Union[ApiGatewayLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ApiGatewayRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c4d62c1f7e7796148ba2e669b7af3d31843b5b65a3fa414ab506df073a7fb84(
    *,
    config4_xx_error_alarm: typing.Union[ApiGateway4XXErrorAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config5_xx_error_alarm: typing.Union[ApiGateway5XXErrorAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_detailed_latency_alarm_list: typing.Optional[typing.Sequence[typing.Union[ApiGatewayRestApiDetailedLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    config_latency_alarm: typing.Optional[typing.Union[ApiGatewayLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ApiGatewayRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5779ec01c7efa4bf90b664d5da8a5ef4a05d633f7ab3e6f2005ca6a1b1eb6db(
    *,
    config4_xx_error_alarm: typing.Union[ApiGateway4XXErrorAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config5_xx_error_alarm: typing.Union[ApiGateway5XXErrorAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_detailed_latency_alarm_list: typing.Optional[typing.Sequence[typing.Union[ApiGatewayRestApiDetailedLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    config_latency_alarm: typing.Optional[typing.Union[ApiGatewayLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ApiGatewayRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bb7d32e109b42c486f3ef83c0712866c58faa867e12169172cdc53eb75347920(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    client_keep_alive: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    desync_mitigation_mode: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.DesyncMitigationMode] = None,
    drop_invalid_header_fields: typing.Optional[builtins.bool] = None,
    http2_enabled: typing.Optional[builtins.bool] = None,
    idle_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ip_address_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.IpAddressType] = None,
    preserve_host_header: typing.Optional[builtins.bool] = None,
    preserve_xff_client_port: typing.Optional[builtins.bool] = None,
    security_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup] = None,
    waf_fail_open: typing.Optional[builtins.bool] = None,
    x_amzn_tls_version_and_cipher_suite_headers: typing.Optional[builtins.bool] = None,
    xff_header_processing_mode: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.XffHeaderProcessingMode] = None,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    cross_zone_enabled: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    deny_all_igw_traffic: typing.Optional[builtins.bool] = None,
    internet_facing: typing.Optional[builtins.bool] = None,
    load_balancer_name: typing.Optional[builtins.str] = None,
    minimum_capacity_unit: typing.Optional[jsii.Number] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9687e512c69ae656e4df83643578f02b457562ac8547996d9527380e3d9121a6(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e290157996a57817cddd93930fef0cef7299d9a971b296117131d4c9dda29a73(
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__822d378f2f32d60c71821d64d091d71130e9a6ed9a7d704ccd11e1551e00d940(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    std_devs: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d03cb57980316a63b6ac7fc8b7dba63532dc8dd451679a6549f835449df23c6e(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    std_devs: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__464de1eb804f7b141dc388b1e4ba9ca853a85e61bc0940fe9c1fd6d3106ebb6b(
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    std_devs: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__539fa0a4f6542e80a2748ff50b5bee1a585895bf9d509c5e6e7b97aff4d5eec8(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    std_devs: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c45483444643a3edd3a6c4c13c0d66965f5e3f8468612892ed9385561e5a6d3(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    std_devs: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61478244c4c6feac26804e8ad2e4b1c2021243a952f35be4f4eff05c4b9a1a57(
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    std_devs: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9947ded5c5ff7799a6316aaf3ad4e40ae5d86fa92b2d0e87d68b940d4ff3aadf(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__600b32b293eaf13ac79f172206fc4f481abdb37ad28dd637d48be434fef52395(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5433b6c5b813275d50a52163cc053ff6fd48aac190c6d3689baf812154a62c9d(
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2bd76af47259143adccda326390737cfd73e26621fa6fcd8d22aba8c782be402(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    config_http_code4xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_http_code5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_http_code_target5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_rejected_connection_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerRejectedConnectionCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ApplicationLoadBalancerRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4986286dd81c90bee7785aecf315b49e7ad3e8aa350d3cdb0507f78aa3eb5d79(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ccd26b3dd9354de62dc9a0658a8bbd649deff69499b0846cdb71b724c7ad68c9(
    *,
    config_http_code4xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_http_code5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_http_code_target5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_rejected_connection_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerRejectedConnectionCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ApplicationLoadBalancerRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a86126a95d1bc9b5b7451f38fbfa9538cc1af9bfa6ba3790aad3d6a0846c23f(
    *,
    config_http_code4xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode4xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_http_code5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCode5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_http_code_target5xx_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerHttpCodeTarget5xxCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_rejected_connection_count_alarm: typing.Optional[typing.Union[ApplicationLoadBalancerRejectedConnectionCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ApplicationLoadBalancerRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2d5fdc80258b5a62ee1a301c5d95dc15e6aca58479cd9536348b6ed6e1c8780c(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__01fa76713b0249fdf3b75f594722ff34e8a7e97acbf487ce20d4da5f9f25e8ee(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8cac3a3f4883bfdd18150e81d9b44d5ee7b7a13e4586f6c11daad970477d3a6f(
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationLoadBalancer,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f3eca73e09d126f9757cb84b797321f327ba4a1f68cd373ba6fb9aa90ea61db3(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    enable_anomaly_mitigation: typing.Optional[builtins.bool] = None,
    load_balancing_algorithm_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.TargetGroupLoadBalancingAlgorithmType] = None,
    multi_value_headers_enabled: typing.Optional[builtins.bool] = None,
    port: typing.Optional[jsii.Number] = None,
    protocol: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationProtocol] = None,
    protocol_version: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationProtocolVersion] = None,
    slow_start: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    stickiness_cookie_duration: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    stickiness_cookie_name: typing.Optional[builtins.str] = None,
    targets: typing.Optional[typing.Sequence[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.IApplicationLoadBalancerTarget]] = None,
    cross_zone_enabled: typing.Optional[builtins.bool] = None,
    deregistration_delay: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    health_check: typing.Optional[typing.Union[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.HealthCheck, typing.Dict[builtins.str, typing.Any]]] = None,
    ip_address_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.TargetGroupIpAddressType] = None,
    target_group_name: typing.Optional[builtins.str] = None,
    target_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.TargetType] = None,
    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e5082ab129e09581e8efe5b3ae12c541bdc4c541519c9c8348f706704aeee7a5(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9dfe5b7537402019ae5b587e15d8f9cdd15e8e3232f5aa11bbb9815b195150c1(
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__61a37400bbff0bb7de91c4ddaaf39b5e5d9fec89268a65f7863af18503c5d7a7(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__05a032d5319017b28e4b24064604ea6011288674f9ddeaf551819c2930a6006e(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9d196b9cf1035270d6184672d9b100db5dd0d35a5878c8cf83f2d14464a24e4c(
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd3ad36e370a1ce87d25da23a20bfbea01f361ef5e21acaced912dd8f79d679e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
    config_healthy_host_count_alarm: typing.Optional[typing.Union[ApplicationTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_un_healthy_host_count_alarm: typing.Optional[typing.Union[ApplicationTargetGroupUnHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ApplicationTargetGroupRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2eff6bb57c5b310692d6d2f5590d32c005a5ff9057fb2202f17de4fab2b1af5(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f49c01378c4b63c1b79b66061b3fa87cec8315abb87bc054045fd2698100ae3(
    *,
    config_healthy_host_count_alarm: typing.Optional[typing.Union[ApplicationTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_un_healthy_host_count_alarm: typing.Optional[typing.Union[ApplicationTargetGroupUnHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ApplicationTargetGroupRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f69da420612f08b947e19d377b1ad5e60721379e53434b957d61153604c36e1(
    *,
    config_healthy_host_count_alarm: typing.Optional[typing.Union[ApplicationTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_un_healthy_host_count_alarm: typing.Optional[typing.Union[ApplicationTargetGroupUnHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ApplicationTargetGroupRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f430a7a39a1f1b915f5b663d4636e2c739a435c15ad3c59786229d1d238d93c6(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__95557f03b14db822ef98d677e96577b75ce44a0efad5ac3c0be58f621379de2f(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f6f05d2de207f9b375204838e135337da9e5b314006480a2437ff6c7607cd5f(
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ApplicationTargetGroup,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f34c8bf92bc1f68db1fc43c47b2bed623d3e4e5b74fcabdf46f1b6be3adb19fb(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0e9f80bdc24a7bb9bf530d5b966c33921cf9260ef5f57056e14dfc2d48ea0a97(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    init: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.CloudFormationInit] = None,
    init_options: typing.Optional[typing.Union[_aws_cdk_aws_autoscaling_ceddda9d.ApplyCloudFormationInitOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    instance_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.InstanceType] = None,
    launch_template: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ILaunchTemplate] = None,
    machine_image: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IMachineImage] = None,
    max_healthy_percentage: typing.Optional[jsii.Number] = None,
    min_healthy_percentage: typing.Optional[jsii.Number] = None,
    mixed_instances_policy: typing.Optional[typing.Union[_aws_cdk_aws_autoscaling_ceddda9d.MixedInstancesPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    require_imdsv2: typing.Optional[builtins.bool] = None,
    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    security_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup] = None,
    user_data: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.UserData] = None,
    allow_all_outbound: typing.Optional[builtins.bool] = None,
    associate_public_ip_address: typing.Optional[builtins.bool] = None,
    auto_scaling_group_name: typing.Optional[builtins.str] = None,
    az_capacity_distribution_strategy: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.CapacityDistributionStrategy] = None,
    block_devices: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_autoscaling_ceddda9d.BlockDevice, typing.Dict[builtins.str, typing.Any]]]] = None,
    capacity_rebalance: typing.Optional[builtins.bool] = None,
    cooldown: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    default_instance_warmup: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    desired_capacity: typing.Optional[jsii.Number] = None,
    group_metrics: typing.Optional[typing.Sequence[_aws_cdk_aws_autoscaling_ceddda9d.GroupMetrics]] = None,
    health_check: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.HealthCheck] = None,
    health_checks: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.HealthChecks] = None,
    ignore_unmodified_size_properties: typing.Optional[builtins.bool] = None,
    instance_monitoring: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.Monitoring] = None,
    key_name: typing.Optional[builtins.str] = None,
    key_pair: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IKeyPair] = None,
    max_capacity: typing.Optional[jsii.Number] = None,
    max_instance_lifetime: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    min_capacity: typing.Optional[jsii.Number] = None,
    new_instances_protected_from_scale_in: typing.Optional[builtins.bool] = None,
    notifications: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_autoscaling_ceddda9d.NotificationConfiguration, typing.Dict[builtins.str, typing.Any]]]] = None,
    signals: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.Signals] = None,
    spot_price: typing.Optional[builtins.str] = None,
    ssm_session_permissions: typing.Optional[builtins.bool] = None,
    termination_policies: typing.Optional[typing.Sequence[_aws_cdk_aws_autoscaling_ceddda9d.TerminationPolicy]] = None,
    termination_policy_custom_lambda_function_arn: typing.Optional[builtins.str] = None,
    update_policy: typing.Optional[_aws_cdk_aws_autoscaling_ceddda9d.UpdatePolicy] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d94d15da6ab5f02c6243b356d97c9d728043a324aca631806c5ea86e4b8e01ca(
    *,
    auto_scaling_group: _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__207504a11eca1048ab0f0cb0cd46ef472eab4a027cdc22dcb06b46c4d9380190(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    auto_scaling_group: _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8bc12a9c6366827286d8a2eed3f9e658ad400eb435e198c1d19335addf45ed9f(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__80d1e0bb39d93b7b99e53b929044820b4b7ed6d9c2e028b1ca724e83ab38616d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    auto_scaling_group: _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
    config_group_in_service_capacity_alarm: typing.Union[AutoScalingGroupInServiceCapacityAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[AutoScalingRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4eae16a88118a3a8b0f1e59758c25173fff964ec13d5833aa7199f039077fc97(
    *,
    config_group_in_service_capacity_alarm: typing.Union[AutoScalingGroupInServiceCapacityAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[AutoScalingRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__84f107eb6b9771648539a36155991f106e101c6f46985039a5e3ccb99826234e(
    *,
    config_group_in_service_capacity_alarm: typing.Union[AutoScalingGroupInServiceCapacityAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[AutoScalingRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    auto_scaling_group: _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c76a791474124f52989c8eac7d582ed82be8d4a1aa8c88ec8952367d68aab818(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__997fd23e9dec2f8580d4a0f3905a7216624c6b51043d6491f7523aa123af316d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    access_control: typing.Optional[_aws_cdk_aws_s3_ceddda9d.BucketAccessControl] = None,
    auto_delete_objects: typing.Optional[builtins.bool] = None,
    block_public_access: typing.Optional[_aws_cdk_aws_s3_ceddda9d.BlockPublicAccess] = None,
    bucket_key_enabled: typing.Optional[builtins.bool] = None,
    bucket_name: typing.Optional[builtins.str] = None,
    cors: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.CorsRule, typing.Dict[builtins.str, typing.Any]]]] = None,
    encryption: typing.Optional[_aws_cdk_aws_s3_ceddda9d.BucketEncryption] = None,
    encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    enforce_ssl: typing.Optional[builtins.bool] = None,
    event_bridge_enabled: typing.Optional[builtins.bool] = None,
    intelligent_tiering_configurations: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.IntelligentTieringConfiguration, typing.Dict[builtins.str, typing.Any]]]] = None,
    inventories: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.Inventory, typing.Dict[builtins.str, typing.Any]]]] = None,
    lifecycle_rules: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.LifecycleRule, typing.Dict[builtins.str, typing.Any]]]] = None,
    metrics: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.BucketMetrics, typing.Dict[builtins.str, typing.Any]]]] = None,
    minimum_tls_version: typing.Optional[jsii.Number] = None,
    notifications_handler_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    notifications_skip_destination_validation: typing.Optional[builtins.bool] = None,
    object_lock_default_retention: typing.Optional[_aws_cdk_aws_s3_ceddda9d.ObjectLockRetention] = None,
    object_lock_enabled: typing.Optional[builtins.bool] = None,
    object_ownership: typing.Optional[_aws_cdk_aws_s3_ceddda9d.ObjectOwnership] = None,
    public_read_access: typing.Optional[builtins.bool] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    replication_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    replication_rules: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.ReplicationRule, typing.Dict[builtins.str, typing.Any]]]] = None,
    server_access_logs_bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
    server_access_logs_prefix: typing.Optional[builtins.str] = None,
    target_object_key_format: typing.Optional[_aws_cdk_aws_s3_ceddda9d.TargetObjectKeyFormat] = None,
    transfer_acceleration: typing.Optional[builtins.bool] = None,
    transition_default_minimum_object_size: typing.Optional[_aws_cdk_aws_s3_ceddda9d.TransitionDefaultMinimumObjectSize] = None,
    versioned: typing.Optional[builtins.bool] = None,
    website_error_document: typing.Optional[builtins.str] = None,
    website_index_document: typing.Optional[builtins.str] = None,
    website_redirect: typing.Optional[typing.Union[_aws_cdk_aws_s3_ceddda9d.RedirectTarget, typing.Dict[builtins.str, typing.Any]]] = None,
    website_routing_rules: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_s3_ceddda9d.RoutingRule, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86037cd53a11220db21e2416eb05b1fd5d54e13a1577d12e916d181d78bd28e4(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cache_node_type: builtins.str,
    engine: builtins.str,
    num_cache_nodes: jsii.Number,
    auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    az_mode: typing.Optional[builtins.str] = None,
    cache_parameter_group_name: typing.Optional[builtins.str] = None,
    cache_security_group_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    cache_subnet_group_name: typing.Optional[builtins.str] = None,
    cluster_name: typing.Optional[builtins.str] = None,
    engine_version: typing.Optional[builtins.str] = None,
    ip_discovery: typing.Optional[builtins.str] = None,
    log_delivery_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster.LogDeliveryConfigurationRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    network_type: typing.Optional[builtins.str] = None,
    notification_topic_arn: typing.Optional[builtins.str] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_availability_zone: typing.Optional[builtins.str] = None,
    preferred_availability_zones: typing.Optional[typing.Sequence[builtins.str]] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    snapshot_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
    snapshot_name: typing.Optional[builtins.str] = None,
    snapshot_retention_limit: typing.Optional[jsii.Number] = None,
    snapshot_window: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_encryption_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a7ccdbca841d390836aded81d1175e953552ca0c93e888187601d7071b0a809e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    replication_group_description: builtins.str,
    at_rest_encryption_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    auth_token: typing.Optional[builtins.str] = None,
    automatic_failover_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    cache_node_type: typing.Optional[builtins.str] = None,
    cache_parameter_group_name: typing.Optional[builtins.str] = None,
    cache_security_group_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    cache_subnet_group_name: typing.Optional[builtins.str] = None,
    cluster_mode: typing.Optional[builtins.str] = None,
    data_tiering_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    engine: typing.Optional[builtins.str] = None,
    engine_version: typing.Optional[builtins.str] = None,
    global_replication_group_id: typing.Optional[builtins.str] = None,
    ip_discovery: typing.Optional[builtins.str] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    log_delivery_configurations: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup.LogDeliveryConfigurationRequestProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    multi_az_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    network_type: typing.Optional[builtins.str] = None,
    node_group_configuration: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup.NodeGroupConfigurationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
    notification_topic_arn: typing.Optional[builtins.str] = None,
    num_cache_clusters: typing.Optional[jsii.Number] = None,
    num_node_groups: typing.Optional[jsii.Number] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_cache_cluster_a_zs: typing.Optional[typing.Sequence[builtins.str]] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    primary_cluster_id: typing.Optional[builtins.str] = None,
    replicas_per_node_group: typing.Optional[jsii.Number] = None,
    replication_group_id: typing.Optional[builtins.str] = None,
    security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
    snapshot_arns: typing.Optional[typing.Sequence[builtins.str]] = None,
    snapshot_name: typing.Optional[builtins.str] = None,
    snapshot_retention_limit: typing.Optional[jsii.Number] = None,
    snapshotting_cluster_id: typing.Optional[builtins.str] = None,
    snapshot_window: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_encryption_enabled: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    transit_encryption_mode: typing.Optional[builtins.str] = None,
    user_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3820b7882a7674f411cc15dedf79c6768e809ba39552ae7ab5cc589063637c14(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f63190c577990aef1c72ba1290e304136a09f7029c86646278b4dcb3cf65ebec(
    *,
    function_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41d8e3486518c487fad458e8dff100b3669925844a0375ca3783b9fdf23b49ee(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__248fcc4e71cc9a3c4ab45ffb841c70093e82bf3af03551acf869b4ae9e35f383(
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__227fda650b67ac25cd09047d27bf71990f1b6cfd651682942cc79a601b270b2b(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    function_name: builtins.str,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ce4e083dc5b9a2a7328c0ac78a8a293ad67fd66c60ba3b3467286362bcd55907(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    function_name: builtins.str,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__598f49854634f167c78a891bef6741976476f2b7fd0a00ca549f373c15ec8226(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    function_name: builtins.str,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af70c9a32ab9863b966d4dbfc706f9bf74bdcbbcc352049b52d7d11ef6e7884f(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64ee14900249018f7c68fd6171113f33480e248f41c63095f472a21485c1a2d8(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    config5xx_error_rate_alarm: typing.Union[CloudFront5xxErrorRateAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_origin_latency_alarm: typing.Union[CloudFrontOriginLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_detailed_function_execution_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    config_detailed_function_throttles_alarm_list: typing.Optional[typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    config_detailed_function_validation_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[CloudFrontRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6879266c5397224eede2bc3d511a20b2cf0cf418483da97a33948992115ccfed(
    *,
    config5xx_error_rate_alarm: typing.Union[CloudFront5xxErrorRateAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_origin_latency_alarm: typing.Union[CloudFrontOriginLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_detailed_function_execution_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    config_detailed_function_throttles_alarm_list: typing.Optional[typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    config_detailed_function_validation_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[CloudFrontRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7867c21528e689be02bd1b707c76d96efac66abc09b9d6918330ab4960080286(
    *,
    config5xx_error_rate_alarm: typing.Union[CloudFront5xxErrorRateAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_origin_latency_alarm: typing.Union[CloudFrontOriginLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_detailed_function_execution_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    config_detailed_function_throttles_alarm_list: typing.Optional[typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    config_detailed_function_validation_errors_alarm_list: typing.Optional[typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[CloudFrontRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__af97d207175eb2e76e4aa13c9c167a4f8d22265802b299fc480b14341738b9e7(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c981c3d670ae2c9b1155edd6332cbda93dce2b1f3a19fc53ecb03ba1115f7d77(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b658a3f61c67bad646a4506df211681542a1cc68672350c7e515461be5d5a57(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff483231024f29d40c2f8d88bea548c79984207f57f24c7e1680f7bdb7f71883(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4ced914fbbe40406d5305a5076e36fccb277dc46eb31a2f5f45ba8aee5f27afe(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae99011110f783b0444b8e6ac9226586a1665200f9ac945e68fef86d3fa756a2(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    engine: _aws_cdk_aws_rds_ceddda9d.IClusterEngine,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    backtrack_window: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    backup: typing.Optional[typing.Union[_aws_cdk_aws_rds_ceddda9d.BackupProps, typing.Dict[builtins.str, typing.Any]]] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
    cloudwatch_logs_retention_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
    cluster_scailability_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.ClusterScailabilityType] = None,
    cluster_scalability_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.ClusterScalabilityType] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    credentials: typing.Optional[_aws_cdk_aws_rds_ceddda9d.Credentials] = None,
    database_insights_mode: typing.Optional[_aws_cdk_aws_rds_ceddda9d.DatabaseInsightsMode] = None,
    default_database_name: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    enable_cluster_level_enhanced_monitoring: typing.Optional[builtins.bool] = None,
    enable_data_api: typing.Optional[builtins.bool] = None,
    enable_local_write_forwarding: typing.Optional[builtins.bool] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    engine_lifecycle_support: typing.Optional[_aws_cdk_aws_rds_ceddda9d.EngineLifecycleSupport] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier_base: typing.Optional[builtins.str] = None,
    instance_props: typing.Optional[typing.Union[_aws_cdk_aws_rds_ceddda9d.InstanceProps, typing.Dict[builtins.str, typing.Any]]] = None,
    instances: typing.Optional[jsii.Number] = None,
    instance_update_behaviour: typing.Optional[_aws_cdk_aws_rds_ceddda9d.InstanceUpdateBehaviour] = None,
    monitoring_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    monitoring_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    network_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.NetworkType] = None,
    parameter_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IParameterGroup] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    performance_insight_encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    performance_insight_retention: typing.Optional[_aws_cdk_aws_rds_ceddda9d.PerformanceInsightRetention] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    readers: typing.Optional[typing.Sequence[_aws_cdk_aws_rds_ceddda9d.IClusterInstance]] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    replication_source_identifier: typing.Optional[builtins.str] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_aws_cdk_aws_s3_ceddda9d.IBucket]] = None,
    s3_export_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_aws_cdk_aws_s3_ceddda9d.IBucket]] = None,
    s3_import_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
    serverless_v2_auto_pause_duration: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    serverless_v2_max_capacity: typing.Optional[jsii.Number] = None,
    serverless_v2_min_capacity: typing.Optional[jsii.Number] = None,
    storage_encrypted: typing.Optional[builtins.bool] = None,
    storage_encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    storage_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.DBClusterStorageType] = None,
    subnet_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.ISubnetGroup] = None,
    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    writer: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IClusterInstance] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9152604e11755d3937ae12655f53012564282cb097fd7057b1d03eb751e9201f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    character_set_name: typing.Optional[builtins.str] = None,
    credentials: typing.Optional[_aws_cdk_aws_rds_ceddda9d.Credentials] = None,
    storage_encrypted: typing.Optional[builtins.bool] = None,
    storage_encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    engine: _aws_cdk_aws_rds_ceddda9d.IInstanceEngine,
    allocated_storage: typing.Optional[jsii.Number] = None,
    allow_major_version_upgrade: typing.Optional[builtins.bool] = None,
    database_name: typing.Optional[builtins.str] = None,
    instance_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.InstanceType] = None,
    license_model: typing.Optional[_aws_cdk_aws_rds_ceddda9d.LicenseModel] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    timezone: typing.Optional[builtins.str] = None,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    apply_immediately: typing.Optional[builtins.bool] = None,
    auto_minor_version_upgrade: typing.Optional[builtins.bool] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    backup_retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    ca_certificate: typing.Optional[_aws_cdk_aws_rds_ceddda9d.CaCertificate] = None,
    cloudwatch_logs_exports: typing.Optional[typing.Sequence[builtins.str]] = None,
    cloudwatch_logs_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
    cloudwatch_logs_retention_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    delete_automated_backups: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    domain: typing.Optional[builtins.str] = None,
    domain_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    enable_performance_insights: typing.Optional[builtins.bool] = None,
    engine_lifecycle_support: typing.Optional[_aws_cdk_aws_rds_ceddda9d.EngineLifecycleSupport] = None,
    iam_authentication: typing.Optional[builtins.bool] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    iops: typing.Optional[jsii.Number] = None,
    max_allocated_storage: typing.Optional[jsii.Number] = None,
    monitoring_interval: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    monitoring_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    multi_az: typing.Optional[builtins.bool] = None,
    network_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.NetworkType] = None,
    option_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IOptionGroup] = None,
    parameter_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IParameterGroup] = None,
    performance_insight_encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    performance_insight_retention: typing.Optional[_aws_cdk_aws_rds_ceddda9d.PerformanceInsightRetention] = None,
    port: typing.Optional[jsii.Number] = None,
    preferred_backup_window: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    processor_features: typing.Optional[typing.Union[_aws_cdk_aws_rds_ceddda9d.ProcessorFeatures, typing.Dict[builtins.str, typing.Any]]] = None,
    publicly_accessible: typing.Optional[builtins.bool] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    s3_export_buckets: typing.Optional[typing.Sequence[_aws_cdk_aws_s3_ceddda9d.IBucket]] = None,
    s3_export_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    s3_import_buckets: typing.Optional[typing.Sequence[_aws_cdk_aws_s3_ceddda9d.IBucket]] = None,
    s3_import_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
    storage_throughput: typing.Optional[jsii.Number] = None,
    storage_type: typing.Optional[_aws_cdk_aws_rds_ceddda9d.StorageType] = None,
    subnet_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.ISubnetGroup] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__46f484d1d1177c5f3c3883060fbc0c874488a986b8174bf67e85d18aba3a973c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    default_behavior: typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.BehaviorOptions, typing.Dict[builtins.str, typing.Any]],
    additional_behaviors: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.BehaviorOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
    certificate: typing.Optional[_aws_cdk_aws_certificatemanager_ceddda9d.ICertificate] = None,
    comment: typing.Optional[builtins.str] = None,
    default_root_object: typing.Optional[builtins.str] = None,
    domain_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    enable_ipv6: typing.Optional[builtins.bool] = None,
    enable_logging: typing.Optional[builtins.bool] = None,
    error_responses: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.ErrorResponse, typing.Dict[builtins.str, typing.Any]]]] = None,
    geo_restriction: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.GeoRestriction] = None,
    http_version: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.HttpVersion] = None,
    log_bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
    log_file_prefix: typing.Optional[builtins.str] = None,
    log_includes_cookies: typing.Optional[builtins.bool] = None,
    minimum_protocol_version: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SecurityPolicyProtocol] = None,
    price_class: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.PriceClass] = None,
    publish_additional_metrics: typing.Optional[builtins.bool] = None,
    ssl_support_method: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SSLMethod] = None,
    web_acl_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c33396aabc047624cd98f8b6013c529bf4c220dcb7217dc70626b10c3ee4c11(
    props: typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionExecutionErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1dc097067f51531d62193f96de11e277083f1d5757eb83a682ada405560d0ad3(
    props: typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionThrottlesAlarmConfig, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e179d19c9fc9edc3aa0308ed1163f6e11d82ff2723a453223538d1b623d488ed(
    props: typing.Sequence[typing.Union[CloudFrontDistributionDetailedFunctionValidationErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab82a99a09f2744657ff9cbcdaac21944d1f4051e326e3dace98bfc944088fda(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bcabd771bbd113e05d836ed3a76a31a745756114857fd3ddf7ca987ab1cd7b5c(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    std_devs: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__299d64b2beecb87b0d236387d739b17cb049b9ac0bd6eaf48971da02c32d7d59(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__09071285f6d7363e67a937314714d0d90fd6ca94372d1671a1b25f7df3f3a4e3(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df53ca11e40a0b33719484628860336ea3eb59316fbc5077a9bd1a63cb270311(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6900991ff0f12bb00229010fcd6d47b85195ca93f18edde326a0c875b690a298(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9254e191b23fed1b7b55f7882d0ba3409d3fa5f0920b7493f0e37b9a4d810d7(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf02c2a755b3f26cf82dd776eea332fad151b972f9b94eeeddf2a5eeab264e4a(
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__743fd8efe73419c42a8dbe71f7fad61467c32befa6db45b707bed978505b2a96(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3d6abb9942ee60c245bffb931dce8750868c7e969ccae01c3b2f35f57741c18c(
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68acb003c1fca22c0b23584e8a3960bf291894afcd0a56987a78dc7a2ba7988f(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ffaa103abf140cfbfb95e89a0b72a6f6840a090c75389d2d4554f46759923315(
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ff0aeafda7e3930a68283d39571b85830d96c56ac4f8d76b7ccd739ae73d3442(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__040bd7d3582121131896de98d02516ea0a71bc776b539ed619e247d6fb11b357(
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fff739d06f4bfe93d2a25f0febaa8495e0d1604317581feda15604b1d98a87d8(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    config_freeable_memory_alarm: typing.Union[DmsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_storage_space_alarm: typing.Union[DmsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[DmsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_swap_usage_alarm: typing.Optional[typing.Union[DmsSwapUsageAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_write_iops_alarm: typing.Optional[typing.Union[DmsWriteIopsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[DmsReplicationInstanceRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9ce743fcb197ac7f7e98a9f4cb54abe9abb9cf1267f8b11d2718c74973084b8(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c8d9847b36753cb62ae1fc2a1303a3bcc1676d195fb399398e7b2ba0de09c78(
    *,
    config_freeable_memory_alarm: typing.Union[DmsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_storage_space_alarm: typing.Union[DmsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[DmsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_swap_usage_alarm: typing.Optional[typing.Union[DmsSwapUsageAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_write_iops_alarm: typing.Optional[typing.Union[DmsWriteIopsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[DmsReplicationInstanceRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4fbb9dc5c3afae087dde4011b8914d4255e2c1b477462ba38fd49172d3b7bdcd(
    *,
    config_freeable_memory_alarm: typing.Union[DmsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_storage_space_alarm: typing.Union[DmsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[DmsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_swap_usage_alarm: typing.Optional[typing.Union[DmsSwapUsageAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_write_iops_alarm: typing.Optional[typing.Union[DmsWriteIopsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[DmsReplicationInstanceRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f556e31738cca869b9f7180f7ef9a13a9f76fc27c4561fa1c649df222b711903(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    std_devs: typing.Optional[jsii.Number] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__283f247727ed1b733e3c1a83af7ac50f14bbb8809f6537c729d4ae3df5fbccc7(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bdb67432e90d78ce4b107fb0e0f859e6fe25040f445056dd20e82e54231290e(
    *,
    replication_task: ReplicationTask,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6a2b5b5171013395409ade0fa68f164c0e13d8305e1a7ad17d067cafc82750d2(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    replication_task: ReplicationTask,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0ecdae9faa8a7cad48a1ebe9a5b9aa28a5e7170faef1718c0b047e75988e547(
    *,
    replication_task: ReplicationTask,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fc88526af55eca64a4ec52eec674536df907580807e10162be48975435162b03(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    replication_task: ReplicationTask,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc4513de71d2468d1499a72bc651d4afc7a32c212903700bf7dec62d00d27675(
    *,
    replication_task: ReplicationTask,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe1ec8ca779feae8c648078782b06c677fa4e08dfba04884a75c7de812d0456f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    replication_task: ReplicationTask,
    config_cdc_latency_source_alarm: typing.Optional[typing.Union[DmsCdcLatencySourceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_cdc_latency_target_alarm: typing.Optional[typing.Union[DmsCdcLatencyTargetAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[DmsReplicationTaskRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbd994d46afbb3a355605c829b801f1a6b0cfd6056a14b3cd62fc4ff03ae561f(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b73316528a16858eb2131e00f250c2fcb128466b12c32be23833d6f18e7234af(
    *,
    config_cdc_latency_source_alarm: typing.Optional[typing.Union[DmsCdcLatencySourceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_cdc_latency_target_alarm: typing.Optional[typing.Union[DmsCdcLatencyTargetAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[DmsReplicationTaskRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__648ab2023b60f0d83f72c45c39ee9dadf30b970d2b27e82aef8c611ca4bf9416(
    *,
    config_cdc_latency_source_alarm: typing.Optional[typing.Union[DmsCdcLatencySourceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_cdc_latency_target_alarm: typing.Optional[typing.Union[DmsCdcLatencyTargetAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[DmsReplicationTaskRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    replication_task: ReplicationTask,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__24080eab2fb25483db7d2f588f068c7c996887cd511fc4c41d9babbed7007499(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    std_devs: typing.Optional[jsii.Number] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__04ac7f5fbad9b4bb4a90fe8fb96b8465fbe97a95b899d1ff314ca79dbcac639f(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6ecc309d5ec4a50b2d939acd5d395ccb636e2fe8086508598d622ecc196b5682(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d575f0f8b362375ef77db3876f4a9147ebdd6e7093435d425ec43ae2c5d5c762(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b5cd40eb7d166aed2672354f28a2ba9387c0df40fafdceb000d5ad038099cbf5(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5f509f6b48878180ae21ef81ef72d674d0f315fd55d5a5eed2c1e6abaf0a708a(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2502c59346b6d388d4cb60df46167a128968ce86e235a1b79ba0e1fecc783a5(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__324bd24124223ff19ee75a06edc28b1aaf8470beefddab3c63ad669a7b8146b8(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef9350e286af026856679ce0bddb7a3b3609cec27a15904bf30ab36d4f74e215(
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a25619b84d7d4b455842b1325cefdaef4deb87b46acb2c73fb3d88d84978d1b(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5e0a90952505978f8d9108fa3ae493dbcfa58be7c5834bf1503856a27c069363(
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__291ab83e5656eb5fc18eb3ff1fdb981eff5fb569f4e2692feb74452860897fc9(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f808f08fbccfed9fbbe711b84a6ea4fe24b0b8cd12997e77b0682ba882e63a5c(
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbdb2f512e7c99fb8f08f57dc7d53e124c7e79bdc207305d0ea870678b91cbad(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    config_read_throttle_events_alarm: typing.Union[DynamoDbReadThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_system_errors_alarm: typing.Union[DynamoDbSystemErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_write_throttle_events_alarm: typing.Union[DynamoDbWriteThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_age_of_oldest_unreplicated_record_alarm: typing.Optional[typing.Union[DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_failed_to_replicate_record_count_alarm: typing.Optional[typing.Union[DynamoDbFailedToReplicateRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_throttled_put_record_count_alarm: typing.Optional[typing.Union[DynamoDbThrottledPutRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[DynamoDbRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__35747c8203fdd27d31c00ee6e1505bc8142f48c425fe19ca5a4ccf4146c124d9(
    *,
    config_read_throttle_events_alarm: typing.Union[DynamoDbReadThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_system_errors_alarm: typing.Union[DynamoDbSystemErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_write_throttle_events_alarm: typing.Union[DynamoDbWriteThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_age_of_oldest_unreplicated_record_alarm: typing.Optional[typing.Union[DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_failed_to_replicate_record_count_alarm: typing.Optional[typing.Union[DynamoDbFailedToReplicateRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_throttled_put_record_count_alarm: typing.Optional[typing.Union[DynamoDbThrottledPutRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[DynamoDbRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7ffd2cd3e384b02323fc23eb8159d35a37f55c38040e5610ba1e04be2f6570b(
    *,
    config_read_throttle_events_alarm: typing.Union[DynamoDbReadThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_system_errors_alarm: typing.Union[DynamoDbSystemErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_write_throttle_events_alarm: typing.Union[DynamoDbWriteThrottleEventsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_age_of_oldest_unreplicated_record_alarm: typing.Optional[typing.Union[DynamoDbAgeOfOldestUnreplicatedRecordAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_failed_to_replicate_record_count_alarm: typing.Optional[typing.Union[DynamoDbFailedToReplicateRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_throttled_put_record_count_alarm: typing.Optional[typing.Union[DynamoDbThrottledPutRecordCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[DynamoDbRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7c6b993d5e6de67c32e464285de758149285264db80bb0d4f94678eb98a5dcab(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b0a93b48307aca9b03b0572a4085c43ec1cc5a5c3c0d86a36dadee8a0c65a54(
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e3a926e71921855a62486b6da786928f86b9d386ec5b56da64ab1259e0b96f29(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b89a3d002025bfe8192cda2bae15fc67656bd831f5a1c3962321a17b4b468d8(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c58ba20dc0b9e0663ab063b6621e22550cc70b8f9f3908795cd0d3cafdaf748b(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87b013ab3fefd956673cc58c761062c54f6338bbe503be161bb3fcbe6fc20d7f(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2acfee6bf8bc47cc16e22eb9e742c07f1dbfe468e105e152d0d2e2330e8db5d1(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__da69fedfa474f63777151900474d5b9b3bbbe274dbdc47b00df12932e6af223d(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51109f896f0b2aa1cd8b00cb3ed1cd101ec7a6f632b108181a1ff7e8302ff176(
    *,
    instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a192e90bcfeb52ed8ea8767b96c9968ed722b4593e1b8fa9893c96c87b3420f(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0bd42a0901293e1b30a68755e84d60cb6bfaced6fd1d3e4173af577dd49bafe1(
    *,
    instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0360502e32c49c2ce7682a7119762b8eefd7c8269c94215b35572e7f30572ce5(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
    config_cpu_utilization_alarm: typing.Optional[typing.Union[Ec2CpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_status_check_failed_alarm: typing.Optional[typing.Union[Ec2StatusCheckFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[Ec2RecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ddcf5625916efb6d352d9f1dd8342c33940ae561c3553dbe33f970cf9e00d09(
    *,
    config_cpu_utilization_alarm: typing.Optional[typing.Union[Ec2CpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_status_check_failed_alarm: typing.Optional[typing.Union[Ec2StatusCheckFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[Ec2RecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87f3897346b11f7f5083dc18346ba5c114ba26d48ca2c77100ae9016ad3fb6cc(
    *,
    config_cpu_utilization_alarm: typing.Optional[typing.Union[Ec2CpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_status_check_failed_alarm: typing.Optional[typing.Union[Ec2StatusCheckFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[Ec2RecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5516121dcab145bdbc42e4b31ddbc8dc71284ff14ba61b6ee15308c6c5313056(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a19b2d14b4bc32c186bd77f44b75461fda6b4cf63f779d16f6d9f8578b88c9a2(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74972eaf9be4c95dd2883750141bbbbcbaf0796242871063a2a6edb6456735ab(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__435cfc2d1cfde9c2203fe0daa10bcd3b41f7de25b559e11efef241dc9bc26922(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48324fe5e5b8daac5fbd26667cddfc678366e54992134e47206b10a34fab5b95(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1395f2f33e520892de58821ff0556cca8137d15dbd6ce7665ec7936fbc306ead(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2705f62db643ae90d66d170ae3c281bf6a34204a6d46765ee5882ba8050d20d1(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4beab2c93287f276fbcaf4a5218c27add48314583ce161890625081294689334(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a50f5604bbcf82d3ca8d6c6b332f24f921e0324fceb0f3c3bf99609d85fcc84(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3b6c6389510c4b5c6845eb21357a642c028a9ca2009848136d2d1438bbb09083(
    *,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1120b7c76e3542cfe4fcaa078948787170d8089ce3e967a17b31b977b29df724(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fa33f504adb615b68b32454b260c7cd0f2f3e56b305a7f752151437faa8aa3da(
    *,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2f3e2d84f095bf643f21bc6e3ee976c637c29b00aa2fe192d9a70fd4f37262f2(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d18209f00433f5a3e6c4b792b59560a561373182c22387db3ddc360d50a2ccde(
    *,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8661ecd7abbab2f17b094ec4f4dca9a8d1b3d3c91ef51fcc936bc6a1067dbb34(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f297f23a60726c901eab5af0c1269d648d2bd51563d95f6fab50e01adafcc597(
    *,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__724a213d96a78a28650ab2f88c23a32d8acc4e510ab175389fe19dfde7067b1d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
    config_ephemeral_storage_utilized_alarm: typing.Union[EcsEphemeralStorageUtilizedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[EcsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_memory_utilization_alarm: typing.Optional[typing.Union[EcsMemoryUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_running_task_count_alarm: typing.Optional[typing.Union[EcsRunningTaskCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[EcsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__96de4954f44195026f55eea03f2bf9f94ce48ca03a87d1ceb3b7e0562af66c36(
    *,
    config_ephemeral_storage_utilized_alarm: typing.Union[EcsEphemeralStorageUtilizedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[EcsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_memory_utilization_alarm: typing.Optional[typing.Union[EcsMemoryUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_running_task_count_alarm: typing.Optional[typing.Union[EcsRunningTaskCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[EcsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe69211690b966f8fe399214b1abfa3ee0f8e6e23a52e1e0c86e724d667261b5(
    *,
    config_ephemeral_storage_utilized_alarm: typing.Union[EcsEphemeralStorageUtilizedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[EcsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_memory_utilization_alarm: typing.Optional[typing.Union[EcsMemoryUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_running_task_count_alarm: typing.Optional[typing.Union[EcsRunningTaskCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[EcsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__65d769a09ddada5b86a816fdf76fa6e40b1e6948c9c25f105b126a90f3c88a3b(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__533c120ca79a560c491be2018ed62af66a6cfb05771c387e262af7fefa786787(
    *,
    service: _aws_cdk_aws_ecs_ceddda9d.FargateService,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ef76ba01d053c9a485c2342a9760eff63fe09a50b5347c65e20096a91b3214a(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a272ff765dac917db57580a5ee50999d563b95e06b6f478221f6127d622bd84(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ba59444e9f296288573427957ad8c2ffa01de4987e11c3fc3bf6bebb012aff55(
    *,
    file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4afc816ca557f0da7bcae39a7e4ecd7231af3dca2609be47c3b2fbd43baedd7(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4df10c3f676eabf19dd289788c7ac7a7ff09a1feb4a268ac4db29bffac3a872(
    *,
    file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__eed52f080dbf663706bf9635f310e07a61a918e8163f27b252f3eb8dbd3791ad(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cf7440c85270651772318b9debc5f85bcd8f547bca2241d8ab4566fa4d39d1d9(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
    config_burst_credit_balance_alarm: typing.Optional[typing.Union[EfsBurstCreditBalanceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_percent_io_limit_alarm: typing.Optional[typing.Union[EfsPercentIOLimitAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[EfsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e79ebeca62049ce971fc36abf56c94e42a78352bf516d7694767dfe454d1c61d(
    *,
    config_burst_credit_balance_alarm: typing.Optional[typing.Union[EfsBurstCreditBalanceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_percent_io_limit_alarm: typing.Optional[typing.Union[EfsPercentIOLimitAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[EfsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f441685864da7a9749a71ceb7f25f5934fa568544256ccd656a18f4bd6618c1(
    *,
    config_burst_credit_balance_alarm: typing.Optional[typing.Union[EfsBurstCreditBalanceAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_percent_io_limit_alarm: typing.Optional[typing.Union[EfsPercentIOLimitAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[EfsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__99e4c0f308e1f2ee42b02f0e6f9fda43b65f43af5c7c8d7036399a6967c6b615(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a43c894e8d06fc4444207a26b40a6beb7a083725cf88fdabccd6db4c9c52649d(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f8536cc9a2a6711272f1ad7b7f883385a70f60edf232b235dc7d33c11990559(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e9689b396bdba25f39a440fe28ea746c5d3320a47e381dd4e7af3cf91d4c51f9(
    *,
    cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81ca50c2abaeb952d84142803af82654ac1f0245c5c300e59e61eb75673689e6(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__df3fa636514cc018599dc9eddfe511a4d43344935134aa7a6ed2da71248d26f7(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__992c9cd9515809dbe36303afb6cb722c430caf9c8047878fcb8c3f3fc88d955b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
    config_database_memory_usage_percentage_alarm: typing.Union[ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_replication_lag_alarm: typing.Union[ElastiCacheReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_engine_cpu_utilization_alarm: typing.Optional[typing.Union[ElastiCacheEngineCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ElastiCacheRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__adcf101bda44240579cdebd708e4750e654def35a484bf41c6f5b0bdaa8bd0cb(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b4239aabe2d3d85cd6e3c20d6cab4febd6741a2026326883425c0ff8cf8ebf84(
    *,
    config_database_memory_usage_percentage_alarm: typing.Union[ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_replication_lag_alarm: typing.Union[ElastiCacheReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_engine_cpu_utilization_alarm: typing.Optional[typing.Union[ElastiCacheEngineCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ElastiCacheRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c10c40110c98066726c626b1963f37da4625770d863088d10181176466a6610d(
    *,
    config_database_memory_usage_percentage_alarm: typing.Union[ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_replication_lag_alarm: typing.Union[ElastiCacheReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_engine_cpu_utilization_alarm: typing.Optional[typing.Union[ElastiCacheEngineCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ElastiCacheRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__734c09c05108f7b104ae5fcf19130b831e45f46b6927113af4237fe769e32930(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd3e64b7518214232a674845684344d9cb26789fec344c96c82c42aaa6960652(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__244c49ef4cee9e947d4a9d5c92eb17b4e19f71f78b1619f6250d0ce3460b93b9(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2dcc3c4ba7f5fd325b214c550c46c80f9db54d2f0b6d0210095f67ca59375af8(
    *,
    cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6436e491efc7cc84e780c19bf1aa069e11eca40983f454d9f07ebd0d9fd86101(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9649102b99a4eef0d967f15d8aae62a17592680121971f890c461c44b797eec0(
    *,
    cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cce02b0949579fd22d58a1bd7d4bf251578e331a530c197cb62e241af54720e5(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d072460c3c69608633b621bfc176d384f6852fbf6882a71ebb92effda24353b9(
    *,
    cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6778be5913fc3575a96b5e811675a4cca0ee4185b7a9fe905f05372d639b23b6(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
    config_database_memory_usage_percentage_alarm: typing.Union[ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_replication_lag_alarm: typing.Union[ElastiCacheReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_engine_cpu_utilization_alarm: typing.Optional[typing.Union[ElastiCacheEngineCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ElastiCacheRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f98def7f41e6788a9c9feef462a4a4dc002c4b1a314e4dfbdcbda2f753163f72(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dacc7a7a50c9083f6e577de2b328dd10aff5eaa0a740fd7cf8120cc8256a1cae(
    *,
    config_database_memory_usage_percentage_alarm: typing.Union[ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_replication_lag_alarm: typing.Union[ElastiCacheReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_engine_cpu_utilization_alarm: typing.Optional[typing.Union[ElastiCacheEngineCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ElastiCacheRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4901d4925a0e7dfde9a1eda23277c20746051b03baba9d17efb30c3046460e91(
    *,
    config_database_memory_usage_percentage_alarm: typing.Union[ElastiCacheDatabaseMemoryUsagePercentageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_replication_lag_alarm: typing.Union[ElastiCacheReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_engine_cpu_utilization_alarm: typing.Optional[typing.Union[ElastiCacheEngineCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[ElastiCacheRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__23785f2a0a27d7f49cd78c1bb124335276aca8e839174ca6154b628b14dd04e5(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4c8342630d0f7958814da4cbad3cff13ca5387a6004060a989ddf087242ebb3b(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a925b369fa7502a1278f860002de54ff34491bf2318e7394cdef10811ddedf00(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    task_definition: _aws_cdk_aws_ecs_ceddda9d.TaskDefinition,
    assign_public_ip: typing.Optional[builtins.bool] = None,
    availability_zone_rebalancing: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.AvailabilityZoneRebalancing] = None,
    platform_version: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.FargatePlatformVersion] = None,
    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    cluster: _aws_cdk_aws_ecs_ceddda9d.ICluster,
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ecs_ceddda9d.CapacityProviderStrategy, typing.Dict[builtins.str, typing.Any]]]] = None,
    circuit_breaker: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.DeploymentCircuitBreaker, typing.Dict[builtins.str, typing.Any]]] = None,
    cloud_map_options: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.CloudMapOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    deployment_alarms: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.DeploymentAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    deployment_controller: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.DeploymentController, typing.Dict[builtins.str, typing.Any]]] = None,
    desired_count: typing.Optional[jsii.Number] = None,
    enable_ecs_managed_tags: typing.Optional[builtins.bool] = None,
    enable_execute_command: typing.Optional[builtins.bool] = None,
    health_check_grace_period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    max_healthy_percent: typing.Optional[jsii.Number] = None,
    min_healthy_percent: typing.Optional[jsii.Number] = None,
    propagate_tags: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.PropagatedTagSource] = None,
    service_connect_configuration: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.ServiceConnectProps, typing.Dict[builtins.str, typing.Any]]] = None,
    service_name: typing.Optional[builtins.str] = None,
    task_definition_revision: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.TaskDefinitionRevision] = None,
    volume_configurations: typing.Optional[typing.Sequence[_aws_cdk_aws_ecs_ceddda9d.ServiceManagedVolume]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__384fdb3a399ee5975ce3e6efdf8b8fa9562e3b74d41f06b276e3d10bcf50f833(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    allow_anonymous_access: typing.Optional[builtins.bool] = None,
    enable_automatic_backups: typing.Optional[builtins.bool] = None,
    encrypted: typing.Optional[builtins.bool] = None,
    file_system_name: typing.Optional[builtins.str] = None,
    file_system_policy: typing.Optional[_aws_cdk_aws_iam_ceddda9d.PolicyDocument] = None,
    kms_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    lifecycle_policy: typing.Optional[_aws_cdk_aws_efs_ceddda9d.LifecyclePolicy] = None,
    one_zone: typing.Optional[builtins.bool] = None,
    out_of_infrequent_access_policy: typing.Optional[_aws_cdk_aws_efs_ceddda9d.OutOfInfrequentAccessPolicy] = None,
    performance_mode: typing.Optional[_aws_cdk_aws_efs_ceddda9d.PerformanceMode] = None,
    provisioned_throughput_per_second: typing.Optional[_aws_cdk_ceddda9d.Size] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    replication_configuration: typing.Optional[_aws_cdk_aws_efs_ceddda9d.ReplicationConfiguration] = None,
    replication_overwrite_protection: typing.Optional[_aws_cdk_aws_efs_ceddda9d.ReplicationOverwriteProtection] = None,
    security_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup] = None,
    throughput_mode: typing.Optional[_aws_cdk_aws_efs_ceddda9d.ThroughputMode] = None,
    transition_to_archive_policy: typing.Optional[_aws_cdk_aws_efs_ceddda9d.LifecyclePolicy] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__300e1b7b513ed361a8dde12f23c6adb84738ebf013386259a5dbea5024022ffa(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    code: _aws_cdk_aws_lambda_ceddda9d.Code,
    handler: builtins.str,
    runtime: _aws_cdk_aws_lambda_ceddda9d.Runtime,
    adot_instrumentation: typing.Optional[typing.Union[_aws_cdk_aws_lambda_ceddda9d.AdotInstrumentationConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    allow_all_ipv6_outbound: typing.Optional[builtins.bool] = None,
    allow_all_outbound: typing.Optional[builtins.bool] = None,
    allow_public_subnet: typing.Optional[builtins.bool] = None,
    application_log_level: typing.Optional[builtins.str] = None,
    application_log_level_v2: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.ApplicationLogLevel] = None,
    architecture: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.Architecture] = None,
    code_signing_config: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.ICodeSigningConfig] = None,
    current_version_options: typing.Optional[typing.Union[_aws_cdk_aws_lambda_ceddda9d.VersionOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    dead_letter_queue: typing.Optional[_aws_cdk_aws_sqs_ceddda9d.IQueue] = None,
    dead_letter_queue_enabled: typing.Optional[builtins.bool] = None,
    dead_letter_topic: typing.Optional[_aws_cdk_aws_sns_ceddda9d.ITopic] = None,
    description: typing.Optional[builtins.str] = None,
    environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    environment_encryption: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    ephemeral_storage_size: typing.Optional[_aws_cdk_ceddda9d.Size] = None,
    events: typing.Optional[typing.Sequence[_aws_cdk_aws_lambda_ceddda9d.IEventSource]] = None,
    filesystem: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.FileSystem] = None,
    function_name: typing.Optional[builtins.str] = None,
    initial_policy: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.PolicyStatement]] = None,
    insights_version: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.LambdaInsightsVersion] = None,
    ipv6_allowed_for_dual_stack: typing.Optional[builtins.bool] = None,
    layers: typing.Optional[typing.Sequence[_aws_cdk_aws_lambda_ceddda9d.ILayerVersion]] = None,
    log_format: typing.Optional[builtins.str] = None,
    logging_format: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.LoggingFormat] = None,
    log_group: typing.Optional[_aws_cdk_aws_logs_ceddda9d.ILogGroup] = None,
    log_removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    log_retention: typing.Optional[_aws_cdk_aws_logs_ceddda9d.RetentionDays] = None,
    log_retention_retry_options: typing.Optional[typing.Union[_aws_cdk_aws_lambda_ceddda9d.LogRetentionRetryOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    log_retention_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    memory_size: typing.Optional[jsii.Number] = None,
    params_and_secrets: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.ParamsAndSecretsLayerVersion] = None,
    profiling: typing.Optional[builtins.bool] = None,
    profiling_group: typing.Optional[_aws_cdk_aws_codeguruprofiler_ceddda9d.IProfilingGroup] = None,
    recursive_loop: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.RecursiveLoop] = None,
    reserved_concurrent_executions: typing.Optional[jsii.Number] = None,
    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    runtime_management_mode: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.RuntimeManagementMode] = None,
    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
    snap_start: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.SnapStartConf] = None,
    system_log_level: typing.Optional[builtins.str] = None,
    system_log_level_v2: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.SystemLogLevel] = None,
    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    tracing: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.Tracing] = None,
    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    max_event_age: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    on_failure: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.IDestination] = None,
    on_success: typing.Optional[_aws_cdk_aws_lambda_ceddda9d.IDestination] = None,
    retry_attempts: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fe9b92d47374b9befb971a26f4d4dbe90f31098ac9851e1d6a2d80880b8939c7(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    instance_type: _aws_cdk_aws_ec2_ceddda9d.InstanceType,
    machine_image: _aws_cdk_aws_ec2_ceddda9d.IMachineImage,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    allow_all_ipv6_outbound: typing.Optional[builtins.bool] = None,
    allow_all_outbound: typing.Optional[builtins.bool] = None,
    associate_public_ip_address: typing.Optional[builtins.bool] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    block_devices: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ec2_ceddda9d.BlockDevice, typing.Dict[builtins.str, typing.Any]]]] = None,
    credit_specification: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.CpuCredits] = None,
    detailed_monitoring: typing.Optional[builtins.bool] = None,
    disable_api_termination: typing.Optional[builtins.bool] = None,
    ebs_optimized: typing.Optional[builtins.bool] = None,
    enclave_enabled: typing.Optional[builtins.bool] = None,
    hibernation_enabled: typing.Optional[builtins.bool] = None,
    init: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.CloudFormationInit] = None,
    init_options: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.ApplyCloudFormationInitOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    instance_initiated_shutdown_behavior: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.InstanceInitiatedShutdownBehavior] = None,
    instance_name: typing.Optional[builtins.str] = None,
    instance_profile: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IInstanceProfile] = None,
    ipv6_address_count: typing.Optional[jsii.Number] = None,
    key_name: typing.Optional[builtins.str] = None,
    key_pair: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IKeyPair] = None,
    placement_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IPlacementGroup] = None,
    private_ip_address: typing.Optional[builtins.str] = None,
    propagate_tags_to_volume_on_creation: typing.Optional[builtins.bool] = None,
    require_imdsv2: typing.Optional[builtins.bool] = None,
    resource_signal_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    security_group: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup] = None,
    source_dest_check: typing.Optional[builtins.bool] = None,
    ssm_session_permissions: typing.Optional[builtins.bool] = None,
    user_data: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.UserData] = None,
    user_data_causes_replacement: typing.Optional[builtins.bool] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dc0e1f097f03b2fa123e12d6dcd4c4ab950585fc2a1da7f2c3e4c5ba7aabc9ce(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    service: _aws_cdk_aws_ec2_ceddda9d.IInterfaceVpcEndpointService,
    dns_record_ip_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.VpcEndpointDnsRecordIpType] = None,
    ip_address_type: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.VpcEndpointIpAddressType] = None,
    lookup_supported_azs: typing.Optional[builtins.bool] = None,
    open: typing.Optional[builtins.bool] = None,
    private_dns_enabled: typing.Optional[builtins.bool] = None,
    private_dns_only_for_inbound_resolver_endpoint: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.VpcEndpointPrivateDnsOnlyForInboundResolverEndpoint] = None,
    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
    subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__716b419718f93d506f3a8f28e319b9f808eddee3d4641ebd195dccca8d474eec(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9bfb27966b8b66696e58f0cdca63f38b3e4abd2f029e1dcdd883870f471a74c7(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f6d24fc2ab7dcff701615e4987ae78b3dd173cefd3eb98f56fd3cd288d75b47(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d8926f47d763f0933cbd527860988a8a2749c891924dcd36c2f3f1e29039d6f(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e14f288432f1c93dade6ca87e081a4cf16901cbcbef6b7c783c411f561140323(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__16f9aa6367d9f62672010c74b9c77970e9a4ad803a8333d788aa6ea4f74dfb61(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c35e2842ae53ffd154b79e7db69c642434d4bb574cd771ed7bdc184108099771(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1f5d57bf581f2eea2bb19216346016a8105d14c7a16a9ac673410b280a87fc3a(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5a80f94cd00993ff5508c02a09a080a5e3dfe40d123f162a15591a81b8faf940(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__065075f4736ec308df17eee0d6a5100064d7a899d094aeb4533fdde663ffc607(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__27101909e8d5207062982ebba2ceaa835aa71fc168b8d767b66d1a5c1a11d99b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
    config_duration_alarm: typing.Union[LambdaDurationAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_errors_alarm: typing.Union[LambdaErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_throttles_alarm: typing.Union[LambdaThrottlesAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_concurrent_executions_alarm: typing.Optional[typing.Union[LambdaConcurrentExecutionsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[LambdaRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ac98314bcd4923aabdf6919cacbc99fe09b02e5eba9973007f013c04c677d9e(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0cd52c68a63a1358db1966d2a14b5e03f18458ff71753842a0c469174dd15066(
    *,
    config_duration_alarm: typing.Union[LambdaDurationAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_errors_alarm: typing.Union[LambdaErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_throttles_alarm: typing.Union[LambdaThrottlesAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_concurrent_executions_alarm: typing.Optional[typing.Union[LambdaConcurrentExecutionsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[LambdaRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2028de2c7bc54f62581b4499458b79fb36fb2c32306e074814ca31178c7a120(
    *,
    config_duration_alarm: typing.Union[LambdaDurationAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_errors_alarm: typing.Union[LambdaErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_throttles_alarm: typing.Union[LambdaThrottlesAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_concurrent_executions_alarm: typing.Optional[typing.Union[LambdaConcurrentExecutionsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[LambdaRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__488351c06ad0ced06f68b654c629b883306654b7e2b923062e130cd249a4ad16(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73e2fd37e074d8437164ecec0a7146e6185d991ab6cce0ab1f03a6d551db8a84(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6e1cacf0523a9e7229f0a95e8fd3bb47e8e7bceca45491724237db0109dd5b93(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    lambda_function: _aws_cdk_aws_lambda_ceddda9d.IFunction,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__874e9ac8bfe6b4390ce3de1ea0547a4b95e0deaa39bde80303f049200372a208(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    client_routing_policy: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.ClientRoutingPolicy] = None,
    enable_prefix_for_ipv6_source_nat: typing.Optional[builtins.bool] = None,
    enforce_security_group_inbound_rules_on_private_link_traffic: typing.Optional[builtins.bool] = None,
    ip_address_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.IpAddressType] = None,
    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
    subnet_mappings: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.SubnetMapping, typing.Dict[builtins.str, typing.Any]]]] = None,
    zonal_shift: typing.Optional[builtins.bool] = None,
    vpc: _aws_cdk_aws_ec2_ceddda9d.IVpc,
    cross_zone_enabled: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    deny_all_igw_traffic: typing.Optional[builtins.bool] = None,
    internet_facing: typing.Optional[builtins.bool] = None,
    load_balancer_name: typing.Optional[builtins.str] = None,
    minimum_capacity_unit: typing.Optional[jsii.Number] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0515ec7baa9a97e7fe9dca5f5fb09c4ccd2f756be846c83a08b945f926c79991(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a042005463fef364a5f88c76af00084ea1545130546ffbfa88720e8d7a5a30ff(
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d65070d625da4f4f5bd8bbb6a934e43bc1eead3d7256fc7bce8dadf7fb9e3ba9(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
    config_tcp_elb_reset_count_alarm: typing.Optional[typing.Union[NetworkLoadBalancerTcpElbResetCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_tcp_target_reset_count_alarm: typing.Optional[typing.Union[NetworkLoadBalancerTcpTargetResetCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[NetworkLoadBalancerRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1db9f286784a34f19abe8e6d579bab5004c193dd611df480072819f96cbe24bd(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e6f19bb799f2b45f402b4b1db18463c0fdd741831880cac23bd2976ed7ccfd59(
    *,
    config_tcp_elb_reset_count_alarm: typing.Optional[typing.Union[NetworkLoadBalancerTcpElbResetCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_tcp_target_reset_count_alarm: typing.Optional[typing.Union[NetworkLoadBalancerTcpTargetResetCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[NetworkLoadBalancerRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c20735cdb328f14217da067af2cbd56f7eea52a6416a904ef77e6b9e3f950ba9(
    *,
    config_tcp_elb_reset_count_alarm: typing.Optional[typing.Union[NetworkLoadBalancerTcpElbResetCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_tcp_target_reset_count_alarm: typing.Optional[typing.Union[NetworkLoadBalancerTcpTargetResetCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[NetworkLoadBalancerRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab43ec376817ab515b876d1b7f25cf2c60b7fe8d81b1acfcc894580e87bbdafe(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__41e8b925eece3dd92773a65de87f89ba82cc955bd301ee53994c41145aa1d661(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48192b1f47fd7069ea7cb2570e07a605b5b4babc55ac3775b7bbc07d5f37fa65(
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0a76efa5d158d5895364ed3746b7368fdeb34e34bada265019b3249248ff7bc8(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8da4f13d68355310c54154c754f80672835a1bbe422124b6501860e62f850f50(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ae6c36fc4b83d6eb07e7b90c83534a4f2b6edd09f188cad8a92f686641fb9cd1(
    *,
    load_balancer: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkLoadBalancer,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__627d81e1a6674ec72062a0ab3ca6a35a9653340ccfcbe1696a77d86472d6eb43(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    port: jsii.Number,
    connection_termination: typing.Optional[builtins.bool] = None,
    preserve_client_ip: typing.Optional[builtins.bool] = None,
    protocol: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.Protocol] = None,
    proxy_protocol_v2: typing.Optional[builtins.bool] = None,
    targets: typing.Optional[typing.Sequence[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.INetworkLoadBalancerTarget]] = None,
    cross_zone_enabled: typing.Optional[builtins.bool] = None,
    deregistration_delay: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    health_check: typing.Optional[typing.Union[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.HealthCheck, typing.Dict[builtins.str, typing.Any]]] = None,
    ip_address_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.TargetGroupIpAddressType] = None,
    target_group_name: typing.Optional[builtins.str] = None,
    target_type: typing.Optional[_aws_cdk_aws_elasticloadbalancingv2_ceddda9d.TargetType] = None,
    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8d61a24f86c919c4efda6399e4c6de688c683bbc631c225d31afb4727051e304(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__94ea805edd5c2534fca28e7747f63a6fdd8388c96342e5cf391e26fdd2552b2b(
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d4e4c83d2335cae7725bc362c38102a05363a5f3158734f62a68d91c68d5f9ce(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1aa11b231c6b8b433836d1fc73c0ef765dd1329c2f8a3bb14eabf1520d2e3d21(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__857fe8dcb085f183a8d4602e51f88041d7882252de61f7fabb1baa8a04e7453a(
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__60ea91e825b25cd9eed9bb40d155812dc0a8bd73008214a67c25f16d41aa268a(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
    config_healthy_host_count_alarm: typing.Optional[typing.Union[NetworkTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_un_healthy_host_count_alarm: typing.Optional[typing.Union[NetworkTargetGroupUnHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[NetworkTargetGroupRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab884658252b1f82046d44ffa0176382e35c5307b0dfa633905a7e952412ad5f(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a40c85d5c69c0d5aa4357ad525b38c0e9ac7f00ccaa6498fc475cfe0dc8d0222(
    *,
    config_healthy_host_count_alarm: typing.Optional[typing.Union[NetworkTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_un_healthy_host_count_alarm: typing.Optional[typing.Union[NetworkTargetGroupUnHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[NetworkTargetGroupRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8fc4e40c8e0cc44d2fb42c90e36c26093379cc0534cb6c6d592475b3898bc6c7(
    *,
    config_healthy_host_count_alarm: typing.Optional[typing.Union[NetworkTargetGroupHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_un_healthy_host_count_alarm: typing.Optional[typing.Union[NetworkTargetGroupUnHealthyHostCountAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[NetworkTargetGroupRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f500a18e915524270f3ec1ba216ee7b9e0e53a790757c455ae4f524ae0ff2222(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1b0eda90b1fc39f4e834c835cfd0f264fdab83c0f820e4a067fd0998f38aef4(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a4c5f589e445ce03d110a99a0c78d6c8ebdeb189355a52f66a19b753d7ca9de7(
    *,
    target_group: _aws_cdk_aws_elasticloadbalancingv2_ceddda9d.NetworkTargetGroup,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6f8fcb8114f64470dce03d9b1f591def295af76f6ac26e5d96480a752b81da6b(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e7c32932c91a0c292e091c8aa6b3ea109446b4ee649ff43bc92bf9314b5302ef(
    *,
    endpoint: _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
    endpoint_type: builtins.str,
    service_name: builtins.str,
    subnet_id: builtins.str,
    vpc_id: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e29234a4677469008bb4721aa92dd359e80b705446ae051d7b6df69797343916(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    endpoint: _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
    endpoint_type: builtins.str,
    service_name: builtins.str,
    subnet_id: builtins.str,
    vpc_id: builtins.str,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    subnets: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISubnet]] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70f23ef143484cf34dcd626e20c76473e0163abac0017f968f70a1306d459034(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    endpoint: _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
    config_packets_dropped_alarm: typing.Union[PrivateLinkEndpointsPacketsDroppedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[PrivateLinkEndpointsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68e9f6cc3de404c6c67539b37f29edca951989c0e4ad916dd9a1847c092ad4d0(
    *,
    config_packets_dropped_alarm: typing.Union[PrivateLinkEndpointsPacketsDroppedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[PrivateLinkEndpointsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__258cca477637122d9e8e211bfc918fa1819149ccb9e2f2a76fa2bc8fb6e88441(
    *,
    config_packets_dropped_alarm: typing.Union[PrivateLinkEndpointsPacketsDroppedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[PrivateLinkEndpointsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    endpoint: _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7ab04c8ace04a70ddc839d55ba7a4228c4e2af3a687ba238e6af0fccc601e839(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    endpoint_type: builtins.str,
    service_name: builtins.str,
    threshold: jsii.Number,
    vpc_id: builtins.str,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    subnets: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISubnet]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__28fb5e837383b87c0fd59c2f26d66fccdfc47923790080f20192aa8e7987f01c(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__87d96e717cd760d7a134135b669a2d2cb8499bf3a643f3112bbcfea819d758aa(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    load_balancer_arn: builtins.str,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    azs: typing.Optional[typing.Sequence[builtins.str]] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4445156337e0b40c4735e7371802327b96c89c83740aa2f95b310d2871d43833(
    *,
    az: builtins.str,
    endpoint_service: _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
    load_balancer_arn: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f45bc6941dfbe09c6f25f7ca0e103741be8ad01250d07c3c375b9c7ceb6c7a9b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    endpoint_service: _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
    config_rst_packets_sent_alarm: typing.Union[PrivateLinkServicesRstPacketsSentAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[PrivateLinkServicesRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2e62f6e1d73cea5a6314c95b51263b3361b816d11e5c77804cee2481d5d48ce8(
    *,
    config_rst_packets_sent_alarm: typing.Union[PrivateLinkServicesRstPacketsSentAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[PrivateLinkServicesRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4f4f497e9997b54f313169cb2a212ddde1ef63d15d806faad75b911a9df9c6b4(
    *,
    config_rst_packets_sent_alarm: typing.Union[PrivateLinkServicesRstPacketsSentAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[PrivateLinkServicesRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    endpoint_service: _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__22106faffa1b0234d2dd3516fd6649502e4c1da5c7be82d11173d45536e56828(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    az: builtins.str,
    endpoint_service: _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
    load_balancer_arn: builtins.str,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    azs: typing.Optional[typing.Sequence[builtins.str]] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bedb6bd45a3c1c50bed606dd1f038a50f2048d17655306e6b21c1bb05d4e3d31(
    *,
    az: builtins.str,
    endpoint_service: _aws_cdk_aws_ec2_ceddda9d.VpcEndpointService,
    load_balancer_arn: builtins.str,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    azs: typing.Optional[typing.Sequence[builtins.str]] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e63632b9287782cde140e2fa25c2d500852c1e3fdad4c8d2118b305c4ebd894d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    content_based_deduplication: typing.Optional[builtins.bool] = None,
    data_key_reuse: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    dead_letter_queue: typing.Optional[typing.Union[_aws_cdk_aws_sqs_ceddda9d.DeadLetterQueue, typing.Dict[builtins.str, typing.Any]]] = None,
    deduplication_scope: typing.Optional[_aws_cdk_aws_sqs_ceddda9d.DeduplicationScope] = None,
    delivery_delay: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    encryption: typing.Optional[_aws_cdk_aws_sqs_ceddda9d.QueueEncryption] = None,
    encryption_master_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    enforce_ssl: typing.Optional[builtins.bool] = None,
    fifo: typing.Optional[builtins.bool] = None,
    fifo_throughput_limit: typing.Optional[_aws_cdk_aws_sqs_ceddda9d.FifoThroughputLimit] = None,
    max_message_size_bytes: typing.Optional[jsii.Number] = None,
    queue_name: typing.Optional[builtins.str] = None,
    receive_message_wait_time: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    redrive_allow_policy: typing.Optional[typing.Union[_aws_cdk_aws_sqs_ceddda9d.RedriveAllowPolicy, typing.Dict[builtins.str, typing.Any]]] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    retention_period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    visibility_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2f0c9f06d3063631c0f0f381e5c5fe86873ce3f2d52c8b0482687567e0ab123(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8ae625b44a196c36eb59faf5ea9e1370fa81440d171558b0109a406cb17dfd9c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b52548f181557f32a37e5ffc6bf59d8e0f903d4fe3e9070e94cb6685b5a79462(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2b4bd72b075660e29961e9a35d0092b5e1486d45e33a4d77b0c4ed27bfd673ce(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36a65cf78dc54ad7efd28569350daee761511a0fc59da75eb9a13f1c03eb68b2(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
    config_aurora_bin_log_replication_lag_alarm: typing.Optional[typing.Union[RdsAuroraBinLogReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_aurora_volume_bytes_left_total_alarm: typing.Optional[typing.Union[RdsAuroraVolumeBytesLeftTotalAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_read_latency_alarm: typing.Union[RdsReadLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_write_latency_alarm: typing.Union[RdsWriteLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ea3c33057c551fe29704e0d1bdb6b0da0b489809f29c70cc912adab97b153841(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7cb015a0f2a148a3b92fbe5fa27d2e60c87b309aaae55b85f49e648cc22c0d29(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85330b777411eaa6bd19301419465a48e61bd9335dedb5c705cdf8f1cf816f09(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f18e3856858f568d2f5e4e03a7ab1e1ef51ebe53a0a56798e0b11062c78b5106(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__11064370710b7a12c4ca3b5dbc11d11742fab3b2928757058193bb9af080ad7b(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cd904878d77126a9943345dc77a0d050ed7d57d6b72ef057b604cec5fb116328(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ab2fa45170a79d2ce79eae19b901d3f4a55e9d72243e706a3f73b32862956335(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3779adad9c6233f0287a82355af3a9ef92980d5bbd00adba0d40502a16b5f328(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f4c25828b191532fd78e8fe00e3ef3866f6fcdfcff1476ab0924b93d297de28(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3f9352001ef4edd8dde95ab794f338b01f49a4775964b0a24481197424cf547d(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f856c8962a5dced29c4d9f95610231f694aac0a200cd784b02129a04a9bc9346(
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ccd4b2b9857d1e3f62fccf945625617c4b27995b3674edf455ee532d3db28b31(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5b76867ab0300177fee37a2434ec45a2f7255a7b8f78b438004aa3338c5237ff(
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__13b74b57eb858f4d3c9013c5a44aa658602aa43a29e79aa6ae7d4f6bd4fc03c1(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__424ad66e36b791e98505612be6b5f295e19b0e2d7cc2bc2c136c958862295cee(
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e8bbdd017b24da0137c9781dc3340e21b181b0d791d5529112316b31c6a539f8(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8caf758b3f402d44aa791c062f7963ced6487e358b7f86713ca8d77980dbc549(
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9c070ab270a5c4d3af61054452b623be2b812fe1081142410f97c9d71c2dd53e(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8f0e1dbeaa4b4f4374428dd9d68acbfdefca0ea516824428036800752f16c6bb(
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a2c452ff0baecdbab050dd920bb173f12f3b938cbf8c7841d0db12df34e0abbd(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd3d98903dfd1b9e0daa6b64e4d9e18c6986debabb15445ffc4d0004a88a2090(
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9acfd0592f5bbf27c262a24a54076955065f64d73ac8e6e60bc13a6b522b0a5d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__216ee8d8751dcf6df88d71c185ec14a3de98e53f1cd338e7d0c51fa591b4d9e6(
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d50eeda9644ca7e4584f0cae2bccf9b598d5d1a49e8201ed0b5fa5dbc20a3c3f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1b211ebf3783040f36dd40c0125e9888685bc3ca0097403392309653a39b362b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_read_latency_alarm: typing.Union[RdsReadLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_write_latency_alarm: typing.Union[RdsWriteLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d849723c72f0fe5d2475f9b0ac425270c7e53fd221dff1855afc357bdac7df27(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dfbac622217ae23c7bdc626b30f927496a8637475dc6499db45343e9ac41148c(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__85c9318aa42634732b84705a471dfba43b191701d414a13b09dee6ab6d6fec32(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3419e18e5a8b513463ce39f2d9740d26444efc6a15f6813731950fdf75536d87(
    *,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd4ca204870767586c42288107b2401f85cfb742bc6f7227988af75f40b987e2(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c089713851f8f90249e8eb10526a74679042374ed0c194a9f4084ae41f83541b(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    replication_instance_class: builtins.str,
    allocated_storage: typing.Optional[jsii.Number] = None,
    allow_major_version_upgrade: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    auto_minor_version_upgrade: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    availability_zone: typing.Optional[builtins.str] = None,
    dns_name_servers: typing.Optional[builtins.str] = None,
    engine_version: typing.Optional[builtins.str] = None,
    kms_key_id: typing.Optional[builtins.str] = None,
    multi_az: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    network_type: typing.Optional[builtins.str] = None,
    preferred_maintenance_window: typing.Optional[builtins.str] = None,
    publicly_accessible: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    replication_instance_identifier: typing.Optional[builtins.str] = None,
    replication_subnet_group_identifier: typing.Optional[builtins.str] = None,
    resource_identifier: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    vpc_security_group_ids: typing.Optional[typing.Sequence[builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36768c7722e96eeb3e44eac0fd5128b954b5d3d67c145574fcf0e5c7b81f3fd3(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    replication_instance_identifier: builtins.str,
    migration_type: builtins.str,
    replication_instance_arn: builtins.str,
    source_endpoint_arn: builtins.str,
    table_mappings: builtins.str,
    target_endpoint_arn: builtins.str,
    cdc_start_position: typing.Optional[builtins.str] = None,
    cdc_start_time: typing.Optional[jsii.Number] = None,
    cdc_stop_position: typing.Optional[builtins.str] = None,
    replication_task_identifier: typing.Optional[builtins.str] = None,
    replication_task_settings: typing.Optional[builtins.str] = None,
    resource_identifier: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    task_data: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__264931e44c29455be9e6e4e7d6a48e1d87a96c9d7aa593f183a7947dd3d3d3d1(
    *,
    migration_type: builtins.str,
    replication_instance_arn: builtins.str,
    source_endpoint_arn: builtins.str,
    table_mappings: builtins.str,
    target_endpoint_arn: builtins.str,
    cdc_start_position: typing.Optional[builtins.str] = None,
    cdc_start_time: typing.Optional[jsii.Number] = None,
    cdc_stop_position: typing.Optional[builtins.str] = None,
    replication_task_identifier: typing.Optional[builtins.str] = None,
    replication_task_settings: typing.Optional[builtins.str] = None,
    resource_identifier: typing.Optional[builtins.str] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    task_data: typing.Optional[builtins.str] = None,
    replication_instance_identifier: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d2aeabda01e3b53e063d03be55fffeb13059b97f986baf1b3d0d180ef20005e6(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    cloud_watch_role: typing.Optional[builtins.bool] = None,
    cloud_watch_role_removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    deploy: typing.Optional[builtins.bool] = None,
    deploy_options: typing.Optional[typing.Union[_aws_cdk_aws_apigateway_ceddda9d.StageOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    description: typing.Optional[builtins.str] = None,
    disable_execute_api_endpoint: typing.Optional[builtins.bool] = None,
    domain_name: typing.Optional[typing.Union[_aws_cdk_aws_apigateway_ceddda9d.DomainNameOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    endpoint_configuration: typing.Optional[typing.Union[_aws_cdk_aws_apigateway_ceddda9d.EndpointConfiguration, typing.Dict[builtins.str, typing.Any]]] = None,
    endpoint_export_name: typing.Optional[builtins.str] = None,
    endpoint_types: typing.Optional[typing.Sequence[_aws_cdk_aws_apigateway_ceddda9d.EndpointType]] = None,
    fail_on_warnings: typing.Optional[builtins.bool] = None,
    parameters: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    policy: typing.Optional[_aws_cdk_aws_iam_ceddda9d.PolicyDocument] = None,
    rest_api_name: typing.Optional[builtins.str] = None,
    retain_deployments: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5145c360c3415cdde5a29a528c3d3bce79794f0947d78bca731a00768e8f89e5(
    props: typing.Sequence[typing.Union[ApiGatewayRestApiDetailedLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]]],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9d4f29388ca9807519ae0412e8634338d955302b834578576dc547f464049e6(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: typing.Optional[jsii.Number] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e32caa975316b8e881679f0e3ca0297c5c175dcc49fcb62b683c66bf9f5782bb(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: typing.Optional[jsii.Number] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c2fd29de3b481f2cfa00b9af24444e83bc204407864373f5dd40399adff9991d(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47bd74a1f4cc68aa49abcb9ddefc859f62a8d650ec660e1f1dc076405de12203(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
    config4xx_errors_alarm: typing.Optional[typing.Union[S3Bucket4xxErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config5xx_errors_alarm: typing.Optional[typing.Union[S3Bucket5xxErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[S3RecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__81cb56b973536fefe93bd8cdf5503a61b0f7a86c873b9ea667e56303d99c024b(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a54261617c599ef9e038be027b2446bed17b11cfdf8002aee30d2b71f6ea7868(
    *,
    config4xx_errors_alarm: typing.Optional[typing.Union[S3Bucket4xxErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config5xx_errors_alarm: typing.Optional[typing.Union[S3Bucket5xxErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[S3RecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bffe2626f56a0b42370556b496eae7b36c626ba33a4d8d3b6ee7cf6c6e78caeb(
    *,
    config4xx_errors_alarm: typing.Optional[typing.Union[S3Bucket4xxErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config5xx_errors_alarm: typing.Optional[typing.Union[S3Bucket5xxErrorsAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[S3RecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__66d865f305d7122fb5935c7fbc0759324302463befce7e670cd03e03120fbfe4(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__513ab9159140e995a2a69fd725c38191b82a9e2ff303888f3d29bbef42b4dc85(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9a52ea1e3e45dabc027956b755eb8370fbc9b0fa89ad1acfb58489dda8cf9627(
    *,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c21e18125d749306c3ebeee177cddfe4f037020046445fc6c15557df2d98e6ac(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__669f1335be35c6b597602733d81a73570ea27f1742caf3b92c1d1bbc13825f57(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0fde71b6806713dbe8039efea231f44aa4a2d8be3604e724d849903c4a6cefa0(
    *,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a652ae052d92cbe7924f6027b90b48e50ac071e422565f8a2eff174dda835bfc(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d7e6887e76506d2e1ae1b27c62735f92c991fdfe14a5a89b268235047486a629(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5437a5ddf7659c1b09f607e81ecdee898e68f8e9dd98dd250720df4b2b59c26b(
    *,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1af9afc85387ad2935d64783fa5c57721a579e9f10cee2f18d60afca6ca528e1(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b9efbac082d2a3142fab08e7a993d5edcf25ace3d060d909292aaab0f702350a(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__31982ff8d0e7df03482d17124a30d0a709178d1bbc6dd3402a61c4511d04627a(
    *,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d8d47b36874bc2b7376685c830b8e3686f3e26a1afaff2ec7ea31e6622ad3f20(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__79f04417113dfb22c780aac29b056cada8488e5b8493523829d046b9f9130540(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6bbc428c0299ecc897c8b6489e065900bca83c57a93f531af2218b73ae10f05a(
    *,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__97367f27f00e0f166d219763a3d0150535c031767ba0c63659dc61e3d8c388f7(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
    config_execution_time_alarm: typing.Union[SfStateMachineExecutionTimeAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_executions_failed_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_executions_timed_out_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsTimedOutAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_execution_throttled_alarm: typing.Optional[typing.Union[SfStateMachineExecutionThrottledAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[SfRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__cb25226c50759f4912961a3b998f0ee4cd7dabcd4d06e309c224c60db85ade46(
    *,
    config_execution_time_alarm: typing.Union[SfStateMachineExecutionTimeAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_executions_failed_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_executions_timed_out_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsTimedOutAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_execution_throttled_alarm: typing.Optional[typing.Union[SfStateMachineExecutionThrottledAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[SfRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7b95545985abdc365dd9deea0270b2fe0cf5210d9f06afa71915911c20831f99(
    *,
    config_execution_time_alarm: typing.Union[SfStateMachineExecutionTimeAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_executions_failed_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_executions_timed_out_alarm: typing.Optional[typing.Union[SfStateMachineExecutionsTimedOutAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_execution_throttled_alarm: typing.Optional[typing.Union[SfStateMachineExecutionThrottledAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[SfRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    state_machine: _aws_cdk_aws_stepfunctions_ceddda9d.StateMachine,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6357da9f37e3e6b457ad09023bb9b95a1d5a38c2f284fa206c1d1d7696f94317(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98752834db6066573e1bc3fdef96ce5810035499b582fbd50205da8ca10e443a(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__02d28bbf6430187b0f9eb1fb025b748f1a32141c7c491a091b9c54a910e6b18e(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fff028ea41836c29985adfc761cb4e4d9d91324dab443383b2985d7174500a19(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6373f947a105537f03e197d13ae190cc1b538074b51e0b7eccd8b7956fedc0f3(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b868a50184ae2ac664cf01403a36fff774472e3686b89e5367994e98b89b7193(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f42d7a4b791067bced9bc860e1f750a1ceba252cff97a6f74fd0c6a844a539e(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__170e0b0914195c00ff510974ac188dcdce904364b454920cfa694a9c41aea277(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__49e12faa9093bf4d0205ccf60bc9d460839db4afed6958548942f1f348123faa(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__892a2b84330c3cd2ff63a79b19f87b73eb88ccfb60ed575de749f562223b34f0(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__328952b7f137facf3708a3106b8d39dc7959798db5ba6df8bb7ee4ef4e058cfb(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__843a4ee9894a844d5695f53e1c878efbf75b200de41a577d4f371b236240f2e8(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d3739e80c1d6309d7906dad7d9e84785a3a83e15921d956349e5a35ee350151b(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43139b7affdf7f55134351c485459ce357015c4e7c697ae842d1c8d514b65565(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ec0121c20b9a0c13a285aa11cf4f02cfa52f0fa656d8e6a0359dce149cf04fcf(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__75001c0fbc3b728c4c377f661f9af34f7b2005073f8201f295eda55eecf79ff2(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8b0eb47a2c3fa8f34233ebb68267787d38ab91e5dbd2e593d54eb6b6833c21bb(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7144b6b471d3381a8a22ad7e1411624239d41faade4130e5d45a811d5546fe73(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__68a91c07dfcbd0aacb0e3c594d36678ba3a1e134a863504ce2a39c87c7da0221(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5333c0338ea3e3f055d2c8daafb1ec07493b232256425a8befa7dc813db863eb(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__62b63074ae7184f232bd0e5938c481c0494ea3e231fea4a6974e72aca3250ee9(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e2f1df38bb641261070fb8b92d0e55844593ac7973d092bf2fd4d6763627299e(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98630e12118de7c882d18933f387c3a322a8c8af12b4b511ecf7e03804a5775d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
    config_number_of_messages_published_alarm: typing.Union[SnsNumberOfMessagesPublishedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_number_of_notifications_delivered_alarm: typing.Union[SnsNumberOfNotificationsDeliveredAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_number_of_notifications_failed_alarm: typing.Union[SnsNumberOfNotificationsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_number_of_notifications_failed_to_redrive_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_notifications_filtered_out_invalid_attributes_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_notifications_filtered_out_invalid_message_body_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_notifications_redriven_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[SnsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__47c92495ab390db59ffeb1ec15eb639c4bda7f2e6fcc6ab00f48d384d9c0898d(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fecc7466425a3fd89d5693837b979038b44222e821924f36e33e1aea20e4236a(
    *,
    config_number_of_messages_published_alarm: typing.Union[SnsNumberOfMessagesPublishedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_number_of_notifications_delivered_alarm: typing.Union[SnsNumberOfNotificationsDeliveredAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_number_of_notifications_failed_alarm: typing.Union[SnsNumberOfNotificationsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_number_of_notifications_failed_to_redrive_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_notifications_filtered_out_invalid_attributes_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_notifications_filtered_out_invalid_message_body_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_notifications_redriven_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[SnsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__168fe991294b441d2405431f15f9275f6ff942b8e21e0e325a0459bc7773caf2(
    *,
    config_number_of_messages_published_alarm: typing.Union[SnsNumberOfMessagesPublishedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_number_of_notifications_delivered_alarm: typing.Union[SnsNumberOfNotificationsDeliveredAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_number_of_notifications_failed_alarm: typing.Union[SnsNumberOfNotificationsFailedAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_number_of_notifications_failed_to_redrive_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFailedToRedriveToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_notifications_filtered_out_invalid_attributes_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidAttributesAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_notifications_filtered_out_invalid_message_body_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsFilteredOutInvalidMessageBodyAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_notifications_redriven_to_dlq_alarm: typing.Optional[typing.Union[SnsNumberOfNotificationsRedrivenToDlqAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[SnsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    topic: _aws_cdk_aws_sns_ceddda9d.ITopic,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c20302d0dce277cc07fd49ad99fdc8325c29e5d392842004761577330967cdf9(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c269e40750c6097ce5a8155e6a89289661005b40532df53de2f6994ca311128c(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2aad26aa3cbe4aee8036df6b618af2e6ad6d3e4a19515aee9606ee50dd9af390(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__74ca6057ea5178302f3aef8ed4d21ecf4774c7eab9442af8f511543718ffcd83(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8815dfd941d4ca8bcecc45ab9b5be4fc29cb8548dfe235cadc57ffe548606090(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c35ed35809a4360f095271f551791be67f6ca04c5462fdaec844342d7ed06514(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9376fa81f847d50cbcd5a89d6f568da884875f0f5dae5fa27c75a88325d354eb(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8a9188694cd82c03a9454a0975930ea6195f10816b6b12711ce2f5521c048ecc(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9416ae2be0a787ae40fb821ebed1c680e9e73112ef095bf0b4590229ef4ce402(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8fb5bc4d73a65dccff1e81a21bd7c4c930f37e13143da72353844ec71b54e125(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c83cc6f93b61287db8574d8fe0172a074b7e233a8e19487d23a436aadfc46237(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a5a27b809a4469882ad8e6a5ad6df46efd97d656d0a63ccc9ef71906dc194139(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0793f6ef8158a82e9718505397a2f6f689150450cf683f7dc859408933d841e7(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    threshold: typing.Optional[jsii.Number] = None,
    queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__7a37434be382ee9bdf1fa47a726cbedf3dab305255578301f29d8d0427d0ed9d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
    config_approximate_age_of_oldest_message_alarm: typing.Union[SqsApproximateAgeOfOldestMessageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_approximate_number_of_messages_not_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesNotVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_approximate_number_of_messages_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_dlq_approximate_number_of_messages_visible_alarm: typing.Optional[typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_messages_sent_alarm: typing.Optional[typing.Union[SqsNumberOfMessagesSentAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    dlqs_get_full_recommended_alarms: typing.Optional[builtins.bool] = None,
    exclude_alarms: typing.Optional[typing.Sequence[SqsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f45c71a79fad93ee92684dc7ebe5ea477b90eedb43380589ebe7c41ecb444281(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__8c678fa9be1dcd6d4347df821d14deb2ed1343e6e74541d15ee2c5175544bc20(
    value: typing.List[builtins.str],
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e486874f28bb3264a44a71dba7087b0c891a7fb880e21b2c6a66b837f0a351a1(
    value: builtins.bool,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__407cc33cddff7246efd0e7d0b66c4c79e9d85a4263615880ce742c9bc4fc1820(
    *,
    config_approximate_age_of_oldest_message_alarm: typing.Union[SqsApproximateAgeOfOldestMessageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_approximate_number_of_messages_not_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesNotVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_approximate_number_of_messages_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_dlq_approximate_number_of_messages_visible_alarm: typing.Optional[typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_messages_sent_alarm: typing.Optional[typing.Union[SqsNumberOfMessagesSentAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    dlqs_get_full_recommended_alarms: typing.Optional[builtins.bool] = None,
    exclude_alarms: typing.Optional[typing.Sequence[SqsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__32e30f379dd47a0ddb371ae48cd5f2d74faa779b4377f94f691abc36732d99fc(
    *,
    config_approximate_age_of_oldest_message_alarm: typing.Union[SqsApproximateAgeOfOldestMessageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_approximate_number_of_messages_not_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesNotVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_approximate_number_of_messages_visible_alarm: typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_dlq_approximate_number_of_messages_visible_alarm: typing.Optional[typing.Union[SqsApproximateNumberOfMessagesVisibleAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_number_of_messages_sent_alarm: typing.Optional[typing.Union[SqsNumberOfMessagesSentAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    dlqs_get_full_recommended_alarms: typing.Optional[builtins.bool] = None,
    exclude_alarms: typing.Optional[typing.Sequence[SqsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    queue: _aws_cdk_aws_sqs_ceddda9d.IQueue,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c1488e71ddba9444ff382477fe0ab220c0f046bbe7f54454c01b2797376287e8(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    comment: typing.Optional[builtins.str] = None,
    definition: typing.Optional[_aws_cdk_aws_stepfunctions_ceddda9d.IChainable] = None,
    definition_body: typing.Optional[_aws_cdk_aws_stepfunctions_ceddda9d.DefinitionBody] = None,
    definition_substitutions: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    encryption_configuration: typing.Optional[_aws_cdk_aws_stepfunctions_ceddda9d.EncryptionConfiguration] = None,
    logs: typing.Optional[typing.Union[_aws_cdk_aws_stepfunctions_ceddda9d.LogOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    query_language: typing.Optional[_aws_cdk_aws_stepfunctions_ceddda9d.QueryLanguage] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    state_machine_name: typing.Optional[builtins.str] = None,
    state_machine_type: typing.Optional[_aws_cdk_aws_stepfunctions_ceddda9d.StateMachineType] = None,
    timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    tracing_enabled: typing.Optional[builtins.bool] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__664a9c0a874f8f8cd8b72ac0153f5e19d4b791dd65cb8b898f3d5f8b617ac83a(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    kinesis_precision_timestamp: typing.Optional[_aws_cdk_aws_dynamodb_ceddda9d.ApproximateCreationDateTimePrecision] = None,
    kinesis_stream: typing.Optional[_aws_cdk_aws_kinesis_ceddda9d.IStream] = None,
    table_name: typing.Optional[builtins.str] = None,
    billing_mode: typing.Optional[_aws_cdk_aws_dynamodb_ceddda9d.BillingMode] = None,
    contributor_insights_enabled: typing.Optional[builtins.bool] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    encryption: typing.Optional[_aws_cdk_aws_dynamodb_ceddda9d.TableEncryption] = None,
    encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    import_source: typing.Optional[typing.Union[_aws_cdk_aws_dynamodb_ceddda9d.ImportSourceSpecification, typing.Dict[builtins.str, typing.Any]]] = None,
    max_read_request_units: typing.Optional[jsii.Number] = None,
    max_write_request_units: typing.Optional[jsii.Number] = None,
    point_in_time_recovery: typing.Optional[builtins.bool] = None,
    point_in_time_recovery_specification: typing.Optional[typing.Union[_aws_cdk_aws_dynamodb_ceddda9d.PointInTimeRecoverySpecification, typing.Dict[builtins.str, typing.Any]]] = None,
    read_capacity: typing.Optional[jsii.Number] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    replica_removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    replication_regions: typing.Optional[typing.Sequence[builtins.str]] = None,
    replication_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    resource_policy: typing.Optional[_aws_cdk_aws_iam_ceddda9d.PolicyDocument] = None,
    stream: typing.Optional[_aws_cdk_aws_dynamodb_ceddda9d.StreamViewType] = None,
    table_class: typing.Optional[_aws_cdk_aws_dynamodb_ceddda9d.TableClass] = None,
    time_to_live_attribute: typing.Optional[builtins.str] = None,
    wait_for_replication_to_finish: typing.Optional[builtins.bool] = None,
    warm_throughput: typing.Optional[typing.Union[_aws_cdk_aws_dynamodb_ceddda9d.WarmThroughput, typing.Dict[builtins.str, typing.Any]]] = None,
    write_capacity: typing.Optional[jsii.Number] = None,
    partition_key: typing.Union[_aws_cdk_aws_dynamodb_ceddda9d.Attribute, typing.Dict[builtins.str, typing.Any]],
    sort_key: typing.Optional[typing.Union[_aws_cdk_aws_dynamodb_ceddda9d.Attribute, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__70e505f14a1afa0f6a7236955dba568672dc67b4c2ceacb436fde882a2d66c49(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    content_based_deduplication: typing.Optional[builtins.bool] = None,
    display_name: typing.Optional[builtins.str] = None,
    enforce_ssl: typing.Optional[builtins.bool] = None,
    fifo: typing.Optional[builtins.bool] = None,
    fifo_throughput_scope: typing.Optional[_aws_cdk_aws_sns_ceddda9d.FifoThroughputScope] = None,
    logging_configs: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_sns_ceddda9d.LoggingConfig, typing.Dict[builtins.str, typing.Any]]]] = None,
    master_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    message_retention_period_in_days: typing.Optional[jsii.Number] = None,
    signature_version: typing.Optional[builtins.str] = None,
    topic_name: typing.Optional[builtins.str] = None,
    tracing_config: typing.Optional[_aws_cdk_aws_sns_ceddda9d.TracingConfig] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9aff1dc734cefac7c53c37e39518798e6756b2ee6950403693f8ed549919fcf1(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    vpc_endpoint_service_load_balancers: typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.IVpcEndpointServiceLoadBalancer],
    acceptance_required: typing.Optional[builtins.bool] = None,
    allowed_principals: typing.Optional[typing.Sequence[_aws_cdk_aws_iam_ceddda9d.ArnPrincipal]] = None,
    allowed_regions: typing.Optional[typing.Sequence[builtins.str]] = None,
    contributor_insights: typing.Optional[builtins.bool] = None,
    supported_ip_address_types: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.IpAddressType]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__71cc4528f4654e83d1b4dc2a90096d0356c91685310092722027a36d0189f911(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a8d50a3f4d65cc339209d9b99ea4646ed1ff7e8ccf3269341560529e3d6585b8(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    customer_gateway_id: builtins.str,
    type: builtins.str,
    enable_acceleration: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    local_ipv4_network_cidr: typing.Optional[builtins.str] = None,
    local_ipv6_network_cidr: typing.Optional[builtins.str] = None,
    outside_ip_address_type: typing.Optional[builtins.str] = None,
    remote_ipv4_network_cidr: typing.Optional[builtins.str] = None,
    remote_ipv6_network_cidr: typing.Optional[builtins.str] = None,
    static_routes_only: typing.Optional[typing.Union[builtins.bool, _aws_cdk_ceddda9d.IResolvable]] = None,
    tags: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_ceddda9d.CfnTag, typing.Dict[builtins.str, typing.Any]]]] = None,
    transit_gateway_id: typing.Optional[builtins.str] = None,
    transport_transit_gateway_attachment_id: typing.Optional[builtins.str] = None,
    tunnel_inside_ip_version: typing.Optional[builtins.str] = None,
    vpn_gateway_id: typing.Optional[builtins.str] = None,
    vpn_tunnel_options_specifications: typing.Optional[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Sequence[typing.Union[_aws_cdk_ceddda9d.IResolvable, typing.Union[_aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection.VpnTunnelOptionsSpecificationProperty, typing.Dict[builtins.str, typing.Any]]]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e0b8c3310f917d3819bf2b78010f052d96ebd46b690cd1cf6741824595e30e42(
    *,
    vpn_connection: _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__64d6f016a04ac6217769664164322160eee7aab082a4a0bee6df7a78e9a0e034(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    vpn_connection: _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
    config_tunnel_state_alarm: typing.Optional[typing.Union[VpnTunnelStateAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[VpnRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__86d645e9faa36b9be6b632a0255e17e95f10afe1dd685f2c2d7689bc214b632d(
    *,
    config_tunnel_state_alarm: typing.Optional[typing.Union[VpnTunnelStateAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[VpnRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2eea57a58f5a3bf0e9a970d530b98886836cd9e7781dd9d779adc93223939b6f(
    *,
    config_tunnel_state_alarm: typing.Optional[typing.Union[VpnTunnelStateAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[VpnRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    vpn_connection: _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aaada650ca8bc3d15077cca07dcff38752d339b88a6fb052fb46c87121708a90(
    scope: _constructs_77d1e7e8.IConstruct,
    id: builtins.str,
    *,
    vpn_connection: _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3e9399e035a439b22cdb17c73504d44fd97fd7224321c312f4e2911ccb32ec5f(
    node: _constructs_77d1e7e8.IConstruct,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__43aa4128b80db6a4cfb8b8f947dd24a17914928d99c5ccd3edcd5ace69a1e249(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c42a6db4e9cc7b7514f67bbdb6b00049c42d9794121f4a4c7f7ff61acb11a6af(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__3a6a8b0d6dd7536abb15fe4726626a61ffd0b027b30d55ab6ef61777b10c2360(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__795a01868868981fcaacf11798c53c030c8d2f28785d4990e9c7cc5ec6070157(
    *,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__48227e9c87f0058e774d98bd2f009c8fde08a7280810c0b3c060595ccd03b410(
    *,
    api: _aws_cdk_aws_apigateway_ceddda9d.RestApi,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9157b059ccea61ff17ab492547ee8636697379e269766bb4aded19d9cda0841a(
    *,
    auto_scaling_group: _aws_cdk_aws_autoscaling_ceddda9d.AutoScalingGroup,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6c8c5ff5e7c2844bcf1c5d45f4493f50ec3267e8839854d2605212965d416869(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0f58a19ff3f4f857d89a603930dc32445d234f186866e8c823e2453416510682(
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__06894f95ad06c2efc2ac67a29130078f4259f45c856be072e661e8443b4e1dfe(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    function_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e80875639a198dc421ffc093725f52a9cb4d14a38ddb28ad178a959df65e20df(
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    function_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f4fb235bb1b4032f75af33b36700d43916361d2be7f99d95259cdff4531b482b(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    function_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__25e79a958cf26cc27370701d54e4c50f716d92329c11e6503f1abaa4bec9599c(
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    function_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a1c69e97db54744fefff7f85fc0b6fb6d2d7471b38e06c79d5c7bef808aee151(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    function_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__f9907e234cf8087c29c6a457699033018d6e5278d083b27b650852ed125db4a8(
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
    function_name: builtins.str,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__50c4b813330e543843cf0a2cd36da2462ea5958bf321939e822cdd934e73996f(
    *,
    distribution: _aws_cdk_aws_cloudfront_ceddda9d.Distribution,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__2906764d9aeabfae4d07ae06ac58fe269a1555b729a400645ab82607c5008b64(
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    std_devs: typing.Optional[jsii.Number] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    comparison_operator: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.ComparisonOperator] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dbe512c114a0598d43f25bd69a3b35067906b97c59ef14738ea2ad65d808bac9(
    *,
    replication_instance: _aws_cdk_aws_dms_ceddda9d.CfnReplicationInstance,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b0a860bd7f9eabbe3f99f7754f0107166a4032441cb20d2698c4d7efc48ea4a8(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__9f348f8b78a34083d95fe7e7df621441fa0bde91f2c6fc46b838da11e7b8f83e(
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98efecbd95f367374d4314f3a5a468d5dfffed68dc321f2ab0f27ed31008c4c9(
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__98da88178305cce5dbc06633d2b934d9ea7adb35424648c86fc6d217c4c9eccc(
    *,
    table: _aws_cdk_aws_dynamodb_ceddda9d.Table,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b33eba2c5ad4ba561b1c26f8bc71fefb78fc5741ff81d3654641260b9994141b(
    *,
    instance: _aws_cdk_aws_ec2_ceddda9d.Instance,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__08931903547dea16bff3263184394b49fb1f550cbe3a0da8fbf53312f5ea7144(
    *,
    file_system: _aws_cdk_aws_efs_ceddda9d.FileSystem,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1eb86189fd2410b545bda060312fc7d8d4328aa2d11687ace0843fb407cfe7dc(
    *,
    cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c0a19aec1269a335c7710e9debe18cb272fc11d853adcdb8455bf19946c75ad0(
    *,
    cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__6bacb9d6a2a0e5811a29c8afafe616efd3e9486c5d853fe1ee51a0288a821884(
    *,
    cache_cluster: _aws_cdk_aws_elasticache_ceddda9d.CfnCacheCluster,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__b73985d171d9bd90c38b1885632619bfa49461782b0b16b2ba76aa01ddd27899(
    *,
    cache_replication_group: _aws_cdk_aws_elasticache_ceddda9d.CfnReplicationGroup,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1c39cdc17e5d760eca4f81a609afea81c16937c48f2a8bb492c8b721818a6a69(
    *,
    endpoint: _aws_cdk_aws_ec2_ceddda9d.InterfaceVpcEndpoint,
    endpoint_type: builtins.str,
    service_name: builtins.str,
    subnet_id: builtins.str,
    vpc_id: builtins.str,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    subnets: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISubnet]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__beb18f34f2021412d98d34314718d66664fa027d213689ff6f0428261cc9a071(
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__e30b9328441cd94f01a1d615db5780f69ca0ca1af46f6a8a08e4a79ac1beebdc(
    *,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_read_latency_alarm: typing.Union[RdsReadLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_write_latency_alarm: typing.Union[RdsWriteLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__bd4d89a7589c4d9c1cf7355f265d70509d02ad61effc55d4cbb9a18bad7374fb(
    *,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_read_latency_alarm: typing.Union[RdsReadLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_write_latency_alarm: typing.Union[RdsWriteLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__0aa5f8fb9093ada52badeda4a61c6d8a7be4621dceffc9f90f256b103ee891fe(
    *,
    database_instance: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IDatabaseInstance] = None,
    instance_identifier: typing.Optional[builtins.str] = None,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: jsii.Number,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__d45cfb8defe415c756707cf35150f504c3ca42a23dece0314de672338d762779(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: typing.Optional[jsii.Number] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__42ecd95425c9d23d522911d78398932e1d8493d1db2971c7b392f778fbcdb03f(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: typing.Optional[jsii.Number] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1679196b0a9e5117c7a636cfb7f006fee301925d2a4605be64b230bdd8dd1a0a(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: typing.Optional[jsii.Number] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1804ab3695bf52f69bd745c3d4ab5e213eb7fb6b4cc260c31532a53abb2b3d7f(
    *,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    threshold: typing.Optional[jsii.Number] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    bucket: _aws_cdk_aws_s3_ceddda9d.IBucket,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__36a080b3ced5485b186a02c11eda8fb698e21b38bf5e471567f541ddeb2e1def(
    *,
    vpn_connection: _aws_cdk_aws_ec2_ceddda9d.CfnVPNConnection,
    alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    alarm_description: typing.Optional[builtins.str] = None,
    alarm_name: typing.Optional[builtins.str] = None,
    datapoints_to_alarm: typing.Optional[jsii.Number] = None,
    evaluation_periods: typing.Optional[jsii.Number] = None,
    threshold: typing.Optional[jsii.Number] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__a71dbce57fbd57d8a1ba34a788a96fd859f3325b1855297784cf40b2a1e37abe(
    *,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_read_latency_alarm: typing.Union[RdsReadLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_write_latency_alarm: typing.Union[RdsWriteLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_aurora_bin_log_replication_lag_alarm: typing.Optional[typing.Union[RdsAuroraBinLogReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_aurora_volume_bytes_left_total_alarm: typing.Optional[typing.Union[RdsAuroraVolumeBytesLeftTotalAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__03520ed9c6cccb284644107e0618ddcd022893247791a1f6732aff5f34120fb3(
    *,
    default_alarm_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_insufficient_data_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    default_ok_action: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.IAlarmAction] = None,
    exclude_alarms: typing.Optional[typing.Sequence[RdsRecommendedAlarmsMetrics]] = None,
    exclude_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    treat_missing_data: typing.Optional[_aws_cdk_aws_cloudwatch_ceddda9d.TreatMissingData] = None,
    config_database_connections_alarm: typing.Union[RdsDatabaseConnectionsAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_db_load_alarm: typing.Union[RdsDbLoadAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_freeable_memory_alarm: typing.Union[RdsFreeableMemoryAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_local_storage_alarm: typing.Union[RdsFreeLocalStorageAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_free_storage_space_alarm: typing.Union[RdsFreeStorageSpaceAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_read_latency_alarm: typing.Union[RdsReadLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_write_latency_alarm: typing.Union[RdsWriteLatencyAlarmConfig, typing.Dict[builtins.str, typing.Any]],
    config_cpu_utilization_alarm: typing.Optional[typing.Union[RdsCpuUtilizationAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_aurora_bin_log_replication_lag_alarm: typing.Optional[typing.Union[RdsAuroraBinLogReplicationLagAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    config_aurora_volume_bytes_left_total_alarm: typing.Optional[typing.Union[RdsAuroraVolumeBytesLeftTotalAlarmConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    database_cluster: _aws_cdk_aws_rds_ceddda9d.IDatabaseCluster,
) -> None:
    """Type checking stubs"""
    pass
