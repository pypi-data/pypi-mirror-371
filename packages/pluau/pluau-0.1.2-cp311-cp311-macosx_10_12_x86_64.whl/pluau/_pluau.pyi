# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing
from enum import Enum

class Buffer:
    ...

class Compiler:
    r"""
    Represents a Luau compiler that compiles Luau chunks into bytecode.
    
    Note: All pluau `Lua` instances have a default compiler set to compile Lua chunks.
    However you can create your own compiler with custom settings using this class.
    """
    def __new__(cls, optimization_level:builtins.int, debug_level:builtins.int, type_info_level:builtins.int, coverage_level:builtins.int) -> Compiler:
        r"""
        Constructs a new Compiler with the specified settings.
        
        # Arguments:
        - `optimization_level`: The optimization level for the Lua chunk (0 = no optimization, 1 = basic optimization, 2 = full optimization which may impact debugging).
        - `debug_level`: The debug level for the Lua chunk (0 = no debugging, 1 = line info + function names only, 2 = full debug info with locals+upvalues)
        - `type_info` (0 = native modules only, 1 = all modules)
        """
    def compile(self, source:builtins.str) -> builtins.list[builtins.int]:
        r"""
        Compiles a Lua source code string into bytecode.
        """

class Function:
    @property
    def pointer(self) -> builtins.int:
        r"""
        Returns the pointer to the Lua function value.
        
        This pointer cannot be converted back to a Lua function
        and is only useful for hashing and debugging.
        """
    def call(self, *args) -> builtins.list[None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer]:
        r"""
        Calls the Lua function with the provided arguments.
        """
    def __call__(self, *args) -> builtins.list[None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer]:
        r"""
        Syntactic sugar for Function.call(args)
        """
    def deep_clone(self) -> Function:
        r"""
        Returns a deep clone to a Lua-owned function
        
        If called on a Luau function, this method copies the function prototype and all its upvalues to the newly created function
        
        If called on a Python function, this method merely clones the function's handle
        """
    def environment(self) -> typing.Optional[Table]:
        r"""
        Returns the environment table of the Lua function
        
        Returns None if the function does not have an environment
        
        Python functions do not have an environment, so this will always return None
        """
    def set_environment(self, table:Table) -> None:
        r"""
        Sets the environment table of the Lua function
        
        This uses setfenv and will hence deoptimize your function. Consider using load_chunk's environment argument instead
        """
    def __eq__(self, other:Function) -> builtins.bool: ...
    def __repr__(self) -> builtins.str: ...

class LightUserData:
    @property
    def pointer(self) -> builtins.int:
        r"""
        Returns the pointer/address of the light userdata.
        """

class Lua:
    r"""
    Represents a Luau VM handle
    """
    def __new__(cls, stdlib:typing.Optional[builtins.int]=None) -> Lua:
        r"""
        Constructs a new Lua VM with an optional standard library set
        """
    def __repr__(self) -> builtins.str: ...
    def used_memory(self) -> builtins.int:
        r"""
        Returns the amount of memory used by the Lua VM
        """
    def memory_limit(self) -> builtins.int:
        r"""
        Returns the memory limit of the Lua VM
        """
    def set_memory_limit(self, limit:builtins.int) -> None:
        r"""
        Sets the memory limit for the Lua VM.
        """
    def sandbox(self, enabled:builtins.bool) -> None:
        r"""
        Enables or disables the sandbox mode for the Luau VM.
        
        This method, in particular:
        
        - Set all libraries to read-only
        - Set all builtin metatables to read-only
        - Set globals to read-only (and activates safeenv)
        - Setup local environment table that performs writes locally and proxies reads to the global environment.
        - Allow only count mode in collectgarbage function.
        
        Note that this is a Luau-specific feature.
        """
    def set_compiler(self, compiler:Compiler) -> None:
        r"""
        Sets the compiler to use
        """
    def create_string(self, value:String | builtins.str | bytes) -> String:
        r"""
        Creates a new Lua string
        """
    def create_function(self, callback:typing.Any) -> Function:
        r"""
        Creates a new Lua function
        """
    def current_thread(self) -> Thread:
        r"""
        Returns a handle to the active Thread.
        
        When using a Lua handle originating outside a callback. this will be the main Lua thread
        
        Within a callback, this will return a reference to the Lua thread that called the callback.
        """
    def set_type_metatable(self, type_:LuaType, metatable:typing.Optional[Table]) -> None:
        r"""
        Sets the metatable for a type
        
        # Arguments
        - `type`: The type to set the metatable for
        - `metatable`: The metatable to set
        """
    def set_registry_value(self, key:builtins.str, value:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> None:
        r"""
        Sets a value on the Lua registry with a given key name
        """
    def get_registry_value(self, key:builtins.str) -> None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer:
        r"""
        Gets a value from the Lua registry by key name
        """
    def globals(self) -> Table:
        r"""
        Returns the global environment table of the Lua VM
        """
    def set_globals(self, table:Table) -> None:
        r"""
        Sets the global environment table of the Lua VM
        Note that any existing Lua functions have cached global environment and will not see the changes made by this method.
        
        To update the environment for existing Lua functions, use Function.set_environment instead.
        """
    def set_interrupt(self, callback:typing.Any) -> None:
        r"""
        Sets an interrupt function that will periodically be called by Luau VM. The interrupt function will provide the callback VM as arguments and expects a VmState to be returned.
        
        Any Luau code is guaranteed to call this handler “eventually” (in practice this can happen at any function call or at any loop iteration).
        
        The provided interrupt function can error, and this error will be propagated through the Luau code that was executing at the time the interrupt was triggered.
        
        Also this can be used to implement continuous execution limits by instructing Luau VM to yield by returning VmState.Yield.
        """
    def remove_interrupt(self) -> None:
        r"""
        Removes the currently set interrupt function
        
        This is a no-op if no interrupt function was set.
        """
    def load_chunk(self, contents:String | builtins.str | bytes, name:typing.Optional[builtins.str]=None, env:typing.Optional[Table]=None, is_binary_chunk:typing.Optional[builtins.bool]=None, compiler:typing.Optional[Compiler]=None) -> Function:
        r"""
        Loads a luau chunk into a function
        """
    def create_table(self) -> Table:
        r"""
        Creates a table
        """
    def create_table_with_capacity(self, narr:builtins.int, nrec:builtins.int) -> Table:
        r"""
        Creates a table with `narr` being the capacity of the array part and `nrec` being the capacity of the hash part.
        """
    def create_thread(self, func:Function) -> Thread:
        r"""
        Creates a new Lua thread given its base Lua function
        
        Equivalent to ``coroutine.create(func)`` in Luau
        """
    def create_buffer(self, contents:String | builtins.str | bytes) -> Buffer:
        r"""
        Creates a new Luau buffer
        """
    def create_userdata(self, data:typing.Any, metatable:Table) -> UserData:
        r"""
        Creates a new Userdata given associated data and a metatable
        """
    def yield_with(self, *args) -> None:
        r"""
        Tells Lua to the currently running Lua thread once the ongoing callback returns.
        
        Any results from the ongoing callback will be ignored and the args passed to yield_with will instead be yielded
        """
    def weak(self) -> WeakLua:
        r"""
        Returns a weak reference to the Lua VM
        """
    def strong_count(self) -> builtins.int:
        r"""
        Returns the strong count of the Lua VM.
        
        Can be useful for debugging
        """
    def weak_count(self) -> builtins.int:
        r"""
        Returns the weak count of the Lua VM.
        
        Can be useful for debugging
        """

class String:
    r"""
    A handle to a Lua-owned string value.
    
    Can be created using Lua.create_string()
    
    Note: using a string once the Lua state has been closed will result in a exception.
    """
    @property
    def pointer(self) -> builtins.int:
        r"""
        Returns the pointer to the Lua string value.
        
        This pointer cannot be converted back to a Lua string
        and is only useful for hashing and debugging.
        """
    def as_bytes(self) -> typing.Any:
        r"""
        Returns the string value as a bytes
        """
    def as_bytes_with_nul(self) -> typing.Any:
        r"""
        Returns the string value as a bytes with the null terminator
        """
    def __len__(self) -> builtins.int:
        r"""
        Returns the string's length in bytes.
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __eq__(self, other:typing.Any) -> builtins.bool: ...

class Table:
    @property
    def empty(self) -> builtins.bool:
        r"""
        Returns true if the table is empty, without invoking any metamethods
        """
    @property
    def readonly(self) -> builtins.bool:
        r"""
        Returns if the table is readonly
        """
    @property
    def pointer(self) -> builtins.int:
        r"""
        Returns the pointer to the Lua table value.
        
        This pointer cannot be converted back to a Lua table
        and is only useful for hashing and debugging.
        """
    @readonly.setter
    def readonly(self, value: builtins.bool) -> None:
        r"""
        Sets the table to be readonly (or not)
        """
    def clear(self) -> None:
        r"""
        Clears the table, removing all keys and values from array and hash parts, without invoking metamethods.
        
        This method is useful to clear the table while keeping its capacity
        
        Internally invokes ``lua_cleartable``
        """
    def contains_key(self, key:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> builtins.bool:
        r"""
        Returns if the table contains a non-nil value for the specified key.
        
        Might invoke ``__index`` metamethod. Use raw_get if this is not desired
        """
    def equals(self, other:Table) -> builtins.bool:
        r"""
        Compares two tables for equality.
        
        Tables are compared by reference first. If they are not referentially equal, then pluau will try to invoke the __eq metamethod on `self`` first and then `other`` if not found.
        """
    def __eq__(self, other:Table) -> builtins.bool: ...
    def for_each(self, callback:typing.Any) -> None:
        r"""
        Iterates over the pairs of the table, invoking the given callback on each key-value pair.
        """
    def get(self, key:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer:
        r"""
        Gets the value associated to key from the table. Might invoke ``__index`` metamethod
        
        Also see ``raw_get`` which does the same thing as ``get`` without invoking metamethods
        """
    def raw_get(self, key:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer:
        r"""
        Gets the value associated to key from the table without invoking metamethods
        
        Also see ``get`` which does the same thing as ``raw_get`` while invoking ``__index`` metamethods
        """
    def len(self) -> builtins.int:
        r"""
        Returns the result of the Lua # operator. Might invoke the __len metamethod
        
        Use ``raw_len`` to get the length without invoking any metamethods
        """
    def raw_len(self) -> builtins.int:
        r"""
        Returns the result of the Lua # operator, without invoking the __len metamethod.
        """
    def __len__(self) -> builtins.int:
        r"""
        Same as ``Table.raw_len()``
        
        To invoke the ``__len`` metamethod. Use ``Table.len()`` instead
        """
    def set_safeenv(self, enabled:builtins.bool) -> None: ...
    def metatable(self) -> typing.Optional[Table]:
        r"""
        Returns the table's metatable (if there is any present)
        
        Ignores __metatable and other protections
        """
    def set_metatable(self, mt:typing.Optional[Table]) -> None:
        r"""
        Sets or removes a metable on this table
        """
    def pop(self) -> None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer:
        r"""
        Removes the last element from the table and returns it. Might invoke the __len and __newindex metamethods.
        
        Also see ``raw_pop`` which does the same thing as ``pop`` without invoking metamethods
        """
    def raw_pop(self) -> None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer:
        r"""
        Removes the last element from the table and returns it without invoking metamethods
        
        Also see ``pop`` which does the same thing as ``raw_pop`` while invoking metamethods
        """
    def push(self, value:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> None:
        r"""
        Appends a value to the back of the table. Might invoke the __len and __newindex metamethods.
        
        Also see ``raw_push`` which does the same thing as ``push`` without invoking metamethods
        """
    def raw_push(self, value:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> None:
        r"""
        Appends a value to the back of the table without invoking metamethods
        
        Also see ``push`` which does the same thing as ``raw_push`` while invoking metamethods
        """
    def insert(self, index:builtins.int, value:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> None:
        r"""
        Inserts element value at position idx to the table (without invoking metamethods), shifting up the elements from table[idx].
        
        The worst case complexity is O(n), where n is the table length.
        """
    def remove(self, key:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> None:
        r"""
        Removes a key from the table without invoking metamethods.
        
        If the key is an integer, all elements from table[key+1] will be shifted down.
        and table[key] will be removed with a worst case complexity of O(n),
        
        For non-integer keys, this is equivalent to a table[key] = nil operation,
        """
    def set(self, key:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer, value:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> None:
        r"""
        Sets a key-value pair (effectively removing the pair if value is nil). Might invoke ``__newindex`` metamethod
        
        Also see ``raw_set`` which does the same thing as ``set`` without invoking metamethods
        """
    def raw_set(self, key:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer, value:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> None:
        r"""
        Sets a key-value pair (effectively removing the pair if value is nil) without invoking metamethods
        
        Also see ``set`` which does the same thing as ``raw_set`` while invoking ``__newindex`` metamethods
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __iter__(self) -> TableIterOwned: ...

class TableIterOwned:
    r"""
    Non thread-safe iterator over table key-value pairs.
    
    Attempting to use this iterator from multiple threads will result in a panic.
    """
    def __iter__(self) -> TableIterOwned: ...
    def __next__(self) -> typing.Tuple[None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer, None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer]: ...

class Thread:
    @property
    def pointer(self) -> builtins.int:
        r"""
        Returns the pointer to the Lua thread value.
        
        This pointer cannot be converted back to a Lua thread
        and is only useful for hashing and debugging.
        """
    @property
    def status(self) -> ThreadState:
        r"""
        Returns the current status of the LuaThread
        """
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...
    def __eq__(self, other:Thread) -> builtins.bool:
        r"""
        Returns if two threads are equal by (Luau) reference
        """
    def sandbox(self) -> None:
        r"""
        Sandboxes a Luau thread
        
        Under the hood replaces the global environment table with a new table, that performs writes locally and proxies reads to caller's global environment.
        
        This mode ideally should be used together with the global sandbox mode (Lua.sandbox).
        
        Please note that Luau links environment table with chunk when loading it into Lua state. Therefore you need to load chunks into a thread to link with the thread environment.
        """
    def reset(self, func:Function) -> None: ...
    def resume(self, *args) -> builtins.list[None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer]:
        r"""
        Resume resumes a thread `th`
        
        Passes args as arguments to the thread. If the coroutine has called coroutine.yield, it will return these arguments. Otherwise, the coroutine wasn’t yet started, so the arguments are passed to its main function.
        
        If the thread is no longer resumable (meaning it has finished execution or encountered an error), this will return a coroutine unresumable error, otherwise will return as follows:
        If the thread is yielded via coroutine.yield or CallbackLua.YieldWith, returns the values passed to yield. If the thread returns values from its main function, returns those.
        """
    def resume_error(self, arg:None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer) -> builtins.list[None | builtins.bool | LightUserData | builtins.int | builtins.float | Vector | builtins.str | String | Table | Function | Thread | UserData | Buffer]: ...
    def close(self) -> None:
        r"""
        Closes a thread and marks it as finished, resetting it to the initial state of a newly created Lua thread regardless of current thread state.
        """
    def traceback(self) -> builtins.str:
        r"""
        Creates a traceback of the thread
        """

class UserData:
    @property
    def pointer(self) -> builtins.int:
        r"""
        Returns the pointer/address of the userdata.
        """
    def data(self) -> typing.Any:
        r"""
        Returns the underlying associated data of the userdata.
        
        Errors if the userdata does not contain associated data (did not originate from Python)
        """
    def metatable(self) -> Table:
        r"""
        Returns the underlying metatable of the userdata.
        """
    def __repr__(self) -> builtins.str: ...
    def __eq__(self, other:UserData) -> builtins.bool: ...

class Vector:
    @property
    def x(self) -> builtins.float: ...
    @property
    def y(self) -> builtins.float: ...
    @property
    def z(self) -> builtins.float: ...
    def __new__(cls, x:builtins.float, y:builtins.float, z:builtins.float) -> Vector:
        r"""
        Constructs a new vector
        """
    @staticmethod
    def zero() -> Vector: ...
    def __repr__(self) -> builtins.str: ...
    def __str__(self) -> builtins.str: ...

class WeakLua:
    r"""
    Provides a weak reference to a Lua VM
    """
    def upgrade(self) -> typing.Optional[Lua]:
        r"""
        Attempts to upgrade the weak reference to a strong reference.
        
        Returns None if the Lua VM has been garbage collected.
        """
    def strong_count(self) -> builtins.int:
        r"""
        Returns the strong count of the Lua VM.
        
        Mostly useful for debugging
        """
    def weak_count(self) -> builtins.int:
        r"""
        Returns the weak count of the Lua VM.
        
        Mostly useful for debugging
        """
    def is_destroyed(self) -> builtins.bool:
        r"""
        Returns if the Lua instance is destroyed.
        
        This is equivalent to checking if the strong count is `0`.
        """
    def __eq__(self, other:WeakLua) -> builtins.bool: ...

class LuaType(Enum):
    Boolean = ...
    LightUserData = ...
    Number = ...
    Vector = ...
    String = ...
    Function = ...
    Thread = ...
    Buffer = ...

class ThreadState(Enum):
    Resumable = ...
    r"""
    The thread was just created or is suspended (yielded).
    
    If a thread is in this state, it can be resumed by calling Thread.resume.
    """
    Running = ...
    r"""
    The thread is currently running.
    """
    Finished = ...
    r"""
    The thread has finished executing.
    """
    Error = ...
    r"""
    The thread has raised a Lua error during execution.
    """

class VmState(Enum):
    Continue = ...
    Yield = ...

class RawError(BaseException): ...

