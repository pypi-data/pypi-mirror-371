import asyncio
import os
from typing import Optional, List, Any
from datetime import datetime
from openai import AsyncOpenAI
from rich.console import Console
from rich.markdown import Markdown
from rich.prompt import Prompt
from rich.panel import Panel
from rich.table import Table
import json
import logging

from app.main import MemorgSystem
from app.models import SearchScope
from app.storage.sqlite_storage import SQLiteStorageAdapter
from app.vector_store.usearch_vector_store import USearchVectorStore

from dotenv import load_dotenv
load_dotenv()

logger = logging.getLogger(__name__)

class MemorgCLI:
    def __init__(self, api_key: str, db_path: str = "memorg.db"):
        self.console = Console()
        self.client = AsyncOpenAI(api_key=api_key)
        self.system = MemorgSystem(
            storage=SQLiteStorageAdapter(db_path),
            vector_store=USearchVectorStore(db_path),
            openai_client=self.client
        )
        self.current_session: Optional[str] = None
        self.current_conversation: Optional[str] = None
        self.current_topic: Optional[str] = None

    async def initialize_session(self):
        """Initialize or load an existing session."""
        if not self.current_session:
            session = await self.system.create_session(
                "cli_user",
                {"max_tokens": 4096}
            )
            self.current_session = session.id
            self.console.print(f"[green]Created new session: {session.id}[/green]")

    async def start_conversation(self):
        """Start a new conversation."""
        if not self.current_session:
            await self.initialize_session()
        
        conversation = await self.system.start_conversation(self.current_session)
        self.current_conversation = conversation.id
        self.console.print(f"[green]Started new conversation: {conversation.id}[/green]")

    async def create_topic(self, title: str):
        """Create a new topic in the current conversation."""
        if not self.current_conversation:
            await self.start_conversation()
        
        topic = await self.system.context_store.create_topic(
            self.current_conversation,
            title
        )
        self.current_topic = topic.id
        self.console.print(f"[green]Created new topic: {title}[/green]")

    async def chat(self):
        """Main chat loop."""
        self.console.print(Panel.fit(
            "[bold blue]Welcome to Memorg CLI Chat![/bold blue]\n"
            "Type 'help' for available commands or start chatting.",
            title="Memorg CLI"
        ))

        while True:
            try:
                user_input = Prompt.ask("\n[bold cyan]You[/bold cyan]")
                
                if user_input.lower() == 'exit':
                    break
                elif user_input.lower() == 'help':
                    self.show_help()
                    continue
                elif user_input.lower() == 'new':
                    await self.start_conversation()
                    continue
                elif user_input.lower() == 'search':
                    await self.handle_search()
                    continue
                elif user_input.lower() == 'memsearch':
                    await self.handle_memory_search()
                    continue
                elif user_input.lower() == 'addnote':
                    await self.handle_add_note()
                    continue
                elif user_input.lower() == 'memory':
                    await self.show_memory_usage()
                    continue

                # Ensure we have an active topic
                if not self.current_topic:
                    await self.create_topic("General Discussion")

                # Search for relevant context before processing the exchange
                search_results = await self.system.search_context(user_input)
                context = self.build_context_from_results(search_results)
                logger.info(f"Found relevant context for query: {user_input}\nContext:\n{context}")

                # Process the exchange
                exchange = await self.system.add_exchange(
                    self.current_topic,
                    user_input,
                    ""  # System message will be generated by the model
                )

                # Get AI response with context
                response = await self.get_ai_response(user_input, search_results if search_results else None)
                
                # Add the response to the exchange
                await self.system.add_exchange(
                    self.current_topic,
                    "",
                    response
                )

                # Display the response
                self.console.print("\n[bold green]AI[/bold green]")
                self.console.print(Markdown(response))

            except KeyboardInterrupt:
                self.console.print("\n[yellow]Use 'exit' to quit the chat[/yellow]")
            except Exception as e:
                self.console.print(f"[red]Error: {str(e)}[/red]")

    async def get_ai_response(self, message: str, context: Optional[List[Any]] = None) -> str:
        """Get response from OpenAI with context."""
        try:
            # Build message history
            messages = [
                {"role": "system", "content": "You are a helpful AI assistant that provides concise and accurate responses."}
            ]
            
            # Add context if provided
            if context:
                # Convert context items to a single string
                context_text = "\n\n".join([
                    item.content if hasattr(item, "content") else str(item)
                    for item in context
                ])
                
                # Extract entities from context
                entities = []
                for item in context:
                    if hasattr(item, "key_entities"):
                        entities.extend(item.key_entities)
                
                # Optimize the context using our window optimizer
                optimized = await self.system.window_optimizer.optimize_context(
                    content=context_text,
                    entities=entities,
                    max_tokens=8000  # Reduced from 32000 to leave more room for conversation
                )
                
                logger.info(f"Optimized context from {len(context_text)} to {len(optimized.content)} characters")
                messages.append({
                    "role": "system",
                    "content": f"Here is some relevant context:\n{optimized.content}"
                })
            
            # Add user message
            messages.append({"role": "user", "content": message})
              
            # Get response from OpenAI
            response = await self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=messages
            )
            
            # Get the response content
            content = response.choices[0].message.content.strip()
            if not content:
                raise ValueError("Empty response from OpenAI")
            
            return content
            
        except Exception as e:
            logger.error(f"Error getting AI response: {e}", exc_info=True)
            return "I apologize, but I encountered an error while processing your request. Please try again."

    def build_context_from_results(self, results: list) -> str:
        """Build context string from search results."""
        if not results:
            return ""

        context_parts = []
        for result in results:
            if hasattr(result, "entity"):
                entity = result.entity
                if hasattr(entity, "content"):
                    context_parts.append(f"- {entity.content}")
                elif hasattr(entity, "title"):
                    context_parts.append(f"- {entity.title}")

        return "\n".join(context_parts)

    async def handle_search(self):
        """Handle search command."""
        query = Prompt.ask("Enter search query")
        results = await self.system.search_context(query)
        
        if not results:
            self.console.print("[yellow]No results found[/yellow]")
            return

        table = Table(title="Search Results")
        table.add_column("Score", justify="right")
        table.add_column("Type")
        table.add_column("Content")

        for result in results:
            content = ""
            if hasattr(result.entity, "content"):
                content = result.entity.content
            elif hasattr(result.entity, "text_content"):
                content = result.entity.text_content
            elif hasattr(result.entity, "title"):
                content = result.entity.title

            table.add_row(
                f"{result.score:.2f}",
                result.match_type.value,
                content[:100] + "..." if len(content) > 100 else content
            )

        self.console.print(table)

    async def handle_memory_search(self):
        """Handle memory search command (searches all memory, not just conversations)."""
        query = Prompt.ask("Enter memory search query")
        results = await self.system.search_memory(query)
        
        if not results:
            self.console.print("[yellow]No results found[/yellow]")
            return

        table = Table(title="Memory Search Results")
        table.add_column("Score", justify="right")
        table.add_column("Type")
        table.add_column("Content")
        table.add_column("Tags")

        for result in results:
            content = getattr(result.item, "content", "")
            item_type = getattr(result.item, "type", "unknown")
            tags = getattr(result.item, "tags", [])
            
            # Format tags as a comma-separated string
            tags_str = ", ".join(tags) if tags else "None"

            table.add_row(
                f"{result.score:.2f}",
                str(item_type),
                content[:100] + "..." if len(content) > 100 else content,
                tags_str
            )

        self.console.print(table)

    async def handle_add_note(self):
        """Handle adding a custom note to memory."""
        content = Prompt.ask("Enter note content")
        tags_input = Prompt.ask("Enter tags (comma-separated, optional)", default="")
        tags = [tag.strip() for tag in tags_input.split(",") if tag.strip()]
        
        # Ensure we have a session
        if not self.current_session:
            await self.initialize_session()
            
        # Create a note using the new memory system
        note_item = await self.system.create_memory_item(
            content=content,
            item_type="note",
            parent_id=self.current_session,
            tags=tags
        )
        
        self.console.print(f"[green]Added note with ID: {note_item.id}[/green]")

    async def show_memory_usage(self):
        """Show current memory usage."""
        usage = await self.system.get_memory_usage()
        
        # Format sizes
        def format_size(size_bytes):
            for unit in ['B', 'KB', 'MB', 'GB']:
                if size_bytes < 1024:
                    return f"{size_bytes:.2f} {unit}"
                size_bytes /= 1024
            return f"{size_bytes:.2f} GB"
        
        self.console.print(Panel.fit(
            f"Memory Usage:\n"
            f"Total Tokens: {usage.get('total_tokens', 0):,}\n"
            f"Active Items: {usage.get('active_items', 0):,}\n"
            f"Compressed Items: {usage.get('compressed_items', 0):,}\n"
            f"Vector Count: {usage.get('vector_count', 0):,}\n"
            f"Index Size: {format_size(usage.get('index_size', 0))}",
            title="Memory Status"
        ))

    def show_help(self):
        """Show available commands."""
        help_text = """
        Available Commands:
        - help: Show this help message
        - new: Start a new conversation
        - search: Search through conversation history
        - memory: Show memory usage statistics
        - memsearch: Search through all memory (not just conversations)
        - addnote: Add a custom note to memory
        - exit: Exit the chat
        """
        self.console.print(Panel.fit(help_text, title="Help"))

async def main():
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        print("Please set OPENAI_API_KEY environment variable")
        return

    cli = MemorgCLI(api_key)
    await cli.chat()

if __name__ == "__main__":
    asyncio.run(main()) 