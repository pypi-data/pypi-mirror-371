"""
Parsers provided by aiida_skeaf.

Register parsers via the "aiida.parsers" entry point in setup.json.
"""
import re
import typing as ty

import numpy as np

from aiida import orm
from aiida.common import exceptions
from aiida.engine import ExitCode
from aiida.parsers.parser import Parser
from aiida.plugins import CalculationFactory

SkeafCalculation = CalculationFactory("skeaf.skeaf")


class SkeafParser(Parser):
    """
    Parser class for parsing output of calculation.
    """

    def __init__(self, node):
        """
        Initialize Parser instance

        Checks that the ProcessNode being passed was produced by a SkeafCalculation.

        :param node: ProcessNode of calculation
        :param type node: :class:`aiida.orm.ProcessNode`
        """
        super().__init__(node)
        if not issubclass(node.process_class, SkeafCalculation):
            raise exceptions.ParsingError("Can only parse SkeafCalculation")

    def parse(self, **kwargs):
        """
        Parse outputs, store results in database.

        :returns: an exit code, if parsing fails (or nothing if parsing succeeds)
        """
        output_filename = self.node.get_option("output_filename")

        # Check that folder content is as expected
        files_retrieved = self.retrieved.list_object_names()
        files_expected = [
            "results_freqvsangle.out",
            "results_short.out",
            "results_orbitoutlines_invAng.out",
        ]
        # Note: set(A) <= set(B) checks whether A is a subset of B
        if not set(files_expected) <= set(files_retrieved):
            self.logger.error(
                f"Found files '{files_retrieved}', expected to find '{files_expected}'"
            )
            return self.exit_codes.ERROR_MISSING_OUTPUT_FILES

        # parse `results_short.out`
        self.logger.info(f"Parsing '{output_filename}'")
        with self.retrieved.open(output_filename, "r") as handle:
            output_node = parse_short_out(handle.readlines())
        self.out("output_parameters", output_node)

        # parse `results_freqvsangle.out`
        filename = "results_freqvsangle.out"
        self.logger.info(f"Parsing '{filename}'")
        with self.retrieved.open(filename, "r") as handle:
            output_node = parse_frequency(handle.readlines())

        # Exchange theta and phi if needed
        input_params = self.node.inputs["parameters"].get_dict()
        angle_iso_convention = input_params.get("angle_iso_convention")
        if angle_iso_convention:
            theta = output_node.get_array("theta")
            phi = output_node.get_array("phi")
            output_node.set_array("theta", phi)
            output_node.set_array("phi", theta)
        output_node.set_attribute(  # pylint: disable=no-member
            "angle_iso_convention", angle_iso_convention
        )

        self.out("frequency", output_node)

        # parse `results_orbitoutlines_invAng.out`
        # filename = 'results_orbitoutlines_invAng.out'
        # self.logger.info(f"Parsing '{filename}'")
        # with self.retrieved.open(filename, "r") as handle:
        #     output_node = SinglefileData(file=handle)
        # self.out("skeaf", output_node)

        return ExitCode(0)


def parse_short_out(filecontent: ty.List[str]) -> orm.Dict:
    """Parse `results_short.out`."""
    parameters = {
        "fermi_energy_unit": "rydberg",
    }

    regexs = {
        "version": re.compile(r"Short results file generated by S.K.E.A.F. (.+)"),
        "fermi_energy": re.compile(r"Fermi energy:\s*([+-]?(?:[0-9]*[.])?[0-9]+) Ryd"),
        "time_per_angle": re.compile(r"Calculations for one angle took\s*(.+)"),
        "time_total": re.compile(r"Whole program run took\s*(.+)"),
        "timestamp_started": re.compile(r"Started finding DOS on\s*(.+)"),
        "timestamp_finished": re.compile(r"Program finished on\s*(.+)"),
    }

    for line in filecontent:
        for key, reg in regexs.items():
            match = reg.match(line.strip())
            if match:
                parameters[key] = match.group(1)
                regexs.pop(key, None)
                break

    parameters["fermi_energy"] = float(parameters["fermi_energy"])

    return orm.Dict(dict=parameters)


def parse_frequency(filecontent: ty.List[str]) -> orm.ArrayData:
    """Parse `results_freqvsangle.out`."""
    array = orm.ArrayData()

    header = filecontent.pop(0)
    array.set_attribute("header", header)

    freq = np.loadtxt(
        filecontent,
        delimiter=",",
        usecols=range(6),
        dtype=float,
        ndmin=2,  # at least 2 dim even if there's single freq in output
    )
    numorbcopy = np.loadtxt(
        filecontent,
        delimiter=",",
        usecols=6,
        dtype=int,
        ndmin=1,  # at least 1 dim even if there's single freq in output
    )

    # in the older numpy versions, e.g. 1.22.4, after reading empty file,
    # freq.shape = (0,1), which causes an error when setting arrays, e.g. array.set_array("phi", freq[:, 1])
    # to avoid dependency on numpy version, we check if freq is empty and reshape it to (0,6)
    if len(freq) == 0 and freq.shape[1] != 6:
        freq = freq.reshape(freq.shape[0], 6)

    array.set_array("theta", freq[:, 0])
    array.set_array("phi", freq[:, 1])
    array.set_array("freq", freq[:, 2])
    array.set_array("mstar", freq[:, 3])
    array.set_array("curv", freq[:, 4])
    array.set_array("type", freq[:, 5])
    array.set_array("numorbcopy", numorbcopy)

    return array
