from __future__ import annotations

import dataclasses
from typing import Any

from macrotype.modules.ir import ClassDecl, ModuleDecl

# Default values used by @dataclass_transform.
_DT_DEFAULTS = {
    "eq_default": True,
    "order_default": False,
    "kw_only_default": False,
    "frozen_default": False,
}


def has_transform(cls: type) -> bool:
    """Return True if *cls* is covered by ``@dataclass_transform``."""

    if "__dataclass_transform__" in getattr(cls, "__dict__", {}):
        return True
    mcls = type(cls)
    if "__dataclass_transform__" in getattr(mcls, "__dict__", {}):
        return True
    for base in cls.__mro__[1:]:
        if "__dataclass_transform__" in getattr(base, "__dict__", {}):
            return True
    return False


def _dt_decorator(obj: Any) -> str | None:
    data = getattr(obj, "__dataclass_transform__", None)
    if not isinstance(data, dict):
        return None
    args: list[str] = []
    for name, default in _DT_DEFAULTS.items():
        val = data.get(name, default)
        if val != default:
            args.append(f"{name}={val}")
    return "dataclass_transform" + (f"({', '.join(args)})" if args else "()")


def apply_dataclass_transform(mi: ModuleDecl) -> None:
    """Attach ``@dataclass_transform`` decorators and strip unsafe ``__init__``."""

    for sym in mi.get_all_decls():
        if not isinstance(sym, ClassDecl):
            continue
        cls = sym.obj
        if not isinstance(cls, type):
            continue
        if "__dataclass_transform__" in getattr(cls, "__dict__", {}):
            deco = _dt_decorator(cls)
            if deco:
                sym.decorators = sym.decorators + (deco,)
                mi.imports.typing.add("dataclass_transform")
            continue
        if has_transform(cls):
            sym.members = tuple(
                m for m in sym.members if not (m.name == "__init__" and hasattr(m, "params"))
            )
            sym.decorators = tuple(d for d in sym.decorators if not d.startswith("dataclass"))


# Defaults used when recreating a ``@dataclass`` decorator.
_DATACLASS_DEFAULTS: dict[str, Any] = {
    "init": True,
    "repr": True,
    "eq": True,
    "order": False,
    "unsafe_hash": False,
    "frozen": False,
    "match_args": True,
    "kw_only": False,
    "slots": False,
    "weakref_slot": False,
}

# Methods automatically generated by ``dataclasses`` which should not appear in
# generated stubs.
_AUTO_DATACLASS_METHODS = {
    "__init__",
    "__repr__",
    "__eq__",
    "__lt__",
    "__le__",
    "__gt__",
    "__ge__",
    "__hash__",
    "__setattr__",
    "__delattr__",
    "__getstate__",
    "__setstate__",
    "_dataclass_getstate",
    "_dataclass_setstate",
    "__getattribute__",
    # ``dataclasses`` generates a private ``_replace`` helper used by
    # ``dataclasses.replace``. This method should not appear in stubs.
    "__replace__",
    "_replace",
}


def _dataclass_auto_methods(
    params: dataclasses._DataclassParams | None,
) -> set[str]:
    """Return the dataclass-generated methods based on *params*."""

    if params is None:
        return set(_AUTO_DATACLASS_METHODS)

    auto_methods = {
        "__init__",
        "__repr__",
        "__getstate__",
        "__setstate__",
        "_dataclass_getstate",
        "_dataclass_setstate",
        "__getattribute__",
        # See comment above â€“ ``_replace`` is an auto-generated helper.
        "__replace__",
        "_replace",
    }
    if params.eq:
        auto_methods.add("__eq__")
    if params.order:
        auto_methods.update({"__lt__", "__le__", "__gt__", "__ge__"})
    if params.frozen:
        auto_methods.update({"__setattr__", "__delattr__"})
    if params.eq and (params.frozen or params.unsafe_hash):
        auto_methods.add("__hash__")
    return auto_methods


def _dataclass_decorator(klass: type) -> str | None:
    """Return the ``@dataclass`` decorator text for *klass*."""

    if not (dataclasses.is_dataclass(klass) or hasattr(klass, "__dataclass_fields__")):
        return None

    params = getattr(klass, "__dataclass_params__", None)
    args: list[str] = []
    if params is not None:
        for name, default in _DATACLASS_DEFAULTS.items():
            if name == "match_args" and not hasattr(params, "match_args"):
                continue
            val = getattr(params, name, default)
            if name == "slots" and not hasattr(params, name):
                val = not hasattr(klass, "__dict__")
            elif name == "weakref_slot" and not hasattr(params, name):
                val = "__weakref__" in getattr(klass, "__slots__", ())
            if val != default:
                args.append(f"{name}={val}")

    return "dataclass" + (f"({', '.join(args)})" if args else "")


def _transform_class(sym: ClassDecl, cls: type) -> None:
    deco = _dataclass_decorator(cls)
    if not deco:
        return
    params = getattr(cls, "__dataclass_params__", None)
    auto_methods = _dataclass_auto_methods(params)
    sym.members = tuple(m for m in sym.members if m.name not in auto_methods)
    if not has_transform(cls):
        sym.decorators = sym.decorators + (deco,)


def transform_dataclasses(mi: ModuleDecl) -> None:
    """Attach dataclass decorators and strip auto methods within ``mi``."""

    for sym in mi.get_all_decls():
        if isinstance(sym, ClassDecl):
            cls = sym.obj
            if isinstance(cls, type):
                _transform_class(sym, cls)


__all__ = ["apply_dataclass_transform", "has_transform", "transform_dataclasses"]
