from __future__ import annotations

"""Synthesize enum members and strip autogenerated methods."""

import enum

from macrotype.modules.ir import ClassDecl, ModuleDecl, Site, TypeDefDecl


def _enum_members(klass: enum.EnumMeta) -> list[TypeDefDecl]:
    """Return alias symbols for enum members in *klass*."""

    members: list[TypeDefDecl] = []
    for member_name, member in klass.__members__.items():
        value = member.value
        try:
            hash(value)
            ann = value
        except TypeError:
            ann = type(value)
        site = Site(role="alias_value", annotation=ann)
        members.append(TypeDefDecl(name=member_name, value=site, obj=member))
    return members


def _auto_enum_methods(klass: type) -> set[str]:
    """Return method names automatically added to enum classes."""

    auto = {"_generate_next_value_", "__new__"}
    for name in ("__repr__", "__str__", "__format__"):
        value = klass.__dict__.get(name)
        if getattr(value, "__module__", None) == "enum":
            auto.add(name)
    if issubclass(klass, enum.Flag):
        auto.update(
            {
                "__or__",
                "__and__",
                "__xor__",
                "__ror__",
                "__rand__",
                "__rxor__",
                "__invert__",
            }
        )
    return auto


def _transform_class(sym: ClassDecl, cls: type) -> None:
    if isinstance(cls, enum.EnumMeta):
        auto = _auto_enum_methods(cls)
        members = [m for m in sym.members if m.name not in auto]
        members = _enum_members(cls) + members
        sym.members = tuple(members)


def transform_enums(mi: ModuleDecl) -> None:
    """Expand enum members and strip autogenerated methods in ``mi``."""

    for sym in mi.get_all_decls():
        if isinstance(sym, ClassDecl):
            cls = sym.obj
            if isinstance(cls, type):
                _transform_class(sym, cls)
