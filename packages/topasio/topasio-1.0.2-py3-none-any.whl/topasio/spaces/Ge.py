from topasio.generic_classes.space import Space
from topasio.generic_classes.tree import Node
from topasio.generic_classes.element import Element

from topasio.printing import writeVal

import quantities as q
import os
from pathlib import Path
from topasio.config import cfg

class Geometry(Space):
    def __init__(self):
        super().__init__()
        self["_name"] = "Ge"
        self["_tree"] = None
        self["_dirmap"] = dict()
        self["_filenamemap"] = dict()
        self["_modified"] = []


    def dumpToFile(self, basename="autotopas"):
        for elemName in self["_modified"]:
            if "Parent" not in self[elemName]["_modified"]:
                self[elemName].Parent = "World"
        
        self["_dirmap"], self["_filenamemap"] = self.getDirMap(self.getTree("World"), basename=basename)
        dirmap = self["_dirmap"]
        filenamemap = self["_filenamemap"]


        for dirname, filename in zip(list(dirmap.values()) + [basename], list(filenamemap.values()) + ["main.tps"]):
            # print(f"Creating file {os.path.join(dirname, filename)}")
            # Create dir recursively if it does not exist
            if not os.path.exists(dirname):
                os.makedirs(dirname, exist_ok=True)
            # Create file with header if it does not exist
            with open(os.path.join(dirname, filename), "w+") as f:
                f.write("# Generated automatically by TopasIO\n")
                f.write("# Do not edit this file directly\n\n")

        for elemName in self["_modified"]:
            if hasattr(self[elemName], "dumpToFile"):
                self[elemName].dumpToFile(elemName=elemName, 
                                        space_name=self["_name"],
                                        filename=self.getFilePath(elemName, basename=basename))
            else:
                with open(f"{basename}/main.tps", "a+") as f:
                    writeVal(f, 
                             space_name=self["_name"], 
                             elemName=elemName, 
                             key=None, 
                             value=self[elemName])

        world_path = Path(self.getFilePath("World", basename=basename))
        with open(world_path.parent.parent / "main.tps", "a+") as f:
            f.write(f"\n\nincludeFile = {basename}/geometry/{world_path.name}\n\n\n")

    def getFilePath(self, elemName: str, basename:str="autotopas") -> str:
        if self.get("_tree") is None:
            self["_tree"] = self.getTree("World")
            self["_dirmap"], self["_filenamemap"] = self.getDirMap(self["_tree"], basename=basename)

        if isinstance(self[elemName], Element):
            node = self["_tree"].find(elemName)
            return self["_dirmap"][node] + self["_filenamemap"][node]
        else:
            return "main.tps"
        
    def getTree(self, parent, tree=None):
        if tree is None:
            tree = Node(parent)

        children = self.getChildrenOf(parent)
        if children == []:
            return

        for child in children:
            child_node = Node(child, parent=tree)
            child_node.isgroup = hasattr(self[child], "_expand")
            child_node.expand = self[child]["_expand"] if child_node.isgroup else None
            self.getTree(child, child_node)

        return tree
    
    def getChildrenOf(self, parent):
        if parent not in self["_modified"]:
            if parent == "World":
                self["_modified"].append("World")
                return self.getChildrenOf(parent)
            print(f"Parent '{parent}' not found in self['_modified'].")
            return []
        children = [child for child in self["_modified"] if isinstance(self[child], Element)]
        if parent == "World":
            children = [child for child in children if child != "World"]
        children = [child for child in children if self[child]["Parent"] == parent]
        return children
    
    def getDirMap(self, tree: Node, basename:str="autotopas") -> dict[Node, str]:
        baseDir = f"{basename}/geometry/"

        dirmap = dict()
        filenamemap = dict()

        for node in tree.iterate():
            if node in dirmap.keys(): #  and not isinstance(dirmap[node], Node)
                continue
            
            if node.name == "World":
                dirmap[node] = baseDir
                filenamemap[node] = "World.tps"

                for child in node.children:
                    if child.isLeaf():
                        dirmap[child] = baseDir
                        filenamemap[child] = f"{child.name}.tps"

                continue

            if node.isParentOfChain():
                file = f"{node.name}.tps"
                for child in node.iterate():
                    filenamemap[child] = file
                    dirmap[child] = node # means the dir of the parent. Will be replaced with the correct path later
                continue

            if node.isgroup and not node.expand:
                file = f"{node.name}.tps"
                filenamemap[node] = file
                dirmap[node] = node

                for child in node.iterate():
                    filenamemap[child] = file
                    dirmap[child] = node # means the dir of the parent. Will be replaced with the correct path later
                continue

            if node.isgroup and node.expand:
                filenamemap[node] = filenamemap[node.parent]
                if node.parent.name == "World":
                    dirmap[node] = dirmap[node.parent]
                else:
                    dirmap[node] = dirmap[node.parent] + node.parent.name + "/"
                    filenamemap[node] = node.name + ".tps"
                continue
            
            if not node.isgroup and not node.isLeaf():
                filenamemap[node] = node.name + ".tps"
                dirmap[node] = dirmap[node.parent] + node.name + "/"

            if not node.isgroup and node.isLeaf():
                filenamemap[node] = node.name + ".tps"
                dirmap[node] = dirmap[node.parent]

            assert dirmap.keys() == filenamemap.keys(), "Directory map and filename map keys do not match."
        for node in dirmap.keys():
            if isinstance(dirmap[node], Node):
                dirmap[node] = dirmap[node.parent]
                if node.isgroup and not node.expand:
                    for child in node.iterate():
                        if child != node:
                            dirmap[child] = dirmap[node] + node.name + "/"

        for node in dirmap.keys():
            if node.isgroup and not node.expand:
                for child in node.iterate():
                    if child != node:
                        dirmap[child] = dirmap[node]

            if node.isgroup and node.expand:            
                for child in node.iterate():
                    if child != node and not dirmap[child].endswith(node.name + "/"):
                        dirmap[child] = dirmap[node] + node.name + "/"

        for node in dirmap.keys():
            if node.isgroup and node.expand:
                if all([not child.isgroup for child in node.children]): # if the group has no children that are groups
                    dirmap[node] = dirmap[node.parent]
                    filenamemap[node] = filenamemap[node.parent]

        # for node in dirmap.keys():
        #     if isinstance(dirmap[node], Node):
        #         raise TypeError(f"Node {node.name} has a mapped dir that is not a string: {dirmap[node]}={dirmap[node].name}")


        # assert dirmap.keys() == filenamemap.keys(), "Directory map and filename map keys do not match after processing."
        return dirmap, filenamemap



def setGeDefaults(self):
    # ------ OPTIONAL CHECKS ON CORRECTNESS OF GEOMETRY ----------------
    self.CheckForOverlaps                = True
    self.CheckInsideEnvelopesForOverlaps = False # Speeds up checking by assuming inner parts of components are OK
    self.CheckForOverlapsResolution      = 1000
    self.CheckForOverlapsTolerance       = 0. * q.mm
    self.QuitIfOverlapDetected           = True
    self.NumberOfPointsPerOverlapCheck   = 100
    self.CheckForUnusedComponents        = True



Ge = Geometry()
Ge.Name = "Ge"
setGeDefaults(Ge)

Ge["_modified"] = []














# def getRichGeTree(parent:str, tree:Tree=None):
#     if tree is None:
#         tree = Tree(Text(f"üåè {parent}", "bold magenta"), guide_style="bold bright_blue")

#     children = getChildrenOf(Ge, parent)
#     if children == []:
#         return

#     for child in children:
#         txt = getElemLabel(child)
#         branch = tree.add(txt)
#         getRichGeTree(child, branch)

#     return tree
