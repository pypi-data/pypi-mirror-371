---
title: "Perch√© √® stato creato Tom√©to Tomato"
---

## Introduzione

Chiunque lavori con i dati molto spesso si imbatte in colonne che dovrebbero rispettare una codifica, un valore standard, una lista di valori noti, ma presentano invece **errori di battitura**, **spazi in eccesso**, **caratteri speciali al posto di caratteri accentati**, **maiuscole/minuscole non coerenti**, ecc..

Qui sotto ad esempio dei nomi ci citt√† italiane, riportati in modo errato:

| city            | tipo di errore    |
|-----------------|-------------------|
| Cefalu'         | bisognerebbe usare la `√π` e non `u'`  |
| Reggio Calabria | Il nome corretto √® `Reggio di Calabria` |
| RODENGO-SAIANO  | bisognerebbe usare `Rodengo Saiano`, senza `-` e non tutto maiuscolo |
: Esempi di nomi di citt√† errati {.striped .small tbl-colwidths="[30,70]"}

<br>
Se volessi associare a queste citt√† il codice[^code] che **Istat** - l'istituto nazionale di statistica - assegna a ciascuna citt√†, non potrei farlo con una semplice operazione di join, perch√© i nomi non corrispondono esattamente. Associare un codice a ciascun comune √® operazione molto importante perch√© mi consente di **unire** dati provenienti da fonti diverse, che altrimenti non potrei confrontare, ma anche di **generare** ad esempio **automaticamente** **mappe**, perch√© i software spesso usano proprio questi codici per identificare i comuni.

[^code]: [Codes of Italian municipalities](https://www.istat.it/en/classification/codes-of-italian-municipalities-provinces-and-regions/)

::: {.callout-tip appearance="simple"}

## Pay Attention

Chi fa didattica sui dati di solito infatti dice (urlando): **CODES, NOT LABELS!!**

:::

I codici correlati alle unit√† amministrative italiane sono pubblici e liberamente accessibili in CC-BY-4.0 su diverse sezioni del sito Istat. Uno di questi √® il [SITUAS](https://situas.istat.it), in cui c'√® la pagina con l'"[**Elenco dei codici e delle denominazioni delle unit√† territoriali**](https://situas.istat.it/web/#/territorio/body?id=61&dateFrom=2025-08-23)", scaricabili in formato `CSV` e `JSON`.

| city | region    | istat_city_code |
|-------------------------|------------|----------------------------|
| Cefal√π                  | Sicilia    | 082027                     |
| Reggio di Calabria      | Calabria   | 080063                     |
| Rodengo Saiano          | Lombardia  | 017163                     |
: Esempio di dati ufficiali Istat sui comuni italiani {.striped .small}


<br>
Se provassi a fare un join tra i dati errati e questi dati ufficiali, **non otterrei alcun risultato**.

---

üëâ Tom√©to Tomato √® stato creato per risolvere questo problema: consente di **fare comodamente** join **non basati su corrispondenze esatte**, ma su **corrispondenze "simili"**, e **arricchire**, **modificare**, **correggere** la propria brutta tabella di input, confrontandola con una tabella di riferimento.

---

### File di esempio

Queste sono le nostre due tabelle di esempio, disponibili come [`input.csv`](files/input.csv) e [`ref_sample.csv`](files/ref_sample.csv) in modo che sia possibile scaricarle e provare a eseguire gli esempi.

## Utilizzare SQL

### Fare il JOIN

Il primo test √® quello di lanciare una semplice query SQL di join, per vedere cosa succede a partire dai nostri dati di esempio.

:::::: columns
::: {.column width="46%"}
| city            | region    |
|-----------------|-----------|
| Cefalu'         | Sicilia   |
| Reggio Calabria | CALABRIA  |
| RODENGO-SAIANO  | Lombardia |

: The raw data {.striped .small}
:::

::: {.column width="8%"}
:::

::: {.column width="46%"}
| city               | region    | city_code |
|--------------------|-----------|-----------|
| Cefal√π             | Sicilia   | 082027    |
| Reggio di Calabria | Calabria  | 080063    |
| Rodengo Saiano     | Lombardia | 017164    |

: The reference data {.striped .small}
:::
::::::

<br>
La query pu√≤ essere quella di sotto. √à impostata come un `LEFT JOIN`, in modo da mostrare tutte le righe della tabella di sinistra, anche se non trovano corrispondenza nella tabella di destra.

```sql
SELECT
  i.*,
  r.city_code
FROM read_csv_auto('input.csv') AS i
LEFT JOIN read_csv_auto('ref_sample.csv') AS r
  ON i.city = r.city AND i.region = r.region
```

::: {.callout-note}
**Nota**: l'uso di `read_csv_auto` nella query di sopra √® una funzionalit√† di [**DuckDB**](https://duckdb.org/) che consente di leggere direttamente file CSV senza doverli importare prima in una tabella. In questo modo √® possibile fare esperimenti veloci senza dover creare tabelle temporanee.
:::

In output otteniamo un pessimo risultato: nessuna delle righe della tabella di sinistra trova corrispondenza nella tabella di destra, e quindi il campo `city_code` risulta sempre `NULL`.

| city            | region    | istat_city_code |
|-----------------|-----------|-----------------|
| Cefalu'         | Sicilia   | NULL            |
| Reggio Calabria | CALABRIA  | NULL            |
| RODENGO-SAIANO  | Lombardia | NULL            |
: Risultato di un join tra dati errati e dati ufficiali {.striped .small}



### Fare il JOIN "fuzzy"

Un JOIN "fuzzy", sfumato, √® quello che consente di trovare corrispondenze anche quando i valori non sono esattamente uguali, ma "simili". Ad esempio, potremmo voler considerare come corrispondenti i nomi di citt√† che differiscono per un solo carattere, o che hanno una distanza di Levenshtein (numero di operazioni necessarie per trasformare una stringa in un'altra) inferiore a una certa soglia.

Potremmo riscrivere la query di join precedente in questo modo, usando la [funzione `levenshtein` di DuckDB](https://duckdb.org/docs/stable/sql/functions/text#levenshteins1-s2) per il campo `city` in modo da considererare come corrispondenti i nomi di citt√† che differiscono per al massimo 2 caratteri:


```sql
SELECT
  i.city AS input_city,
  i.region AS input_region,
  r.city AS ref_city,
  r.region AS ref_region,
  r.city_code,
  levenshtein(i.city, r.city) AS levenshtein_distance
FROM read_csv_auto('input.csv') AS i
JOIN read_csv_auto('ref_sample.csv') AS r
  ON i.region = r.region
  AND levenshtein(i.city, r.city) <= 2;
```

| input_city      | input_region | ref_city        | ref_region | city_code | levenshtein_distance |
|-----------------|-------------|-----------------|------------|-----------|----------------------:|
| Cefalu'         | Sicilia     | Cefal√π          | Sicilia    | 082027    | 2                    |
: Risultato di un join fuzzy tra dati errati e dati ufficiali {.striped .small}

L'unica citt√† di cui c'√® un risulato √® soltanto `Cefalu'`, perch√© la **distanza** di Levenshtein tra `Cefalu'` e `Cefal√π` √® **2**: sostituzione di `u'` con `√π` e rimozione di `'`.

Se aumentiamo la soglia a 10, non cambia nulla, perch√© ad esempio il Comune di `Rodengo Saiano` √® scritto in maiuscolo e con il trattino e la distanza tra `RODENGO-SAIANO` e `Rodengo Saiano` √® pari a **12**:

```bash
SELECT levenshtein('RODENGO-SAIANO', 'Rodengo Saiano') AS distance;

12
```

Se si imposta la soglia a 15 ne otteniamo in ogni caso soltanto 2, perch√© il JOIN del campo `region` non trova corrispondenza tra `CALABRIA` e `Calabria`. Quindi dovremmo usare una funzione di distanza tra stringhe anche per il campo `region`:

```sql
SELECT
  i.city AS input_city,
  i.region AS input_region,
  r.city AS ref_city,
  r.region AS ref_region,
  r.city_code,
  levenshtein(i.city, r.city) AS levenshtein_distance
FROM read_csv_auto('input.csv') AS i
JOIN read_csv_auto('ref_sample.csv') AS r
  ON levenshtein(i.city, r.city) <= 15
  AND levenshtein(LOWER(i.region), LOWER(r.region)) < 10
```

Ma √® l'**output non √®** proprio **quello che ci aspettiamo**, non 3 righe in totale (una per ogni Comune), ma **ben 8 righe**:

| input_city      | input_region | ref_city            | ref_region | city_code | levenshtein_distance |
|-----------------|-------------|---------------------|------------|-----------|----------------------:|
| Cefalu'         | Sicilia     | Cefal√π              | Sicilia    | 082027    | 2                    |
| Cefalu'         | Sicilia     | Reggio di Calabria  | Calabria   | 080063    | 15                   |
| Cefalu'         | Sicilia     | Rodengo Saiano      | Lombardia  | 017163    | 12                   |
| Reggio Calabria | CALABRIA    | Cefal√π              | Sicilia    | 082027    | 12                   |
| Reggio Calabria | CALABRIA    | Reggio di Calabria  | Calabria   | 080063    | 3                    |
| Reggio Calabria | CALABRIA    | Rodengo Saiano      | Lombardia  | 017163    | 10                   |
| RODENGO-SAIANO  | Lombardia   | Cefal√π              | Sicilia    | 082027    | 14                   |
| RODENGO-SAIANO  | Lombardia   | Rodengo Saiano      | Lombardia  | 017163    | 12                   |
: Risultato di un join fuzzy tra dati errati e dati ufficiali {.striped .small}

Quando si esegue un JOIN esatto, l'obiettivo √® trovare una singola e chiara corrispondenza per ogni riga. Nel mondo del  "fuzzy matching", le regole cambiano. Abbassando le nostre pretese con soglie di distanza permissive, non stiamo pi√π chiedendo al database "trova l'unica corrispondenza giusta", ma piuttosto:

> Per ogni riga del mio input, trovami tutte le righe nel file di riferimento che soddisfano questi criteri di somiglianza generici.

Se una riga di input √® "vagamente simile" a pi√π righe di riferimento, il database creer√† una riga di output per ciascuna di queste coincidenze. Questo effetto di moltiplicazione √® noto come **prodotto cartesiano** delle coincidenze.

Dopo aver generato le possibili corrispondenze, dovremmo filtrarle per tenere solo la migliore per ogni record di partenza. Il processo pu√≤ essere suddiviso in tre fasi:

- trovare tutte le possibili corrispondenze e calcolare le distanze
- assegnare un rango a ciascuna corrispondenza in base alla somma delle distanze
- selezionare solo la corrispondenza con il rango pi√π alto (cio√® la pi√π simile)


```sql
-- Fase 1: trova tutti i candidati e calcola le distanze
WITH all_matches AS (
    SELECT
        i.city AS input_city,
        i.region AS input_region,
        r.city AS ref_city,
        r.region AS ref_region,
        r.city_code,
        levenshtein(i.city, r.city) AS city_distance,
        levenshtein(i.region, r.region) AS region_distance
    FROM read_csv_auto('input.csv') AS i
    JOIN read_csv_auto('ref_sample.csv') AS r
      ON levenshtein(i.city, r.city) <= 15
     AND levenshtein(i.region, r.region) < 10
),
-- Fase 2: assegna un rango ai candidati
ranked_matches AS (
    SELECT
        *,
        ROW_NUMBER() OVER (
            PARTITION BY input_city, input_region
            ORDER BY (city_distance + region_distance) ASC
        ) AS rn
    FROM all_matches
)
-- Fase 3: prendi solo il miglior candidato (rn = 1)
SELECT
    input_city,
    input_region,
    ref_city,
    ref_region,
    city_code,
    city_distance,
    region_distance
FROM ranked_matches
WHERE rn = 1;
```

| input_city      | input_region | ref_city            | ref_region | city_code | city_distance | region_distance |
|-----------------|-------------|---------------------|------------|-----------|---------------:|----------------:|
| Cefalu'         | Sicilia     | Cefal√π              | Sicilia    | 082027    | 2             | 0              |
| RODENGO-SAIANO  | Lombardia   | Rodengo Saiano      | Lombardia  | 017163    | 12            | 0              |
| Reggio Calabria | CALABRIA    | Reggio di Calabria  | Calabria   | 080063    | 3             | 7              |
: Risultato di un join fuzzy, con selezione della migliore corrispondenza {.striped .small}


### Una sintesi per ridurre le distanze

A seguira una tabellina di riepilogo, sull'esempio del nome del [Comune di `Forza¬∑d'Agr√≤`](https://www.wikiwand.com/en/articles/Forza_d'Agr%C3%B2), scritto per√≤ in modo errato `Forza¬∑¬∑D‚ÄôAgro¬∑`:

- c'√® la `D` maiuscola invece che minuscola;
- ci sono due spazi in eccesso (uno tra `Forza` e `D'Agro` e uno alla fine);
- non c'√® la `o` accentata, ma una `o` normale;
- c'√® un apostrofo tipografico `‚Äô`, invece di uno dritto `'`.

::: {.callout-note}
**Nota**: qui sopra sono stati resi visibili gli spazi in eccesso con il carattere `¬∑`.
:::

:::{.column-body-outset}
| descrizione | left | right | distanza | funzione aggiunta |
| :--- | :--- | :--- | ---: | :--- |
| Inizio | `Forza¬∑¬∑D‚ÄôAgro¬∑` | `Forza¬∑d'Agr√≤` | 7 |  |
| In minuscolo | `forza¬∑¬∑d‚Äôagro¬∑` | `forza¬∑d'agr√≤` | 6 | `LOWER('value')` |
| Rimossi spazi ridondanti | `forza¬∑d‚Äôagro` | `forza¬∑d'agr√≤` | 5 | `regexp_replace(trim(LOWER('value')), '\s+', ' ')` |
| Rimossi accentati | `forza¬∑d‚Äôagro` | `forza¬∑d'agro` | 3 | `strip_accents(regexp_replace(trim(LOWER('value')), '\s+', ' '))` |
| Rimossi caratteri speciali | `forza¬∑dagro` | `forza¬∑dagro` | 0 | `regexp_replace(strip_accents(regexp_replace(trim(LOWER('value')), '\s+', ' ')), '[^a-zA-Z0-9 ]', '', 'g')` |
: Riduzione della distanza con passaggi successivi di normalizzazione {.striped .table-sm .table-bordered .table-responsive tbl-colwidths="[20,15,15,10,35]"}
:::

<br>
üëâ Quindi **un caso molto brutto**, pieno di errori, pu√≤ essere normalizzato in modo da **ridurre** la **distanza** di Levenshtein a **zero**, e quindi trovare la corrispondenza esatta e `Forza¬∑¬∑D'Agro¬∑` √® uguale a `Forza¬∑d'Agr√≤` e quindi riesco a ricavarne il codice identificativo.

## Note finali

In questo percorso abbiamo descritto alcuni elementi di base per misurare la "distanza" tra le stringhe e a normalizzare il testo per rendere il confronto pi√π efficace. Abbiamo visto come gestire maiuscole/minuscole, spazi superflui, accenti e caratteri speciali, che sono gli elementi di base di ogni processo di pulizia dei dati.

Tuttavia, questo √® solo l'inizio. Il mondo del "fuzzy matching" √® molto pi√π vasto e complesso. Per affrontare dataset pi√π grandi e "disordinati", si ricorre spesso a metodi pi√π sofisticati, che vanno oltre il semplice conteggio delle modifiche:

- Algoritmi fonetici: Invece di guardare come sono scritte le parole, questi algoritmi le codificano in base a come suonano. Metodi come Metaphone o Soundex sono bravissimi a capire che "Smith" e "Smythe" sono probabilmente la stessa cosa.
- Modelli statistici (n-gram): Questi metodi scompongono le stringhe in piccole parti (es. coppie o triplette di caratteri) e ne confrontano la frequenza, risultando molto efficaci nel trovare somiglianze anche quando l'ordine delle parole √® diverso.

Strumenti di pulizia dati come [OpenRefine](https://openrefine.org/) integrano decine di questi algoritmi avanzati, permettendo di raggruppare e correggere dati simili con grande efficacia.
