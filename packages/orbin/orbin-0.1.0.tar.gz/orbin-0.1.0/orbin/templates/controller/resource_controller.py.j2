"""
{{ model_class_name }}Controller - FastAPI controller for {{ controller_name }}.

This controller handles HTTP requests for {{ controller_name }} resources.
Generated on {{ timestamp }}
"""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Optional
from pydantic import BaseModel, ConfigDict

from config.database import get_db
from app.models.{{ model_name }} import {{ model_class_name }}


# Create router for {{ controller_name }} routes
router = APIRouter(
    prefix="{{ route_prefix }}",
    tags=["{{ controller_name }}"]
)


# Pydantic models (you may want to move these to a separate schemas file)
class {{ model_class_name }}Base(BaseModel):
    """Base schema for {{ controller_name }}."""
{% for attr in model_attributes %}    {{ attr.name }}: Optional[{{ attr.pydantic_type }}] = None
{% endfor %}

class {{ model_class_name }}Create({{ model_class_name }}Base):
    """Schema for creating {{ controller_name }}."""
{% for attr in model_attributes if attr.required %}    {{ attr.name }}: {{ attr.pydantic_type }}
{% endfor %}

class {{ model_class_name }}Update({{ model_class_name }}Base):
    """Schema for updating {{ controller_name }}."""
    pass


class {{ model_class_name }}Response({{ model_class_name }}Base):
    """Schema for {{ controller_name }} responses."""
    id: str
    created_at: str
    updated_at: str
    
    model_config = ConfigDict(from_attributes=True)


class {{ model_class_name }}Controller:
    """Controller for {{ controller_name }} operations."""
    
    @staticmethod
    @router.get("")
    async def index(db: Session = Depends(get_db)) -> List[{{ model_class_name }}Response]:
        """Get all {{ controller_name }}."""
        {{ controller_name }} = db.query({{ model_class_name }}).all()
        return [{{ model_class_name }}Response(
            id=str(item.id),
{% for attr in model_attributes %}            {{ attr.name }}=item.{{ attr.name }},
{% endfor %}            created_at=item.created_at.isoformat() if item.created_at else "",
            updated_at=item.updated_at.isoformat() if item.updated_at else ""
        ) for item in {{ controller_name }}]
    
    @staticmethod
    @router.get("/{id}")
    async def show(id: str, db: Session = Depends(get_db)) -> {{ model_class_name }}Response:
        """Get a specific {{ model_name }}."""
        {{ model_name }} = db.query({{ model_class_name }}).filter({{ model_class_name }}.id == id).first()
        if not {{ model_name }}:
            raise HTTPException(status_code=404, detail="{{ model_class_name }} not found")
        
        return {{ model_class_name }}Response(
            id=str({{ model_name }}.id),
{% for attr in model_attributes %}            {{ attr.name }}={{ model_name }}.{{ attr.name }},
{% endfor %}            created_at={{ model_name }}.created_at.isoformat() if {{ model_name }}.created_at else "",
            updated_at={{ model_name }}.updated_at.isoformat() if {{ model_name }}.updated_at else ""
        )
    
    @staticmethod
    @router.post("")
    async def create({{ model_name }}_data: {{ model_class_name }}Create, db: Session = Depends(get_db)) -> {{ model_class_name }}Response:
        """Create a new {{ model_name }}."""
        {{ model_name }} = {{ model_class_name }}(
{% for attr in model_attributes %}            {{ attr.name }}={{ model_name }}_data.{{ attr.name }},
{% endfor %}        )
        db.add({{ model_name }})
        db.commit()
        db.refresh({{ model_name }})
        
        return {{ model_class_name }}Response(
            id=str({{ model_name }}.id),
{% for attr in model_attributes %}            {{ attr.name }}={{ model_name }}.{{ attr.name }},
{% endfor %}            created_at={{ model_name }}.created_at.isoformat() if {{ model_name }}.created_at else "",
            updated_at={{ model_name }}.updated_at.isoformat() if {{ model_name }}.updated_at else ""
        )
    
    @staticmethod
    @router.put("/{id}")
    async def update(id: str, {{ model_name }}_data: {{ model_class_name }}Update, db: Session = Depends(get_db)) -> {{ model_class_name }}Response:
        """Update a specific {{ model_name }}."""
        {{ model_name }} = db.query({{ model_class_name }}).filter({{ model_class_name }}.id == id).first()
        if not {{ model_name }}:
            raise HTTPException(status_code=404, detail="{{ model_class_name }} not found")
        
        # Update only provided fields
        update_data = {{ model_name }}_data.model_dump(exclude_unset=True)
        for key, value in update_data.items():
            setattr({{ model_name }}, key, value)
        
        db.commit()
        db.refresh({{ model_name }})
        
        return {{ model_class_name }}Response(
            id=str({{ model_name }}.id),
{% for attr in model_attributes %}            {{ attr.name }}={{ model_name }}.{{ attr.name }},
{% endfor %}            created_at={{ model_name }}.created_at.isoformat() if {{ model_name }}.created_at else "",
            updated_at={{ model_name }}.updated_at.isoformat() if {{ model_name }}.updated_at else ""
        )
    
    @staticmethod
    @router.delete("/{id}")
    async def destroy(id: str, db: Session = Depends(get_db)) -> dict:
        """Delete a specific {{ model_name }}."""
        {{ model_name }} = db.query({{ model_class_name }}).filter({{ model_class_name }}.id == id).first()
        if not {{ model_name }}:
            raise HTTPException(status_code=404, detail="{{ model_class_name }} not found")
        
        db.delete({{ model_name }})
        db.commit()
        
        return {"message": "{{ model_class_name }} deleted successfully", "id": str({{ model_name }}.id)}


# Export the router to be included in the main app
__all__ = ["router", "{{ model_class_name }}Controller"]
