"use strict";(self.webpackChunkjupy_sqlite_extension=self.webpackChunkjupy_sqlite_extension||[]).push([[675],{675:(e,t,o)=>{o.r(t),o.d(t,{default:()=>u});var a=o(531),n=o(494),r=o(310),s=o(269);const u={id:"jupy-sqlite-extension:plugin",description:"JupyterLab extension for SQLite execution based on cell metadata without magic",autoStart:!0,requires:[a.INotebookTracker],activate:(e,t)=>{console.log("JupyterLab extension jupy-sqlite-extension is activated!");const o=async e=>{const t=e.model.getMetadata("sql_cell"),o=e.model.getMetadata("language"),a=e.model.getMetadata("db_file");if(!0===t||"sql"===o){const t=a;if(!t)return e.outputArea.model.clear(),void e.outputArea.model.add({output_type:"error",ename:"SQLiteError",evalue:"Missing db_file in cell metadata",traceback:['SQLiteError: Cell metadata must include "db_file" field']});try{const o=e.model.sharedModel.getSource(),a=await async function(e="",t={}){const o=s.ServerConnection.makeSettings(),a=r.URLExt.join(o.baseUrl,"jupy-sqlite-extension",e);let n;try{n=await s.ServerConnection.makeRequest(a,t,o)}catch(e){throw new s.ServerConnection.NetworkError(e)}let u=await n.text();if(u.length>0)try{u=JSON.parse(u)}catch(e){console.log("Not a JSON response body.",n)}if(!n.ok)throw new s.ServerConnection.ResponseError(n,u.message||u);return u}("execute-sql",{method:"POST",body:JSON.stringify({sql:o,db_file:t}),headers:{"Content-Type":"application/json"}});e.outputArea.model.clear(),a.error?e.outputArea.model.add({output_type:"error",ename:"SQLiteError",evalue:a.error,traceback:[a.error]}):a.formatted_output?e.outputArea.model.add({output_type:"stream",name:"stdout",text:a.formatted_output}):a.message&&e.outputArea.model.add({output_type:"stream",name:"stdout",text:a.message})}catch(t){e.outputArea.model.clear(),e.outputArea.model.add({output_type:"error",ename:"SQLiteError",evalue:String(t),traceback:[String(t)]})}}};t.widgetAdded.connect((e,t)=>{const a=t.content;a.model.cells.changed.connect(()=>{a.widgets.forEach(e=>{if(e instanceof n.CodeCell){const t=e;t.model.stateChanged.connect(e=>{const a=e;null!==a.executionCount&&a.executionCount>0&&o(t)})}})}),a.widgets.forEach(e=>{if(e instanceof n.CodeCell){const t=e;t.model.stateChanged.connect(e=>{const a=e;null!==a.executionCount&&a.executionCount>0&&o(t)})}})})}}}}]);