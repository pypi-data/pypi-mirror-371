# coding: utf-8

"""
CxO Bot Automation API

 CxO Bot Automation API manages the CxO automation platform.  ## Workflows  A CxO Workflow defines the overall flow of AI automated tasks.  Conceptually, a Workflow is a sequence of steps. Those steps are defined by advanced AI units, known as Agents, and are carried out by performing detailed actions, resulting in a execution run.  ## Schedules  CxO Schedules are features allowing you to execute specific CxO Workflows at specified times or intervals.

The version of the OpenAPI document: 0.1.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501


import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictInt, StrictStr
from typing import Any, List, Optional
from typing_extensions import Annotated
from uuid import UUID
from adomo.models.execution_status import ExecutionStatus
from adomo.models.history_event_response import HistoryEventResponse
from adomo.models.job_response import JobResponse
from adomo.models.jobs_response import JobsResponse
from adomo.models.jobs_sort_on import JobsSortOn
from adomo.models.page_size import PageSize
from adomo.models.query_response import QueryResponse
from adomo.models.sort_direction import SortDirection
from adomo.models.update_response import UpdateResponse

from adomo.api_client import ApiClient, RequestSerialized
from adomo.api_response import ApiResponse
from adomo.rest import RESTResponseType


class JobsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def get_job_events_jobs_job_id_events_get(
        self,
        job_id: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[HistoryEventResponse]:
        """Get Job Events


        :param job_id: (required)
        :type job_id: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_job_events_jobs_job_id_events_get_serialize(
            job_id=job_id,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[HistoryEventResponse]",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_job_events_jobs_job_id_events_get_with_http_info(
        self,
        job_id: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[HistoryEventResponse]]:
        """Get Job Events


        :param job_id: (required)
        :type job_id: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_job_events_jobs_job_id_events_get_serialize(
            job_id=job_id,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[HistoryEventResponse]",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_job_events_jobs_job_id_events_get_without_preload_content(
        self,
        job_id: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Job Events


        :param job_id: (required)
        :type job_id: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_job_events_jobs_job_id_events_get_serialize(
            job_id=job_id,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[HistoryEventResponse]",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_job_events_jobs_job_id_events_get_serialize(
        self,
        job_id,
        authorization,
        x_api_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if job_id is not None:
            _path_params["job_id"] = job_id
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params["authorization"] = authorization
        if x_api_token is not None:
            _header_params["X-API-Token"] = x_api_token
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/jobs/{job_id}/events",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_job_jobs_job_id_get(
        self,
        job_id: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobResponse:
        """Get Job


        :param job_id: (required)
        :type job_id: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_job_jobs_job_id_get_serialize(
            job_id=job_id,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "JobResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_job_jobs_job_id_get_with_http_info(
        self,
        job_id: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobResponse]:
        """Get Job


        :param job_id: (required)
        :type job_id: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_job_jobs_job_id_get_serialize(
            job_id=job_id,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "JobResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_job_jobs_job_id_get_without_preload_content(
        self,
        job_id: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Job


        :param job_id: (required)
        :type job_id: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_job_jobs_job_id_get_serialize(
            job_id=job_id,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "JobResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_job_jobs_job_id_get_serialize(
        self,
        job_id,
        authorization,
        x_api_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if job_id is not None:
            _path_params["job_id"] = job_id
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params["authorization"] = authorization
        if x_api_token is not None:
            _header_params["X-API-Token"] = x_api_token
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/jobs/{job_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_jobs_jobs_get(
        self,
        status: Annotated[
            Optional[Annotated[List[ExecutionStatus], Field(min_length=1)]],
            Field(
                description=" ## filter by status  Allows multiple status filters. Add the status number "
            ),
        ] = None,
        workflow: Annotated[
            Optional[Annotated[List[UUID], Field(min_length=1)]],
            Field(
                description=" ## filter by workflow  Allows multiple workflow filters. Add the workflow ID "
            ),
        ] = None,
        start_time_from: Annotated[
            Optional[datetime], Field(description="filter by start_time from timestamp")
        ] = None,
        start_time_to: Optional[datetime] = None,
        execution_time_from: Optional[datetime] = None,
        execution_time_to: Optional[datetime] = None,
        close_time_from: Optional[datetime] = None,
        close_time_to: Optional[datetime] = None,
        sort_on: Optional[JobsSortOn] = None,
        sort_direction: Optional[SortDirection] = None,
        page_size: Optional[PageSize] = None,
        page_number: Optional[StrictInt] = None,
        q: Optional[StrictStr] = None,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> JobsResponse:
        """Get Jobs


        :param status:  ## filter by status  Allows multiple status filters. Add the status number
        :type status: List[ExecutionStatus]
        :param workflow:  ## filter by workflow  Allows multiple workflow filters. Add the workflow ID
        :type workflow: List[str]
        :param start_time_from: filter by start_time from timestamp
        :type start_time_from: datetime
        :param start_time_to:
        :type start_time_to: datetime
        :param execution_time_from:
        :type execution_time_from: datetime
        :param execution_time_to:
        :type execution_time_to: datetime
        :param close_time_from:
        :type close_time_from: datetime
        :param close_time_to:
        :type close_time_to: datetime
        :param sort_on:
        :type sort_on: JobsSortOn
        :param sort_direction:
        :type sort_direction: SortDirection
        :param page_size:
        :type page_size: PageSize
        :param page_number:
        :type page_number: int
        :param q:
        :type q: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_jobs_jobs_get_serialize(
            status=status,
            workflow=workflow,
            start_time_from=start_time_from,
            start_time_to=start_time_to,
            execution_time_from=execution_time_from,
            execution_time_to=execution_time_to,
            close_time_from=close_time_from,
            close_time_to=close_time_to,
            sort_on=sort_on,
            sort_direction=sort_direction,
            page_size=page_size,
            page_number=page_number,
            q=q,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "JobsResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_jobs_jobs_get_with_http_info(
        self,
        status: Annotated[
            Optional[Annotated[List[ExecutionStatus], Field(min_length=1)]],
            Field(
                description=" ## filter by status  Allows multiple status filters. Add the status number "
            ),
        ] = None,
        workflow: Annotated[
            Optional[Annotated[List[UUID], Field(min_length=1)]],
            Field(
                description=" ## filter by workflow  Allows multiple workflow filters. Add the workflow ID "
            ),
        ] = None,
        start_time_from: Annotated[
            Optional[datetime], Field(description="filter by start_time from timestamp")
        ] = None,
        start_time_to: Optional[datetime] = None,
        execution_time_from: Optional[datetime] = None,
        execution_time_to: Optional[datetime] = None,
        close_time_from: Optional[datetime] = None,
        close_time_to: Optional[datetime] = None,
        sort_on: Optional[JobsSortOn] = None,
        sort_direction: Optional[SortDirection] = None,
        page_size: Optional[PageSize] = None,
        page_number: Optional[StrictInt] = None,
        q: Optional[StrictStr] = None,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[JobsResponse]:
        """Get Jobs


        :param status:  ## filter by status  Allows multiple status filters. Add the status number
        :type status: List[ExecutionStatus]
        :param workflow:  ## filter by workflow  Allows multiple workflow filters. Add the workflow ID
        :type workflow: List[str]
        :param start_time_from: filter by start_time from timestamp
        :type start_time_from: datetime
        :param start_time_to:
        :type start_time_to: datetime
        :param execution_time_from:
        :type execution_time_from: datetime
        :param execution_time_to:
        :type execution_time_to: datetime
        :param close_time_from:
        :type close_time_from: datetime
        :param close_time_to:
        :type close_time_to: datetime
        :param sort_on:
        :type sort_on: JobsSortOn
        :param sort_direction:
        :type sort_direction: SortDirection
        :param page_size:
        :type page_size: PageSize
        :param page_number:
        :type page_number: int
        :param q:
        :type q: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_jobs_jobs_get_serialize(
            status=status,
            workflow=workflow,
            start_time_from=start_time_from,
            start_time_to=start_time_to,
            execution_time_from=execution_time_from,
            execution_time_to=execution_time_to,
            close_time_from=close_time_from,
            close_time_to=close_time_to,
            sort_on=sort_on,
            sort_direction=sort_direction,
            page_size=page_size,
            page_number=page_number,
            q=q,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "JobsResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_jobs_jobs_get_without_preload_content(
        self,
        status: Annotated[
            Optional[Annotated[List[ExecutionStatus], Field(min_length=1)]],
            Field(
                description=" ## filter by status  Allows multiple status filters. Add the status number "
            ),
        ] = None,
        workflow: Annotated[
            Optional[Annotated[List[UUID], Field(min_length=1)]],
            Field(
                description=" ## filter by workflow  Allows multiple workflow filters. Add the workflow ID "
            ),
        ] = None,
        start_time_from: Annotated[
            Optional[datetime], Field(description="filter by start_time from timestamp")
        ] = None,
        start_time_to: Optional[datetime] = None,
        execution_time_from: Optional[datetime] = None,
        execution_time_to: Optional[datetime] = None,
        close_time_from: Optional[datetime] = None,
        close_time_to: Optional[datetime] = None,
        sort_on: Optional[JobsSortOn] = None,
        sort_direction: Optional[SortDirection] = None,
        page_size: Optional[PageSize] = None,
        page_number: Optional[StrictInt] = None,
        q: Optional[StrictStr] = None,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Jobs


        :param status:  ## filter by status  Allows multiple status filters. Add the status number
        :type status: List[ExecutionStatus]
        :param workflow:  ## filter by workflow  Allows multiple workflow filters. Add the workflow ID
        :type workflow: List[str]
        :param start_time_from: filter by start_time from timestamp
        :type start_time_from: datetime
        :param start_time_to:
        :type start_time_to: datetime
        :param execution_time_from:
        :type execution_time_from: datetime
        :param execution_time_to:
        :type execution_time_to: datetime
        :param close_time_from:
        :type close_time_from: datetime
        :param close_time_to:
        :type close_time_to: datetime
        :param sort_on:
        :type sort_on: JobsSortOn
        :param sort_direction:
        :type sort_direction: SortDirection
        :param page_size:
        :type page_size: PageSize
        :param page_number:
        :type page_number: int
        :param q:
        :type q: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._get_jobs_jobs_get_serialize(
            status=status,
            workflow=workflow,
            start_time_from=start_time_from,
            start_time_to=start_time_to,
            execution_time_from=execution_time_from,
            execution_time_to=execution_time_to,
            close_time_from=close_time_from,
            close_time_to=close_time_to,
            sort_on=sort_on,
            sort_direction=sort_direction,
            page_size=page_size,
            page_number=page_number,
            q=q,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "JobsResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _get_jobs_jobs_get_serialize(
        self,
        status,
        workflow,
        start_time_from,
        start_time_to,
        execution_time_from,
        execution_time_to,
        close_time_from,
        close_time_to,
        sort_on,
        sort_direction,
        page_size,
        page_number,
        q,
        authorization,
        x_api_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            "status": "multi",
            "workflow": "multi",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if status is not None:

            _query_params.append(("status", status))

        if workflow is not None:

            _query_params.append(("workflow", workflow))

        if start_time_from is not None:
            if isinstance(start_time_from, datetime):
                _query_params.append(
                    (
                        "start_time_from",
                        start_time_from.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("start_time_from", start_time_from))

        if start_time_to is not None:
            if isinstance(start_time_to, datetime):
                _query_params.append(
                    (
                        "start_time_to",
                        start_time_to.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("start_time_to", start_time_to))

        if execution_time_from is not None:
            if isinstance(execution_time_from, datetime):
                _query_params.append(
                    (
                        "execution_time_from",
                        execution_time_from.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("execution_time_from", execution_time_from))

        if execution_time_to is not None:
            if isinstance(execution_time_to, datetime):
                _query_params.append(
                    (
                        "execution_time_to",
                        execution_time_to.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("execution_time_to", execution_time_to))

        if close_time_from is not None:
            if isinstance(close_time_from, datetime):
                _query_params.append(
                    (
                        "close_time_from",
                        close_time_from.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("close_time_from", close_time_from))

        if close_time_to is not None:
            if isinstance(close_time_to, datetime):
                _query_params.append(
                    (
                        "close_time_to",
                        close_time_to.strftime(
                            self.api_client.configuration.datetime_format
                        ),
                    )
                )
            else:
                _query_params.append(("close_time_to", close_time_to))

        if sort_on is not None:

            _query_params.append(("sort_on", sort_on.value))

        if sort_direction is not None:

            _query_params.append(("sort_direction", sort_direction.value))

        if page_size is not None:

            _query_params.append(("page_size", page_size.value))

        if page_number is not None:

            _query_params.append(("page_number", page_number))

        if q is not None:

            _query_params.append(("q", q))

        # process the header parameters
        if authorization is not None:
            _header_params["authorization"] = authorization
        if x_api_token is not None:
            _header_params["X-API-Token"] = x_api_token
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/jobs",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def query_job_jobs_job_id_query_get(
        self,
        job_id: StrictStr,
        query: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> QueryResponse:
        """Query Job

        query a specified workflow run

        :param job_id: (required)
        :type job_id: str
        :param query: (required)
        :type query: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_job_jobs_job_id_query_get_serialize(
            job_id=job_id,
            query=query,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "QueryResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def query_job_jobs_job_id_query_get_with_http_info(
        self,
        job_id: StrictStr,
        query: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[QueryResponse]:
        """Query Job

        query a specified workflow run

        :param job_id: (required)
        :type job_id: str
        :param query: (required)
        :type query: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_job_jobs_job_id_query_get_serialize(
            job_id=job_id,
            query=query,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "QueryResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def query_job_jobs_job_id_query_get_without_preload_content(
        self,
        job_id: StrictStr,
        query: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Query Job

        query a specified workflow run

        :param job_id: (required)
        :type job_id: str
        :param query: (required)
        :type query: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._query_job_jobs_job_id_query_get_serialize(
            job_id=job_id,
            query=query,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "QueryResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _query_job_jobs_job_id_query_get_serialize(
        self,
        job_id,
        query,
        authorization,
        x_api_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if job_id is not None:
            _path_params["job_id"] = job_id
        # process the query parameters
        if query is not None:

            _query_params.append(("query", query))

        # process the header parameters
        if authorization is not None:
            _header_params["authorization"] = authorization
        if x_api_token is not None:
            _header_params["X-API-Token"] = x_api_token
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/jobs/{job_id}/query",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def signal_job_jobs_job_id_signal_signal_patch(
        self,
        job_id: StrictStr,
        signal: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Signal Job

        send a signal to the specified workflow run

        :param job_id: (required)
        :type job_id: str
        :param signal: (required)
        :type signal: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._signal_job_jobs_job_id_signal_signal_patch_serialize(
            job_id=job_id,
            signal=signal,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "object",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def signal_job_jobs_job_id_signal_signal_patch_with_http_info(
        self,
        job_id: StrictStr,
        signal: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Signal Job

        send a signal to the specified workflow run

        :param job_id: (required)
        :type job_id: str
        :param signal: (required)
        :type signal: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._signal_job_jobs_job_id_signal_signal_patch_serialize(
            job_id=job_id,
            signal=signal,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "object",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def signal_job_jobs_job_id_signal_signal_patch_without_preload_content(
        self,
        job_id: StrictStr,
        signal: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Signal Job

        send a signal to the specified workflow run

        :param job_id: (required)
        :type job_id: str
        :param signal: (required)
        :type signal: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._signal_job_jobs_job_id_signal_signal_patch_serialize(
            job_id=job_id,
            signal=signal,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "object",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _signal_job_jobs_job_id_signal_signal_patch_serialize(
        self,
        job_id,
        signal,
        authorization,
        x_api_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if job_id is not None:
            _path_params["job_id"] = job_id
        if signal is not None:
            _path_params["signal"] = signal
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params["authorization"] = authorization
        if x_api_token is not None:
            _header_params["X-API-Token"] = x_api_token
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PATCH",
            resource_path="/jobs/{job_id}/signal/{signal}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def terminate_job_jobs_job_id_terminate_patch(
        self,
        job_id: StrictStr,
        reason: Optional[StrictStr] = None,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Terminate Job


        :param job_id: (required)
        :type job_id: str
        :param reason:
        :type reason: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._terminate_job_jobs_job_id_terminate_patch_serialize(
            job_id=job_id,
            reason=reason,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def terminate_job_jobs_job_id_terminate_patch_with_http_info(
        self,
        job_id: StrictStr,
        reason: Optional[StrictStr] = None,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Terminate Job


        :param job_id: (required)
        :type job_id: str
        :param reason:
        :type reason: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._terminate_job_jobs_job_id_terminate_patch_serialize(
            job_id=job_id,
            reason=reason,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def terminate_job_jobs_job_id_terminate_patch_without_preload_content(
        self,
        job_id: StrictStr,
        reason: Optional[StrictStr] = None,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Terminate Job


        :param job_id: (required)
        :type job_id: str
        :param reason:
        :type reason: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._terminate_job_jobs_job_id_terminate_patch_serialize(
            job_id=job_id,
            reason=reason,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "object",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _terminate_job_jobs_job_id_terminate_patch_serialize(
        self,
        job_id,
        reason,
        authorization,
        x_api_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if job_id is not None:
            _path_params["job_id"] = job_id
        # process the query parameters
        if reason is not None:

            _query_params.append(("reason", reason))

        # process the header parameters
        if authorization is not None:
            _header_params["authorization"] = authorization
        if x_api_token is not None:
            _header_params["X-API-Token"] = x_api_token
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PATCH",
            resource_path="/jobs/{job_id}/terminate",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def update_job_jobs_job_id_update_update_patch(
        self,
        job_id: StrictStr,
        update: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UpdateResponse:
        """Update Job


        :param job_id: (required)
        :type job_id: str
        :param update: (required)
        :type update: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_job_jobs_job_id_update_update_patch_serialize(
            job_id=job_id,
            update=update,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UpdateResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def update_job_jobs_job_id_update_update_patch_with_http_info(
        self,
        job_id: StrictStr,
        update: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UpdateResponse]:
        """Update Job


        :param job_id: (required)
        :type job_id: str
        :param update: (required)
        :type update: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_job_jobs_job_id_update_update_patch_serialize(
            job_id=job_id,
            update=update,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UpdateResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def update_job_jobs_job_id_update_update_patch_without_preload_content(
        self,
        job_id: StrictStr,
        update: StrictStr,
        authorization: Optional[StrictStr] = None,
        x_api_token: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Job


        :param job_id: (required)
        :type job_id: str
        :param update: (required)
        :type update: str
        :param authorization:
        :type authorization: str
        :param x_api_token:
        :type x_api_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _param = self._update_job_jobs_job_id_update_update_patch_serialize(
            job_id=job_id,
            update=update,
            authorization=authorization,
            x_api_token=x_api_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "UpdateResponse",
            "422": "HTTPValidationError",
        }

        response_data = self.api_client.call_api(
            *_param, _request_timeout=_request_timeout
        )
        return response_data.response

    def _update_job_jobs_job_id_update_update_patch_serialize(
        self,
        job_id,
        update,
        authorization,
        x_api_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if job_id is not None:
            _path_params["job_id"] = job_id
        if update is not None:
            _path_params["update"] = update
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params["authorization"] = authorization
        if x_api_token is not None:
            _header_params["X-API-Token"] = x_api_token
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json"]
            )

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PATCH",
            resource_path="/jobs{job_id}/update/{update}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
