from __future__ import annotations

from datetime import date, datetime
from decimal import Decimal

from django import VERSION as _django_version
from django.db import models
from django.db.models.expressions import RawSQL


class TriggerCharField(models.CharField):
    """
    Mark a char field as automatically generated by a database trigger.

    - `db_returning = True` ensures that the model instance is updated after save() with the value computed by the database trigger.
    """
    db_returning = True
    editable = False

    def formfield(self, **kwargs):
        return None
    

def get_django_field_python_type(field: models.Field) -> type|None:
    if not isinstance(field, models.Field):
        raise TypeError(f"field: {type(field).__name__}")

    if isinstance(field, models.CharField):
        return str
    elif isinstance(field, models.TextField):
        return str
    elif isinstance(field, models.BooleanField):
        return bool
    elif isinstance(field, models.IntegerField):
        return int
    elif isinstance(field, models.FloatField):
        return float
    elif isinstance(field, models.DecimalField):
        return Decimal
    elif isinstance(field, models.DateTimeField):
        return datetime
    elif isinstance(field, models.DateField):
        return date
    elif isinstance(field, models.JSONField):
        return dict
    elif isinstance(field, models.ForeignKey):
        pk = None
        for field in field.related_model._meta.fields:
            if field.primary_key:
                pk = field
                break
        return get_django_field_python_type(pk) if pk else None
    elif type(field).__name__ == 'ArrayField':
        return list
    else:
        return None # we don't want to make false assumptions (e.g. we would probably want 'str' in the context of a load table and 'int' for a foreign key field)


if _django_version >= (5, 0):
    class GeneratedSlugField(models.GeneratedField): # type: ignore
        db_returning = True
        editable = False

        def __init__(self, column_name: str, *, max_length: int, db_index = False, unique = False, db_persist = True, **kwargs):
            self._column_name = column_name
            self._max_length = max_length
            if not isinstance(self._max_length, int):
                raise TypeError(f"Invalid max_length: {self._max_length}")

            super().__init__(
                expression = RawSQL(f'slugen({column_name})', ()),
                output_field = models.SlugField(max_length=max_length),
                db_persist=db_persist,
                db_index=db_index,
                unique=unique,
                **kwargs
            )

        def deconstruct(self):
            name, path, args, kwargs = super().deconstruct()
            del kwargs["expression"]
            del kwargs["output_field"]
            kwargs["column_name"] = self._column_name
            kwargs["max_length"] = self._max_length
            return name, path, args, kwargs
