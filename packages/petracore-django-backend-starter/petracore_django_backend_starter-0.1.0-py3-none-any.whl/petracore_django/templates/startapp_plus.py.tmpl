import re
from pathlib import Path
from textwrap import dedent

import os
import importlib

from django.conf import settings
from django.core.management import call_command
from django.core.management.base import BaseCommand, CommandError


def model_name_from_app(app_name: str) -> str:
    base = "".join(part.capitalize() for part in app_name.split("_"))
    return base[:-1] if base.endswith("s") and len(base) > 1 else base


def parse_fields(fields_str: str) -> str:
    """
    Accepts: 'name:CharField(max_length=255),is_active:BooleanField(default=True)'
    Returns indented model field lines, or sensible defaults if empty.
    """
    fields_str = (fields_str or "").strip()
    if not fields_str:
        return dedent("""
            name = models.CharField(max_length=1000)
            description = models.CharField(max_length=20000, null=True, blank=True)
        """).strip()

    lines = []
    for chunk in [c.strip() for c in fields_str.split(",") if c.strip()]:
        if ":" not in chunk:
            raise CommandError(f"Bad field spec '{chunk}'. Use name:FieldType(args)")
        name, type_ = [p.strip() for p in chunk.split(":", 1)]
        rhs = type_ if type_.startswith("models.") else f"models.{type_}"
        lines.append(f"{name} = {rhs}")
    return "\n".join(lines)


def write_file(path: Path, content: str, force: bool):
    if path.exists() and not force:
        return
    path.write_text(content, encoding="utf-8")


def _append_installed_apps(settings_txt, apps):
    """Append missing apps to INSTALLED_APPS, fixing ctomma placement (list or tuple)."""
    # Try list form: INSTALLED_APPS = [ ... ]
    m = re.search(r"INSTALLED_APPS\s*=\s*\[(.*?)\]", settings_txt, flags=re.S | re.M)
    if m:
        block = m.group(1)
        missing = [a for a in apps if re.search(rf"['\"]{re.escape(a)}['\"]", block) is None]
        if not missing:
            return settings_txt
        block_rstrip = block.rstrip()
        trimmed = block_rstrip.rstrip()
        needs_leading_comma = bool(trimmed and not trimmed.endswith(','))
        insertion = (',' if needs_leading_comma else '') + ''.join(f"\n    '{a}'," for a in missing)
        new_block = block_rstrip + insertion
        return settings_txt[:m.start(1)] + new_block + settings_txt[m.end(1):]

    # Try tuple form: INSTALLED_APPS = ( ... )
    m = re.search(r"INSTALLED_APPS\s*=\s*\((.*?)\)", settings_txt, flags=re.S | re.M)
    if m:
        block = m.group(1)
        missing = [a for a in apps if re.search(rf"['\"]{re.escape(a)}['\"]", block) is None]
        if not missing:
            return settings_txt
        block_rstrip = block.rstrip()
        trimmed = block_rstrip.rstrip()
        needs_leading_comma = bool(trimmed and not trimmed.endswith(','))
        insertion = (',' if needs_leading_comma else '') + ''.join(f"\n    '{a}'," for a in missing)
        new_block = block_rstrip + insertion
        return settings_txt[:m.start(1)] + new_block + settings_txt[m.end(1):]

    # If INSTALLED_APPS not found, leave file unchanged
    return settings_txt


def tmpl_models(model_name: str, fields_block: str) -> str:
    from textwrap import indent  # local import to avoid changing global imports

    # Ensure all field lines are indented 8 spaces to align under the class block.
    fields_block = (fields_block or "").strip()
    indented_fields = indent(fields_block, " " * 8) if fields_block else "        pass"

    return dedent(f"""
    \"\"\"
    Auto-generated by startapp_plus
    \"\"\"
    from core.models import CreatedModified, models


    class {model_name}(CreatedModified):
{indented_fields}

        class Meta:
            ordering = ['-date_created']

        def __str__(self):
            return getattr(self, 'name', f"{model_name} {{self.pk}}")
    """).lstrip()


def tmpl_services(app_name: str, model_name: str) -> str:
    return dedent(f"""
    \"\"\"
    Service layer for {app_name}
    \"\"\"
    from core.base_service import Repository
    from .models import {model_name}

    Base{model_name}Service = Repository.create_service({model_name})


    class {model_name}Service(Base{model_name}Service):
        \"\"\"Extend with domain logic and hooks (create/update/delete).\"\"\"
        @classmethod
        def create(cls, **data):
            obj = super().create(**data)
            return obj
    """).lstrip()


def tmpl_serializers(model_name: str) -> str:
    return dedent(f"""
    from rest_framework import serializers
    from .models import {model_name}


    class {model_name}Serializer(serializers.ModelSerializer):
        class Meta:
            model = {model_name}
            fields = '__all__'
            depth = 1


    class CreateUpdate{model_name}Serializer(serializers.Serializer):
        \"\"\"Use this for create/update payloads if you don't want to expose all fields.\"\"\"
        pass
    """).lstrip()


def tmpl_views(app_name: str, model_name: str) -> str:
    return dedent(f"""
    from rest_framework import status
    from rest_framework.parsers import JSONParser, MultiPartParser, FormParser
    from rest_framework.permissions import IsAuthenticated
    from rest_framework.response import Response
    from rest_framework.viewsets import ModelViewSet

    from .models import {model_name}
    from .services import {model_name}Service
    from .serializers import {model_name}Serializer, CreateUpdate{model_name}Serializer


    class {model_name}ViewSet(ModelViewSet):
        serializer_class = CreateUpdate{model_name}Serializer
        response_serializer_class = {model_name}Serializer
        permission_classes = [IsAuthenticated]
        service_class = {model_name}Service
        parser_classes = [JSONParser, MultiPartParser, FormParser]

        def get_queryset(self):
            return {model_name}.objects.all()

        def list(self, request, *args, **kwargs):
            qs = self.filter_queryset(self.get_queryset())
            ser = self.response_serializer_class(qs, many=True)
            return Response(ser.data)

        def retrieve(self, request, *args, **kwargs):
            obj = self.get_object()
            ser = self.response_serializer_class(obj)
            return Response(ser.data)

        def create(self, request, *args, **kwargs):
            ser = self.get_serializer(data=request.data)
            ser.is_valid(raise_exception=True)
            obj = self.service_class.create(**ser.validated_data)
            out = self.response_serializer_class(obj)
            return Response(out.data, status=status.HTTP_201_CREATED)

        def update(self, request, *args, **kwargs):
            obj = self.get_object()
            ser = self.get_serializer(obj, data=request.data, partial=False)
            ser.is_valid(raise_exception=True)
            updated = self.service_class.update_object(pk=obj.pk, **ser.validated_data)
            out = self.response_serializer_class(updated)
            return Response(out.data)

        def partial_update(self, request, *args, **kwargs):
            obj = self.get_object()
            ser = self.get_serializer(obj, data=request.data, partial=True)
            ser.is_valid(raise_exception=True)
            updated = self.service_class.update_object(pk=obj.pk, **ser.validated_data)
            out = self.response_serializer_class(updated)
            return Response(out.data)

        def destroy(self, request, *args, **kwargs):
            obj = self.get_object()
            self.service_class.delete_object(pk=obj.pk)
            return Response(status=status.HTTP_204_NO_CONTENT)
    """).lstrip()


def tmpl_urls(app_name: str, model_name: str) -> str:
    lname = model_name.lower()
    return dedent(f"""
    from rest_framework.routers import DefaultRouter
    from .views import {model_name}ViewSet

    router = DefaultRouter()
    router.register(r'{lname}s', {model_name}ViewSet, basename='{lname}')

    urlpatterns = router.urls
    """).lstrip()


class Command(BaseCommand):
    help = "Create a Django app and scaffold models/services/serializers/views/urls with project-style stubs."

    def add_arguments(self, parser):
        parser.add_argument("app_name", help="App label (letters, numbers, underscores).")
        parser.add_argument("--model", dest="model_name", help="Model class name.")
        parser.add_argument("--fields", dest="fields", default="", help="CSV: name:FieldType(args)")
        parser.add_argument("--force", action="store_true", help="Overwrite generated files if they already exist.")

    def handle(self, *args, **opts):
        app_name = opts["app_name"].strip()
        if not re.match(r"^[A-Za-z_][A-Za-z0-9_]*$", app_name):
            raise CommandError(f"'{app_name}' is not a valid app name. Use letters, numbers, and underscores only.")

        model_name = opts["model_name"] or model_name_from_app(app_name)
        fields_block = parse_fields(opts["fields"])

        base_dir = Path(getattr(settings, "BASE_DIR", "."))
        app_dir = base_dir / app_name

        if not app_dir.exists():
            call_command("startapp", app_name)

        from pathlib import Path as _P
        def _w(p, c): _P(p).write_text(c, encoding="utf-8")

        _w(app_dir / "models.py", tmpl_models(model_name, fields_block))
        _w(app_dir / "services.py", tmpl_services(app_name, model_name))
        _w(app_dir / "serializers.py", tmpl_serializers(model_name))
        _w(app_dir / "views.py", tmpl_views(app_name, model_name))
        _w(app_dir / "urls.py", tmpl_urls(app_name, model_name))

        # Try to add the app to INSTALLED_APPS in settings.py
        try:
            # Resolve the actual settings module file path robustly.
            # settings.__file__ is not available on the Settings object, so use the module.
            module_name = os.environ.get("DJANGO_SETTINGS_MODULE") or getattr(settings, "SETTINGS_MODULE", None)
            if not module_name:
                raise RuntimeError("DJANGO_SETTINGS_MODULE is not set. Make sure you run via manage.py or set the env var.")

            mod = importlib.import_module(module_name)
            settings_path = Path(getattr(mod, "__file__", "")).resolve()
            if not settings_path:
                raise RuntimeError(f"Could not resolve a path for settings module: {module_name}")
            if settings_path.suffix == ".pyc":
                settings_path = settings_path.with_suffix('.py')

            # Try updating the resolved settings file first
            s_txt = settings_path.read_text(encoding="utf-8")
            s_new = _append_installed_apps(s_txt, [app_name])
            if s_new != s_txt:
                settings_path.write_text(s_new, encoding="utf-8")
                self.stdout.write(self.style.SUCCESS(f"Added '{app_name}' to INSTALLED_APPS in {settings_path.name}."))
            else:
                # If INSTALLED_APPS isn't found (common when using a package layout like settings/__init__.py
                # that imports from base.py), attempt a best-effort update of base.py next to __init__.py.
                if settings_path.name == "__init__.py":
                    base_path = settings_path.with_name("base.py")
                    if base_path.exists():
                        b_txt = base_path.read_text(encoding="utf-8")
                        b_new = _append_installed_apps(b_txt, [app_name])
                        if b_new != b_txt:
                            base_path.write_text(b_new, encoding="utf-8")
                            self.stdout.write(self.style.SUCCESS(f"Added '{app_name}' to INSTALLED_APPS in {base_path.name}."))
                        else:
                            self.stdout.write(self.style.WARNING(f"'{app_name}' already present in INSTALLED_APPS."))
                    else:
                        self.stdout.write(self.style.WARNING(f"'{app_name}' already present in INSTALLED_APPS."))
                else:
                    self.stdout.write(self.style.WARNING(f"'{app_name}' already present in INSTALLED_APPS."))
        except Exception as e:
            self.stdout.write(self.style.WARNING(f"Couldn't update INSTALLED_APPS automatically: {e}"))

        self.stdout.write(self.style.SUCCESS(
            f"Scaffolded app '{app_name}' with model '{model_name}' and stubs (services/serializers/views/urls)."
        ))