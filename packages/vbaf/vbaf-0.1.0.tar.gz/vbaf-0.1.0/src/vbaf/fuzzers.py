"""Fuzzers for the implementation of Vocabulary-Based Adversarial Fuzzing (VB-AF)"""

import random
import inspect
from typing import Callable, Generator, Union


class VBAF:
    """A framework class implementation for Vocabulary-Based Adversarial Fuzzing (VB-AF).

    This class encapsulates the implementation logic for generating and applying VB-AF attacks.
    It can be used to create fuzzer instances with specific configurations and then apply them to
    inference functions, either through direct payload generation or via a convenient decorator.
    """

    def __init__(
        self,
        vocabulary: list[str],
        seed: Union[int, None] = None,
        separator: str = "\u200b",
        join_on: str = "",
        rand_bounds: tuple[int] = (7, 21),
        position_bounds: tuple[float] = (0.5, 0.6),
        n_size: int = 100,
    ):
        """Initializes the VB-AF fuzzer with a specific instance configuration.

        Args:
            vocabulary (list[str]): A list of tokens (strings) to sample from to create the surrounding noise.
            seed (int | None, optional): An integer seed for `random` to ensure reproducible fuzzing. Defaults to `None`.
            separator (str, optional): The character used to join individual tokens. Defaults to Zero-Width Space (ZWSP) '\\u200b'.
            join_on (str, optional): The character used to join the `n_size` token sequences. Defaults to an empty string.
            rand_bounds (tuple[int], optional): A (min, max) tuple defining the inclusive range for the number of tokens in each noise sequence. Defaults to (7, 21).
            position_bounds (tuple[float], optional): A (min, max) float tuple defining the range `[int(min * n_size), int(max * n_size)]` from which to randomly select the payload's position. Defaults to (0.5, 0.6).
            n_size (int, optional): The total number of token sequences in the final prompt. Defaults to 100.
        """
        self.vocabulary = vocabulary
        self.seed = seed
        self.separator = separator
        self.join_on = join_on
        self.rand_bounds = rand_bounds
        self.position_bounds = position_bounds
        self.n_size = n_size
        pass

    def generate_fuzzy_payload(self, payload: str) -> str:
        """Generates a single adversarial prompt using the VB-AF method based on the instance configuration.

        This function creates a fuzzy payload by embedding a string request (`payload`) within a
        larger block of chaotic token-based noise. The noise is generated by sampling from a provided
        token `vocabulary`.

        Args:
            payload (str): The target string / request to embed in the noise.

        Returns:
            str: The fully constructed adversarial fuzzy payload.

        Raises:
            AssertionError:

                - If `payload` is not a string instance,
                - If `rand_bounds` defines an invalid or out-of-bounds range
                - If `position_bounds` defines an invalid range not included in [0,1]
                - If `n_size` is not a positive integer.
        """
        vocabulary_size = len(self.vocabulary)

        # Ensure that payload is a str object
        assert isinstance(payload, str), f"Payload must be a string instance"

        # Fix a seed if available
        if self.seed is not None:
            random.seed(self.seed)

        # Fuzzy payload must never be empty
        assert self.n_size > 0, f"n_size must be > 0, but got n_size={self.n_size}"

        # Ensure that a token sequence can never be longer than the vocabulary itself
        assert (
            0 <= self.rand_bounds[0] < self.rand_bounds[1] <= vocabulary_size
        ), f"rand_bounds must define a valid inclusive range within [0, {vocabulary_size}], but got rand_bounds={self.rand_bounds}"

        # Similarly, also ensure that position bounds is within proportion
        assert (
            0 <= self.position_bounds[0] < self.position_bounds[1] <= 1
        ), f"position_bounds must define a valid inclusive range within [0,1], but got position_bounds={self.position_bounds}"

        argK_min: float
        argK_max: float
        argK_min, argK_max = self.position_bounds

        # Random position of the payload
        argK: int = random.randint(
            int(argK_min * self.n_size), int(argK_max * self.n_size)
        )

        # Join all token sequences into a single fuzzy payload
        fuzzy_payload: str = self.join_on.join(
            [
                (
                    (
                        # Join all tokens into a sequence using this separator
                        self.separator.join(
                            # All token sequences are of random length k
                            random.choices(
                                self.vocabulary, k=random.randint(*self.rand_bounds)
                            )
                        )
                    )
                    if k != argK
                    else f"{self.separator}{payload}{self.separator}"  # Payload is injected exactly at argK
                )
                for k in range(self.n_size)
            ]
        )

        return fuzzy_payload

    def fuzz(self, n_attempts: int = 100, **kwargs) -> Callable:
        """A decorator to apply VB-AF to an inference function.

        This decorator wraps an inference function that takes a string payload as its first argument (e.g. a function that calls an LLM's API). It
        transforms the decorated function into a fuzzing harness (generator) that, for each call, yields `n_attempts` of results by passing a newly
        generated fuzzy payload to the original inference function on each iteration.

        Args:
            n_attempts (int, optional): The number of fuzzing attempts to generate for each call to the decorated function. Defaults to 100.
            **kwargs (any): Arbitrary keyword arguments that will be passed either to the fuzzer or the decorated function. The decorator will intelligently
                pass fuzzer-related parameters (like `rand_bounds`) to the fuzzer and the rest to the inference function.

        Returns:
            Callable: A decorator that transforms an inference function into a fuzzing harness generator.

        Raises:
            AssertionError:

                - If `n_attempts` is not a positive integer
                - If the decorated function does not accept at least one positional string argument.

        Example:
            ```python
            from vbaf import VBAF

            tokens = [str(i) for i in range(10)]
            fuzzer = VBAF(tokens, n_size=15, rand_bounds=(2,5))

            @fuzzer.fuzz(n_attempts=3)
            def fuzzing_harness(prompt: str):
                # Realistically, this would call and LLM API
                return f"Mock response for: {prompt}"

            for fuzzy_payload, result in fuzzing_harness("my payload here"):
                print(f"Input: {fuzzy_payload}")
                print(f"Result: {result}")
            ```

        Note:
            Results from the fuzzing harness are yielded as tuples in the form of `(fuzzy_payload, response)`. This allows for direct analysis of the payload-response mapping.
        """

        # Number of attempts must be a positive integer
        assert (
            n_attempts > 0
        ), f"n_attempts must be > 0, but got n_attempts={n_attempts}"

        # A decorator that wraps around the LLM inference function
        def decorator(inference: Callable) -> Callable:
            # Separating parameters being sent to payload generator and the inference function
            sig = inspect.signature(self.generate_fuzzy_payload)
            fuzzer_params = set(sig.parameters.keys())

            infer_sig = inspect.signature(inference)
            infer_params = list(infer_sig.parameters.values())
            first_infer_param = infer_params[0]

            assert (
                len(infer_params) >= 1
            ), "Inference function to harness must take at least a first string parameter e.g. request: str"

            if first_infer_param.annotation is not inspect.Parameter.empty:
                assert (
                    first_infer_param.annotation == str
                ), "First parameter of inference must be annotated as str."

            assert first_infer_param.kind in (
                inspect.Parameter.POSITIONAL_ONLY,
                inspect.Parameter.POSITIONAL_OR_KEYWORD,
            ), "First parameter of inference must be a positional argument (e.g. `def foo(request: str): ...`)."

            def wrapper(request: str, *args) -> Generator:
                for _ in range(n_attempts):
                    fuzzy_payload = self.generate_fuzzy_payload(request)

                    inference_kwargs = {
                        key: value
                        for key, value in kwargs.items()
                        if key not in fuzzer_params
                    }

                    # This result can be the final response by the LLM, or a mixture of items, like involved Chain-of-Thought (CoT), response metadata
                    result = inference(fuzzy_payload, *args, **inference_kwargs)

                    yield (
                        fuzzy_payload,
                        result,
                    )  # We often require fuzzy_payload for outcome analysis, this can be unpacked for analysis

            return wrapper

        return decorator
