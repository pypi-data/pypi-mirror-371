# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: scandal/scandal.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class Source(betterproto.Message):
    url: str = betterproto.string_field(1)
    content_type: Optional[str] = betterproto.string_field(2, optional=True)
    size: Optional[int] = betterproto.int64_field(3, optional=True)
    parquet: "MetadataParquet" = betterproto.message_field(10, group="metadata")


@dataclass(eq=False, repr=False)
class Metadata(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class MetadataParquet(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class Sink(betterproto.Message):
    url: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Connectivity(betterproto.Message):
    """
    Information about the client's perceived connectivity to a FileSystem.
    """

    unreachable: bool = betterproto.bool_field(1)
    round_trip_time_us: Optional[int] = betterproto.int32_field(2, optional=True)


@dataclass(eq=False, repr=False)
class Fetch(betterproto.Message):
    """Let's make "fetch" happen."""

    pass


@dataclass(eq=False, repr=False)
class FetchRequest(betterproto.Message):
    """TODO(ngates): include projection expression."""

    uri: str = betterproto.string_field(1)
    """
    A signed request to read an
     spfs://&lt;fsid&gt;/path?token=&lt;jwt&gt URI.
    """

    connectivity: "Connectivity" = betterproto.message_field(2)
    """Declares whether the client has connectivity to the FileSystem."""

    accepts: List[str] = betterproto.string_field(3)
    """Declares the MIME types the client can read directly."""


@dataclass(eq=False, repr=False)
class FetchResponse(betterproto.Message):
    sources: List["Source"] = betterproto.message_field(1)
    """
    The sources the client should use to attempt to read the file.
     The client should try each source in order until it finds one that works.
    """


@dataclass(eq=False, repr=False)
class Put(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class PutRequest(betterproto.Message):
    uri: str = betterproto.string_field(1)
    connectivity: "Connectivity" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class PutResponse(betterproto.Message):
    sinks: List["Sink"] = betterproto.message_field(1)


class ScandalServiceStub(betterproto.ServiceStub):
    async def fetch(
        self,
        fetch_request: "FetchRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "FetchResponse":
        return await self._unary_unary(
            "/scandal.ScandalService/Fetch",
            fetch_request,
            FetchResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def put(
        self,
        put_request: "PutRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PutResponse":
        return await self._unary_unary(
            "/scandal.ScandalService/Put",
            put_request,
            PutResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class ScandalServiceBase(ServiceBase):
    async def fetch(self, fetch_request: "FetchRequest") -> "FetchResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def put(self, put_request: "PutRequest") -> "PutResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_fetch(
        self, stream: "grpclib.server.Stream[FetchRequest, FetchResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.fetch(request)
        await stream.send_message(response)

    async def __rpc_put(
        self, stream: "grpclib.server.Stream[PutRequest, PutResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.put(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/scandal.ScandalService/Fetch": grpclib.const.Handler(
                self.__rpc_fetch,
                grpclib.const.Cardinality.UNARY_UNARY,
                FetchRequest,
                FetchResponse,
            ),
            "/scandal.ScandalService/Put": grpclib.const.Handler(
                self.__rpc_put,
                grpclib.const.Cardinality.UNARY_UNARY,
                PutRequest,
                PutResponse,
            ),
        }
