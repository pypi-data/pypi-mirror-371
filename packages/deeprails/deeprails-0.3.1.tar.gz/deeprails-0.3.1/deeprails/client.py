import httpx
from typing import List, Optional, Dict, Any

from .schemas import EvaluationResponse
from .exceptions import DeepRailsAPIError

class DeepRails:
    """
    Python SDK client for the DeepRails API.
    """

    def __init__(self, token: str, base_url: str = "https://api.deeprails.com"):
        """
        Initializes the DeepRails client.

        Args:
            token: Your DeepRails API key (starts with 'sk_').
            base_url: The base URL of the DeepRails API.
        """
        if not token:
            raise ValueError("A valid DeepRails API token is required.")
        
        self._base_url = base_url
        self._headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
            "User-Agent": "deeprails-python-sdk/0.3.0"
        }
        self._client = httpx.Client(base_url=self._base_url, headers=self._headers, timeout=30.0)


    def _request(self, method: str, endpoint: str, **kwargs) -> httpx.Response:
        """Helper method to make requests and handle API errors."""
        try:
            response = self._client.request(method, endpoint, **kwargs)
            response.raise_for_status()
            return response
        except httpx.HTTPStatusError as e:
            error_detail = "No detail provided."
            try:
                error_detail = e.response.json().get("detail", error_detail)
            except Exception:
                error_detail = e.response.text
            raise DeepRailsAPIError(status_code=e.response.status_code, error_detail=error_detail) from e
        except httpx.RequestError as e:
            raise DeepRailsAPIError(status_code=500, error_detail=f"Request failed: {e}") from e


    def create_evaluation(
        self,
        *,
        model_input: Dict[str, Any],
        model_output: str,
        model_used: Optional[str] = None,
        run_mode: Optional[str] = "smart",  # Set default to "smart"
        guardrail_metrics: Optional[List[str]] = None,
        nametag: Optional[str] = None,
        webhook: Optional[str] = None
    ) -> EvaluationResponse:
        """
        Creates a new evaluation and immediately processes it.

        Args:
            model_input: A dictionary containing the inputs for the model.
                         Must contain a "user_prompt" key.
            model_output: The response generated by the model you are evaluating.
            model_used: The name or identifier of the model being evaluated.
            run_mode: The evaluation mode (e.g., "smart", "dev").
            guardrail_metrics: A list of metrics to evaluate.
            nametag: A user-defined name or tag for the evaluation.
            webhook: A URL to send a POST request to upon evaluation completion.

        Returns:
            An EvaluationResponse object with the details of the created evaluation.
        """
        if "user_prompt" not in model_input:
            raise ValueError("`model_input` must contain a 'user_prompt' key.")

        payload = {
            "model_input": model_input,
            "model_output": model_output,
            "model_used": model_used,
            "run_mode": run_mode,
            "guardrail_metrics": guardrail_metrics,
            "nametag": nametag,
            "webhook": webhook,
        }
        json_payload = {k: v for k, v in payload.items() if v is not None}

        response = self._request("POST", "/evaluate", json=json_payload)
        return EvaluationResponse.parse_obj(response.json())


    def get_evaluation(self, eval_id: str) -> EvaluationResponse:
        """
        Retrieves the status and results of a specific evaluation.

        Args:
            eval_id: The unique identifier of the evaluation.

        Returns:
            An EvaluationResponse object with the full, up-to-date details of the evaluation.
        """
        response = self._request("GET", f"/evaluate/{eval_id}")
        return EvaluationResponse.parse_obj(response.json())


    def create_monitor(
        self,
        *,
        name: str,
        description: Optional[str] = None
    ) -> MonitorResponse:
        """
        Creates a new monitor for tracking AI responses.

        Args:
            name: A name for the monitor.
            description: Optional description of the monitor's purpose.

        Returns:
            A MonitorResponse object with the details of the created monitor.
        """
        payload = {
            "name": name,
            "description": description
        }
        
        # Remove None values
        json_payload = {k: v for k, v in payload.items() if v is not None}

        response = self._request("POST", "/monitor", json=json_payload)
        response_json = response.json()
        
        # Handle DeepRails API response structure
        if "data" in response_json:
            return MonitorResponse.parse_obj(response_json["data"])
        else:
            return MonitorResponse.parse_obj(response_json)

    def get_monitor(self, monitor_id: str) -> MonitorResponse:
        """
        Get details of a specific monitor.

        Args:
            monitor_id: The ID of the monitor to retrieve.

        Returns:
            A MonitorResponse object with the monitor details.
        """
        response = self._request("GET", f"/monitor/{monitor_id}")
        response_json = response.json()
        
        # Handle DeepRails API response structure
        if "data" in response_json:
            return MonitorResponse.parse_obj(response_json["data"])
        else:
            return MonitorResponse.parse_obj(response_json)

    def create_monitor_event(
        self,
        *,
        monitor_id: str,
        model_input: Dict[str, Any],
        model_output: str,
        guardrail_metrics: List[str],
        model_used: Optional[str] = None,
        run_mode: Optional[str] = None,
        nametag: Optional[str] = None,
        webhook: Optional[str] = None
    ) -> MonitorEventResponse:
        """
        Creates a new event for a monitor.
        
        Args:
            monitor_id: The ID of the monitor to create an event for.
            model_input: A dictionary containing the inputs for the model.
            model_output: The response generated by the model you are evaluating.
            guardrail_metrics: A list of metrics to evaluate.
            model_used: The name or identifier of the model being evaluated.
            run_mode: The evaluation mode (e.g., "smart", "dev").
            nametag: A user-defined name or tag for the event.
            webhook: A URL to send a POST request to upon evaluation completion.
        
        Returns:
            A MonitorEventResponse object with the details of the created event.
        """
        payload = {
            "model_input": model_input,
            "model_output": model_output,
            "model_used": model_used,
            "run_mode": run_mode,
            "guardrail_metrics": guardrail_metrics,
            "nametag": nametag,
            "webhook": webhook,
        }
        
        # Remove None values
        json_payload = {k: v for k, v in payload.items() if v is not None}
        
        response = self._request("POST", f"/monitor/{monitor_id}/events", json=json_payload)
        response_json = response.json()
        
        # Handle DeepRails API response structure
        if "data" in response_json:
            return MonitorEventResponse.parse_obj(response_json["data"])
        else:
            return MonitorEventResponse.parse_obj(response_json)

    def get_monitor_events(
        self, 
        monitor_id: str, 
        limit: int = 10, 
        offset: int = 0
    ) -> List[MonitorEventResponse]:
        """
        Retrieves events for a specific monitor.
        
        Args:
            monitor_id: The ID of the monitor to get events for.
            limit: Maximum number of events to return (default: 10).
            offset: Offset for pagination (default: 0).
            
        Returns:
            A list of MonitorEventResponse objects with details of the monitor events.
        """
        params = {
            "limit": limit,
            "offset": offset
        }
        
        response = self._request("GET", f"/monitor/{monitor_id}/events", params=params)
        response_json = response.json()
        
        # Handle DeepRails API response structure
        if "data" in response_json and isinstance(response_json["data"], list):
            return [MonitorEventResponse.parse_obj(event) for event in response_json["data"]]
        else:
            # Fallback if the response structure is unexpected
            return []

    def get_monitors(
        self,
        *,
        page: int = 1,
        limit: int = 20,
        search: Optional[List[str]] = None,
        monitor_status: Optional[List[str]] = None,
        date_from: Optional[str] = None,
        date_to: Optional[str] = None,
        sort_by: str = "created_at",
        sort_order: str = "desc"
    ) -> MonitorListResponse:
        """
        Get a paginated list of monitors with optional filtering.
        
        Args:
            page: Page number for pagination (default: 1)
            limit: Number of items per page (default: 20, max: 100)
            search: Optional list of free-text search terms
            monitor_status: Optional list of monitor statuses ("active", "inactive", "all")
            date_from: Optional filter for monitors from this date (ISO format)
            date_to: Optional filter for monitors to this date (ISO format)
            sort_by: Field to sort by (default: "created_at")
            sort_order: Sort order (default: "desc")
            
        Returns:
            A MonitorListResponse object containing monitors, pagination info, and applied filters.
        """
        params = {
            "page": page,
            "limit": limit,
            "sort_by": sort_by,
            "sort_order": sort_order,
            "search": search,
            "monitor_status": monitor_status,
            "date_from": date_from,
            "date_to": date_to
        }
        
        # Remove None values
        params = {k: v for k, v in params.items() if v is not None}
        
        response = self._request("GET", "/monitor", params=params)
        return MonitorListResponse.parse_obj(response.json())