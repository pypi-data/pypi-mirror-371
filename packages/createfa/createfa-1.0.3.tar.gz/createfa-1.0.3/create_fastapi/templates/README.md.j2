# Structure complète du package avec templates

# MANIFEST.in
recursive-include create_fastapi/templates *.j2
include README.md
include LICENSE
include requirements.txt

# ============================================================

# pyproject.toml (alternative moderne à setup.py)
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "fastapi-generator"
version = "1.0.0"
authors = [
    {name = "Votre Nom", email = "votre.email@example.com"},
]
description = "Un générateur d'applications FastAPI avec structure complète"
readme = "README.md"
license = {text = "MIT"}
requires-python = ">=3.8"
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: MIT License",
    "Operating System :: OS Independent",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.8",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Topic :: Software Development :: Code Generators",
]
keywords = ["fastapi", "generator", "api", "web", "framework"]
dependencies = [
    "click>=8.0.0",
    "jinja2>=3.0.0",
    "colorama>=0.4.0",
]

[project.urls]
"Homepage" = "https://github.com/votrenom/fastapi-generator"
"Bug Tracker" = "https://github.com/votrenom/fastapi-generator/issues"

[project.scripts]
fastapi-gen = "create_fastapi.cli:main"
fastapi-generator = "create_fastapi.cli:main"

# ============================================================

# create_fastapi/templates/main.py.j2
"""Application FastAPI générée automatiquement"""

from fastapi import FastAPI
{% if include_docker %}
from fastapi.middleware.cors import CORSMiddleware
{% endif %}
{% if database != 'none' %}
from app.core.database import engine, Base
{% endif %}
from app.routers import items

# Créer les tables de base de données
{% if database != 'none' %}
Base.metadata.create_all(bind=engine)
{% endif %}

app = FastAPI(
    title="{{ project_name.title() }} API",
    description="API générée avec FastAPI Generator",
    version="1.0.0",
    docs_url="/docs",
    redoc_url="/redoc"
)

{% if include_docker %}
# Configuration CORS pour Docker
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # À configurer selon vos besoins
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
{% endif %}

# Inclusion des routers
app.include_router(items.router)

@app.get("/")
async def root():
    """Point d'entrée principal de l'API"""
    return {
        "message": "Bienvenue sur {{ project_name.title() }} API!",
        "docs": "/docs",
        "redoc": "/redoc"
    }

@app.get("/health")
async def health_check():
    """Endpoint de vérification de santé"""
    return {"status": "healthy", "service": "{{ project_name }}"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000, reload=True)

# ============================================================

# create_fastapi/templates/requirements.txt.j2
# FastAPI et serveur
fastapi==0.104.1
uvicorn[standard]==0.24.0

# Validation et sérialisation
pydantic==2.4.2
pydantic-settings==2.0.3

# Autres dépendances
python-multipart==0.0.6
python-jose[cryptography]==3.3.0

{% if database == 'postgresql' %}
# PostgreSQL
asyncpg==0.29.0
psycopg2-binary==2.9.7
{% elif database == 'mysql' %}
# MySQL
aiomysql==0.2.0
PyMySQL==1.1.0
{% elif database == 'sqlite' %}
# SQLite
aiosqlite==0.19.0
{% endif %}

{% if database != 'none' %}
# ORM
sqlalchemy==2.0.23
alembic==1.12.1
{% endif %}

{% if include_auth %}
# Authentification
passlib[bcrypt]==1.7.4
python-multipart==0.0.6
{% endif %}

{% if include_tests %}
# Tests
pytest==7.4.3
pytest-asyncio==0.21.1
httpx==0.25.2
{% endif %}

# Développement
python-dotenv==1.0.0

# ============================================================

# create_fastapi/templates/router_example.py.j2
"""Router d'exemple pour les items"""

from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from typing import List, Optional
{% if database != 'none' %}
from sqlalchemy.orm import Session
from app.core.database import get_db
{% endif %}

router = APIRouter(
    prefix="/items",
    tags=["items"],
    responses={404: {"description": "Not found"}},
)

# Modèles Pydantic
class ItemBase(BaseModel):
    name: str
    description: Optional[str] = None
    price: float

class ItemCreate(ItemBase):
    pass

class Item(ItemBase):
    id: int
    
    class Config:
        from_attributes = True

{% if database == 'none' %}
# Base de données fictive en mémoire
fake_items_db = [
    {"id": 1, "name": "Laptop", "description": "Ordinateur portable", "price": 999.99},
    {"id": 2, "name": "Mouse", "description": "Souris sans fil", "price": 29.99},
    {"id": 3, "name": "Keyboard", "description": "Clavier mécanique", "price": 129.99},
]

@router.get("/", response_model=List[Item])
async def read_items():
    """Récupère tous les items"""
    return fake_items_db

@router.get("/{item_id}", response_model=Item)
async def read_item(item_id: int):
    """Récupère un item par son ID"""
    for item in fake_items_db:
        if item["id"] == item_id:
            return item
    raise HTTPException(status_code=404, detail="Item not found")

@router.post("/", response_model=Item)
async def create_item(item: ItemCreate):
    """Crée un nouvel item"""
    new_id = max([item["id"] for item in fake_items_db], default=0) + 1
    new_item = {"id": new_id, **item.dict()}
    fake_items_db.append(new_item)
    return new_item

@router.put("/{item_id}", response_model=Item)
async def update_item(item_id: int, item: ItemCreate):
    """Met à jour un item"""
    for i, db_item in enumerate(fake_items_db):
        if db_item["id"] == item_id:
            fake_items_db[i] = {"id": item_id, **item.dict()}
            return fake_items_db[i]
    raise HTTPException(status_code=404, detail="Item not found")

@router.delete("/{item_id}")
async def delete_item(item_id: int):
    """Supprime un item"""
    for i, item in enumerate(fake_items_db):
        if item["id"] == item_id:
            del fake_items_db[i]
            return {"message": "Item deleted"}
    raise HTTPException(status_code=404, detail="Item not found")

{% else %}
# Avec base de données
@router.get("/", response_model=List[Item])
async def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    """Récupère tous les items"""
    # TODO: Implémenter avec votre ORM
    return []

@router.get("/{item_id}", response_model=Item)
async def read_item(item_id: int, db: Session = Depends(get_db)):
    """Récupère un item par son ID"""
    # TODO: Implémenter avec votre ORM
    raise HTTPException(status_code=404, detail="Item not found")

@router.post("/", response_model=Item)
async def create_item(item: ItemCreate, db: Session = Depends(get_db)):
    """Crée un nouvel item"""
    # TODO: Implémenter avec votre ORM
    return item

@router.put("/{item_id}", response_model=Item)
async def update_item(item_id: int, item: ItemCreate, db: Session = Depends(get_db)):
    """Met à jour un item"""
    # TODO: Implémenter avec votre ORM
    raise HTTPException(status_code=404, detail="Item not found")

@router.delete("/{item_id}")
async def delete_item(item_id: int, db: Session = Depends(get_db)):
    """Supprime un item"""
    # TODO: Implémenter avec votre ORM
    return {"message": "Item deleted"}
{% endif %}

# ============================================================

# create_fastapi/templates/config.py.j2
"""Configuration de l'application"""

from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    """Paramètres de configuration de l'application"""
    
    # Configuration générale
    app_name: str = "{{ project_name.title() }} API"
    debug: bool = False
    version: str = "1.0.0"
    
    # Configuration de la base de données
    {% if database == 'postgresql' %}
    database_url: str = "postgresql://user:password@localhost/{{ project_name }}"
    {% elif database == 'mysql' %}
    database_url: str = "mysql://user:password@localhost/{{ project_name }}"
    {% elif database == 'sqlite' %}
    database_url: str = "sqlite:///./{{ project_name }}.db"
    {% else %}
    database_url: Optional[str] = None
    {% endif %}
    
    {% if include_auth %}
    # Configuration JWT
    secret_key: str = "your-secret-key-change-this-in-production"
    algorithm: str = "HS256"
    access_token_expire_minutes: int = 30
    {% endif %}
    
    # Configuration CORS
    cors_origins: list = ["http://localhost:3000", "http://localhost:8080"]
    
    class Config:
        env_file = ".env"
        env_file_encoding = "utf-8"

settings = Settings()

# ============================================================

# create_fastapi/templates/database.py.j2
{% if database != 'none' %}
"""Configuration de la base de données"""

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.core.config import settings

{% if database == 'sqlite' %}
engine = create_engine(
    settings.database_url, 
    connect_args={"check_same_thread": False}
)
{% else %}
engine = create_engine(settings.database_url)
{% endif %}

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    """Obtenir une session de base de données"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
{% endif %}

# ============================================================

# create_fastapi/templates/Dockerfile.j2
{% if include_docker %}
FROM python:3.11-slim

WORKDIR /app

# Installer les dépendances système
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copier et installer les requirements
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copier le code de l'application
COPY . .

# Exposer le port
EXPOSE 8000

# Commande par défaut
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
{% endif %}

# ============================================================

# create_fastapi/templates/docker-compose.yml.j2
{% if include_docker %}
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL={{ database_url_docker }}
    {% if database != 'none' and database != 'sqlite' %}
    depends_on:
      - db
    {% endif %}
    volumes:
      - .:/app
    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload

  {% if database == 'postgresql' %}
  db:
    image: postgres:15
    environment:
      POSTGRES_DB: {{ project_name }}
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
  {% elif database == 'mysql' %}
  db:
    image: mysql:8.0
    environment:
      MYSQL_DATABASE: {{ project_name }}
      MYSQL_USER: user
      MYSQL_PASSWORD: password
      MYSQL_ROOT_PASSWORD: rootpassword
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:
  {% endif %}
{% endif %}

# ============================================================

# create_fastapi/templates/README.md.j2
# {{ project_name.title() }}

{{ project_name.title() }} - Application FastAPI générée avec FastAPI Generator.

## 🚀 Démarrage rapide

### Prérequis

- Python 3.8+
- pip ou poetry

### Installation

1. **Cloner le projet** (si depuis Git)
```bash
git clone <url-du-repo>
cd {{ project_name }}
```

2. **Créer un environnement virtuel**
```bash
python -m venv venv
source venv/bin/activate  # Sur Windows: venv\Scripts\activate
```

3. **Installer les dépendances**
```bash
pip install -r requirements.txt
```

{% if database != 'none' %}
4. **Configurer la base de données**
```bash
# Créer le fichier .env avec vos paramètres de BDD
cp .env.example .env
# Éditer .env avec vos paramètres

# Appliquer les migrations (si Alembic est configuré)
alembic upgrade head
```
{% endif %}

### Lancement

```bash
# Méthode 1: Avec Uvicorn
uvicorn main:app --reload

# Méthode 2: Directement
python main.py
```

{% if include_docker %}
### Avec Docker

```bash
# Build et run
docker-compose up --build

# Ou avec Docker seul
docker build -t {{ project_name }} .
docker run -p 8000:8000 {{ project_name }}
```
{% endif %}

## 📚 Documentation

Une fois l'application lancée, accédez à :

- **API**: http://localhost:8000
- **Documentation Swagger**: http://localhost:8000/docs  
- **Documentation ReDoc**: http://localhost:8000/redoc

## 🏗️ Structure du projet

```
{{ project_name }}/
├── main.py                 # Point d'entrée de l'application
├── requirements.txt        # Dépendances
{% if include_docker %}├── Dockerfile             # Configuration Docker
├── docker-compose.yml     # Services Docker
{% endif %}├── .env                    # Variables d'environnement
├── README.md              # Ce fichier
├── app/
│   ├── __init__.py
│   ├── core/
│   │   ├── __init__.py
│   │   ├── config.py      # Configuration
{% if database != 'none' %}│   │   └── database.py    # Configuration BDD
{% endif %}│   ├── models/
│   │   └── __init__.py    # Modèles Pydantic/SQLAlchemy
│   └── routers/
│       ├── __init__.py
│       └── items.py       # Routes d'exemple
{% if include_auth %}├── auth/
│   ├── __init__.py
│   ├── jwt.py             # Gestion JWT
│   └── users.py           # Gestion utilisateurs
{% endif %}{% if include_tests %}└── tests/
    ├── __init__.py
    └── test_main.py       # Tests unitaires
{% endif %}```

## 🛠️ Développement

### Ajouter un nouveau router

```bash
# Avec FastAPI Generator
fastapi-gen add-router users --model User --crud

# Ou manuellement
# 1. Créer app/routers/users.py
# 2. Ajouter l'import dans main.py
# 3. Inclure le router: app.include_router(users.router)
```

### Ajouter un modèle

```bash
# Avec FastAPI Generator  
fastapi-gen add-model User --fields "name:str,email:str,age:int"

# Ou créer manuellement dans app/models/
```

{% if include_tests %}
### Tests

```bash
# Lancer tous les tests
pytest

# Tests avec couverture
pytest --cov=app

# Tests en mode watch
pytest-watch
```
{% endif %}

## 🔧 Configuration

Les paramètres se configurent via le fichier `.env` :

```env
# Général
APP_NAME="{{ project_name.title() }} API"
DEBUG=false

{% if database != 'none' %}
# Base de données
DATABASE_URL={{ database_example_url }}
{% endif %}

{% if include_auth %}
# JWT
SECRET_KEY=your-secret-key-here
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
{% endif %}

# CORS
CORS_ORIGINS=["http://localhost:3000"]
```

## 📋 Endpoints disponibles

- `GET /` - Page d'accueil
- `GET /health` - Santé de l'API
- `GET /items/` - Liste des items
- `GET /items/{id}` - Détail d'un item
- `POST /items/` - Créer un item
- `PUT /items/{id}` - Mettre à jour un item  
- `DELETE /items/{id}` - Supprimer un item

## 🤝 Contribution

1. Fork le projet
2. Créer une branche (`git checkout -b feature/amazing-feature`)
3. Commit (`git commit -m 'Add amazing feature'`)
4. Push (`git push origin feature/amazing-feature`)
5. Ouvrir une Pull Request

## 📝 License

Ce projet est sous licence MIT. Voir `LICENSE` pour plus de détails.

## 🆘 Support

- Documentation FastAPI: https://fastapi.tiangolo.com/
- Issues: [GitHub Issues](https://github.com/bonitoFotso/create_fastapi/issues)

---

*Généré avec ❤️ par [FastAPI Generator](https://github.com/bonitoFotso/create_fastapi)*