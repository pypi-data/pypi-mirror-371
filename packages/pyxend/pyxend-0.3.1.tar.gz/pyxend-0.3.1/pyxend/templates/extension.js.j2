const vscode = require("vscode");
const cp = require("child_process");
const path = require("path");
const fs = require("fs");

function runPython(kind /* 'command' | 'event' */, name) {
  const editor = vscode.window.activeTextEditor;

  let selection = null, document = null, selectedText = "", fullText = "",
      language = "", filePath = "", cursorPos = null, cursorWord = "",
      lines = 0, fileSize = 0, openedFiles = [], isSaved = true, workspace = "";

  const workspaceFolders = vscode.workspace.workspaceFolders || [];
  openedFiles = vscode.workspace.textDocuments.map(doc => doc.uri.fsPath);
  workspace = workspaceFolders.length > 0 ? workspaceFolders[0].uri.fsPath : "";

  if (editor) {
    selection = editor.selection;
    document = editor.document;
    selectedText = document.getText(selection) || "";
    fullText = document.getText() || "";
    language = document.languageId || "";
    filePath = document.uri.fsPath || "";
    cursorPos = selection ? { line: selection.start.line, character: selection.start.character } : null;
    const wordRange = document.getWordRangeAtPosition(editor.selection.active);
    cursorWord = wordRange ? document.getText(wordRange) : "";
    lines = document.lineCount || 0;
    fileSize = Buffer.byteLength(fullText, "utf-8");
    isSaved = !document.isDirty;
  }

  const contextPayload = {
    selected_text: selectedText,
    all_text: fullText,
    language,
    file_path: filePath,
    cursor_pos: cursorPos,
    cursor_word: cursorWord,
    lines,
    file_size: fileSize,
    opened_files: openedFiles,
    is_saved: isSaved,
    workspace
  };

  const scriptPath = path.join(__dirname, "main.py");
  const args = [scriptPath, kind, name, JSON.stringify(contextPayload)];

  const py = cp.spawnSync("python", args, { encoding: "utf-8" });

  if (py.error) {
    vscode.window.showErrorMessage("[pyxend] Failed to start Python: " + String(py.error));
    return;
  }
  if (py.stderr) {
    const err = py.stderr.trim();
    if (err) {
      vscode.window.showErrorMessage("[pyxend] Python stderr: " + err);
      return;
    }
  }

  let actions;
  try {
    actions = JSON.parse(py.stdout);
  } catch (e) {
    vscode.window.showErrorMessage("[pyxend] Invalid JSON from Python");
    return;
  }

  if (!Array.isArray(actions)) {
    vscode.window.showErrorMessage("[pyxend] " + (actions.error || "Unknown error"));
    return;
  }

  actions.forEach((action) => {
    const editor = vscode.window.activeTextEditor;
    const document = editor?.document;

    switch (action.action) {
      case "show_modal": {
        const type = action.type || "info";
        const msg = action.message;
        if (type === "error") vscode.window.showErrorMessage(msg);
        else if (type === "warning") vscode.window.showWarningMessage(msg);
        else vscode.window.showInformationMessage(msg);
        break;
      }

      case "replace_selected_text": {
        vscode.window.showWarningMessage("[pyxend] Action 'replace_selected_text' is deprecated and will be removed in 1.0.0. Use 'replace_text' with preset 'selected' instead.");
        const selEditor = vscode.window.activeTextEditor;
        const selSelection = selEditor?.selection;
        if (!selEditor || !selSelection) {
          vscode.window.showErrorMessage("[pyxend] Cannot replace text: no selection or editor.");
          return;
        }
        selEditor.edit(editBuilder => {
          editBuilder.replace(selSelection, action.text || "");
        });
        break;
      }

      case "open_file": {
        if (!action.path) {
          vscode.window.showErrorMessage("[pyxend] Cannot open file: no path provided.");
          return;
        }
        if (!fs.existsSync(action.path)) {
          vscode.window.showErrorMessage("[pyxend] File does not exist: " + action.path);
          return;
        }
        vscode.workspace.openTextDocument(action.path).then(doc => {
          vscode.window.showTextDocument(doc);
        });
        break;
      }

      case "set_cursor_pos": {
        if (!editor) {
          vscode.window.showErrorMessage("[pyxend] Cannot set cursor: no editor.");
          return;
        }
        if (typeof action.line !== 'number' || typeof action.character !== 'number') {
          vscode.window.showErrorMessage("[pyxend] Invalid cursor position.");
          return;
        }
        const position = new vscode.Position(action.line, action.character);
        editor.selection = new vscode.Selection(position, position);
        editor.revealRange(new vscode.Range(position, position));
        break;
      }

      case "save_file": {
        if (!document) {
          vscode.window.showErrorMessage("[pyxend] Cannot save: no document.");
          return;
        }
        document.save();
        break;
      }

      case "run_terminal_command": {
        if (!action.command) {
          vscode.window.showErrorMessage("[pyxend] No terminal command provided.");
          return;
        }
        const terminal = vscode.window.createTerminal(action.terminal_name || "pyxend terminal");
        terminal.show();
        terminal.sendText(action.command);
        break;
      }

      case "overwrite_file": {
        vscode.window.showWarningMessage("[pyxend] Action 'overwrite_file' is deprecated and will be removed in 1.0.0. Use 'replace_text' with preset 'all' instead.");
        if (!editor || !document) {
          vscode.window.showErrorMessage("[pyxend] Cannot overwrite file: editor or document missing.");
          return;
        }
        const entireRange = new vscode.Range(
          document.positionAt(0),
          document.positionAt(document.getText().length)
        );
        editor.edit(editBuilder => {
          editBuilder.replace(entireRange, action.text || "");
        });
        break;
      }

      case "delete_selected_text": {
        const delEditor = vscode.window.activeTextEditor;
        const delSelection = delEditor?.selection;
        if (!delEditor || !delSelection) {
          vscode.window.showErrorMessage("[pyxend] Cannot delete: no selection.");
          return;
        }
        delEditor.edit(editBuilder => {
          editBuilder.delete(delSelection);
        });
        break;
      }

      case "insert_text": {
        if (!editor || !document) return;
        let insertPos;
        if (action.preset === "start") {
          insertPos = new vscode.Position(0, 0);
        } else if (action.preset === "end") {
          const lastLine = document.lineCount - 1;
          insertPos = new vscode.Position(lastLine, document.lineAt(lastLine).text.length);
        } else if (action.preset === "cursor") {
          insertPos = editor.selection.active;
        } else if (typeof action.line === "number" && typeof action.character === "number") {
          insertPos = new vscode.Position(action.line, action.character);
        } else {
          vscode.window.showErrorMessage("[pyxend] Invalid insert_text position.");
          return;
        }
        editor.edit(editBuilder => {
          editBuilder.insert(insertPos, action.text || "");
        });
        break;
      }

      case "replace_text": {
        if (!editor || !document) {
          vscode.window.showErrorMessage("[pyxend] Cannot replace text: missing editor or document.");
          return;
        }

        let replaceRange;

        if (action.preset === "all") {
          replaceRange = new vscode.Range(
            document.positionAt(0),
            document.positionAt(document.getText().length)
          );
        } else if (action.preset === "selected") {
          const sel = editor.selection;
          if (!sel || sel.isEmpty) {
            vscode.window.showErrorMessage("[pyxend] Cannot replace selected text: no selection.");
            return;
          }
          replaceRange = new vscode.Range(sel.start, sel.end);
        } else if (
          action.start && action.end &&
          typeof action.start.line === "number" &&
          typeof action.start.character === "number" &&
          typeof action.end.line === "number" &&
          typeof action.end.character === "number"
        ) {
          replaceRange = new vscode.Range(
            new vscode.Position(action.start.line, action.start.character),
            new vscode.Position(action.end.line, action.end.character)
          );
        } else {
          vscode.window.showErrorMessage("[pyxend] Invalid range or preset for replace_text.");
          return;
        }

        editor.edit(editBuilder => {
          editBuilder.replace(replaceRange, action.text || "");
        });
        break;
      }

      case "delete_file": {
        if (!filePath || !fs.existsSync(filePath)) {
          vscode.window.showErrorMessage("[pyxend] Cannot delete file: not found.");
          return;
        }
        fs.unlinkSync(filePath);
        break;
      }

      case "select_range": {
        if (!editor ||
            typeof action.start.line !== "number" || typeof action.start.character !== "number" ||
            typeof action.end.line !== "number"   || typeof action.end.character !== "number") {
          vscode.window.showErrorMessage("[pyxend] Invalid selection range.");
          return;
        }
        const start = new vscode.Position(action.start.line, action.start.character);
        const end = new vscode.Position(action.end.line, action.end.character);
        editor.selection = new vscode.Selection(start, end);
        editor.revealRange(new vscode.Range(start, end));
        break;
      }

      case "open_terminal": {
        vscode.window.createTerminal(action.name || "pyxend").show();
        break;
      }

      case "run_terminal": {
        const name = action.name || "pyxend";
        let terminal = vscode.window.terminals.find(t => t.name === name);
        if (!terminal) terminal = vscode.window.createTerminal(name);
        terminal.show();
        terminal.sendText(action.command || "");
        break;
      }

      case "close_terminal": {
        const name = action.name || "pyxend";
        const terminal = vscode.window.terminals.find(t => t.name === name);
        if (terminal) terminal.dispose();
        break;
      }

      case "reload_editor": {
        vscode.commands.executeCommand("workbench.action.reloadWindow");
        break;
      }

      case "status_message":
        vscode.window.setStatusBarMessage(action.message || "pyxend", action.timeout || 3000);
        break;

      default:
        vscode.window.showWarningMessage("[pyxend] Unknown action: " + action.action);
    }
  });
}

function activate(context) {
  runPython("event", "startup");

  context.subscriptions.push(
    {% for command in commands %}
    vscode.commands.registerCommand("{{ extension_name }}.{{ command }}", () => {
      runPython("command", "{{ command }}");
    }),
    {% endfor %}
  );

  context.subscriptions.push(
    vscode.workspace.onDidChangeTextDocument(() => {
      runPython("event", "change");
    })
  );
}

function deactivate() {
  try {
    runPython("event", "shutdown");
  } catch (_) {}
}

module.exports = { activate, deactivate };
