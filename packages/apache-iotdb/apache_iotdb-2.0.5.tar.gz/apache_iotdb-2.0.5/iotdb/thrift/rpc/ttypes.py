#
# Autogenerated by Thrift Compiler (0.14.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import iotdb.thrift.common.ttypes

from thrift.transport import TTransport
all_structs = []


class TSProtocolVersion(object):
    IOTDB_SERVICE_PROTOCOL_V1 = 0
    IOTDB_SERVICE_PROTOCOL_V2 = 1
    IOTDB_SERVICE_PROTOCOL_V3 = 2

    _VALUES_TO_NAMES = {
        0: "IOTDB_SERVICE_PROTOCOL_V1",
        1: "IOTDB_SERVICE_PROTOCOL_V2",
        2: "IOTDB_SERVICE_PROTOCOL_V3",
    }

    _NAMES_TO_VALUES = {
        "IOTDB_SERVICE_PROTOCOL_V1": 0,
        "IOTDB_SERVICE_PROTOCOL_V2": 1,
        "IOTDB_SERVICE_PROTOCOL_V3": 2,
    }


class TSConnectionType(object):
    THRIFT_BASED = 0
    MQTT_BASED = 1
    INTERNAL = 2
    REST_BASED = 3

    _VALUES_TO_NAMES = {
        0: "THRIFT_BASED",
        1: "MQTT_BASED",
        2: "INTERNAL",
        3: "REST_BASED",
    }

    _NAMES_TO_VALUES = {
        "THRIFT_BASED": 0,
        "MQTT_BASED": 1,
        "INTERNAL": 2,
        "REST_BASED": 3,
    }


class TSQueryDataSet(object):
    """
    Attributes:
     - time
     - valueList
     - bitmapList

    """


    def __init__(self, time=None, valueList=None, bitmapList=None,):
        self.time = time
        self.valueList = valueList
        self.bitmapList = bitmapList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.time = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.valueList = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readBinary()
                        self.valueList.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.bitmapList = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readBinary()
                        self.bitmapList.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryDataSet')
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.STRING, 1)
            oprot.writeBinary(self.time)
            oprot.writeFieldEnd()
        if self.valueList is not None:
            oprot.writeFieldBegin('valueList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.valueList))
            for iter12 in self.valueList:
                oprot.writeBinary(iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.bitmapList is not None:
            oprot.writeFieldBegin('bitmapList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.bitmapList))
            for iter13 in self.bitmapList:
                oprot.writeBinary(iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.time is None:
            raise TProtocolException(message='Required field time is unset!')
        if self.valueList is None:
            raise TProtocolException(message='Required field valueList is unset!')
        if self.bitmapList is None:
            raise TProtocolException(message='Required field bitmapList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSQueryNonAlignDataSet(object):
    """
    Attributes:
     - timeList
     - valueList

    """


    def __init__(self, timeList=None, valueList=None,):
        self.timeList = timeList
        self.valueList = valueList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.timeList = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readBinary()
                        self.timeList.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.valueList = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = iprot.readBinary()
                        self.valueList.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryNonAlignDataSet')
        if self.timeList is not None:
            oprot.writeFieldBegin('timeList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.timeList))
            for iter26 in self.timeList:
                oprot.writeBinary(iter26)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valueList is not None:
            oprot.writeFieldBegin('valueList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.valueList))
            for iter27 in self.valueList:
                oprot.writeBinary(iter27)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.timeList is None:
            raise TProtocolException(message='Required field timeList is unset!')
        if self.valueList is None:
            raise TProtocolException(message='Required field valueList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSTracingInfo(object):
    """
    Attributes:
     - activityList
     - elapsedTimeList
     - seriesPathNum
     - seqFileNum
     - unSeqFileNum
     - sequenceChunkNum
     - sequenceChunkPointNum
     - unsequenceChunkNum
     - unsequenceChunkPointNum
     - totalPageNum
     - overlappedPageNum

    """


    def __init__(self, activityList=None, elapsedTimeList=None, seriesPathNum=None, seqFileNum=None, unSeqFileNum=None, sequenceChunkNum=None, sequenceChunkPointNum=None, unsequenceChunkNum=None, unsequenceChunkPointNum=None, totalPageNum=None, overlappedPageNum=None,):
        self.activityList = activityList
        self.elapsedTimeList = elapsedTimeList
        self.seriesPathNum = seriesPathNum
        self.seqFileNum = seqFileNum
        self.unSeqFileNum = unSeqFileNum
        self.sequenceChunkNum = sequenceChunkNum
        self.sequenceChunkPointNum = sequenceChunkPointNum
        self.unsequenceChunkNum = unsequenceChunkNum
        self.unsequenceChunkPointNum = unsequenceChunkPointNum
        self.totalPageNum = totalPageNum
        self.overlappedPageNum = overlappedPageNum

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.activityList = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.activityList.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.elapsedTimeList = []
                    (_etype37, _size34) = iprot.readListBegin()
                    for _i38 in range(_size34):
                        _elem39 = iprot.readI64()
                        self.elapsedTimeList.append(_elem39)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.seriesPathNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.seqFileNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.unSeqFileNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.sequenceChunkNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.sequenceChunkPointNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.unsequenceChunkNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.unsequenceChunkPointNum = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.totalPageNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.overlappedPageNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSTracingInfo')
        if self.activityList is not None:
            oprot.writeFieldBegin('activityList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.activityList))
            for iter40 in self.activityList:
                oprot.writeString(iter40.encode('utf-8') if sys.version_info[0] == 2 else iter40)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.elapsedTimeList is not None:
            oprot.writeFieldBegin('elapsedTimeList', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.elapsedTimeList))
            for iter41 in self.elapsedTimeList:
                oprot.writeI64(iter41)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.seriesPathNum is not None:
            oprot.writeFieldBegin('seriesPathNum', TType.I32, 3)
            oprot.writeI32(self.seriesPathNum)
            oprot.writeFieldEnd()
        if self.seqFileNum is not None:
            oprot.writeFieldBegin('seqFileNum', TType.I32, 4)
            oprot.writeI32(self.seqFileNum)
            oprot.writeFieldEnd()
        if self.unSeqFileNum is not None:
            oprot.writeFieldBegin('unSeqFileNum', TType.I32, 5)
            oprot.writeI32(self.unSeqFileNum)
            oprot.writeFieldEnd()
        if self.sequenceChunkNum is not None:
            oprot.writeFieldBegin('sequenceChunkNum', TType.I32, 6)
            oprot.writeI32(self.sequenceChunkNum)
            oprot.writeFieldEnd()
        if self.sequenceChunkPointNum is not None:
            oprot.writeFieldBegin('sequenceChunkPointNum', TType.I64, 7)
            oprot.writeI64(self.sequenceChunkPointNum)
            oprot.writeFieldEnd()
        if self.unsequenceChunkNum is not None:
            oprot.writeFieldBegin('unsequenceChunkNum', TType.I32, 8)
            oprot.writeI32(self.unsequenceChunkNum)
            oprot.writeFieldEnd()
        if self.unsequenceChunkPointNum is not None:
            oprot.writeFieldBegin('unsequenceChunkPointNum', TType.I64, 9)
            oprot.writeI64(self.unsequenceChunkPointNum)
            oprot.writeFieldEnd()
        if self.totalPageNum is not None:
            oprot.writeFieldBegin('totalPageNum', TType.I32, 10)
            oprot.writeI32(self.totalPageNum)
            oprot.writeFieldEnd()
        if self.overlappedPageNum is not None:
            oprot.writeFieldBegin('overlappedPageNum', TType.I32, 11)
            oprot.writeI32(self.overlappedPageNum)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.activityList is None:
            raise TProtocolException(message='Required field activityList is unset!')
        if self.elapsedTimeList is None:
            raise TProtocolException(message='Required field elapsedTimeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSExecuteStatementResp(object):
    """
    Attributes:
     - status
     - queryId
     - columns
     - operationType
     - ignoreTimeStamp
     - dataTypeList
     - queryDataSet
     - nonAlignQueryDataSet
     - columnNameIndexMap
     - sgColumns
     - aliasColumns
     - tracingInfo
     - queryResult
     - moreData
     - database
     - tableModel
     - columnIndex2TsBlockColumnIndexList

    """


    def __init__(self, status=None, queryId=None, columns=None, operationType=None, ignoreTimeStamp=None, dataTypeList=None, queryDataSet=None, nonAlignQueryDataSet=None, columnNameIndexMap=None, sgColumns=None, aliasColumns=None, tracingInfo=None, queryResult=None, moreData=None, database=None, tableModel=None, columnIndex2TsBlockColumnIndexList=None,):
        self.status = status
        self.queryId = queryId
        self.columns = columns
        self.operationType = operationType
        self.ignoreTimeStamp = ignoreTimeStamp
        self.dataTypeList = dataTypeList
        self.queryDataSet = queryDataSet
        self.nonAlignQueryDataSet = nonAlignQueryDataSet
        self.columnNameIndexMap = columnNameIndexMap
        self.sgColumns = sgColumns
        self.aliasColumns = aliasColumns
        self.tracingInfo = tracingInfo
        self.queryResult = queryResult
        self.moreData = moreData
        self.database = database
        self.tableModel = tableModel
        self.columnIndex2TsBlockColumnIndexList = columnIndex2TsBlockColumnIndexList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columns.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.operationType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.ignoreTimeStamp = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.dataTypeList = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.dataTypeList.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.queryDataSet = TSQueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.nonAlignQueryDataSet = TSQueryNonAlignDataSet()
                    self.nonAlignQueryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.columnNameIndexMap = {}
                    (_ktype55, _vtype56, _size54) = iprot.readMapBegin()
                    for _i58 in range(_size54):
                        _key59 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val60 = iprot.readI32()
                        self.columnNameIndexMap[_key59] = _val60
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.sgColumns = []
                    (_etype64, _size61) = iprot.readListBegin()
                    for _i65 in range(_size61):
                        _elem66 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.sgColumns.append(_elem66)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.LIST:
                    self.aliasColumns = []
                    (_etype70, _size67) = iprot.readListBegin()
                    for _i71 in range(_size67):
                        _elem72 = iprot.readByte()
                        self.aliasColumns.append(_elem72)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.tracingInfo = TSTracingInfo()
                    self.tracingInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.queryResult = []
                    (_etype76, _size73) = iprot.readListBegin()
                    for _i77 in range(_size73):
                        _elem78 = iprot.readBinary()
                        self.queryResult.append(_elem78)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.moreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.tableModel = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.LIST:
                    self.columnIndex2TsBlockColumnIndexList = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = iprot.readI32()
                        self.columnIndex2TsBlockColumnIndexList.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSExecuteStatementResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter85 in self.columns:
                oprot.writeString(iter85.encode('utf-8') if sys.version_info[0] == 2 else iter85)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.operationType is not None:
            oprot.writeFieldBegin('operationType', TType.STRING, 4)
            oprot.writeString(self.operationType.encode('utf-8') if sys.version_info[0] == 2 else self.operationType)
            oprot.writeFieldEnd()
        if self.ignoreTimeStamp is not None:
            oprot.writeFieldBegin('ignoreTimeStamp', TType.BOOL, 5)
            oprot.writeBool(self.ignoreTimeStamp)
            oprot.writeFieldEnd()
        if self.dataTypeList is not None:
            oprot.writeFieldBegin('dataTypeList', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.dataTypeList))
            for iter86 in self.dataTypeList:
                oprot.writeString(iter86.encode('utf-8') if sys.version_info[0] == 2 else iter86)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 7)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.nonAlignQueryDataSet is not None:
            oprot.writeFieldBegin('nonAlignQueryDataSet', TType.STRUCT, 8)
            self.nonAlignQueryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.columnNameIndexMap is not None:
            oprot.writeFieldBegin('columnNameIndexMap', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.columnNameIndexMap))
            for kiter87, viter88 in self.columnNameIndexMap.items():
                oprot.writeString(kiter87.encode('utf-8') if sys.version_info[0] == 2 else kiter87)
                oprot.writeI32(viter88)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.sgColumns is not None:
            oprot.writeFieldBegin('sgColumns', TType.LIST, 10)
            oprot.writeListBegin(TType.STRING, len(self.sgColumns))
            for iter89 in self.sgColumns:
                oprot.writeString(iter89.encode('utf-8') if sys.version_info[0] == 2 else iter89)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aliasColumns is not None:
            oprot.writeFieldBegin('aliasColumns', TType.LIST, 11)
            oprot.writeListBegin(TType.BYTE, len(self.aliasColumns))
            for iter90 in self.aliasColumns:
                oprot.writeByte(iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tracingInfo is not None:
            oprot.writeFieldBegin('tracingInfo', TType.STRUCT, 12)
            self.tracingInfo.write(oprot)
            oprot.writeFieldEnd()
        if self.queryResult is not None:
            oprot.writeFieldBegin('queryResult', TType.LIST, 13)
            oprot.writeListBegin(TType.STRING, len(self.queryResult))
            for iter91 in self.queryResult:
                oprot.writeBinary(iter91)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.moreData is not None:
            oprot.writeFieldBegin('moreData', TType.BOOL, 14)
            oprot.writeBool(self.moreData)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 15)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.tableModel is not None:
            oprot.writeFieldBegin('tableModel', TType.BOOL, 16)
            oprot.writeBool(self.tableModel)
            oprot.writeFieldEnd()
        if self.columnIndex2TsBlockColumnIndexList is not None:
            oprot.writeFieldBegin('columnIndex2TsBlockColumnIndexList', TType.LIST, 17)
            oprot.writeListBegin(TType.I32, len(self.columnIndex2TsBlockColumnIndexList))
            for iter92 in self.columnIndex2TsBlockColumnIndexList:
                oprot.writeI32(iter92)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSOpenSessionResp(object):
    """
    Attributes:
     - status
     - serverProtocolVersion
     - sessionId
     - configuration

    """


    def __init__(self, status=None, serverProtocolVersion=0, sessionId=None, configuration=None,):
        self.status = status
        self.serverProtocolVersion = serverProtocolVersion
        self.sessionId = sessionId
        self.configuration = configuration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.serverProtocolVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.configuration = {}
                    (_ktype94, _vtype95, _size93) = iprot.readMapBegin()
                    for _i97 in range(_size93):
                        _key98 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val99 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.configuration[_key98] = _val99
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSOpenSessionResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.serverProtocolVersion is not None:
            oprot.writeFieldBegin('serverProtocolVersion', TType.I32, 2)
            oprot.writeI32(self.serverProtocolVersion)
            oprot.writeFieldEnd()
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 3)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.configuration is not None:
            oprot.writeFieldBegin('configuration', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configuration))
            for kiter100, viter101 in self.configuration.items():
                oprot.writeString(kiter100.encode('utf-8') if sys.version_info[0] == 2 else kiter100)
                oprot.writeString(viter101.encode('utf-8') if sys.version_info[0] == 2 else viter101)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.serverProtocolVersion is None:
            raise TProtocolException(message='Required field serverProtocolVersion is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSOpenSessionReq(object):
    """
    Attributes:
     - client_protocol
     - zoneId
     - username
     - password
     - configuration

    """


    def __init__(self, client_protocol=2, zoneId=None, username=None, password=None, configuration=None,):
        self.client_protocol = client_protocol
        self.zoneId = zoneId
        self.username = username
        self.password = password
        self.configuration = configuration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.client_protocol = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.zoneId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.configuration = {}
                    (_ktype103, _vtype104, _size102) = iprot.readMapBegin()
                    for _i106 in range(_size102):
                        _key107 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val108 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.configuration[_key107] = _val108
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSOpenSessionReq')
        if self.client_protocol is not None:
            oprot.writeFieldBegin('client_protocol', TType.I32, 1)
            oprot.writeI32(self.client_protocol)
            oprot.writeFieldEnd()
        if self.zoneId is not None:
            oprot.writeFieldBegin('zoneId', TType.STRING, 2)
            oprot.writeString(self.zoneId.encode('utf-8') if sys.version_info[0] == 2 else self.zoneId)
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 3)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 4)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.configuration is not None:
            oprot.writeFieldBegin('configuration', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configuration))
            for kiter109, viter110 in self.configuration.items():
                oprot.writeString(kiter109.encode('utf-8') if sys.version_info[0] == 2 else kiter109)
                oprot.writeString(viter110.encode('utf-8') if sys.version_info[0] == 2 else viter110)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.client_protocol is None:
            raise TProtocolException(message='Required field client_protocol is unset!')
        if self.zoneId is None:
            raise TProtocolException(message='Required field zoneId is unset!')
        if self.username is None:
            raise TProtocolException(message='Required field username is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCloseSessionReq(object):
    """
    Attributes:
     - sessionId

    """


    def __init__(self, sessionId=None,):
        self.sessionId = sessionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCloseSessionReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSExecuteStatementReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - statementId
     - fetchSize
     - timeout
     - enableRedirectQuery
     - jdbcQuery

    """


    def __init__(self, sessionId=None, statement=None, statementId=None, fetchSize=None, timeout=None, enableRedirectQuery=None, jdbcQuery=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.statementId = statementId
        self.fetchSize = fetchSize
        self.timeout = timeout
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSExecuteStatementReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 3)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 4)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 5)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 6)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 7)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSExecuteBatchStatementReq(object):
    """
    Attributes:
     - sessionId
     - statements

    """


    def __init__(self, sessionId=None, statements=None,):
        self.sessionId = sessionId
        self.statements = statements

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.statements = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.statements.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSExecuteBatchStatementReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statements is not None:
            oprot.writeFieldBegin('statements', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.statements))
            for iter117 in self.statements:
                oprot.writeString(iter117.encode('utf-8') if sys.version_info[0] == 2 else iter117)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statements is None:
            raise TProtocolException(message='Required field statements is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSGetOperationStatusReq(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSGetOperationStatusReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCancelOperationReq(object):
    """
    Attributes:
     - sessionId
     - queryId

    """


    def __init__(self, sessionId=None, queryId=None,):
        self.sessionId = sessionId
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCancelOperationReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCloseOperationReq(object):
    """
    Attributes:
     - sessionId
     - queryId
     - statementId

    """


    def __init__(self, sessionId=None, queryId=None, statementId=None,):
        self.sessionId = sessionId
        self.queryId = queryId
        self.statementId = statementId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCloseOperationReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 2)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 3)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchResultsReq(object):
    """
    Attributes:
     - sessionId
     - statement
     - fetchSize
     - queryId
     - isAlign
     - timeout
     - statementId

    """


    def __init__(self, sessionId=None, statement=None, fetchSize=None, queryId=None, isAlign=None, timeout=None, statementId=None,):
        self.sessionId = sessionId
        self.statement = statement
        self.fetchSize = fetchSize
        self.queryId = queryId
        self.isAlign = isAlign
        self.timeout = timeout
        self.statementId = statementId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.queryId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isAlign = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchResultsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 2)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.I64, 4)
            oprot.writeI64(self.queryId)
            oprot.writeFieldEnd()
        if self.isAlign is not None:
            oprot.writeFieldBegin('isAlign', TType.BOOL, 5)
            oprot.writeBool(self.isAlign)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 6)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 7)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statement is None:
            raise TProtocolException(message='Required field statement is unset!')
        if self.fetchSize is None:
            raise TProtocolException(message='Required field fetchSize is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        if self.isAlign is None:
            raise TProtocolException(message='Required field isAlign is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchResultsResp(object):
    """
    Attributes:
     - status
     - hasResultSet
     - isAlign
     - queryDataSet
     - nonAlignQueryDataSet
     - queryResult
     - moreData

    """


    def __init__(self, status=None, hasResultSet=None, isAlign=None, queryDataSet=None, nonAlignQueryDataSet=None, queryResult=None, moreData=None,):
        self.status = status
        self.hasResultSet = hasResultSet
        self.isAlign = isAlign
        self.queryDataSet = queryDataSet
        self.nonAlignQueryDataSet = nonAlignQueryDataSet
        self.queryResult = queryResult
        self.moreData = moreData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.hasResultSet = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isAlign = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.queryDataSet = TSQueryDataSet()
                    self.queryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.nonAlignQueryDataSet = TSQueryNonAlignDataSet()
                    self.nonAlignQueryDataSet.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.queryResult = []
                    (_etype121, _size118) = iprot.readListBegin()
                    for _i122 in range(_size118):
                        _elem123 = iprot.readBinary()
                        self.queryResult.append(_elem123)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.moreData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchResultsResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.hasResultSet is not None:
            oprot.writeFieldBegin('hasResultSet', TType.BOOL, 2)
            oprot.writeBool(self.hasResultSet)
            oprot.writeFieldEnd()
        if self.isAlign is not None:
            oprot.writeFieldBegin('isAlign', TType.BOOL, 3)
            oprot.writeBool(self.isAlign)
            oprot.writeFieldEnd()
        if self.queryDataSet is not None:
            oprot.writeFieldBegin('queryDataSet', TType.STRUCT, 4)
            self.queryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.nonAlignQueryDataSet is not None:
            oprot.writeFieldBegin('nonAlignQueryDataSet', TType.STRUCT, 5)
            self.nonAlignQueryDataSet.write(oprot)
            oprot.writeFieldEnd()
        if self.queryResult is not None:
            oprot.writeFieldBegin('queryResult', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.queryResult))
            for iter124 in self.queryResult:
                oprot.writeBinary(iter124)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.moreData is not None:
            oprot.writeFieldBegin('moreData', TType.BOOL, 7)
            oprot.writeBool(self.moreData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.hasResultSet is None:
            raise TProtocolException(message='Required field hasResultSet is unset!')
        if self.isAlign is None:
            raise TProtocolException(message='Required field isAlign is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchMetadataResp(object):
    """
    Attributes:
     - status
     - metadataInJson
     - columnsList
     - dataType

    """


    def __init__(self, status=None, metadataInJson=None, columnsList=None, dataType=None,):
        self.status = status
        self.metadataInJson = metadataInJson
        self.columnsList = columnsList
        self.dataType = dataType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.metadataInJson = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columnsList = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.columnsList.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dataType = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchMetadataResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.metadataInJson is not None:
            oprot.writeFieldBegin('metadataInJson', TType.STRING, 2)
            oprot.writeString(self.metadataInJson.encode('utf-8') if sys.version_info[0] == 2 else self.metadataInJson)
            oprot.writeFieldEnd()
        if self.columnsList is not None:
            oprot.writeFieldBegin('columnsList', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.columnsList))
            for iter131 in self.columnsList:
                oprot.writeString(iter131.encode('utf-8') if sys.version_info[0] == 2 else iter131)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.STRING, 4)
            oprot.writeString(self.dataType.encode('utf-8') if sys.version_info[0] == 2 else self.dataType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFetchMetadataReq(object):
    """
    Attributes:
     - sessionId
     - type
     - columnPath

    """


    def __init__(self, sessionId=None, type=None, columnPath=None,):
        self.sessionId = sessionId
        self.type = type
        self.columnPath = columnPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.columnPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFetchMetadataReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 2)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.columnPath is not None:
            oprot.writeFieldBegin('columnPath', TType.STRING, 3)
            oprot.writeString(self.columnPath.encode('utf-8') if sys.version_info[0] == 2 else self.columnPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSGetTimeZoneResp(object):
    """
    Attributes:
     - status
     - timeZone

    """


    def __init__(self, status=None, timeZone=None,):
        self.status = status
        self.timeZone = timeZone

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timeZone = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSGetTimeZoneResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.timeZone is not None:
            oprot.writeFieldBegin('timeZone', TType.STRING, 2)
            oprot.writeString(self.timeZone.encode('utf-8') if sys.version_info[0] == 2 else self.timeZone)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.timeZone is None:
            raise TProtocolException(message='Required field timeZone is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSSetTimeZoneReq(object):
    """
    Attributes:
     - sessionId
     - timeZone

    """


    def __init__(self, sessionId=None, timeZone=None,):
        self.sessionId = sessionId
        self.timeZone = timeZone

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.timeZone = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSSetTimeZoneReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.timeZone is not None:
            oprot.writeFieldBegin('timeZone', TType.STRING, 2)
            oprot.writeString(self.timeZone.encode('utf-8') if sys.version_info[0] == 2 else self.timeZone)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.timeZone is None:
            raise TProtocolException(message='Required field timeZone is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertRecordReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - values
     - timestamp
     - isAligned
     - isWriteToTable
     - columnCategoryies

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, values=None, timestamp=None, isAligned=None, isWriteToTable=None, columnCategoryies=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.values = values
        self.timestamp = timestamp
        self.isAligned = isAligned
        self.isWriteToTable = isWriteToTable
        self.columnCategoryies = columnCategoryies

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype135, _size132) = iprot.readListBegin()
                    for _i136 in range(_size132):
                        _elem137 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem137)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.values = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.isWriteToTable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.columnCategoryies = []
                    (_etype141, _size138) = iprot.readListBegin()
                    for _i142 in range(_size138):
                        _elem143 = iprot.readByte()
                        self.columnCategoryies.append(_elem143)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertRecordReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter144 in self.measurements:
                oprot.writeString(iter144.encode('utf-8') if sys.version_info[0] == 2 else iter144)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.STRING, 4)
            oprot.writeBinary(self.values)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 5)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        if self.isWriteToTable is not None:
            oprot.writeFieldBegin('isWriteToTable', TType.BOOL, 7)
            oprot.writeBool(self.isWriteToTable)
            oprot.writeFieldEnd()
        if self.columnCategoryies is not None:
            oprot.writeFieldBegin('columnCategoryies', TType.LIST, 8)
            oprot.writeListBegin(TType.BYTE, len(self.columnCategoryies))
            for iter145 in self.columnCategoryies:
                oprot.writeByte(iter145)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertStringRecordReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - values
     - timestamp
     - isAligned
     - timeout

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, values=None, timestamp=None, isAligned=None, timeout=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.values = values
        self.timestamp = timestamp
        self.isAligned = isAligned
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype149, _size146) = iprot.readListBegin()
                    for _i150 in range(_size146):
                        _elem151 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem151)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype155, _size152) = iprot.readListBegin()
                    for _i156 in range(_size152):
                        _elem157 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.values.append(_elem157)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertStringRecordReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter158 in self.measurements:
                oprot.writeString(iter158.encode('utf-8') if sys.version_info[0] == 2 else iter158)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.values))
            for iter159 in self.values:
                oprot.writeString(iter159.encode('utf-8') if sys.version_info[0] == 2 else iter159)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 5)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 7)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.timestamp is None:
            raise TProtocolException(message='Required field timestamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertTabletReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - values
     - timestamps
     - types
     - size
     - isAligned
     - writeToTable
     - columnCategories

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, values=None, timestamps=None, types=None, size=None, isAligned=None, writeToTable=None, columnCategories=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.values = values
        self.timestamps = timestamps
        self.types = types
        self.size = size
        self.isAligned = isAligned
        self.writeToTable = writeToTable
        self.columnCategories = columnCategories

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype163, _size160) = iprot.readListBegin()
                    for _i164 in range(_size160):
                        _elem165 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem165)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.values = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.timestamps = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.types = []
                    (_etype169, _size166) = iprot.readListBegin()
                    for _i170 in range(_size166):
                        _elem171 = iprot.readI32()
                        self.types.append(_elem171)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.writeToTable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.LIST:
                    self.columnCategories = []
                    (_etype175, _size172) = iprot.readListBegin()
                    for _i176 in range(_size172):
                        _elem177 = iprot.readByte()
                        self.columnCategories.append(_elem177)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertTabletReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter178 in self.measurements:
                oprot.writeString(iter178.encode('utf-8') if sys.version_info[0] == 2 else iter178)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.STRING, 4)
            oprot.writeBinary(self.values)
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.STRING, 5)
            oprot.writeBinary(self.timestamps)
            oprot.writeFieldEnd()
        if self.types is not None:
            oprot.writeFieldBegin('types', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.types))
            for iter179 in self.types:
                oprot.writeI32(iter179)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.size is not None:
            oprot.writeFieldBegin('size', TType.I32, 7)
            oprot.writeI32(self.size)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 8)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        if self.writeToTable is not None:
            oprot.writeFieldBegin('writeToTable', TType.BOOL, 9)
            oprot.writeBool(self.writeToTable)
            oprot.writeFieldEnd()
        if self.columnCategories is not None:
            oprot.writeFieldBegin('columnCategories', TType.LIST, 10)
            oprot.writeListBegin(TType.BYTE, len(self.columnCategories))
            for iter180 in self.columnCategories:
                oprot.writeByte(iter180)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.values is None:
            raise TProtocolException(message='Required field values is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        if self.types is None:
            raise TProtocolException(message='Required field types is unset!')
        if self.size is None:
            raise TProtocolException(message='Required field size is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertTabletsReq(object):
    """
    Attributes:
     - sessionId
     - prefixPaths
     - measurementsList
     - valuesList
     - timestampsList
     - typesList
     - sizeList
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPaths=None, measurementsList=None, valuesList=None, timestampsList=None, typesList=None, sizeList=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPaths = prefixPaths
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestampsList = timestampsList
        self.typesList = typesList
        self.sizeList = sizeList
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixPaths = []
                    (_etype184, _size181) = iprot.readListBegin()
                    for _i185 in range(_size181):
                        _elem186 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPaths.append(_elem186)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype190, _size187) = iprot.readListBegin()
                    for _i191 in range(_size187):
                        _elem192 = []
                        (_etype196, _size193) = iprot.readListBegin()
                        for _i197 in range(_size193):
                            _elem198 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem192.append(_elem198)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem192)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype202, _size199) = iprot.readListBegin()
                    for _i203 in range(_size199):
                        _elem204 = iprot.readBinary()
                        self.valuesList.append(_elem204)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestampsList = []
                    (_etype208, _size205) = iprot.readListBegin()
                    for _i209 in range(_size205):
                        _elem210 = iprot.readBinary()
                        self.timestampsList.append(_elem210)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.typesList = []
                    (_etype214, _size211) = iprot.readListBegin()
                    for _i215 in range(_size211):
                        _elem216 = []
                        (_etype220, _size217) = iprot.readListBegin()
                        for _i221 in range(_size217):
                            _elem222 = iprot.readI32()
                            _elem216.append(_elem222)
                        iprot.readListEnd()
                        self.typesList.append(_elem216)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.sizeList = []
                    (_etype226, _size223) = iprot.readListBegin()
                    for _i227 in range(_size223):
                        _elem228 = iprot.readI32()
                        self.sizeList.append(_elem228)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertTabletsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPaths is not None:
            oprot.writeFieldBegin('prefixPaths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixPaths))
            for iter229 in self.prefixPaths:
                oprot.writeString(iter229.encode('utf-8') if sys.version_info[0] == 2 else iter229)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter230 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter230))
                for iter231 in iter230:
                    oprot.writeString(iter231.encode('utf-8') if sys.version_info[0] == 2 else iter231)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter232 in self.valuesList:
                oprot.writeBinary(iter232)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestampsList is not None:
            oprot.writeFieldBegin('timestampsList', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.timestampsList))
            for iter233 in self.timestampsList:
                oprot.writeBinary(iter233)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.typesList is not None:
            oprot.writeFieldBegin('typesList', TType.LIST, 6)
            oprot.writeListBegin(TType.LIST, len(self.typesList))
            for iter234 in self.typesList:
                oprot.writeListBegin(TType.I32, len(iter234))
                for iter235 in iter234:
                    oprot.writeI32(iter235)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sizeList is not None:
            oprot.writeFieldBegin('sizeList', TType.LIST, 7)
            oprot.writeListBegin(TType.I32, len(self.sizeList))
            for iter236 in self.sizeList:
                oprot.writeI32(iter236)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 8)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPaths is None:
            raise TProtocolException(message='Required field prefixPaths is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestampsList is None:
            raise TProtocolException(message='Required field timestampsList is unset!')
        if self.typesList is None:
            raise TProtocolException(message='Required field typesList is unset!')
        if self.sizeList is None:
            raise TProtocolException(message='Required field sizeList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertRecordsReq(object):
    """
    Attributes:
     - sessionId
     - prefixPaths
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPaths=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPaths = prefixPaths
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixPaths = []
                    (_etype240, _size237) = iprot.readListBegin()
                    for _i241 in range(_size237):
                        _elem242 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPaths.append(_elem242)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype246, _size243) = iprot.readListBegin()
                    for _i247 in range(_size243):
                        _elem248 = []
                        (_etype252, _size249) = iprot.readListBegin()
                        for _i253 in range(_size249):
                            _elem254 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem248.append(_elem254)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem248)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype258, _size255) = iprot.readListBegin()
                    for _i259 in range(_size255):
                        _elem260 = iprot.readBinary()
                        self.valuesList.append(_elem260)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype264, _size261) = iprot.readListBegin()
                    for _i265 in range(_size261):
                        _elem266 = iprot.readI64()
                        self.timestamps.append(_elem266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPaths is not None:
            oprot.writeFieldBegin('prefixPaths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixPaths))
            for iter267 in self.prefixPaths:
                oprot.writeString(iter267.encode('utf-8') if sys.version_info[0] == 2 else iter267)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter268 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter268))
                for iter269 in iter268:
                    oprot.writeString(iter269.encode('utf-8') if sys.version_info[0] == 2 else iter269)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter270 in self.valuesList:
                oprot.writeBinary(iter270)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter271 in self.timestamps:
                oprot.writeI64(iter271)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPaths is None:
            raise TProtocolException(message='Required field prefixPaths is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertRecordsOfOneDeviceReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPath=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype275, _size272) = iprot.readListBegin()
                    for _i276 in range(_size272):
                        _elem277 = []
                        (_etype281, _size278) = iprot.readListBegin()
                        for _i282 in range(_size278):
                            _elem283 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem277.append(_elem283)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem277)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype287, _size284) = iprot.readListBegin()
                    for _i288 in range(_size284):
                        _elem289 = iprot.readBinary()
                        self.valuesList.append(_elem289)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype293, _size290) = iprot.readListBegin()
                    for _i294 in range(_size290):
                        _elem295 = iprot.readI64()
                        self.timestamps.append(_elem295)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertRecordsOfOneDeviceReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter296 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter296))
                for iter297 in iter296:
                    oprot.writeString(iter297.encode('utf-8') if sys.version_info[0] == 2 else iter297)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.valuesList))
            for iter298 in self.valuesList:
                oprot.writeBinary(iter298)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter299 in self.timestamps:
                oprot.writeI64(iter299)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertStringRecordsOfOneDeviceReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPath=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype303, _size300) = iprot.readListBegin()
                    for _i304 in range(_size300):
                        _elem305 = []
                        (_etype309, _size306) = iprot.readListBegin()
                        for _i310 in range(_size306):
                            _elem311 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem305.append(_elem311)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem305)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype315, _size312) = iprot.readListBegin()
                    for _i316 in range(_size312):
                        _elem317 = []
                        (_etype321, _size318) = iprot.readListBegin()
                        for _i322 in range(_size318):
                            _elem323 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem317.append(_elem323)
                        iprot.readListEnd()
                        self.valuesList.append(_elem317)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype327, _size324) = iprot.readListBegin()
                    for _i328 in range(_size324):
                        _elem329 = iprot.readI64()
                        self.timestamps.append(_elem329)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertStringRecordsOfOneDeviceReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter330 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter330))
                for iter331 in iter330:
                    oprot.writeString(iter331.encode('utf-8') if sys.version_info[0] == 2 else iter331)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.valuesList))
            for iter332 in self.valuesList:
                oprot.writeListBegin(TType.STRING, len(iter332))
                for iter333 in iter332:
                    oprot.writeString(iter333.encode('utf-8') if sys.version_info[0] == 2 else iter333)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter334 in self.timestamps:
                oprot.writeI64(iter334)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSInsertStringRecordsReq(object):
    """
    Attributes:
     - sessionId
     - prefixPaths
     - measurementsList
     - valuesList
     - timestamps
     - isAligned

    """


    def __init__(self, sessionId=None, prefixPaths=None, measurementsList=None, valuesList=None, timestamps=None, isAligned=None,):
        self.sessionId = sessionId
        self.prefixPaths = prefixPaths
        self.measurementsList = measurementsList
        self.valuesList = valuesList
        self.timestamps = timestamps
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixPaths = []
                    (_etype338, _size335) = iprot.readListBegin()
                    for _i339 in range(_size335):
                        _elem340 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixPaths.append(_elem340)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurementsList = []
                    (_etype344, _size341) = iprot.readListBegin()
                    for _i345 in range(_size341):
                        _elem346 = []
                        (_etype350, _size347) = iprot.readListBegin()
                        for _i351 in range(_size347):
                            _elem352 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem346.append(_elem352)
                        iprot.readListEnd()
                        self.measurementsList.append(_elem346)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.valuesList = []
                    (_etype356, _size353) = iprot.readListBegin()
                    for _i357 in range(_size353):
                        _elem358 = []
                        (_etype362, _size359) = iprot.readListBegin()
                        for _i363 in range(_size359):
                            _elem364 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem358.append(_elem364)
                        iprot.readListEnd()
                        self.valuesList.append(_elem358)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.timestamps = []
                    (_etype368, _size365) = iprot.readListBegin()
                    for _i369 in range(_size365):
                        _elem370 = iprot.readI64()
                        self.timestamps.append(_elem370)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSInsertStringRecordsReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPaths is not None:
            oprot.writeFieldBegin('prefixPaths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixPaths))
            for iter371 in self.prefixPaths:
                oprot.writeString(iter371.encode('utf-8') if sys.version_info[0] == 2 else iter371)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementsList is not None:
            oprot.writeFieldBegin('measurementsList', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.measurementsList))
            for iter372 in self.measurementsList:
                oprot.writeListBegin(TType.STRING, len(iter372))
                for iter373 in iter372:
                    oprot.writeString(iter373.encode('utf-8') if sys.version_info[0] == 2 else iter373)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.valuesList is not None:
            oprot.writeFieldBegin('valuesList', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.valuesList))
            for iter374 in self.valuesList:
                oprot.writeListBegin(TType.STRING, len(iter374))
                for iter375 in iter374:
                    oprot.writeString(iter375.encode('utf-8') if sys.version_info[0] == 2 else iter375)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamps is not None:
            oprot.writeFieldBegin('timestamps', TType.LIST, 5)
            oprot.writeListBegin(TType.I64, len(self.timestamps))
            for iter376 in self.timestamps:
                oprot.writeI64(iter376)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 6)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPaths is None:
            raise TProtocolException(message='Required field prefixPaths is unset!')
        if self.measurementsList is None:
            raise TProtocolException(message='Required field measurementsList is unset!')
        if self.valuesList is None:
            raise TProtocolException(message='Required field valuesList is unset!')
        if self.timestamps is None:
            raise TProtocolException(message='Required field timestamps is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSDeleteDataReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - startTime
     - endTime

    """


    def __init__(self, sessionId=None, paths=None, startTime=None, endTime=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.startTime = startTime
        self.endTime = endTime

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype380, _size377) = iprot.readListBegin()
                    for _i381 in range(_size377):
                        _elem382 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem382)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSDeleteDataReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter383 in self.paths:
                oprot.writeString(iter383.encode('utf-8') if sys.version_info[0] == 2 else iter383)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 3)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 4)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateTimeseriesReq(object):
    """
    Attributes:
     - sessionId
     - path
     - dataType
     - encoding
     - compressor
     - props
     - tags
     - attributes
     - measurementAlias

    """


    def __init__(self, sessionId=None, path=None, dataType=None, encoding=None, compressor=None, props=None, tags=None, attributes=None, measurementAlias=None,):
        self.sessionId = sessionId
        self.path = path
        self.dataType = dataType
        self.encoding = encoding
        self.compressor = compressor
        self.props = props
        self.tags = tags
        self.attributes = attributes
        self.measurementAlias = measurementAlias

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.dataType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.compressor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.props = {}
                    (_ktype385, _vtype386, _size384) = iprot.readMapBegin()
                    for _i388 in range(_size384):
                        _key389 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val390 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.props[_key389] = _val390
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.tags = {}
                    (_ktype392, _vtype393, _size391) = iprot.readMapBegin()
                    for _i395 in range(_size391):
                        _key396 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val397 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.tags[_key396] = _val397
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype399, _vtype400, _size398) = iprot.readMapBegin()
                    for _i402 in range(_size398):
                        _key403 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        _val404 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.attributes[_key403] = _val404
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.measurementAlias = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateTimeseriesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 2)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.I32, 3)
            oprot.writeI32(self.dataType)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 4)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        if self.compressor is not None:
            oprot.writeFieldBegin('compressor', TType.I32, 5)
            oprot.writeI32(self.compressor)
            oprot.writeFieldEnd()
        if self.props is not None:
            oprot.writeFieldBegin('props', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.props))
            for kiter405, viter406 in self.props.items():
                oprot.writeString(kiter405.encode('utf-8') if sys.version_info[0] == 2 else kiter405)
                oprot.writeString(viter406.encode('utf-8') if sys.version_info[0] == 2 else viter406)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tags))
            for kiter407, viter408 in self.tags.items():
                oprot.writeString(kiter407.encode('utf-8') if sys.version_info[0] == 2 else kiter407)
                oprot.writeString(viter408.encode('utf-8') if sys.version_info[0] == 2 else viter408)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 8)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter409, viter410 in self.attributes.items():
                oprot.writeString(kiter409.encode('utf-8') if sys.version_info[0] == 2 else kiter409)
                oprot.writeString(viter410.encode('utf-8') if sys.version_info[0] == 2 else viter410)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.measurementAlias is not None:
            oprot.writeFieldBegin('measurementAlias', TType.STRING, 9)
            oprot.writeString(self.measurementAlias.encode('utf-8') if sys.version_info[0] == 2 else self.measurementAlias)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        if self.dataType is None:
            raise TProtocolException(message='Required field dataType is unset!')
        if self.encoding is None:
            raise TProtocolException(message='Required field encoding is unset!')
        if self.compressor is None:
            raise TProtocolException(message='Required field compressor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateAlignedTimeseriesReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - measurements
     - dataTypes
     - encodings
     - compressors
     - measurementAlias
     - tagsList
     - attributesList

    """


    def __init__(self, sessionId=None, prefixPath=None, measurements=None, dataTypes=None, encodings=None, compressors=None, measurementAlias=None, tagsList=None, attributesList=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.measurements = measurements
        self.dataTypes = dataTypes
        self.encodings = encodings
        self.compressors = compressors
        self.measurementAlias = measurementAlias
        self.tagsList = tagsList
        self.attributesList = attributesList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype414, _size411) = iprot.readListBegin()
                    for _i415 in range(_size411):
                        _elem416 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem416)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.dataTypes = []
                    (_etype420, _size417) = iprot.readListBegin()
                    for _i421 in range(_size417):
                        _elem422 = iprot.readI32()
                        self.dataTypes.append(_elem422)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.encodings = []
                    (_etype426, _size423) = iprot.readListBegin()
                    for _i427 in range(_size423):
                        _elem428 = iprot.readI32()
                        self.encodings.append(_elem428)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.compressors = []
                    (_etype432, _size429) = iprot.readListBegin()
                    for _i433 in range(_size429):
                        _elem434 = iprot.readI32()
                        self.compressors.append(_elem434)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.measurementAlias = []
                    (_etype438, _size435) = iprot.readListBegin()
                    for _i439 in range(_size435):
                        _elem440 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurementAlias.append(_elem440)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype444, _size441) = iprot.readListBegin()
                    for _i445 in range(_size441):
                        _elem446 = {}
                        (_ktype448, _vtype449, _size447) = iprot.readMapBegin()
                        for _i451 in range(_size447):
                            _key452 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val453 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem446[_key452] = _val453
                        iprot.readMapEnd()
                        self.tagsList.append(_elem446)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.attributesList = []
                    (_etype457, _size454) = iprot.readListBegin()
                    for _i458 in range(_size454):
                        _elem459 = {}
                        (_ktype461, _vtype462, _size460) = iprot.readMapBegin()
                        for _i464 in range(_size460):
                            _key465 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val466 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem459[_key465] = _val466
                        iprot.readMapEnd()
                        self.attributesList.append(_elem459)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateAlignedTimeseriesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter467 in self.measurements:
                oprot.writeString(iter467.encode('utf-8') if sys.version_info[0] == 2 else iter467)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypes is not None:
            oprot.writeFieldBegin('dataTypes', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.dataTypes))
            for iter468 in self.dataTypes:
                oprot.writeI32(iter468)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encodings is not None:
            oprot.writeFieldBegin('encodings', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.encodings))
            for iter469 in self.encodings:
                oprot.writeI32(iter469)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.compressors is not None:
            oprot.writeFieldBegin('compressors', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.compressors))
            for iter470 in self.compressors:
                oprot.writeI32(iter470)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementAlias is not None:
            oprot.writeFieldBegin('measurementAlias', TType.LIST, 7)
            oprot.writeListBegin(TType.STRING, len(self.measurementAlias))
            for iter471 in self.measurementAlias:
                oprot.writeString(iter471.encode('utf-8') if sys.version_info[0] == 2 else iter471)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 8)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter472 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter472))
                for kiter473, viter474 in iter472.items():
                    oprot.writeString(kiter473.encode('utf-8') if sys.version_info[0] == 2 else kiter473)
                    oprot.writeString(viter474.encode('utf-8') if sys.version_info[0] == 2 else viter474)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributesList is not None:
            oprot.writeFieldBegin('attributesList', TType.LIST, 9)
            oprot.writeListBegin(TType.MAP, len(self.attributesList))
            for iter475 in self.attributesList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter475))
                for kiter476, viter477 in iter475.items():
                    oprot.writeString(kiter476.encode('utf-8') if sys.version_info[0] == 2 else kiter476)
                    oprot.writeString(viter477.encode('utf-8') if sys.version_info[0] == 2 else viter477)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.dataTypes is None:
            raise TProtocolException(message='Required field dataTypes is unset!')
        if self.encodings is None:
            raise TProtocolException(message='Required field encodings is unset!')
        if self.compressors is None:
            raise TProtocolException(message='Required field compressors is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSRawDataQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - fetchSize
     - startTime
     - endTime
     - statementId
     - enableRedirectQuery
     - jdbcQuery
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, paths=None, fetchSize=None, startTime=None, endTime=None, statementId=None, enableRedirectQuery=None, jdbcQuery=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.fetchSize = fetchSize
        self.startTime = startTime
        self.endTime = endTime
        self.statementId = statementId
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype481, _size478) = iprot.readListBegin()
                    for _i482 in range(_size478):
                        _elem483 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem483)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSRawDataQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter484 in self.paths:
                oprot.writeString(iter484.encode('utf-8') if sys.version_info[0] == 2 else iter484)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 4)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 5)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 6)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 7)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 8)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 9)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 10)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.startTime is None:
            raise TProtocolException(message='Required field startTime is unset!')
        if self.endTime is None:
            raise TProtocolException(message='Required field endTime is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSLastDataQueryReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - fetchSize
     - time
     - statementId
     - enableRedirectQuery
     - jdbcQuery
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, paths=None, fetchSize=None, time=None, statementId=None, enableRedirectQuery=None, jdbcQuery=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.fetchSize = fetchSize
        self.time = time
        self.statementId = statementId
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype488, _size485) = iprot.readListBegin()
                    for _i489 in range(_size485):
                        _elem490 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem490)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSLastDataQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter491 in self.paths:
                oprot.writeString(iter491.encode('utf-8') if sys.version_info[0] == 2 else iter491)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.I64, 4)
            oprot.writeI64(self.time)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 5)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 6)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 7)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 8)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 9)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.time is None:
            raise TProtocolException(message='Required field time is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFastLastDataQueryForOnePrefixPathReq(object):
    """
    Attributes:
     - sessionId
     - prefixes
     - fetchSize
     - statementId
     - enableRedirectQuery
     - jdbcQuery
     - timeout

    """


    def __init__(self, sessionId=None, prefixes=None, fetchSize=None, statementId=None, enableRedirectQuery=None, jdbcQuery=None, timeout=None,):
        self.sessionId = sessionId
        self.prefixes = prefixes
        self.fetchSize = fetchSize
        self.statementId = statementId
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery
        self.timeout = timeout

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.prefixes = []
                    (_etype495, _size492) = iprot.readListBegin()
                    for _i496 in range(_size492):
                        _elem497 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.prefixes.append(_elem497)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFastLastDataQueryForOnePrefixPathReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixes is not None:
            oprot.writeFieldBegin('prefixes', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.prefixes))
            for iter498 in self.prefixes:
                oprot.writeString(iter498.encode('utf-8') if sys.version_info[0] == 2 else iter498)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 3)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 4)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 5)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 6)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 7)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixes is None:
            raise TProtocolException(message='Required field prefixes is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSFastLastDataQueryForOneDeviceReq(object):
    """
    Attributes:
     - sessionId
     - db
     - deviceId
     - sensors
     - fetchSize
     - statementId
     - enableRedirectQuery
     - jdbcQuery
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, db=None, deviceId=None, sensors=None, fetchSize=None, statementId=None, enableRedirectQuery=None, jdbcQuery=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.db = db
        self.deviceId = deviceId
        self.sensors = sensors
        self.fetchSize = fetchSize
        self.statementId = statementId
        self.enableRedirectQuery = enableRedirectQuery
        self.jdbcQuery = jdbcQuery
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.deviceId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.sensors = []
                    (_etype502, _size499) = iprot.readListBegin()
                    for _i503 in range(_size499):
                        _elem504 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.sensors.append(_elem504)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.enableRedirectQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.jdbcQuery = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSFastLastDataQueryForOneDeviceReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 2)
            oprot.writeString(self.db.encode('utf-8') if sys.version_info[0] == 2 else self.db)
            oprot.writeFieldEnd()
        if self.deviceId is not None:
            oprot.writeFieldBegin('deviceId', TType.STRING, 3)
            oprot.writeString(self.deviceId.encode('utf-8') if sys.version_info[0] == 2 else self.deviceId)
            oprot.writeFieldEnd()
        if self.sensors is not None:
            oprot.writeFieldBegin('sensors', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.sensors))
            for iter505 in self.sensors:
                oprot.writeString(iter505.encode('utf-8') if sys.version_info[0] == 2 else iter505)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 5)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 6)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.enableRedirectQuery is not None:
            oprot.writeFieldBegin('enableRedirectQuery', TType.BOOL, 7)
            oprot.writeBool(self.enableRedirectQuery)
            oprot.writeFieldEnd()
        if self.jdbcQuery is not None:
            oprot.writeFieldBegin('jdbcQuery', TType.BOOL, 8)
            oprot.writeBool(self.jdbcQuery)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 9)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 10)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        if self.deviceId is None:
            raise TProtocolException(message='Required field deviceId is unset!')
        if self.sensors is None:
            raise TProtocolException(message='Required field sensors is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSAggregationQueryReq(object):
    """
    Attributes:
     - sessionId
     - statementId
     - paths
     - aggregations
     - startTime
     - endTime
     - interval
     - slidingStep
     - fetchSize
     - timeout
     - legalPathNodes

    """


    def __init__(self, sessionId=None, statementId=None, paths=None, aggregations=None, startTime=None, endTime=None, interval=None, slidingStep=None, fetchSize=None, timeout=None, legalPathNodes=None,):
        self.sessionId = sessionId
        self.statementId = statementId
        self.paths = paths
        self.aggregations = aggregations
        self.startTime = startTime
        self.endTime = endTime
        self.interval = interval
        self.slidingStep = slidingStep
        self.fetchSize = fetchSize
        self.timeout = timeout
        self.legalPathNodes = legalPathNodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype509, _size506) = iprot.readListBegin()
                    for _i510 in range(_size506):
                        _elem511 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem511)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.aggregations = []
                    (_etype515, _size512) = iprot.readListBegin()
                    for _i516 in range(_size512):
                        _elem517 = iprot.readI32()
                        self.aggregations.append(_elem517)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.interval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.slidingStep = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.legalPathNodes = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSAggregationQueryReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 2)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter518 in self.paths:
                oprot.writeString(iter518.encode('utf-8') if sys.version_info[0] == 2 else iter518)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aggregations is not None:
            oprot.writeFieldBegin('aggregations', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.aggregations))
            for iter519 in self.aggregations:
                oprot.writeI32(iter519)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 5)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 6)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.interval is not None:
            oprot.writeFieldBegin('interval', TType.I64, 7)
            oprot.writeI64(self.interval)
            oprot.writeFieldEnd()
        if self.slidingStep is not None:
            oprot.writeFieldBegin('slidingStep', TType.I64, 8)
            oprot.writeI64(self.slidingStep)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 9)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 10)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.legalPathNodes is not None:
            oprot.writeFieldBegin('legalPathNodes', TType.BOOL, 11)
            oprot.writeBool(self.legalPathNodes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.aggregations is None:
            raise TProtocolException(message='Required field aggregations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSGroupByQueryIntervalReq(object):
    """
    Attributes:
     - sessionId
     - statementId
     - device
     - measurement
     - dataType
     - aggregationType
     - database
     - startTime
     - endTime
     - interval
     - fetchSize
     - timeout
     - isAligned

    """


    def __init__(self, sessionId=None, statementId=None, device=None, measurement=None, dataType=None, aggregationType=None, database=None, startTime=None, endTime=None, interval=None, fetchSize=None, timeout=None, isAligned=None,):
        self.sessionId = sessionId
        self.statementId = statementId
        self.device = device
        self.measurement = measurement
        self.dataType = dataType
        self.aggregationType = aggregationType
        self.database = database
        self.startTime = startTime
        self.endTime = endTime
        self.interval = interval
        self.fetchSize = fetchSize
        self.timeout = timeout
        self.isAligned = isAligned

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.statementId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.device = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.measurement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.dataType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.aggregationType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.endTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.interval = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.fetchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.timeout = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSGroupByQueryIntervalReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.statementId is not None:
            oprot.writeFieldBegin('statementId', TType.I64, 2)
            oprot.writeI64(self.statementId)
            oprot.writeFieldEnd()
        if self.device is not None:
            oprot.writeFieldBegin('device', TType.STRING, 3)
            oprot.writeString(self.device.encode('utf-8') if sys.version_info[0] == 2 else self.device)
            oprot.writeFieldEnd()
        if self.measurement is not None:
            oprot.writeFieldBegin('measurement', TType.STRING, 4)
            oprot.writeString(self.measurement.encode('utf-8') if sys.version_info[0] == 2 else self.measurement)
            oprot.writeFieldEnd()
        if self.dataType is not None:
            oprot.writeFieldBegin('dataType', TType.I32, 5)
            oprot.writeI32(self.dataType)
            oprot.writeFieldEnd()
        if self.aggregationType is not None:
            oprot.writeFieldBegin('aggregationType', TType.I32, 6)
            oprot.writeI32(self.aggregationType)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 7)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 8)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.endTime is not None:
            oprot.writeFieldBegin('endTime', TType.I64, 9)
            oprot.writeI64(self.endTime)
            oprot.writeFieldEnd()
        if self.interval is not None:
            oprot.writeFieldBegin('interval', TType.I64, 10)
            oprot.writeI64(self.interval)
            oprot.writeFieldEnd()
        if self.fetchSize is not None:
            oprot.writeFieldBegin('fetchSize', TType.I32, 11)
            oprot.writeI32(self.fetchSize)
            oprot.writeFieldEnd()
        if self.timeout is not None:
            oprot.writeFieldBegin('timeout', TType.I64, 12)
            oprot.writeI64(self.timeout)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 13)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.statementId is None:
            raise TProtocolException(message='Required field statementId is unset!')
        if self.device is None:
            raise TProtocolException(message='Required field device is unset!')
        if self.measurement is None:
            raise TProtocolException(message='Required field measurement is unset!')
        if self.dataType is None:
            raise TProtocolException(message='Required field dataType is unset!')
        if self.aggregationType is None:
            raise TProtocolException(message='Required field aggregationType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateMultiTimeseriesReq(object):
    """
    Attributes:
     - sessionId
     - paths
     - dataTypes
     - encodings
     - compressors
     - propsList
     - tagsList
     - attributesList
     - measurementAliasList

    """


    def __init__(self, sessionId=None, paths=None, dataTypes=None, encodings=None, compressors=None, propsList=None, tagsList=None, attributesList=None, measurementAliasList=None,):
        self.sessionId = sessionId
        self.paths = paths
        self.dataTypes = dataTypes
        self.encodings = encodings
        self.compressors = compressors
        self.propsList = propsList
        self.tagsList = tagsList
        self.attributesList = attributesList
        self.measurementAliasList = measurementAliasList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype523, _size520) = iprot.readListBegin()
                    for _i524 in range(_size520):
                        _elem525 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.paths.append(_elem525)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dataTypes = []
                    (_etype529, _size526) = iprot.readListBegin()
                    for _i530 in range(_size526):
                        _elem531 = iprot.readI32()
                        self.dataTypes.append(_elem531)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.encodings = []
                    (_etype535, _size532) = iprot.readListBegin()
                    for _i536 in range(_size532):
                        _elem537 = iprot.readI32()
                        self.encodings.append(_elem537)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.compressors = []
                    (_etype541, _size538) = iprot.readListBegin()
                    for _i542 in range(_size538):
                        _elem543 = iprot.readI32()
                        self.compressors.append(_elem543)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.propsList = []
                    (_etype547, _size544) = iprot.readListBegin()
                    for _i548 in range(_size544):
                        _elem549 = {}
                        (_ktype551, _vtype552, _size550) = iprot.readMapBegin()
                        for _i554 in range(_size550):
                            _key555 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val556 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem549[_key555] = _val556
                        iprot.readMapEnd()
                        self.propsList.append(_elem549)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.tagsList = []
                    (_etype560, _size557) = iprot.readListBegin()
                    for _i561 in range(_size557):
                        _elem562 = {}
                        (_ktype564, _vtype565, _size563) = iprot.readMapBegin()
                        for _i567 in range(_size563):
                            _key568 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val569 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem562[_key568] = _val569
                        iprot.readMapEnd()
                        self.tagsList.append(_elem562)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.attributesList = []
                    (_etype573, _size570) = iprot.readListBegin()
                    for _i574 in range(_size570):
                        _elem575 = {}
                        (_ktype577, _vtype578, _size576) = iprot.readMapBegin()
                        for _i580 in range(_size576):
                            _key581 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _val582 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                            _elem575[_key581] = _val582
                        iprot.readMapEnd()
                        self.attributesList.append(_elem575)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.measurementAliasList = []
                    (_etype586, _size583) = iprot.readListBegin()
                    for _i587 in range(_size583):
                        _elem588 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurementAliasList.append(_elem588)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateMultiTimeseriesReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter589 in self.paths:
                oprot.writeString(iter589.encode('utf-8') if sys.version_info[0] == 2 else iter589)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypes is not None:
            oprot.writeFieldBegin('dataTypes', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.dataTypes))
            for iter590 in self.dataTypes:
                oprot.writeI32(iter590)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encodings is not None:
            oprot.writeFieldBegin('encodings', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.encodings))
            for iter591 in self.encodings:
                oprot.writeI32(iter591)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.compressors is not None:
            oprot.writeFieldBegin('compressors', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.compressors))
            for iter592 in self.compressors:
                oprot.writeI32(iter592)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.propsList is not None:
            oprot.writeFieldBegin('propsList', TType.LIST, 6)
            oprot.writeListBegin(TType.MAP, len(self.propsList))
            for iter593 in self.propsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter593))
                for kiter594, viter595 in iter593.items():
                    oprot.writeString(kiter594.encode('utf-8') if sys.version_info[0] == 2 else kiter594)
                    oprot.writeString(viter595.encode('utf-8') if sys.version_info[0] == 2 else viter595)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tagsList is not None:
            oprot.writeFieldBegin('tagsList', TType.LIST, 7)
            oprot.writeListBegin(TType.MAP, len(self.tagsList))
            for iter596 in self.tagsList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter596))
                for kiter597, viter598 in iter596.items():
                    oprot.writeString(kiter597.encode('utf-8') if sys.version_info[0] == 2 else kiter597)
                    oprot.writeString(viter598.encode('utf-8') if sys.version_info[0] == 2 else viter598)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributesList is not None:
            oprot.writeFieldBegin('attributesList', TType.LIST, 8)
            oprot.writeListBegin(TType.MAP, len(self.attributesList))
            for iter599 in self.attributesList:
                oprot.writeMapBegin(TType.STRING, TType.STRING, len(iter599))
                for kiter600, viter601 in iter599.items():
                    oprot.writeString(kiter600.encode('utf-8') if sys.version_info[0] == 2 else kiter600)
                    oprot.writeString(viter601.encode('utf-8') if sys.version_info[0] == 2 else viter601)
                oprot.writeMapEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.measurementAliasList is not None:
            oprot.writeFieldBegin('measurementAliasList', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.measurementAliasList))
            for iter602 in self.measurementAliasList:
                oprot.writeString(iter602.encode('utf-8') if sys.version_info[0] == 2 else iter602)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.dataTypes is None:
            raise TProtocolException(message='Required field dataTypes is unset!')
        if self.encodings is None:
            raise TProtocolException(message='Required field encodings is unset!')
        if self.compressors is None:
            raise TProtocolException(message='Required field compressors is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ServerProperties(object):
    """
    Attributes:
     - version
     - supportedTimeAggregationOperations
     - timestampPrecision
     - maxConcurrentClientNum
     - thriftMaxFrameSize
     - isReadOnly
     - buildInfo
     - logo

    """


    def __init__(self, version=None, supportedTimeAggregationOperations=None, timestampPrecision=None, maxConcurrentClientNum=None, thriftMaxFrameSize=None, isReadOnly=None, buildInfo=None, logo=None,):
        self.version = version
        self.supportedTimeAggregationOperations = supportedTimeAggregationOperations
        self.timestampPrecision = timestampPrecision
        self.maxConcurrentClientNum = maxConcurrentClientNum
        self.thriftMaxFrameSize = thriftMaxFrameSize
        self.isReadOnly = isReadOnly
        self.buildInfo = buildInfo
        self.logo = logo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.supportedTimeAggregationOperations = []
                    (_etype606, _size603) = iprot.readListBegin()
                    for _i607 in range(_size603):
                        _elem608 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.supportedTimeAggregationOperations.append(_elem608)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.timestampPrecision = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.maxConcurrentClientNum = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.thriftMaxFrameSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isReadOnly = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.buildInfo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.logo = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ServerProperties')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 1)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.supportedTimeAggregationOperations is not None:
            oprot.writeFieldBegin('supportedTimeAggregationOperations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.supportedTimeAggregationOperations))
            for iter609 in self.supportedTimeAggregationOperations:
                oprot.writeString(iter609.encode('utf-8') if sys.version_info[0] == 2 else iter609)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestampPrecision is not None:
            oprot.writeFieldBegin('timestampPrecision', TType.STRING, 3)
            oprot.writeString(self.timestampPrecision.encode('utf-8') if sys.version_info[0] == 2 else self.timestampPrecision)
            oprot.writeFieldEnd()
        if self.maxConcurrentClientNum is not None:
            oprot.writeFieldBegin('maxConcurrentClientNum', TType.I32, 4)
            oprot.writeI32(self.maxConcurrentClientNum)
            oprot.writeFieldEnd()
        if self.thriftMaxFrameSize is not None:
            oprot.writeFieldBegin('thriftMaxFrameSize', TType.I32, 5)
            oprot.writeI32(self.thriftMaxFrameSize)
            oprot.writeFieldEnd()
        if self.isReadOnly is not None:
            oprot.writeFieldBegin('isReadOnly', TType.BOOL, 6)
            oprot.writeBool(self.isReadOnly)
            oprot.writeFieldEnd()
        if self.buildInfo is not None:
            oprot.writeFieldBegin('buildInfo', TType.STRING, 7)
            oprot.writeString(self.buildInfo.encode('utf-8') if sys.version_info[0] == 2 else self.buildInfo)
            oprot.writeFieldEnd()
        if self.logo is not None:
            oprot.writeFieldBegin('logo', TType.STRING, 8)
            oprot.writeString(self.logo.encode('utf-8') if sys.version_info[0] == 2 else self.logo)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.supportedTimeAggregationOperations is None:
            raise TProtocolException(message='Required field supportedTimeAggregationOperations is unset!')
        if self.timestampPrecision is None:
            raise TProtocolException(message='Required field timestampPrecision is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSSetSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - templateName
     - prefixPath

    """


    def __init__(self, sessionId=None, templateName=None, prefixPath=None,):
        self.sessionId = sessionId
        self.templateName = templateName
        self.prefixPath = prefixPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSSetSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 2)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 3)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSCreateSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - serializedTemplate

    """


    def __init__(self, sessionId=None, name=None, serializedTemplate=None,):
        self.sessionId = sessionId
        self.name = name
        self.serializedTemplate = serializedTemplate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.serializedTemplate = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSCreateSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.serializedTemplate is not None:
            oprot.writeFieldBegin('serializedTemplate', TType.STRING, 3)
            oprot.writeBinary(self.serializedTemplate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.serializedTemplate is None:
            raise TProtocolException(message='Required field serializedTemplate is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSAppendSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - isAligned
     - measurements
     - dataTypes
     - encodings
     - compressors

    """


    def __init__(self, sessionId=None, name=None, isAligned=None, measurements=None, dataTypes=None, encodings=None, compressors=None,):
        self.sessionId = sessionId
        self.name = name
        self.isAligned = isAligned
        self.measurements = measurements
        self.dataTypes = dataTypes
        self.encodings = encodings
        self.compressors = compressors

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.isAligned = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype613, _size610) = iprot.readListBegin()
                    for _i614 in range(_size610):
                        _elem615 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem615)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.dataTypes = []
                    (_etype619, _size616) = iprot.readListBegin()
                    for _i620 in range(_size616):
                        _elem621 = iprot.readI32()
                        self.dataTypes.append(_elem621)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.encodings = []
                    (_etype625, _size622) = iprot.readListBegin()
                    for _i626 in range(_size622):
                        _elem627 = iprot.readI32()
                        self.encodings.append(_elem627)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.compressors = []
                    (_etype631, _size628) = iprot.readListBegin()
                    for _i632 in range(_size628):
                        _elem633 = iprot.readI32()
                        self.compressors.append(_elem633)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSAppendSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.isAligned is not None:
            oprot.writeFieldBegin('isAligned', TType.BOOL, 3)
            oprot.writeBool(self.isAligned)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter634 in self.measurements:
                oprot.writeString(iter634.encode('utf-8') if sys.version_info[0] == 2 else iter634)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dataTypes is not None:
            oprot.writeFieldBegin('dataTypes', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.dataTypes))
            for iter635 in self.dataTypes:
                oprot.writeI32(iter635)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encodings is not None:
            oprot.writeFieldBegin('encodings', TType.LIST, 6)
            oprot.writeListBegin(TType.I32, len(self.encodings))
            for iter636 in self.encodings:
                oprot.writeI32(iter636)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.compressors is not None:
            oprot.writeFieldBegin('compressors', TType.LIST, 7)
            oprot.writeListBegin(TType.I32, len(self.compressors))
            for iter637 in self.compressors:
                oprot.writeI32(iter637)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.isAligned is None:
            raise TProtocolException(message='Required field isAligned is unset!')
        if self.measurements is None:
            raise TProtocolException(message='Required field measurements is unset!')
        if self.dataTypes is None:
            raise TProtocolException(message='Required field dataTypes is unset!')
        if self.encodings is None:
            raise TProtocolException(message='Required field encodings is unset!')
        if self.compressors is None:
            raise TProtocolException(message='Required field compressors is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSPruneSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - path

    """


    def __init__(self, sessionId=None, name=None, path=None,):
        self.sessionId = sessionId
        self.name = name
        self.path = path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.path = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSPruneSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 3)
            oprot.writeString(self.path.encode('utf-8') if sys.version_info[0] == 2 else self.path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSQueryTemplateReq(object):
    """
    Attributes:
     - sessionId
     - name
     - queryType
     - measurement

    """


    def __init__(self, sessionId=None, name=None, queryType=None, measurement=None,):
        self.sessionId = sessionId
        self.name = name
        self.queryType = queryType
        self.measurement = measurement

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.queryType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.measurement = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.queryType is not None:
            oprot.writeFieldBegin('queryType', TType.I32, 3)
            oprot.writeI32(self.queryType)
            oprot.writeFieldEnd()
        if self.measurement is not None:
            oprot.writeFieldBegin('measurement', TType.STRING, 4)
            oprot.writeString(self.measurement.encode('utf-8') if sys.version_info[0] == 2 else self.measurement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.queryType is None:
            raise TProtocolException(message='Required field queryType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSQueryTemplateResp(object):
    """
    Attributes:
     - status
     - queryType
     - result
     - count
     - measurements

    """


    def __init__(self, status=None, queryType=None, result=None, count=None, measurements=None,):
        self.status = status
        self.queryType = queryType
        self.result = result
        self.count = count
        self.measurements = measurements

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.queryType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.result = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.measurements = []
                    (_etype641, _size638) = iprot.readListBegin()
                    for _i642 in range(_size638):
                        _elem643 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.measurements.append(_elem643)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSQueryTemplateResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.queryType is not None:
            oprot.writeFieldBegin('queryType', TType.I32, 2)
            oprot.writeI32(self.queryType)
            oprot.writeFieldEnd()
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.BOOL, 3)
            oprot.writeBool(self.result)
            oprot.writeFieldEnd()
        if self.count is not None:
            oprot.writeFieldBegin('count', TType.I32, 4)
            oprot.writeI32(self.count)
            oprot.writeFieldEnd()
        if self.measurements is not None:
            oprot.writeFieldBegin('measurements', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.measurements))
            for iter644 in self.measurements:
                oprot.writeString(iter644.encode('utf-8') if sys.version_info[0] == 2 else iter644)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.queryType is None:
            raise TProtocolException(message='Required field queryType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSUnsetSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - prefixPath
     - templateName

    """


    def __init__(self, sessionId=None, prefixPath=None, templateName=None,):
        self.sessionId = sessionId
        self.prefixPath = prefixPath
        self.templateName = templateName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.prefixPath = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSUnsetSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.prefixPath is not None:
            oprot.writeFieldBegin('prefixPath', TType.STRING, 2)
            oprot.writeString(self.prefixPath.encode('utf-8') if sys.version_info[0] == 2 else self.prefixPath)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 3)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.prefixPath is None:
            raise TProtocolException(message='Required field prefixPath is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSDropSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - templateName

    """


    def __init__(self, sessionId=None, templateName=None,):
        self.sessionId = sessionId
        self.templateName = templateName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.templateName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSDropSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.templateName is not None:
            oprot.writeFieldBegin('templateName', TType.STRING, 2)
            oprot.writeString(self.templateName.encode('utf-8') if sys.version_info[0] == 2 else self.templateName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.templateName is None:
            raise TProtocolException(message='Required field templateName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTimeseriesUsingSchemaTemplateReq(object):
    """
    Attributes:
     - sessionId
     - devicePathList

    """


    def __init__(self, sessionId=None, devicePathList=None,):
        self.sessionId = sessionId
        self.devicePathList = devicePathList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.sessionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.devicePathList = []
                    (_etype648, _size645) = iprot.readListBegin()
                    for _i649 in range(_size645):
                        _elem650 = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                        self.devicePathList.append(_elem650)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTimeseriesUsingSchemaTemplateReq')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.I64, 1)
            oprot.writeI64(self.sessionId)
            oprot.writeFieldEnd()
        if self.devicePathList is not None:
            oprot.writeFieldBegin('devicePathList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.devicePathList))
            for iter651 in self.devicePathList:
                oprot.writeString(iter651.encode('utf-8') if sys.version_info[0] == 2 else iter651)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sessionId is None:
            raise TProtocolException(message='Required field sessionId is unset!')
        if self.devicePathList is None:
            raise TProtocolException(message='Required field devicePathList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSyncIdentityInfo(object):
    """
    Attributes:
     - pipeName
     - createTime
     - version
     - database

    """


    def __init__(self, pipeName=None, createTime=None, version=None, database=None,):
        self.pipeName = pipeName
        self.createTime = createTime
        self.version = version
        self.database = database

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pipeName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.createTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.database = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSyncIdentityInfo')
        if self.pipeName is not None:
            oprot.writeFieldBegin('pipeName', TType.STRING, 1)
            oprot.writeString(self.pipeName.encode('utf-8') if sys.version_info[0] == 2 else self.pipeName)
            oprot.writeFieldEnd()
        if self.createTime is not None:
            oprot.writeFieldBegin('createTime', TType.I64, 2)
            oprot.writeI64(self.createTime)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 3)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRING, 4)
            oprot.writeString(self.database.encode('utf-8') if sys.version_info[0] == 2 else self.database)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipeName is None:
            raise TProtocolException(message='Required field pipeName is unset!')
        if self.createTime is None:
            raise TProtocolException(message='Required field createTime is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.database is None:
            raise TProtocolException(message='Required field database is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSyncTransportMetaInfo(object):
    """
    Attributes:
     - fileName
     - startIndex

    """


    def __init__(self, fileName=None, startIndex=None,):
        self.fileName = fileName
        self.startIndex = startIndex

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fileName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.startIndex = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSyncTransportMetaInfo')
        if self.fileName is not None:
            oprot.writeFieldBegin('fileName', TType.STRING, 1)
            oprot.writeString(self.fileName.encode('utf-8') if sys.version_info[0] == 2 else self.fileName)
            oprot.writeFieldEnd()
        if self.startIndex is not None:
            oprot.writeFieldBegin('startIndex', TType.I64, 2)
            oprot.writeI64(self.startIndex)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fileName is None:
            raise TProtocolException(message='Required field fileName is unset!')
        if self.startIndex is None:
            raise TProtocolException(message='Required field startIndex is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeTransferReq(object):
    """
    Attributes:
     - version
     - type
     - body

    """


    def __init__(self, version=None, type=None, body=None,):
        self.version = version
        self.type = type
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.type = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeTransferReq')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.BYTE, 1)
            oprot.writeByte(self.version)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I16, 2)
            oprot.writeI16(self.type)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 3)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.body is None:
            raise TProtocolException(message='Required field body is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeTransferResp(object):
    """
    Attributes:
     - status
     - body

    """


    def __init__(self, status=None, body=None,):
        self.status = status
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeTransferResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 2)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeSubscribeReq(object):
    """
    Attributes:
     - version
     - type
     - body

    """


    def __init__(self, version=None, type=None, body=None,):
        self.version = version
        self.type = type
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.type = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.body = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeSubscribeReq')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.BYTE, 1)
            oprot.writeByte(self.version)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I16, 2)
            oprot.writeI16(self.type)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.STRING, 3)
            oprot.writeBinary(self.body)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipeSubscribeResp(object):
    """
    Attributes:
     - status
     - version
     - type
     - body

    """


    def __init__(self, status=None, version=None, type=None, body=None,):
        self.status = status
        self.version = version
        self.type = type
        self.body = body

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.version = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.type = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.body = []
                    (_etype655, _size652) = iprot.readListBegin()
                    for _i656 in range(_size652):
                        _elem657 = iprot.readBinary()
                        self.body.append(_elem657)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipeSubscribeResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.BYTE, 2)
            oprot.writeByte(self.version)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I16, 3)
            oprot.writeI16(self.type)
            oprot.writeFieldEnd()
        if self.body is not None:
            oprot.writeFieldBegin('body', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.body))
            for iter658 in self.body:
                oprot.writeBinary(iter658)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSBackupConfigurationResp(object):
    """
    Attributes:
     - status
     - enableOperationSync
     - secondaryAddress
     - secondaryPort

    """


    def __init__(self, status=None, enableOperationSync=None, secondaryAddress=None, secondaryPort=None,):
        self.status = status
        self.enableOperationSync = enableOperationSync
        self.secondaryAddress = secondaryAddress
        self.secondaryPort = secondaryPort

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = iotdb.thrift.common.ttypes.TSStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.enableOperationSync = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.secondaryAddress = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.secondaryPort = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSBackupConfigurationResp')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.enableOperationSync is not None:
            oprot.writeFieldBegin('enableOperationSync', TType.BOOL, 2)
            oprot.writeBool(self.enableOperationSync)
            oprot.writeFieldEnd()
        if self.secondaryAddress is not None:
            oprot.writeFieldBegin('secondaryAddress', TType.STRING, 3)
            oprot.writeString(self.secondaryAddress.encode('utf-8') if sys.version_info[0] == 2 else self.secondaryAddress)
            oprot.writeFieldEnd()
        if self.secondaryPort is not None:
            oprot.writeFieldBegin('secondaryPort', TType.I32, 4)
            oprot.writeI32(self.secondaryPort)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSConnectionInfo(object):
    """
    Attributes:
     - userName
     - logInTime
     - connectionId
     - type

    """


    def __init__(self, userName=None, logInTime=None, connectionId=None, type=None,):
        self.userName = userName
        self.logInTime = logInTime
        self.connectionId = connectionId
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.userName = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.logInTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.connectionId = iprot.readString().decode('utf-8', errors='replace') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSConnectionInfo')
        if self.userName is not None:
            oprot.writeFieldBegin('userName', TType.STRING, 1)
            oprot.writeString(self.userName.encode('utf-8') if sys.version_info[0] == 2 else self.userName)
            oprot.writeFieldEnd()
        if self.logInTime is not None:
            oprot.writeFieldBegin('logInTime', TType.I64, 2)
            oprot.writeI64(self.logInTime)
            oprot.writeFieldEnd()
        if self.connectionId is not None:
            oprot.writeFieldBegin('connectionId', TType.STRING, 3)
            oprot.writeString(self.connectionId.encode('utf-8') if sys.version_info[0] == 2 else self.connectionId)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 4)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.userName is None:
            raise TProtocolException(message='Required field userName is unset!')
        if self.logInTime is None:
            raise TProtocolException(message='Required field logInTime is unset!')
        if self.connectionId is None:
            raise TProtocolException(message='Required field connectionId is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSConnectionInfoResp(object):
    """
    Attributes:
     - connectionInfoList

    """


    def __init__(self, connectionInfoList=None,):
        self.connectionInfoList = connectionInfoList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.connectionInfoList = []
                    (_etype662, _size659) = iprot.readListBegin()
                    for _i663 in range(_size659):
                        _elem664 = TSConnectionInfo()
                        _elem664.read(iprot)
                        self.connectionInfoList.append(_elem664)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSConnectionInfoResp')
        if self.connectionInfoList is not None:
            oprot.writeFieldBegin('connectionInfoList', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.connectionInfoList))
            for iter665 in self.connectionInfoList:
                iter665.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.connectionInfoList is None:
            raise TProtocolException(message='Required field connectionInfoList is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TSQueryDataSet)
TSQueryDataSet.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'time', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'valueList', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'bitmapList', (TType.STRING, 'BINARY', False), None, ),  # 3
)
all_structs.append(TSQueryNonAlignDataSet)
TSQueryNonAlignDataSet.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'timeList', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'valueList', (TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TSTracingInfo)
TSTracingInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'activityList', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'elapsedTimeList', (TType.I64, None, False), None, ),  # 2
    (3, TType.I32, 'seriesPathNum', None, None, ),  # 3
    (4, TType.I32, 'seqFileNum', None, None, ),  # 4
    (5, TType.I32, 'unSeqFileNum', None, None, ),  # 5
    (6, TType.I32, 'sequenceChunkNum', None, None, ),  # 6
    (7, TType.I64, 'sequenceChunkPointNum', None, None, ),  # 7
    (8, TType.I32, 'unsequenceChunkNum', None, None, ),  # 8
    (9, TType.I64, 'unsequenceChunkPointNum', None, None, ),  # 9
    (10, TType.I32, 'totalPageNum', None, None, ),  # 10
    (11, TType.I32, 'overlappedPageNum', None, None, ),  # 11
)
all_structs.append(TSExecuteStatementResp)
TSExecuteStatementResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.LIST, 'columns', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'operationType', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'ignoreTimeStamp', None, None, ),  # 5
    (6, TType.LIST, 'dataTypeList', (TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.STRUCT, 'queryDataSet', [TSQueryDataSet, None], None, ),  # 7
    (8, TType.STRUCT, 'nonAlignQueryDataSet', [TSQueryNonAlignDataSet, None], None, ),  # 8
    (9, TType.MAP, 'columnNameIndexMap', (TType.STRING, 'UTF8', TType.I32, None, False), None, ),  # 9
    (10, TType.LIST, 'sgColumns', (TType.STRING, 'UTF8', False), None, ),  # 10
    (11, TType.LIST, 'aliasColumns', (TType.BYTE, None, False), None, ),  # 11
    (12, TType.STRUCT, 'tracingInfo', [TSTracingInfo, None], None, ),  # 12
    (13, TType.LIST, 'queryResult', (TType.STRING, 'BINARY', False), None, ),  # 13
    (14, TType.BOOL, 'moreData', None, None, ),  # 14
    (15, TType.STRING, 'database', 'UTF8', None, ),  # 15
    (16, TType.BOOL, 'tableModel', None, None, ),  # 16
    (17, TType.LIST, 'columnIndex2TsBlockColumnIndexList', (TType.I32, None, False), None, ),  # 17
)
all_structs.append(TSOpenSessionResp)
TSOpenSessionResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'serverProtocolVersion', None, 0, ),  # 2
    (3, TType.I64, 'sessionId', None, None, ),  # 3
    (4, TType.MAP, 'configuration', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 4
)
all_structs.append(TSOpenSessionReq)
TSOpenSessionReq.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'client_protocol', None, 2, ),  # 1
    (2, TType.STRING, 'zoneId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'username', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'password', 'UTF8', None, ),  # 4
    (5, TType.MAP, 'configuration', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(TSCloseSessionReq)
TSCloseSessionReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
)
all_structs.append(TSExecuteStatementReq)
TSExecuteStatementReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.I64, 'statementId', None, None, ),  # 3
    (4, TType.I32, 'fetchSize', None, None, ),  # 4
    (5, TType.I64, 'timeout', None, None, ),  # 5
    (6, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 6
    (7, TType.BOOL, 'jdbcQuery', None, None, ),  # 7
)
all_structs.append(TSExecuteBatchStatementReq)
TSExecuteBatchStatementReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'statements', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TSGetOperationStatusReq)
TSGetOperationStatusReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
)
all_structs.append(TSCancelOperationReq)
TSCancelOperationReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
)
all_structs.append(TSCloseOperationReq)
TSCloseOperationReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'queryId', None, None, ),  # 2
    (3, TType.I64, 'statementId', None, None, ),  # 3
)
all_structs.append(TSFetchResultsReq)
TSFetchResultsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'statement', 'UTF8', None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'queryId', None, None, ),  # 4
    (5, TType.BOOL, 'isAlign', None, None, ),  # 5
    (6, TType.I64, 'timeout', None, None, ),  # 6
    (7, TType.I64, 'statementId', None, None, ),  # 7
)
all_structs.append(TSFetchResultsResp)
TSFetchResultsResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BOOL, 'hasResultSet', None, None, ),  # 2
    (3, TType.BOOL, 'isAlign', None, None, ),  # 3
    (4, TType.STRUCT, 'queryDataSet', [TSQueryDataSet, None], None, ),  # 4
    (5, TType.STRUCT, 'nonAlignQueryDataSet', [TSQueryNonAlignDataSet, None], None, ),  # 5
    (6, TType.LIST, 'queryResult', (TType.STRING, 'BINARY', False), None, ),  # 6
    (7, TType.BOOL, 'moreData', None, None, ),  # 7
)
all_structs.append(TSFetchMetadataResp)
TSFetchMetadataResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'metadataInJson', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'columnsList', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'dataType', 'UTF8', None, ),  # 4
)
all_structs.append(TSFetchMetadataReq)
TSFetchMetadataReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'type', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'columnPath', 'UTF8', None, ),  # 3
)
all_structs.append(TSGetTimeZoneResp)
TSGetTimeZoneResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'timeZone', 'UTF8', None, ),  # 2
)
all_structs.append(TSSetTimeZoneReq)
TSSetTimeZoneReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'timeZone', 'UTF8', None, ),  # 2
)
all_structs.append(TSInsertRecordReq)
TSInsertRecordReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'values', 'BINARY', None, ),  # 4
    (5, TType.I64, 'timestamp', None, None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
    (7, TType.BOOL, 'isWriteToTable', None, None, ),  # 7
    (8, TType.LIST, 'columnCategoryies', (TType.BYTE, None, False), None, ),  # 8
)
all_structs.append(TSInsertStringRecordReq)
TSInsertStringRecordReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'values', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I64, 'timestamp', None, None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
    (7, TType.I64, 'timeout', None, None, ),  # 7
)
all_structs.append(TSInsertTabletReq)
TSInsertTabletReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.STRING, 'values', 'BINARY', None, ),  # 4
    (5, TType.STRING, 'timestamps', 'BINARY', None, ),  # 5
    (6, TType.LIST, 'types', (TType.I32, None, False), None, ),  # 6
    (7, TType.I32, 'size', None, None, ),  # 7
    (8, TType.BOOL, 'isAligned', None, None, ),  # 8
    (9, TType.BOOL, 'writeToTable', None, None, ),  # 9
    (10, TType.LIST, 'columnCategories', (TType.BYTE, None, False), None, ),  # 10
)
all_structs.append(TSInsertTabletsReq)
TSInsertTabletsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixPaths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'timestampsList', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'typesList', (TType.LIST, (TType.I32, None, False), False), None, ),  # 6
    (7, TType.LIST, 'sizeList', (TType.I32, None, False), None, ),  # 7
    (8, TType.BOOL, 'isAligned', None, None, ),  # 8
)
all_structs.append(TSInsertRecordsReq)
TSInsertRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixPaths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSInsertRecordsOfOneDeviceReq)
TSInsertRecordsOfOneDeviceReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSInsertStringRecordsOfOneDeviceReq)
TSInsertStringRecordsOfOneDeviceReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSInsertStringRecordsReq)
TSInsertStringRecordsReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixPaths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'measurementsList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
    (4, TType.LIST, 'valuesList', (TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.LIST, 'timestamps', (TType.I64, None, False), None, ),  # 5
    (6, TType.BOOL, 'isAligned', None, None, ),  # 6
)
all_structs.append(TSDeleteDataReq)
TSDeleteDataReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I64, 'startTime', None, None, ),  # 3
    (4, TType.I64, 'endTime', None, None, ),  # 4
)
all_structs.append(TSCreateTimeseriesReq)
TSCreateTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'path', 'UTF8', None, ),  # 2
    (3, TType.I32, 'dataType', None, None, ),  # 3
    (4, TType.I32, 'encoding', None, None, ),  # 4
    (5, TType.I32, 'compressor', None, None, ),  # 5
    (6, TType.MAP, 'props', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 6
    (7, TType.MAP, 'tags', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 7
    (8, TType.MAP, 'attributes', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 8
    (9, TType.STRING, 'measurementAlias', 'UTF8', None, ),  # 9
)
all_structs.append(TSCreateAlignedTimeseriesReq)
TSCreateAlignedTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'dataTypes', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'compressors', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'measurementAlias', (TType.STRING, 'UTF8', False), None, ),  # 7
    (8, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 8
    (9, TType.LIST, 'attributesList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 9
)
all_structs.append(TSRawDataQueryReq)
TSRawDataQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'startTime', None, None, ),  # 4
    (5, TType.I64, 'endTime', None, None, ),  # 5
    (6, TType.I64, 'statementId', None, None, ),  # 6
    (7, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 7
    (8, TType.BOOL, 'jdbcQuery', None, None, ),  # 8
    (9, TType.I64, 'timeout', None, None, ),  # 9
    (10, TType.BOOL, 'legalPathNodes', None, None, ),  # 10
)
all_structs.append(TSLastDataQueryReq)
TSLastDataQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'time', None, None, ),  # 4
    (5, TType.I64, 'statementId', None, None, ),  # 5
    (6, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 6
    (7, TType.BOOL, 'jdbcQuery', None, None, ),  # 7
    (8, TType.I64, 'timeout', None, None, ),  # 8
    (9, TType.BOOL, 'legalPathNodes', None, None, ),  # 9
)
all_structs.append(TSFastLastDataQueryForOnePrefixPathReq)
TSFastLastDataQueryForOnePrefixPathReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'prefixes', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.I32, 'fetchSize', None, None, ),  # 3
    (4, TType.I64, 'statementId', None, None, ),  # 4
    (5, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 5
    (6, TType.BOOL, 'jdbcQuery', None, None, ),  # 6
    (7, TType.I64, 'timeout', None, None, ),  # 7
)
all_structs.append(TSFastLastDataQueryForOneDeviceReq)
TSFastLastDataQueryForOneDeviceReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'db', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'deviceId', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'sensors', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I32, 'fetchSize', None, None, ),  # 5
    (6, TType.I64, 'statementId', None, None, ),  # 6
    (7, TType.BOOL, 'enableRedirectQuery', None, None, ),  # 7
    (8, TType.BOOL, 'jdbcQuery', None, None, ),  # 8
    (9, TType.I64, 'timeout', None, None, ),  # 9
    (10, TType.BOOL, 'legalPathNodes', None, None, ),  # 10
)
all_structs.append(TSAggregationQueryReq)
TSAggregationQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'statementId', None, None, ),  # 2
    (3, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.LIST, 'aggregations', (TType.I32, None, False), None, ),  # 4
    (5, TType.I64, 'startTime', None, None, ),  # 5
    (6, TType.I64, 'endTime', None, None, ),  # 6
    (7, TType.I64, 'interval', None, None, ),  # 7
    (8, TType.I64, 'slidingStep', None, None, ),  # 8
    (9, TType.I32, 'fetchSize', None, None, ),  # 9
    (10, TType.I64, 'timeout', None, None, ),  # 10
    (11, TType.BOOL, 'legalPathNodes', None, None, ),  # 11
)
all_structs.append(TSGroupByQueryIntervalReq)
TSGroupByQueryIntervalReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.I64, 'statementId', None, None, ),  # 2
    (3, TType.STRING, 'device', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'measurement', 'UTF8', None, ),  # 4
    (5, TType.I32, 'dataType', None, None, ),  # 5
    (6, TType.I32, 'aggregationType', None, None, ),  # 6
    (7, TType.STRING, 'database', 'UTF8', None, ),  # 7
    (8, TType.I64, 'startTime', None, None, ),  # 8
    (9, TType.I64, 'endTime', None, None, ),  # 9
    (10, TType.I64, 'interval', None, None, ),  # 10
    (11, TType.I32, 'fetchSize', None, None, ),  # 11
    (12, TType.I64, 'timeout', None, None, ),  # 12
    (13, TType.BOOL, 'isAligned', None, None, ),  # 13
)
all_structs.append(TSCreateMultiTimeseriesReq)
TSCreateMultiTimeseriesReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'paths', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.LIST, 'dataTypes', (TType.I32, None, False), None, ),  # 3
    (4, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 4
    (5, TType.LIST, 'compressors', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'propsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 6
    (7, TType.LIST, 'tagsList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 7
    (8, TType.LIST, 'attributesList', (TType.MAP, (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), False), None, ),  # 8
    (9, TType.LIST, 'measurementAliasList', (TType.STRING, 'UTF8', False), None, ),  # 9
)
all_structs.append(ServerProperties)
ServerProperties.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'version', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'supportedTimeAggregationOperations', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'timestampPrecision', 'UTF8', None, ),  # 3
    (4, TType.I32, 'maxConcurrentClientNum', None, None, ),  # 4
    (5, TType.I32, 'thriftMaxFrameSize', None, None, ),  # 5
    (6, TType.BOOL, 'isReadOnly', None, None, ),  # 6
    (7, TType.STRING, 'buildInfo', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'logo', 'UTF8', None, ),  # 8
)
all_structs.append(TSSetSchemaTemplateReq)
TSSetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'templateName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 3
)
all_structs.append(TSCreateSchemaTemplateReq)
TSCreateSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'serializedTemplate', 'BINARY', None, ),  # 3
)
all_structs.append(TSAppendSchemaTemplateReq)
TSAppendSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'isAligned', None, None, ),  # 3
    (4, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.LIST, 'dataTypes', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'encodings', (TType.I32, None, False), None, ),  # 6
    (7, TType.LIST, 'compressors', (TType.I32, None, False), None, ),  # 7
)
all_structs.append(TSPruneSchemaTemplateReq)
TSPruneSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'path', 'UTF8', None, ),  # 3
)
all_structs.append(TSQueryTemplateReq)
TSQueryTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.I32, 'queryType', None, None, ),  # 3
    (4, TType.STRING, 'measurement', 'UTF8', None, ),  # 4
)
all_structs.append(TSQueryTemplateResp)
TSQueryTemplateResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.I32, 'queryType', None, None, ),  # 2
    (3, TType.BOOL, 'result', None, None, ),  # 3
    (4, TType.I32, 'count', None, None, ),  # 4
    (5, TType.LIST, 'measurements', (TType.STRING, 'UTF8', False), None, ),  # 5
)
all_structs.append(TSUnsetSchemaTemplateReq)
TSUnsetSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'prefixPath', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'templateName', 'UTF8', None, ),  # 3
)
all_structs.append(TSDropSchemaTemplateReq)
TSDropSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.STRING, 'templateName', 'UTF8', None, ),  # 2
)
all_structs.append(TCreateTimeseriesUsingSchemaTemplateReq)
TCreateTimeseriesUsingSchemaTemplateReq.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'sessionId', None, None, ),  # 1
    (2, TType.LIST, 'devicePathList', (TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TSyncIdentityInfo)
TSyncIdentityInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pipeName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'createTime', None, None, ),  # 2
    (3, TType.STRING, 'version', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'database', 'UTF8', None, ),  # 4
)
all_structs.append(TSyncTransportMetaInfo)
TSyncTransportMetaInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fileName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'startIndex', None, None, ),  # 2
)
all_structs.append(TPipeTransferReq)
TPipeTransferReq.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'version', None, None, ),  # 1
    (2, TType.I16, 'type', None, None, ),  # 2
    (3, TType.STRING, 'body', 'BINARY', None, ),  # 3
)
all_structs.append(TPipeTransferResp)
TPipeTransferResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.STRING, 'body', 'BINARY', None, ),  # 2
)
all_structs.append(TPipeSubscribeReq)
TPipeSubscribeReq.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'version', None, None, ),  # 1
    (2, TType.I16, 'type', None, None, ),  # 2
    (3, TType.STRING, 'body', 'BINARY', None, ),  # 3
)
all_structs.append(TPipeSubscribeResp)
TPipeSubscribeResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BYTE, 'version', None, None, ),  # 2
    (3, TType.I16, 'type', None, None, ),  # 3
    (4, TType.LIST, 'body', (TType.STRING, 'BINARY', False), None, ),  # 4
)
all_structs.append(TSBackupConfigurationResp)
TSBackupConfigurationResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [iotdb.thrift.common.ttypes.TSStatus, None], None, ),  # 1
    (2, TType.BOOL, 'enableOperationSync', None, None, ),  # 2
    (3, TType.STRING, 'secondaryAddress', 'UTF8', None, ),  # 3
    (4, TType.I32, 'secondaryPort', None, None, ),  # 4
)
all_structs.append(TSConnectionInfo)
TSConnectionInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'userName', 'UTF8', None, ),  # 1
    (2, TType.I64, 'logInTime', None, None, ),  # 2
    (3, TType.STRING, 'connectionId', 'UTF8', None, ),  # 3
    (4, TType.I32, 'type', None, None, ),  # 4
)
all_structs.append(TSConnectionInfoResp)
TSConnectionInfoResp.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'connectionInfoList', (TType.STRUCT, [TSConnectionInfo, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs
