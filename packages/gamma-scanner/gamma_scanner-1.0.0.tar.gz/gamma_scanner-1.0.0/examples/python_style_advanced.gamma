# Gamma Scanner - Python-Style Advanced Example
# Complete programming language, not YARA-inspired at all!

import re
import hashlib
from gamma import Pattern, Scanner, Alert, Match
from gamma.crypto import Hash
from gamma.utils import FileType

# Global configuration (like any Python script)
SCAN_CONFIG = {
    "max_file_size": 10 * 1024 * 1024,  # 10MB
    "alert_threshold": 3,
    "enable_heuristics": True
}

# Pattern definitions using method chaining (like jQuery/modern JS)
malware_patterns = {
    'trojans': [
        Pattern.text("TR/Crypt.ZPACK.Gen").ignoreCase().wholeWord(),
        Pattern.regex(r"HEUR[:\/]Trojan").ignoreCase(),
        Pattern.hex("4d5a90000300000004000000ffff0000")
    ],
    'ransomware': [
        Pattern.text("encrypted_file_recovery").ignoreCase(),
        Pattern.regex(r"\.lock\d*$").ignoreCase(),
        Pattern.text("bitcoin", "cryptocurrency", "ransom").ignoreCase()
    ],
    'webshells': [
        Pattern.text("<?php eval($_").ignoreCase(),
        Pattern.regex(r"system\s*\(\s*\$_[GET|POST]").ignoreCase(),
        Pattern.text("c99shell", "r57shell", "wso shell").ignoreCase()
    ]
}

# Advanced threat detection class (OOP style)
class ThreatIntelligence:
    def __init__(self):
        self.reputation_db = {}
        self.yara_rules = []
        self.ml_model = None
        
    def load_threat_feeds(self, sources):
        """Load threat intelligence from multiple sources"""
        for source in sources:
            try:
                data = self.fetch_feed(source)
                self.reputation_db.update(data)
            except Exception as e:
                print(f"Failed to load {source}: {e}")
    
    def check_reputation(self, indicator):
        """Check indicator reputation"""
        return self.reputation_db.get(indicator, {"score": 0, "category": "unknown"})
    
    def analyze_with_ml(self, content):
        """Use machine learning for advanced detection"""
        if not self.ml_model:
            return {"confidence": 0.5, "prediction": "unknown"}
            
        features = self.extract_features(content)
        prediction = self.ml_model.predict(features)
        return {"confidence": prediction.confidence, "prediction": prediction.label}

# Main malware scanner function (like a normal Python function)  
def scan_for_malware(file_path, options=None):
    """
    Comprehensive malware scanning function
    
    Args:
        file_path (str): Path to file to scan
        options (dict): Scanning options
        
    Returns:
        dict: Scan results with alerts and metadata
    """
    options = options or SCAN_CONFIG
    results = {
        'file_path': file_path,
        'scan_time': None,
        'alerts': [],
        'metadata': {},
        'risk_score': 0
    }
    
    try:
        # Load and validate file
        with open(file_path, 'rb') as f:
            content = f.read()
            
        if len(content) > options['max_file_size']:
            results['alerts'].append({
                'type': 'warning',
                'message': f'File too large: {len(content)} bytes',
                'severity': 'medium'
            })
            return results
            
        # File metadata extraction  
        results['metadata'] = {
            'size': len(content),
            'md5': hashlib.md5(content).hexdigest(),
            'sha256': hashlib.sha256(content).hexdigest(),
            'file_type': FileType.detect(content),
            'entropy': calculate_entropy(content)
        }
        
        # Pattern matching (using our patterns)
        scanner = Scanner(content)
        
        # Check each pattern category
        for category, patterns in malware_patterns.items():
            matches = scanner.scan_patterns(patterns)
            if matches:
                for match in matches:
                    alert = Alert(
                        category=category,
                        message=f"{category.title()} pattern detected: {match.pattern}",
                        severity=determine_severity(category, match),
                        offset=match.offset,
                        length=match.length,
                        pattern_id=match.pattern.id
                    )
                    results['alerts'].append(alert.to_dict())
                    results['risk_score'] += get_risk_weight(category)
        
        # Heuristic analysis
        if options.get('enable_heuristics'):
            heuristic_alerts = run_heuristics(scanner, content)
            results['alerts'].extend(heuristic_alerts)
            
        # Threat intelligence lookup
        threat_intel = ThreatIntelligence()
        file_hash = results['metadata']['sha256']
        reputation = threat_intel.check_reputation(file_hash)
        
        if reputation['score'] > 70:
            results['alerts'].append({
                'type': 'threat_intel',
                'message': f'Known malicious file: {reputation["category"]}',
                'severity': 'critical',
                'source': 'threat_intelligence'
            })
            
        return results
        
    except Exception as e:
        results['alerts'].append({
            'type': 'error', 
            'message': f'Scan failed: {str(e)}',
            'severity': 'low'
        })
        return results

# Heuristic analysis functions
def run_heuristics(scanner, content):
    """Run heuristic detection algorithms"""
    alerts = []
    
    # High entropy detection (packed/encrypted files)
    entropy = calculate_entropy(content)
    if entropy > 7.5:
        alerts.append({
            'type': 'heuristic',
            'message': f'High entropy detected: {entropy:.2f} (possible packer/encryption)',
            'severity': 'medium',
            'metadata': {'entropy': entropy}
        })
    
    # Suspicious API calls
    suspicious_apis = [
        'VirtualAlloc', 'WriteProcessMemory', 'CreateRemoteThread',
        'SetWindowsHookEx', 'GetProcAddress', 'LoadLibrary'
    ]
    
    api_count = 0
    for api in suspicious_apis:
        if scanner.content.count(Pattern.text(api).ignoreCase()) > 0:
            api_count += 1
            
    if api_count >= 3:
        alerts.append({
            'type': 'heuristic',
            'message': f'Multiple suspicious API calls detected: {api_count}',
            'severity': 'high',
            'metadata': {'api_count': api_count}
        })
    
    # URL/IP extraction and analysis
    urls = extract_urls(content)
    suspicious_urls = []
    
    for url in urls:
        if is_suspicious_url(url):
            suspicious_urls.append(url)
            
    if suspicious_urls:
        alerts.append({
            'type': 'network',
            'message': f'Suspicious URLs found: {len(suspicious_urls)}',
            'severity': 'medium',
            'metadata': {'urls': suspicious_urls}
        })
    
    return alerts

# Utility functions (like any programming language)
def calculate_entropy(data):
    """Calculate Shannon entropy of data"""
    if not data:
        return 0
        
    entropy = 0
    for x in range(256):
        p_x = float(data.count(bytes([x]))) / len(data)
        if p_x > 0:
            entropy += - p_x * math.log(p_x, 2)
    return entropy

def extract_urls(content):
    """Extract URLs from content using regex"""
    url_pattern = re.compile(
        r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'
    )
    return url_pattern.findall(content.decode('utf-8', errors='ignore'))

def is_suspicious_url(url):
    """Check if URL is suspicious"""
    suspicious_indicators = [
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}',  # IP addresses
        r'\.tk$|\.ml$|\.ga$|\.cf$',               # Suspicious TLDs
        r'[a-z]{10,}\.com',                       # Random long domains
    ]
    
    for pattern in suspicious_indicators:
        if re.search(pattern, url):
            return True
    return False

# Async scanning for large files
async def scan_directory_async(directory_path, max_workers=4):
    """Asynchronously scan directory for threats"""
    import asyncio
    import concurrent.futures
    import os
    
    files_to_scan = []
    for root, dirs, files in os.walk(directory_path):
        for file in files:
            files_to_scan.append(os.path.join(root, file))
    
    results = []
    
    # Use thread pool for CPU-bound scanning
    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
        loop = asyncio.get_event_loop()
        
        # Create scanning tasks
        tasks = [
            loop.run_in_executor(executor, scan_for_malware, file_path)
            for file_path in files_to_scan
        ]
        
        # Wait for all scans to complete
        scan_results = await asyncio.gather(*tasks)
        
        # Filter and process results
        for result in scan_results:
            if result['alerts']:
                results.append(result)
    
    return {
        'total_files': len(files_to_scan),
        'infected_files': len(results),
        'results': results,
        'scan_summary': generate_summary(results)
    }

# Main execution (like any Python script)
if __name__ == "__main__":
    import sys
    import argparse
    
    parser = argparse.ArgumentParser(description='Gamma Scanner - Advanced Threat Detection')
    parser.add_argument('target', help='File or directory to scan')
    parser.add_argument('--output', '-o', help='Output file for results')
    parser.add_argument('--format', choices=['json', 'xml', 'csv'], default='json')
    parser.add_argument('--verbose', '-v', action='store_true')
    
    args = parser.parse_args()
    
    if os.path.isfile(args.target):
        # Single file scan
        results = scan_for_malware(args.target)
        print(f"Scan complete: {len(results['alerts'])} alerts")
        
    elif os.path.isdir(args.target):
        # Directory scan
        import asyncio
        results = asyncio.run(scan_directory_async(args.target))
        print(f"Directory scan complete: {results['infected_files']}/{results['total_files']} files flagged")
        
    else:
        print(f"Error: {args.target} not found")
        sys.exit(1)