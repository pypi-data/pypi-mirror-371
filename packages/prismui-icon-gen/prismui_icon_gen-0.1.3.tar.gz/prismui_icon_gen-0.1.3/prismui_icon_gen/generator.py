import os
import re
import logging
import subprocess
import shutil
from xml.dom import minidom
from xml.etree.ElementTree import Element, SubElement, tostring

logger = logging.getLogger(__name__)

class IconGenerator:
    def __init__(self, base_dir: str, icons_dir: str, output_dir: str = None):
        self.base_dir = os.path.abspath(base_dir)
        self.icons_dir = os.path.abspath(icons_dir)
        self.output_dir = self.resolve_output_dir(output_dir)

    def resolve_output_dir(self, output_dir: str | None) -> str:
        if output_dir:
            return os.path.abspath(output_dir)

        parent_dir = os.path.dirname(self.icons_dir)
        theme_name = os.path.basename(self.icons_dir.rstrip(os.sep))
        default_out_dir = os.path.join(parent_dir, f"{theme_name}_icon")

        if not os.path.exists(default_out_dir):
            os.makedirs(default_out_dir, exist_ok=True)
            logger.info(f"Add Output Folder: {default_out_dir}")

        return default_out_dir
    
    def rename_output_dir(self, output_dir: str, new_name:str):
        try:
            if not os.path.exists(output_dir):
                raise FileNotFoundError(f"Can't find folder: {output_dir}")

            parent_dir = os.path.dirname(output_dir)
            new_dir = os.path.join(parent_dir, new_name)

            if os.path.exists(new_dir):
                logger.warning(f"âš ï¸ Folder have already exist: {new_dir}")
                shutil.rmtree(new_dir)

            os.rename(output_dir, new_dir)
            logger.info(f"ðŸ“‚ Rename Folder : {output_dir} â†’ {new_dir}")
            return new_dir

        except FileNotFoundError as e:
            logger.error("âŒ Errorï¼š%s", e)
            raise
        except Exception as e:
            logger.error("âŒ Error: %s", e)
            raise

    def sanitize_name(self, name: str, used_names: set) -> str:
        base = os.path.splitext(name)[0]
        base = re.sub(r"[^a-zA-Z0-9]+", "_", base).upper()
        if base and base[0].isdigit():
            base = "_" + base
        new_name = base
        counter = 2
        while new_name in used_names:
            new_name = f"{base}_{counter}"
            counter += 1
        used_names.add(new_name)
        return new_name

    def generate_qrc(self, theme_name: str, theme_dir: str, output_qrc_path: str) -> bool:
        """Generate .qrc file for a theme. Returns True if any SVG files found."""
        logger.info(f"[{theme_name}] Generating .qrc...")
        rcc = Element("RCC")
        qresource = SubElement(rcc, "qresource", prefix="/")
        found_any = False

        for root, _, files in os.walk(theme_dir):
            for file in files:
                if file.lower().endswith(".svg"):
                    full_path = os.path.join(root, file)
                    rel_path = os.path.relpath(full_path, self.output_dir).replace("\\", "/")
                    SubElement(qresource, "file").text = rel_path
                    logger.info(f" + {rel_path}")
                    found_any = True

        if not found_any:
            logger.warning(f"[{theme_name}] No .svg files found in {theme_dir}.")
            return False

        xml_str = tostring(rcc, encoding="utf-8").decode("utf-8")
        dom = minidom.parseString(xml_str)
        pretty_xml = "\n".join(dom.toprettyxml(indent="  ").splitlines()[1:])
        with open(output_qrc_path, "w", encoding="utf-8") as f:
            f.write(pretty_xml)
        logger.info(f"[{theme_name}] .qrc generated at {output_qrc_path}")
        return True

    def generate_icon_class(self, theme_name: str, theme_dir: str):
        """Generate Python icon class for a theme."""
        class_name = f"{theme_name.capitalize()}Icon"
        output_path = os.path.join(self.output_dir, f"{theme_name}_icon.py")
        logger.info(f"[{theme_name}] Generating icon class: {class_name} -> {output_path}")

        used_names = set()
        rc_module_name = f"resources_{theme_name}_rc"
        lines = [
            "# Auto-generated by prismui-icon-gen - Do not edit manually",
            "",
            "from PyQt5.QtGui import QIcon, QPixmap, QColor, QPainter",
            "from PyQt5.QtSvg import QSvgRenderer",
            "from PyQt5.QtCore import QSize, Qt",
            "",
            f"from . import {rc_module_name}",
            "",
            "class IconAccessor(str):",
            "    def __call__(self, color: str = None, size: QSize = QSize(16,16)) -> QIcon:",
            "        if color is None or not self.lower().endswith('.svg'):",
            "            return QIcon(self)",
            "        renderer = QSvgRenderer(self)",
            "        pixmap = QPixmap(size)",
            "        pixmap.fill(Qt.transparent)",
            "        painter = QPainter(pixmap)",
            "        renderer.render(painter)",
            "        painter.setCompositionMode(QPainter.CompositionMode_SourceIn)",
            "        painter.fillRect(pixmap.rect(), QColor(color))",
            "        painter.end()",
            "        return QIcon(pixmap)",
            "",
            "class ThemeIconMeta(type):",
            "    def __new__(mcs, name, bases, attrs):",
            "        new_attrs = {}",
            "        for key, value in attrs.items():",
            "            if isinstance(value, str) and value.startswith(':/'):",
            "                new_attrs[key] = IconAccessor(value)",
            "            else:",
            "                new_attrs[key] = value",
            "        return super().__new__(mcs, name, bases, new_attrs)",
            "",
            f"class {class_name}(metaclass=ThemeIconMeta):",
            f"    \"\"\"Auto-generated icons for the '{theme_name}' theme.\"\"\"",
        ]

        has_any = False
        for root, _, files in os.walk(theme_dir):
            for file in sorted(files):
                if file.lower().endswith((".svg", ".png", ".ico")):
                    const_name = self.sanitize_name(file, used_names)
                    rel_path = os.path.relpath(os.path.join(root, file), self.output_dir).replace("\\", "/")
                    lines.append(f"    {const_name} = IconAccessor(':icons/{rel_path}')")
                    has_any = True

        if not has_any:
            lines.append("    pass")

        with open(output_path, "w", encoding="utf-8") as f:
            f.write("\n".join(lines))

        logger.info(f"[{theme_name}] Icon class generated at {output_path}")

    def compile_qrc(self, input_qrc: str, output_py: str):
        if not os.path.exists(input_qrc):
            logger.warning(f"QRC file not found: {input_qrc}, skipping compilation.")
            return
        logger.info(f"Compiling {input_qrc} -> {output_py}")
        try:
            subprocess.run(["pyrcc5", input_qrc, "-o", output_py], check=True, cwd=self.base_dir)
        except Exception as e:
            logger.error(f"Failed to compile QRC: {e}")

    def generate_all_themes(self, clean_first: bool = False):
        if clean_first:
            self.clean_previous_generated(confirm_delete=False)
        
        theme_folders = [
            d for d in os.listdir(self.icons_dir)
            if os.path.isdir(os.path.join(self.icons_dir, d))
        ]

        for theme_folder in os.listdir(self.icons_dir):
            theme_dir = os.path.join(self.icons_dir, theme_folder)
            theme_name = theme_folder
            if os.path.isdir(theme_dir):
                theme_name = theme_folder
                qrc_path = os.path.join(self.output_dir, f"resources_{theme_name}.qrc")
                rcc_py = os.path.join(self.output_dir, f"resources_{theme_name}_rc.py")
                if self.generate_qrc(theme_name, theme_dir, qrc_path):
                    self.compile_qrc(qrc_path, rcc_py)
                self.generate_icon_class(theme_name, theme_dir)

        if theme_folders:
            outer_theme_name = theme_folders[0]
            self.rename_output_dir(self.output_dir, f"{outer_theme_name}_icons")

    def clean_previous_generated(self, confirm_delete: bool = True):
        removed_files = []
        for theme_folder in os.listdir(self.icons_dir):
            theme_dir = os.path.join(self.icons_dir, theme_folder)
            if not os.path.isdir(theme_dir):
                continue
            theme_name = theme_folder
            qrc_file = os.path.join(self.base_dir, f"resources_{theme_name}.qrc")
            rc_file = os.path.join(self.output_dir, f"resources_{theme_name}_rc.py")
            icon_file = os.path.join(self.output_dir, f"{theme_name}_icon.py")

            for f in [qrc_file, rc_file, icon_file]:
                if os.path.exists(f):
                    removed_files.append(f)

        for f in removed_files:
            try:
                os.remove(f)
                logger.info(f"Deleted: {f}")
            except Exception as e:
                logger.error(f"Failed to delete {f}: {e}")

        if not removed_files:
            logger.info("No previous generated files detected.")
