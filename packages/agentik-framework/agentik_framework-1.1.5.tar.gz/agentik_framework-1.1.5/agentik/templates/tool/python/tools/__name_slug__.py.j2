"""
=====================================================================
Custom Tool Template (Python)
=====================================================================
Generated by Agentik template 'tool/python'.

This file provides a ready-to-use skeleton for building a custom tool.
Fill in the placeholders and implement your logic in the `run()` method.

---------------------------------------------------------------------
How to use:
1) Replace placeholders:
   - {{ name }}        → Human-readable title for your tool.
   - {{ name_slug }}   → CLI slug (lowercase, no spaces).
   - {{ class_name }}  → Python class name (e.g., MyTool).
2) Update the `description` field to describe your tool’s purpose.
3) Define inputs in `schema["properties"]` and mark required fields.
4) Implement logic inside `run()`. Always return a dict with:
       {"ok": True, ...}
   Use `ValueError` for invalid or missing inputs.
5) Run your tool via CLI:
       agentik tools run {{ name_slug }} --json --arg key=value
=====================================================================
"""

from __future__ import annotations
from typing import Any, Dict

# IMPORTANT: use absolute import so local file loading works.
from agentik.tools.base import ToolBase


class {{ class_name }}(ToolBase):
    # CLI: agentik tools run {{ name_slug }}
    name = "{{ name_slug }}"
    description = "Briefly describe what this tool does and what it returns."

    # Optional: JSON Schema-like hint for inputs
    schema: Dict[str, Any] = {
        "type": "object",
        "properties": {
            # "query": {"type": "string", "description": "Main input text"},
            # "limit": {"type": "number", "description": "Max items to process"},
            # "verbose": {"type": "boolean", "description": "Extra details"},
        },
        "required": [
            # e.g., "query"
        ],
        "additionalProperties": True,
    }

    def run(self, **kwargs: Any) -> Dict[str, Any]:
        """
        Implement your tool logic here.

        Steps:
        - Read inputs from `kwargs`, validate as needed.
        - Do your processing.
        - Return a dict with "ok": True and your result fields.
        - Raise ValueError for user-correctable issues (missing/invalid inputs).
        """
        # Example starter: echo inputs so you can test end-to-end
        return {"ok": True, "echo": kwargs}
