#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:no_utf8strings
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import CatalogObjects.ttypes
import Data.ttypes
import ExecStats.ttypes
import Exprs.ttypes
import Types.ttypes
import ExternalDataSource.ttypes
import ResourceProfile.ttypes

from thrift.transport import TTransport
all_structs = []


class TPlanNodeType(object):
    HDFS_SCAN_NODE = 0
    HBASE_SCAN_NODE = 1
    HASH_JOIN_NODE = 2
    AGGREGATION_NODE = 3
    SORT_NODE = 4
    EMPTY_SET_NODE = 5
    EXCHANGE_NODE = 6
    UNION_NODE = 7
    SELECT_NODE = 8
    NESTED_LOOP_JOIN_NODE = 9
    DATA_SOURCE_NODE = 10
    ANALYTIC_EVAL_NODE = 11
    SINGULAR_ROW_SRC_NODE = 12
    UNNEST_NODE = 13
    SUBPLAN_NODE = 14
    KUDU_SCAN_NODE = 15
    CARDINALITY_CHECK_NODE = 16
    MULTI_AGGREGATION_NODE = 17
    ICEBERG_DELETE_NODE = 18
    ICEBERG_METADATA_SCAN_NODE = 19
    TUPLE_CACHE_NODE = 20
    SYSTEM_TABLE_SCAN_NODE = 21
    ICEBERG_MERGE_NODE = 22

    _VALUES_TO_NAMES = {
        0: "HDFS_SCAN_NODE",
        1: "HBASE_SCAN_NODE",
        2: "HASH_JOIN_NODE",
        3: "AGGREGATION_NODE",
        4: "SORT_NODE",
        5: "EMPTY_SET_NODE",
        6: "EXCHANGE_NODE",
        7: "UNION_NODE",
        8: "SELECT_NODE",
        9: "NESTED_LOOP_JOIN_NODE",
        10: "DATA_SOURCE_NODE",
        11: "ANALYTIC_EVAL_NODE",
        12: "SINGULAR_ROW_SRC_NODE",
        13: "UNNEST_NODE",
        14: "SUBPLAN_NODE",
        15: "KUDU_SCAN_NODE",
        16: "CARDINALITY_CHECK_NODE",
        17: "MULTI_AGGREGATION_NODE",
        18: "ICEBERG_DELETE_NODE",
        19: "ICEBERG_METADATA_SCAN_NODE",
        20: "TUPLE_CACHE_NODE",
        21: "SYSTEM_TABLE_SCAN_NODE",
        22: "ICEBERG_MERGE_NODE",
    }

    _NAMES_TO_VALUES = {
        "HDFS_SCAN_NODE": 0,
        "HBASE_SCAN_NODE": 1,
        "HASH_JOIN_NODE": 2,
        "AGGREGATION_NODE": 3,
        "SORT_NODE": 4,
        "EMPTY_SET_NODE": 5,
        "EXCHANGE_NODE": 6,
        "UNION_NODE": 7,
        "SELECT_NODE": 8,
        "NESTED_LOOP_JOIN_NODE": 9,
        "DATA_SOURCE_NODE": 10,
        "ANALYTIC_EVAL_NODE": 11,
        "SINGULAR_ROW_SRC_NODE": 12,
        "UNNEST_NODE": 13,
        "SUBPLAN_NODE": 14,
        "KUDU_SCAN_NODE": 15,
        "CARDINALITY_CHECK_NODE": 16,
        "MULTI_AGGREGATION_NODE": 17,
        "ICEBERG_DELETE_NODE": 18,
        "ICEBERG_METADATA_SCAN_NODE": 19,
        "TUPLE_CACHE_NODE": 20,
        "SYSTEM_TABLE_SCAN_NODE": 21,
        "ICEBERG_MERGE_NODE": 22,
    }


class TExecNodePhase(object):
    PREPARE = 0
    PREPARE_SCANNER = 1
    OPEN = 2
    GETNEXT = 3
    GETNEXT_SCANNER = 4
    CLOSE = 5
    SCANNER_ERROR = 6
    INVALID = 7

    _VALUES_TO_NAMES = {
        0: "PREPARE",
        1: "PREPARE_SCANNER",
        2: "OPEN",
        3: "GETNEXT",
        4: "GETNEXT_SCANNER",
        5: "CLOSE",
        6: "SCANNER_ERROR",
        7: "INVALID",
    }

    _NAMES_TO_VALUES = {
        "PREPARE": 0,
        "PREPARE_SCANNER": 1,
        "OPEN": 2,
        "GETNEXT": 3,
        "GETNEXT_SCANNER": 4,
        "CLOSE": 5,
        "SCANNER_ERROR": 6,
        "INVALID": 7,
    }


class TDebugAction(object):
    WAIT = 0
    FAIL = 1
    INJECT_ERROR_LOG = 2
    MEM_LIMIT_EXCEEDED = 3
    SET_DENY_RESERVATION_PROBABILITY = 4
    DELAY = 5

    _VALUES_TO_NAMES = {
        0: "WAIT",
        1: "FAIL",
        2: "INJECT_ERROR_LOG",
        3: "MEM_LIMIT_EXCEEDED",
        4: "SET_DENY_RESERVATION_PROBABILITY",
        5: "DELAY",
    }

    _NAMES_TO_VALUES = {
        "WAIT": 0,
        "FAIL": 1,
        "INJECT_ERROR_LOG": 2,
        "MEM_LIMIT_EXCEEDED": 3,
        "SET_DENY_RESERVATION_PROBABILITY": 4,
        "DELAY": 5,
    }


class TReplicaPreference(object):
    CACHE_LOCAL = 0
    CACHE_RACK = 1
    DISK_LOCAL = 2
    DISK_RACK = 3
    REMOTE = 4

    _VALUES_TO_NAMES = {
        0: "CACHE_LOCAL",
        1: "CACHE_RACK",
        2: "DISK_LOCAL",
        3: "DISK_RACK",
        4: "REMOTE",
    }

    _NAMES_TO_VALUES = {
        "CACHE_LOCAL": 0,
        "CACHE_RACK": 1,
        "DISK_LOCAL": 2,
        "DISK_RACK": 3,
        "REMOTE": 4,
    }


class TRuntimeFilterType(object):
    BLOOM = 0
    MIN_MAX = 1
    IN_LIST = 2

    _VALUES_TO_NAMES = {
        0: "BLOOM",
        1: "MIN_MAX",
        2: "IN_LIST",
    }

    _NAMES_TO_VALUES = {
        "BLOOM": 0,
        "MIN_MAX": 1,
        "IN_LIST": 2,
    }


class TMinmaxFilteringLevel(object):
    ROW_GROUP = 1
    PAGE = 2
    ROW = 3

    _VALUES_TO_NAMES = {
        1: "ROW_GROUP",
        2: "PAGE",
        3: "ROW",
    }

    _NAMES_TO_VALUES = {
        "ROW_GROUP": 1,
        "PAGE": 2,
        "ROW": 3,
    }


class TJoinOp(object):
    INNER_JOIN = 0
    LEFT_OUTER_JOIN = 1
    LEFT_SEMI_JOIN = 2
    LEFT_ANTI_JOIN = 3
    NULL_AWARE_LEFT_ANTI_JOIN = 4
    RIGHT_OUTER_JOIN = 5
    RIGHT_SEMI_JOIN = 6
    RIGHT_ANTI_JOIN = 7
    FULL_OUTER_JOIN = 8
    CROSS_JOIN = 9
    ICEBERG_DELETE_JOIN = 10

    _VALUES_TO_NAMES = {
        0: "INNER_JOIN",
        1: "LEFT_OUTER_JOIN",
        2: "LEFT_SEMI_JOIN",
        3: "LEFT_ANTI_JOIN",
        4: "NULL_AWARE_LEFT_ANTI_JOIN",
        5: "RIGHT_OUTER_JOIN",
        6: "RIGHT_SEMI_JOIN",
        7: "RIGHT_ANTI_JOIN",
        8: "FULL_OUTER_JOIN",
        9: "CROSS_JOIN",
        10: "ICEBERG_DELETE_JOIN",
    }

    _NAMES_TO_VALUES = {
        "INNER_JOIN": 0,
        "LEFT_OUTER_JOIN": 1,
        "LEFT_SEMI_JOIN": 2,
        "LEFT_ANTI_JOIN": 3,
        "NULL_AWARE_LEFT_ANTI_JOIN": 4,
        "RIGHT_OUTER_JOIN": 5,
        "RIGHT_SEMI_JOIN": 6,
        "RIGHT_ANTI_JOIN": 7,
        "FULL_OUTER_JOIN": 8,
        "CROSS_JOIN": 9,
        "ICEBERG_DELETE_JOIN": 10,
    }


class TSortType(object):
    TOTAL = 0
    TOPN = 1
    PARTIAL = 2
    PARTITIONED_TOPN = 3

    _VALUES_TO_NAMES = {
        0: "TOTAL",
        1: "TOPN",
        2: "PARTIAL",
        3: "PARTITIONED_TOPN",
    }

    _NAMES_TO_VALUES = {
        "TOTAL": 0,
        "TOPN": 1,
        "PARTIAL": 2,
        "PARTITIONED_TOPN": 3,
    }


class TAnalyticWindowType(object):
    RANGE = 0
    ROWS = 1

    _VALUES_TO_NAMES = {
        0: "RANGE",
        1: "ROWS",
    }

    _NAMES_TO_VALUES = {
        "RANGE": 0,
        "ROWS": 1,
    }


class TAnalyticWindowBoundaryType(object):
    CURRENT_ROW = 0
    PRECEDING = 1
    FOLLOWING = 2

    _VALUES_TO_NAMES = {
        0: "CURRENT_ROW",
        1: "PRECEDING",
        2: "FOLLOWING",
    }

    _NAMES_TO_VALUES = {
        "CURRENT_ROW": 0,
        "PRECEDING": 1,
        "FOLLOWING": 2,
    }


class TMergeCaseType(object):
    UPDATE = 0
    INSERT = 1
    DELETE = 2

    _VALUES_TO_NAMES = {
        0: "UPDATE",
        1: "INSERT",
        2: "DELETE",
    }

    _NAMES_TO_VALUES = {
        "UPDATE": 0,
        "INSERT": 1,
        "DELETE": 2,
    }


class TMergeMatchType(object):
    MATCHED = 0
    NOT_MATCHED_BY_TARGET = 1
    NOT_MATCHED_BY_SOURCE = 2

    _VALUES_TO_NAMES = {
        0: "MATCHED",
        1: "NOT_MATCHED_BY_TARGET",
        2: "NOT_MATCHED_BY_SOURCE",
    }

    _NAMES_TO_VALUES = {
        "MATCHED": 0,
        "NOT_MATCHED_BY_TARGET": 1,
        "NOT_MATCHED_BY_SOURCE": 2,
    }


class TIcebergMergeRowPresent(object):
    BOTH = 0
    SOURCE = 1
    TARGET = 2

    _VALUES_TO_NAMES = {
        0: "BOTH",
        1: "SOURCE",
        2: "TARGET",
    }

    _NAMES_TO_VALUES = {
        "BOTH": 0,
        "SOURCE": 1,
        "TARGET": 2,
    }


class TRuntimeFilterTargetDesc(object):
    """
    Attributes:
     - node_id
     - target_expr
     - is_bound_by_partition_columns
     - target_expr_slotids
     - is_local_target
     - kudu_col_name
     - kudu_col_type
     - low_value
     - high_value
     - is_min_max_value_present
     - is_column_in_data_file

    """


    def __init__(self, node_id=None, target_expr=None, is_bound_by_partition_columns=None, target_expr_slotids=None, is_local_target=None, kudu_col_name=None, kudu_col_type=None, low_value=None, high_value=None, is_min_max_value_present=None, is_column_in_data_file=None,):
        self.node_id = node_id
        self.target_expr = target_expr
        self.is_bound_by_partition_columns = is_bound_by_partition_columns
        self.target_expr_slotids = target_expr_slotids
        self.is_local_target = is_local_target
        self.kudu_col_name = kudu_col_name
        self.kudu_col_type = kudu_col_type
        self.low_value = low_value
        self.high_value = high_value
        self.is_min_max_value_present = is_min_max_value_present
        self.is_column_in_data_file = is_column_in_data_file

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.target_expr = Exprs.ttypes.TExpr()
                    self.target_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_bound_by_partition_columns = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.target_expr_slotids = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.target_expr_slotids.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_local_target = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.kudu_col_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.kudu_col_type = Types.ttypes.TColumnType()
                    self.kudu_col_type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.low_value = Data.ttypes.TColumnValue()
                    self.low_value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.high_value = Data.ttypes.TColumnValue()
                    self.high_value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.is_min_max_value_present = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.is_column_in_data_file = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRuntimeFilterTargetDesc')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.target_expr is not None:
            oprot.writeFieldBegin('target_expr', TType.STRUCT, 2)
            self.target_expr.write(oprot)
            oprot.writeFieldEnd()
        if self.is_bound_by_partition_columns is not None:
            oprot.writeFieldBegin('is_bound_by_partition_columns', TType.BOOL, 3)
            oprot.writeBool(self.is_bound_by_partition_columns)
            oprot.writeFieldEnd()
        if self.target_expr_slotids is not None:
            oprot.writeFieldBegin('target_expr_slotids', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.target_expr_slotids))
            for iter6 in self.target_expr_slotids:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_local_target is not None:
            oprot.writeFieldBegin('is_local_target', TType.BOOL, 5)
            oprot.writeBool(self.is_local_target)
            oprot.writeFieldEnd()
        if self.kudu_col_name is not None:
            oprot.writeFieldBegin('kudu_col_name', TType.STRING, 6)
            oprot.writeString(self.kudu_col_name)
            oprot.writeFieldEnd()
        if self.kudu_col_type is not None:
            oprot.writeFieldBegin('kudu_col_type', TType.STRUCT, 7)
            self.kudu_col_type.write(oprot)
            oprot.writeFieldEnd()
        if self.low_value is not None:
            oprot.writeFieldBegin('low_value', TType.STRUCT, 8)
            self.low_value.write(oprot)
            oprot.writeFieldEnd()
        if self.high_value is not None:
            oprot.writeFieldBegin('high_value', TType.STRUCT, 9)
            self.high_value.write(oprot)
            oprot.writeFieldEnd()
        if self.is_min_max_value_present is not None:
            oprot.writeFieldBegin('is_min_max_value_present', TType.BOOL, 10)
            oprot.writeBool(self.is_min_max_value_present)
            oprot.writeFieldEnd()
        if self.is_column_in_data_file is not None:
            oprot.writeFieldBegin('is_column_in_data_file', TType.BOOL, 11)
            oprot.writeBool(self.is_column_in_data_file)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.target_expr is None:
            raise TProtocolException(message='Required field target_expr is unset!')
        if self.is_bound_by_partition_columns is None:
            raise TProtocolException(message='Required field is_bound_by_partition_columns is unset!')
        if self.target_expr_slotids is None:
            raise TProtocolException(message='Required field target_expr_slotids is unset!')
        if self.is_local_target is None:
            raise TProtocolException(message='Required field is_local_target is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRuntimeFilterDesc(object):
    """
    Attributes:
     - filter_id
     - src_expr
     - targets
     - planid_to_target_ndx
     - is_broadcast_join
     - has_local_targets
     - has_remote_targets
     - applied_on_partition_columns
     - ndv_estimate
     - type
     - compareOp
     - filter_size_bytes
     - src_node_id

    """


    def __init__(self, filter_id=None, src_expr=None, targets=None, planid_to_target_ndx=None, is_broadcast_join=None, has_local_targets=None, has_remote_targets=None, applied_on_partition_columns=None, ndv_estimate=None, type=None, compareOp=None, filter_size_bytes=None, src_node_id=None,):
        self.filter_id = filter_id
        self.src_expr = src_expr
        self.targets = targets
        self.planid_to_target_ndx = planid_to_target_ndx
        self.is_broadcast_join = is_broadcast_join
        self.has_local_targets = has_local_targets
        self.has_remote_targets = has_remote_targets
        self.applied_on_partition_columns = applied_on_partition_columns
        self.ndv_estimate = ndv_estimate
        self.type = type
        self.compareOp = compareOp
        self.filter_size_bytes = filter_size_bytes
        self.src_node_id = src_node_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.filter_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.src_expr = Exprs.ttypes.TExpr()
                    self.src_expr.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.targets = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = TRuntimeFilterTargetDesc()
                        _elem12.read(iprot)
                        self.targets.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.planid_to_target_ndx = {}
                    (_ktype14, _vtype15, _size13) = iprot.readMapBegin()
                    for _i17 in range(_size13):
                        _key18 = iprot.readI32()
                        _val19 = iprot.readI32()
                        self.planid_to_target_ndx[_key18] = _val19
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_broadcast_join = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.has_local_targets = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.has_remote_targets = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.applied_on_partition_columns = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.ndv_estimate = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.compareOp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.filter_size_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.src_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRuntimeFilterDesc')
        if self.filter_id is not None:
            oprot.writeFieldBegin('filter_id', TType.I32, 1)
            oprot.writeI32(self.filter_id)
            oprot.writeFieldEnd()
        if self.src_expr is not None:
            oprot.writeFieldBegin('src_expr', TType.STRUCT, 2)
            self.src_expr.write(oprot)
            oprot.writeFieldEnd()
        if self.targets is not None:
            oprot.writeFieldBegin('targets', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.targets))
            for iter20 in self.targets:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.planid_to_target_ndx is not None:
            oprot.writeFieldBegin('planid_to_target_ndx', TType.MAP, 4)
            oprot.writeMapBegin(TType.I32, TType.I32, len(self.planid_to_target_ndx))
            for kiter21, viter22 in self.planid_to_target_ndx.items():
                oprot.writeI32(kiter21)
                oprot.writeI32(viter22)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.is_broadcast_join is not None:
            oprot.writeFieldBegin('is_broadcast_join', TType.BOOL, 5)
            oprot.writeBool(self.is_broadcast_join)
            oprot.writeFieldEnd()
        if self.has_local_targets is not None:
            oprot.writeFieldBegin('has_local_targets', TType.BOOL, 6)
            oprot.writeBool(self.has_local_targets)
            oprot.writeFieldEnd()
        if self.has_remote_targets is not None:
            oprot.writeFieldBegin('has_remote_targets', TType.BOOL, 7)
            oprot.writeBool(self.has_remote_targets)
            oprot.writeFieldEnd()
        if self.applied_on_partition_columns is not None:
            oprot.writeFieldBegin('applied_on_partition_columns', TType.BOOL, 8)
            oprot.writeBool(self.applied_on_partition_columns)
            oprot.writeFieldEnd()
        if self.ndv_estimate is not None:
            oprot.writeFieldBegin('ndv_estimate', TType.I64, 9)
            oprot.writeI64(self.ndv_estimate)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 10)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.compareOp is not None:
            oprot.writeFieldBegin('compareOp', TType.I32, 11)
            oprot.writeI32(self.compareOp)
            oprot.writeFieldEnd()
        if self.filter_size_bytes is not None:
            oprot.writeFieldBegin('filter_size_bytes', TType.I64, 12)
            oprot.writeI64(self.filter_size_bytes)
            oprot.writeFieldEnd()
        if self.src_node_id is not None:
            oprot.writeFieldBegin('src_node_id', TType.I32, 13)
            oprot.writeI32(self.src_node_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.filter_id is None:
            raise TProtocolException(message='Required field filter_id is unset!')
        if self.src_expr is None:
            raise TProtocolException(message='Required field src_expr is unset!')
        if self.targets is None:
            raise TProtocolException(message='Required field targets is unset!')
        if self.planid_to_target_ndx is None:
            raise TProtocolException(message='Required field planid_to_target_ndx is unset!')
        if self.is_broadcast_join is None:
            raise TProtocolException(message='Required field is_broadcast_join is unset!')
        if self.has_local_targets is None:
            raise TProtocolException(message='Required field has_local_targets is unset!')
        if self.has_remote_targets is None:
            raise TProtocolException(message='Required field has_remote_targets is unset!')
        if self.applied_on_partition_columns is None:
            raise TProtocolException(message='Required field applied_on_partition_columns is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.compareOp is None:
            raise TProtocolException(message='Required field compareOp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsFileSplit(object):
    """
    Attributes:
     - relative_path
     - offset
     - length
     - partition_id
     - file_length
     - file_compression
     - mtime
     - is_erasure_coded
     - partition_path_hash
     - absolute_path
     - is_encrypted

    """


    def __init__(self, relative_path=None, offset=None, length=None, partition_id=None, file_length=None, file_compression=None, mtime=None, is_erasure_coded=None, partition_path_hash=None, absolute_path=None, is_encrypted=None,):
        self.relative_path = relative_path
        self.offset = offset
        self.length = length
        self.partition_id = partition_id
        self.file_length = file_length
        self.file_compression = file_compression
        self.mtime = mtime
        self.is_erasure_coded = is_erasure_coded
        self.partition_path_hash = partition_path_hash
        self.absolute_path = absolute_path
        self.is_encrypted = is_encrypted

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.relative_path = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.length = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.partition_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.file_length = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.file_compression = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.mtime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.is_erasure_coded = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.partition_path_hash = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.absolute_path = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.is_encrypted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsFileSplit')
        if self.relative_path is not None:
            oprot.writeFieldBegin('relative_path', TType.STRING, 1)
            oprot.writeString(self.relative_path)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 2)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.length is not None:
            oprot.writeFieldBegin('length', TType.I64, 3)
            oprot.writeI64(self.length)
            oprot.writeFieldEnd()
        if self.partition_id is not None:
            oprot.writeFieldBegin('partition_id', TType.I64, 4)
            oprot.writeI64(self.partition_id)
            oprot.writeFieldEnd()
        if self.file_length is not None:
            oprot.writeFieldBegin('file_length', TType.I64, 5)
            oprot.writeI64(self.file_length)
            oprot.writeFieldEnd()
        if self.file_compression is not None:
            oprot.writeFieldBegin('file_compression', TType.I32, 6)
            oprot.writeI32(self.file_compression)
            oprot.writeFieldEnd()
        if self.mtime is not None:
            oprot.writeFieldBegin('mtime', TType.I64, 7)
            oprot.writeI64(self.mtime)
            oprot.writeFieldEnd()
        if self.is_erasure_coded is not None:
            oprot.writeFieldBegin('is_erasure_coded', TType.BOOL, 8)
            oprot.writeBool(self.is_erasure_coded)
            oprot.writeFieldEnd()
        if self.partition_path_hash is not None:
            oprot.writeFieldBegin('partition_path_hash', TType.I32, 9)
            oprot.writeI32(self.partition_path_hash)
            oprot.writeFieldEnd()
        if self.absolute_path is not None:
            oprot.writeFieldBegin('absolute_path', TType.STRING, 10)
            oprot.writeString(self.absolute_path)
            oprot.writeFieldEnd()
        if self.is_encrypted is not None:
            oprot.writeFieldBegin('is_encrypted', TType.BOOL, 11)
            oprot.writeBool(self.is_encrypted)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.relative_path is None:
            raise TProtocolException(message='Required field relative_path is unset!')
        if self.offset is None:
            raise TProtocolException(message='Required field offset is unset!')
        if self.length is None:
            raise TProtocolException(message='Required field length is unset!')
        if self.partition_id is None:
            raise TProtocolException(message='Required field partition_id is unset!')
        if self.file_length is None:
            raise TProtocolException(message='Required field file_length is unset!')
        if self.file_compression is None:
            raise TProtocolException(message='Required field file_compression is unset!')
        if self.mtime is None:
            raise TProtocolException(message='Required field mtime is unset!')
        if self.partition_path_hash is None:
            raise TProtocolException(message='Required field partition_path_hash is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THBaseKeyRange(object):
    """
    Attributes:
     - startKey
     - stopKey

    """


    def __init__(self, startKey=None, stopKey=None,):
        self.startKey = startKey
        self.stopKey = stopKey

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.startKey = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.stopKey = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THBaseKeyRange')
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.STRING, 1)
            oprot.writeString(self.startKey)
            oprot.writeFieldEnd()
        if self.stopKey is not None:
            oprot.writeFieldBegin('stopKey', TType.STRING, 2)
            oprot.writeString(self.stopKey)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFileSplitGeneratorSpec(object):
    """
    Attributes:
     - file_desc
     - max_block_size
     - is_splittable
     - partition_id
     - partition_path_hash
     - is_footer_only

    """


    def __init__(self, file_desc=None, max_block_size=None, is_splittable=None, partition_id=None, partition_path_hash=None, is_footer_only=None,):
        self.file_desc = file_desc
        self.max_block_size = max_block_size
        self.is_splittable = is_splittable
        self.partition_id = partition_id
        self.partition_path_hash = partition_path_hash
        self.is_footer_only = is_footer_only

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.file_desc = CatalogObjects.ttypes.THdfsFileDesc()
                    self.file_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max_block_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_splittable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.partition_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.partition_path_hash = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.is_footer_only = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFileSplitGeneratorSpec')
        if self.file_desc is not None:
            oprot.writeFieldBegin('file_desc', TType.STRUCT, 1)
            self.file_desc.write(oprot)
            oprot.writeFieldEnd()
        if self.max_block_size is not None:
            oprot.writeFieldBegin('max_block_size', TType.I64, 2)
            oprot.writeI64(self.max_block_size)
            oprot.writeFieldEnd()
        if self.is_splittable is not None:
            oprot.writeFieldBegin('is_splittable', TType.BOOL, 3)
            oprot.writeBool(self.is_splittable)
            oprot.writeFieldEnd()
        if self.partition_id is not None:
            oprot.writeFieldBegin('partition_id', TType.I64, 4)
            oprot.writeI64(self.partition_id)
            oprot.writeFieldEnd()
        if self.partition_path_hash is not None:
            oprot.writeFieldBegin('partition_path_hash', TType.I32, 5)
            oprot.writeI32(self.partition_path_hash)
            oprot.writeFieldEnd()
        if self.is_footer_only is not None:
            oprot.writeFieldBegin('is_footer_only', TType.BOOL, 6)
            oprot.writeBool(self.is_footer_only)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.file_desc is None:
            raise TProtocolException(message='Required field file_desc is unset!')
        if self.max_block_size is None:
            raise TProtocolException(message='Required field max_block_size is unset!')
        if self.is_splittable is None:
            raise TProtocolException(message='Required field is_splittable is unset!')
        if self.partition_id is None:
            raise TProtocolException(message='Required field partition_id is unset!')
        if self.partition_path_hash is None:
            raise TProtocolException(message='Required field partition_path_hash is unset!')
        if self.is_footer_only is None:
            raise TProtocolException(message='Required field is_footer_only is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TScanRange(object):
    """
    Attributes:
     - hdfs_file_split
     - hbase_key_range
     - kudu_scan_token
     - file_metadata
     - is_system_scan

    """


    def __init__(self, hdfs_file_split=None, hbase_key_range=None, kudu_scan_token=None, file_metadata=None, is_system_scan=None,):
        self.hdfs_file_split = hdfs_file_split
        self.hbase_key_range = hbase_key_range
        self.kudu_scan_token = kudu_scan_token
        self.file_metadata = file_metadata
        self.is_system_scan = is_system_scan

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hdfs_file_split = THdfsFileSplit()
                    self.hdfs_file_split.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.hbase_key_range = THBaseKeyRange()
                    self.hbase_key_range.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.kudu_scan_token = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.file_metadata = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_system_scan = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TScanRange')
        if self.hdfs_file_split is not None:
            oprot.writeFieldBegin('hdfs_file_split', TType.STRUCT, 1)
            self.hdfs_file_split.write(oprot)
            oprot.writeFieldEnd()
        if self.hbase_key_range is not None:
            oprot.writeFieldBegin('hbase_key_range', TType.STRUCT, 2)
            self.hbase_key_range.write(oprot)
            oprot.writeFieldEnd()
        if self.kudu_scan_token is not None:
            oprot.writeFieldBegin('kudu_scan_token', TType.STRING, 3)
            oprot.writeBinary(self.kudu_scan_token)
            oprot.writeFieldEnd()
        if self.file_metadata is not None:
            oprot.writeFieldBegin('file_metadata', TType.STRING, 4)
            oprot.writeBinary(self.file_metadata)
            oprot.writeFieldEnd()
        if self.is_system_scan is not None:
            oprot.writeFieldBegin('is_system_scan', TType.BOOL, 5)
            oprot.writeBool(self.is_system_scan)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TOverlapPredicateDesc(object):
    """
    Attributes:
     - filter_id
     - slot_index

    """


    def __init__(self, filter_id=None, slot_index=None,):
        self.filter_id = filter_id
        self.slot_index = slot_index

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.filter_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.slot_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TOverlapPredicateDesc')
        if self.filter_id is not None:
            oprot.writeFieldBegin('filter_id', TType.I32, 1)
            oprot.writeI32(self.filter_id)
            oprot.writeFieldEnd()
        if self.slot_index is not None:
            oprot.writeFieldBegin('slot_index', TType.I32, 2)
            oprot.writeI32(self.slot_index)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.filter_id is None:
            raise TProtocolException(message='Required field filter_id is unset!')
        if self.slot_index is None:
            raise TProtocolException(message='Required field slot_index is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsScanNode(object):
    """
    Attributes:
     - tuple_id
     - collection_conjuncts
     - replica_preference
     - random_replica
     - skip_header_line_count
     - use_mt_scan_node
     - stats_conjuncts
     - stats_tuple_id
     - dictionary_filter_conjuncts
     - count_star_slot_offset
     - is_partition_key_scan
     - file_formats
     - overlap_predicate_descs
     - deleteFileScanNodeId
     - deterministic_scanrange_assignment

    """


    def __init__(self, tuple_id=None, collection_conjuncts=None, replica_preference=None, random_replica=None, skip_header_line_count=None, use_mt_scan_node=None, stats_conjuncts=None, stats_tuple_id=None, dictionary_filter_conjuncts=None, count_star_slot_offset=None, is_partition_key_scan=None, file_formats=None, overlap_predicate_descs=None, deleteFileScanNodeId=None, deterministic_scanrange_assignment=None,):
        self.tuple_id = tuple_id
        self.collection_conjuncts = collection_conjuncts
        self.replica_preference = replica_preference
        self.random_replica = random_replica
        self.skip_header_line_count = skip_header_line_count
        self.use_mt_scan_node = use_mt_scan_node
        self.stats_conjuncts = stats_conjuncts
        self.stats_tuple_id = stats_tuple_id
        self.dictionary_filter_conjuncts = dictionary_filter_conjuncts
        self.count_star_slot_offset = count_star_slot_offset
        self.is_partition_key_scan = is_partition_key_scan
        self.file_formats = file_formats
        self.overlap_predicate_descs = overlap_predicate_descs
        self.deleteFileScanNodeId = deleteFileScanNodeId
        self.deterministic_scanrange_assignment = deterministic_scanrange_assignment

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.collection_conjuncts = {}
                    (_ktype24, _vtype25, _size23) = iprot.readMapBegin()
                    for _i27 in range(_size23):
                        _key28 = iprot.readI32()
                        _val29 = []
                        (_etype33, _size30) = iprot.readListBegin()
                        for _i34 in range(_size30):
                            _elem35 = Exprs.ttypes.TExpr()
                            _elem35.read(iprot)
                            _val29.append(_elem35)
                        iprot.readListEnd()
                        self.collection_conjuncts[_key28] = _val29
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.replica_preference = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.random_replica = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.skip_header_line_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.use_mt_scan_node = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.stats_conjuncts = []
                    (_etype39, _size36) = iprot.readListBegin()
                    for _i40 in range(_size36):
                        _elem41 = Exprs.ttypes.TExpr()
                        _elem41.read(iprot)
                        self.stats_conjuncts.append(_elem41)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.stats_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.dictionary_filter_conjuncts = {}
                    (_ktype43, _vtype44, _size42) = iprot.readMapBegin()
                    for _i46 in range(_size42):
                        _key47 = iprot.readI32()
                        _val48 = []
                        (_etype52, _size49) = iprot.readListBegin()
                        for _i53 in range(_size49):
                            _elem54 = iprot.readI32()
                            _val48.append(_elem54)
                        iprot.readListEnd()
                        self.dictionary_filter_conjuncts[_key47] = _val48
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.count_star_slot_offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.is_partition_key_scan = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.SET:
                    self.file_formats = set()
                    (_etype58, _size55) = iprot.readSetBegin()
                    for _i59 in range(_size55):
                        _elem60 = iprot.readI32()
                        self.file_formats.add(_elem60)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.overlap_predicate_descs = []
                    (_etype64, _size61) = iprot.readListBegin()
                    for _i65 in range(_size61):
                        _elem66 = TOverlapPredicateDesc()
                        _elem66.read(iprot)
                        self.overlap_predicate_descs.append(_elem66)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.deleteFileScanNodeId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.deterministic_scanrange_assignment = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsScanNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.collection_conjuncts is not None:
            oprot.writeFieldBegin('collection_conjuncts', TType.MAP, 2)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.collection_conjuncts))
            for kiter67, viter68 in self.collection_conjuncts.items():
                oprot.writeI32(kiter67)
                oprot.writeListBegin(TType.STRUCT, len(viter68))
                for iter69 in viter68:
                    iter69.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.replica_preference is not None:
            oprot.writeFieldBegin('replica_preference', TType.I32, 3)
            oprot.writeI32(self.replica_preference)
            oprot.writeFieldEnd()
        if self.random_replica is not None:
            oprot.writeFieldBegin('random_replica', TType.BOOL, 4)
            oprot.writeBool(self.random_replica)
            oprot.writeFieldEnd()
        if self.skip_header_line_count is not None:
            oprot.writeFieldBegin('skip_header_line_count', TType.I32, 5)
            oprot.writeI32(self.skip_header_line_count)
            oprot.writeFieldEnd()
        if self.use_mt_scan_node is not None:
            oprot.writeFieldBegin('use_mt_scan_node', TType.BOOL, 6)
            oprot.writeBool(self.use_mt_scan_node)
            oprot.writeFieldEnd()
        if self.stats_conjuncts is not None:
            oprot.writeFieldBegin('stats_conjuncts', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.stats_conjuncts))
            for iter70 in self.stats_conjuncts:
                iter70.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.stats_tuple_id is not None:
            oprot.writeFieldBegin('stats_tuple_id', TType.I32, 8)
            oprot.writeI32(self.stats_tuple_id)
            oprot.writeFieldEnd()
        if self.dictionary_filter_conjuncts is not None:
            oprot.writeFieldBegin('dictionary_filter_conjuncts', TType.MAP, 9)
            oprot.writeMapBegin(TType.I32, TType.LIST, len(self.dictionary_filter_conjuncts))
            for kiter71, viter72 in self.dictionary_filter_conjuncts.items():
                oprot.writeI32(kiter71)
                oprot.writeListBegin(TType.I32, len(viter72))
                for iter73 in viter72:
                    oprot.writeI32(iter73)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.count_star_slot_offset is not None:
            oprot.writeFieldBegin('count_star_slot_offset', TType.I32, 10)
            oprot.writeI32(self.count_star_slot_offset)
            oprot.writeFieldEnd()
        if self.is_partition_key_scan is not None:
            oprot.writeFieldBegin('is_partition_key_scan', TType.BOOL, 11)
            oprot.writeBool(self.is_partition_key_scan)
            oprot.writeFieldEnd()
        if self.file_formats is not None:
            oprot.writeFieldBegin('file_formats', TType.SET, 12)
            oprot.writeSetBegin(TType.I32, len(self.file_formats))
            for iter74 in self.file_formats:
                oprot.writeI32(iter74)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.overlap_predicate_descs is not None:
            oprot.writeFieldBegin('overlap_predicate_descs', TType.LIST, 13)
            oprot.writeListBegin(TType.STRUCT, len(self.overlap_predicate_descs))
            for iter75 in self.overlap_predicate_descs:
                iter75.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.deleteFileScanNodeId is not None:
            oprot.writeFieldBegin('deleteFileScanNodeId', TType.I32, 14)
            oprot.writeI32(self.deleteFileScanNodeId)
            oprot.writeFieldEnd()
        if self.deterministic_scanrange_assignment is not None:
            oprot.writeFieldBegin('deterministic_scanrange_assignment', TType.BOOL, 15)
            oprot.writeBool(self.deterministic_scanrange_assignment)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        if self.file_formats is None:
            raise TProtocolException(message='Required field file_formats is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataSourceScanNode(object):
    """
    Attributes:
     - tuple_id
     - data_source
     - init_string
     - accepted_predicates

    """


    def __init__(self, tuple_id=None, data_source=None, init_string=None, accepted_predicates=None,):
        self.tuple_id = tuple_id
        self.data_source = data_source
        self.init_string = init_string
        self.accepted_predicates = accepted_predicates

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.data_source = CatalogObjects.ttypes.TDataSource()
                    self.data_source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.init_string = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.accepted_predicates = []
                    (_etype79, _size76) = iprot.readListBegin()
                    for _i80 in range(_size76):
                        _elem81 = []
                        (_etype85, _size82) = iprot.readListBegin()
                        for _i86 in range(_size82):
                            _elem87 = ExternalDataSource.ttypes.TBinaryPredicate()
                            _elem87.read(iprot)
                            _elem81.append(_elem87)
                        iprot.readListEnd()
                        self.accepted_predicates.append(_elem81)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataSourceScanNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.data_source is not None:
            oprot.writeFieldBegin('data_source', TType.STRUCT, 2)
            self.data_source.write(oprot)
            oprot.writeFieldEnd()
        if self.init_string is not None:
            oprot.writeFieldBegin('init_string', TType.STRING, 3)
            oprot.writeString(self.init_string)
            oprot.writeFieldEnd()
        if self.accepted_predicates is not None:
            oprot.writeFieldBegin('accepted_predicates', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.accepted_predicates))
            for iter88 in self.accepted_predicates:
                oprot.writeListBegin(TType.STRUCT, len(iter88))
                for iter89 in iter88:
                    iter89.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        if self.data_source is None:
            raise TProtocolException(message='Required field data_source is unset!')
        if self.init_string is None:
            raise TProtocolException(message='Required field init_string is unset!')
        if self.accepted_predicates is None:
            raise TProtocolException(message='Required field accepted_predicates is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THBaseFilter(object):
    """
    Attributes:
     - family
     - qualifier
     - op_ordinal
     - filter_constant

    """


    def __init__(self, family=None, qualifier=None, op_ordinal=None, filter_constant=None,):
        self.family = family
        self.qualifier = qualifier
        self.op_ordinal = op_ordinal
        self.filter_constant = filter_constant

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.family = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.qualifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.op_ordinal = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.filter_constant = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THBaseFilter')
        if self.family is not None:
            oprot.writeFieldBegin('family', TType.STRING, 1)
            oprot.writeString(self.family)
            oprot.writeFieldEnd()
        if self.qualifier is not None:
            oprot.writeFieldBegin('qualifier', TType.STRING, 2)
            oprot.writeString(self.qualifier)
            oprot.writeFieldEnd()
        if self.op_ordinal is not None:
            oprot.writeFieldBegin('op_ordinal', TType.I32, 3)
            oprot.writeI32(self.op_ordinal)
            oprot.writeFieldEnd()
        if self.filter_constant is not None:
            oprot.writeFieldBegin('filter_constant', TType.STRING, 4)
            oprot.writeString(self.filter_constant)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.family is None:
            raise TProtocolException(message='Required field family is unset!')
        if self.op_ordinal is None:
            raise TProtocolException(message='Required field op_ordinal is unset!')
        if self.filter_constant is None:
            raise TProtocolException(message='Required field filter_constant is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THBaseScanNode(object):
    """
    Attributes:
     - tuple_id
     - table_name
     - filters
     - suggested_max_caching

    """


    def __init__(self, tuple_id=None, table_name=None, filters=None, suggested_max_caching=None,):
        self.tuple_id = tuple_id
        self.table_name = table_name
        self.filters = filters
        self.suggested_max_caching = suggested_max_caching

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.filters = []
                    (_etype93, _size90) = iprot.readListBegin()
                    for _i94 in range(_size90):
                        _elem95 = THBaseFilter()
                        _elem95.read(iprot)
                        self.filters.append(_elem95)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.suggested_max_caching = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THBaseScanNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.filters is not None:
            oprot.writeFieldBegin('filters', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.filters))
            for iter96 in self.filters:
                iter96.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.suggested_max_caching is not None:
            oprot.writeFieldBegin('suggested_max_caching', TType.I32, 4)
            oprot.writeI32(self.suggested_max_caching)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduScanNode(object):
    """
    Attributes:
     - tuple_id
     - use_mt_scan_node
     - count_star_slot_offset

    """


    def __init__(self, tuple_id=None, use_mt_scan_node=None, count_star_slot_offset=None,):
        self.tuple_id = tuple_id
        self.use_mt_scan_node = use_mt_scan_node
        self.count_star_slot_offset = count_star_slot_offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.use_mt_scan_node = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.count_star_slot_offset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduScanNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.use_mt_scan_node is not None:
            oprot.writeFieldBegin('use_mt_scan_node', TType.BOOL, 2)
            oprot.writeBool(self.use_mt_scan_node)
            oprot.writeFieldEnd()
        if self.count_star_slot_offset is not None:
            oprot.writeFieldBegin('count_star_slot_offset', TType.I32, 3)
            oprot.writeI32(self.count_star_slot_offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSystemTableScanNode(object):
    """
    Attributes:
     - tuple_id
     - table_name

    """


    def __init__(self, tuple_id=None, table_name=None,):
        self.tuple_id = tuple_id
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.table_name = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSystemTableScanNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.I32, 2)
            oprot.writeI32(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEqJoinCondition(object):
    """
    Attributes:
     - left
     - right
     - is_not_distinct_from

    """


    def __init__(self, left=None, right=None, is_not_distinct_from=None,):
        self.left = left
        self.right = right
        self.is_not_distinct_from = is_not_distinct_from

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.left = Exprs.ttypes.TExpr()
                    self.left.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.right = Exprs.ttypes.TExpr()
                    self.right.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_not_distinct_from = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEqJoinCondition')
        if self.left is not None:
            oprot.writeFieldBegin('left', TType.STRUCT, 1)
            self.left.write(oprot)
            oprot.writeFieldEnd()
        if self.right is not None:
            oprot.writeFieldBegin('right', TType.STRUCT, 2)
            self.right.write(oprot)
            oprot.writeFieldEnd()
        if self.is_not_distinct_from is not None:
            oprot.writeFieldBegin('is_not_distinct_from', TType.BOOL, 3)
            oprot.writeBool(self.is_not_distinct_from)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.left is None:
            raise TProtocolException(message='Required field left is unset!')
        if self.right is None:
            raise TProtocolException(message='Required field right is unset!')
        if self.is_not_distinct_from is None:
            raise TProtocolException(message='Required field is_not_distinct_from is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THashJoinNode(object):
    """
    Attributes:
     - eq_join_conjuncts
     - other_join_conjuncts
     - hash_seed

    """


    def __init__(self, eq_join_conjuncts=None, other_join_conjuncts=None, hash_seed=None,):
        self.eq_join_conjuncts = eq_join_conjuncts
        self.other_join_conjuncts = other_join_conjuncts
        self.hash_seed = hash_seed

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.eq_join_conjuncts = []
                    (_etype100, _size97) = iprot.readListBegin()
                    for _i101 in range(_size97):
                        _elem102 = TEqJoinCondition()
                        _elem102.read(iprot)
                        self.eq_join_conjuncts.append(_elem102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.other_join_conjuncts = []
                    (_etype106, _size103) = iprot.readListBegin()
                    for _i107 in range(_size103):
                        _elem108 = Exprs.ttypes.TExpr()
                        _elem108.read(iprot)
                        self.other_join_conjuncts.append(_elem108)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.hash_seed = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THashJoinNode')
        if self.eq_join_conjuncts is not None:
            oprot.writeFieldBegin('eq_join_conjuncts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.eq_join_conjuncts))
            for iter109 in self.eq_join_conjuncts:
                iter109.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.other_join_conjuncts is not None:
            oprot.writeFieldBegin('other_join_conjuncts', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.other_join_conjuncts))
            for iter110 in self.other_join_conjuncts:
                iter110.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hash_seed is not None:
            oprot.writeFieldBegin('hash_seed', TType.I32, 3)
            oprot.writeI32(self.hash_seed)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.eq_join_conjuncts is None:
            raise TProtocolException(message='Required field eq_join_conjuncts is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNestedLoopJoinNode(object):
    """
    Attributes:
     - join_conjuncts

    """


    def __init__(self, join_conjuncts=None,):
        self.join_conjuncts = join_conjuncts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.join_conjuncts = []
                    (_etype114, _size111) = iprot.readListBegin()
                    for _i115 in range(_size111):
                        _elem116 = Exprs.ttypes.TExpr()
                        _elem116.read(iprot)
                        self.join_conjuncts.append(_elem116)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNestedLoopJoinNode')
        if self.join_conjuncts is not None:
            oprot.writeFieldBegin('join_conjuncts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.join_conjuncts))
            for iter117 in self.join_conjuncts:
                iter117.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergDeleteNode(object):
    """
    Attributes:
     - eq_join_conjuncts

    """


    def __init__(self, eq_join_conjuncts=None,):
        self.eq_join_conjuncts = eq_join_conjuncts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.eq_join_conjuncts = []
                    (_etype121, _size118) = iprot.readListBegin()
                    for _i122 in range(_size118):
                        _elem123 = TEqJoinCondition()
                        _elem123.read(iprot)
                        self.eq_join_conjuncts.append(_elem123)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergDeleteNode')
        if self.eq_join_conjuncts is not None:
            oprot.writeFieldBegin('eq_join_conjuncts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.eq_join_conjuncts))
            for iter124 in self.eq_join_conjuncts:
                iter124.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.eq_join_conjuncts is None:
            raise TProtocolException(message='Required field eq_join_conjuncts is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TJoinNode(object):
    """
    Attributes:
     - join_op
     - build_tuples
     - nullable_build_tuples
     - hash_join_node
     - nested_loop_join_node
     - iceberg_delete_node

    """


    def __init__(self, join_op=None, build_tuples=None, nullable_build_tuples=None, hash_join_node=None, nested_loop_join_node=None, iceberg_delete_node=None,):
        self.join_op = join_op
        self.build_tuples = build_tuples
        self.nullable_build_tuples = nullable_build_tuples
        self.hash_join_node = hash_join_node
        self.nested_loop_join_node = nested_loop_join_node
        self.iceberg_delete_node = iceberg_delete_node

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.join_op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.build_tuples = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = iprot.readI32()
                        self.build_tuples.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.nullable_build_tuples = []
                    (_etype134, _size131) = iprot.readListBegin()
                    for _i135 in range(_size131):
                        _elem136 = iprot.readBool()
                        self.nullable_build_tuples.append(_elem136)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.hash_join_node = THashJoinNode()
                    self.hash_join_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.nested_loop_join_node = TNestedLoopJoinNode()
                    self.nested_loop_join_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.iceberg_delete_node = TIcebergDeleteNode()
                    self.iceberg_delete_node.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TJoinNode')
        if self.join_op is not None:
            oprot.writeFieldBegin('join_op', TType.I32, 1)
            oprot.writeI32(self.join_op)
            oprot.writeFieldEnd()
        if self.build_tuples is not None:
            oprot.writeFieldBegin('build_tuples', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.build_tuples))
            for iter137 in self.build_tuples:
                oprot.writeI32(iter137)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nullable_build_tuples is not None:
            oprot.writeFieldBegin('nullable_build_tuples', TType.LIST, 3)
            oprot.writeListBegin(TType.BOOL, len(self.nullable_build_tuples))
            for iter138 in self.nullable_build_tuples:
                oprot.writeBool(iter138)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hash_join_node is not None:
            oprot.writeFieldBegin('hash_join_node', TType.STRUCT, 4)
            self.hash_join_node.write(oprot)
            oprot.writeFieldEnd()
        if self.nested_loop_join_node is not None:
            oprot.writeFieldBegin('nested_loop_join_node', TType.STRUCT, 5)
            self.nested_loop_join_node.write(oprot)
            oprot.writeFieldEnd()
        if self.iceberg_delete_node is not None:
            oprot.writeFieldBegin('iceberg_delete_node', TType.STRUCT, 6)
            self.iceberg_delete_node.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.join_op is None:
            raise TProtocolException(message='Required field join_op is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAggregator(object):
    """
    Attributes:
     - grouping_exprs
     - aggregate_functions
     - intermediate_tuple_id
     - output_tuple_id
     - need_finalize
     - use_streaming_preaggregation
     - resource_profile

    """


    def __init__(self, grouping_exprs=None, aggregate_functions=None, intermediate_tuple_id=None, output_tuple_id=None, need_finalize=None, use_streaming_preaggregation=None, resource_profile=None,):
        self.grouping_exprs = grouping_exprs
        self.aggregate_functions = aggregate_functions
        self.intermediate_tuple_id = intermediate_tuple_id
        self.output_tuple_id = output_tuple_id
        self.need_finalize = need_finalize
        self.use_streaming_preaggregation = use_streaming_preaggregation
        self.resource_profile = resource_profile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.grouping_exprs = []
                    (_etype142, _size139) = iprot.readListBegin()
                    for _i143 in range(_size139):
                        _elem144 = Exprs.ttypes.TExpr()
                        _elem144.read(iprot)
                        self.grouping_exprs.append(_elem144)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.aggregate_functions = []
                    (_etype148, _size145) = iprot.readListBegin()
                    for _i149 in range(_size145):
                        _elem150 = Exprs.ttypes.TExpr()
                        _elem150.read(iprot)
                        self.aggregate_functions.append(_elem150)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.intermediate_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.output_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.need_finalize = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.use_streaming_preaggregation = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.resource_profile = ResourceProfile.ttypes.TBackendResourceProfile()
                    self.resource_profile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAggregator')
        if self.grouping_exprs is not None:
            oprot.writeFieldBegin('grouping_exprs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.grouping_exprs))
            for iter151 in self.grouping_exprs:
                iter151.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aggregate_functions is not None:
            oprot.writeFieldBegin('aggregate_functions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.aggregate_functions))
            for iter152 in self.aggregate_functions:
                iter152.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.intermediate_tuple_id is not None:
            oprot.writeFieldBegin('intermediate_tuple_id', TType.I32, 3)
            oprot.writeI32(self.intermediate_tuple_id)
            oprot.writeFieldEnd()
        if self.output_tuple_id is not None:
            oprot.writeFieldBegin('output_tuple_id', TType.I32, 4)
            oprot.writeI32(self.output_tuple_id)
            oprot.writeFieldEnd()
        if self.need_finalize is not None:
            oprot.writeFieldBegin('need_finalize', TType.BOOL, 5)
            oprot.writeBool(self.need_finalize)
            oprot.writeFieldEnd()
        if self.use_streaming_preaggregation is not None:
            oprot.writeFieldBegin('use_streaming_preaggregation', TType.BOOL, 6)
            oprot.writeBool(self.use_streaming_preaggregation)
            oprot.writeFieldEnd()
        if self.resource_profile is not None:
            oprot.writeFieldBegin('resource_profile', TType.STRUCT, 7)
            self.resource_profile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.aggregate_functions is None:
            raise TProtocolException(message='Required field aggregate_functions is unset!')
        if self.intermediate_tuple_id is None:
            raise TProtocolException(message='Required field intermediate_tuple_id is unset!')
        if self.output_tuple_id is None:
            raise TProtocolException(message='Required field output_tuple_id is unset!')
        if self.need_finalize is None:
            raise TProtocolException(message='Required field need_finalize is unset!')
        if self.use_streaming_preaggregation is None:
            raise TProtocolException(message='Required field use_streaming_preaggregation is unset!')
        if self.resource_profile is None:
            raise TProtocolException(message='Required field resource_profile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAggregationNode(object):
    """
    Attributes:
     - aggregators
     - estimated_input_cardinality
     - replicate_input
     - fast_limit_check

    """


    def __init__(self, aggregators=None, estimated_input_cardinality=None, replicate_input=None, fast_limit_check=None,):
        self.aggregators = aggregators
        self.estimated_input_cardinality = estimated_input_cardinality
        self.replicate_input = replicate_input
        self.fast_limit_check = fast_limit_check

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.aggregators = []
                    (_etype156, _size153) = iprot.readListBegin()
                    for _i157 in range(_size153):
                        _elem158 = TAggregator()
                        _elem158.read(iprot)
                        self.aggregators.append(_elem158)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.estimated_input_cardinality = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.replicate_input = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.fast_limit_check = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAggregationNode')
        if self.aggregators is not None:
            oprot.writeFieldBegin('aggregators', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.aggregators))
            for iter159 in self.aggregators:
                iter159.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.estimated_input_cardinality is not None:
            oprot.writeFieldBegin('estimated_input_cardinality', TType.I64, 2)
            oprot.writeI64(self.estimated_input_cardinality)
            oprot.writeFieldEnd()
        if self.replicate_input is not None:
            oprot.writeFieldBegin('replicate_input', TType.BOOL, 3)
            oprot.writeBool(self.replicate_input)
            oprot.writeFieldEnd()
        if self.fast_limit_check is not None:
            oprot.writeFieldBegin('fast_limit_check', TType.BOOL, 4)
            oprot.writeBool(self.fast_limit_check)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.aggregators is None:
            raise TProtocolException(message='Required field aggregators is unset!')
        if self.estimated_input_cardinality is None:
            raise TProtocolException(message='Required field estimated_input_cardinality is unset!')
        if self.replicate_input is None:
            raise TProtocolException(message='Required field replicate_input is unset!')
        if self.fast_limit_check is None:
            raise TProtocolException(message='Required field fast_limit_check is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSortInfo(object):
    """
    Attributes:
     - ordering_exprs
     - is_asc_order
     - nulls_first
     - sort_tuple_slot_exprs
     - sorting_order
     - num_lexical_keys_in_zorder

    """


    def __init__(self, ordering_exprs=None, is_asc_order=None, nulls_first=None, sort_tuple_slot_exprs=None, sorting_order=None, num_lexical_keys_in_zorder=None,):
        self.ordering_exprs = ordering_exprs
        self.is_asc_order = is_asc_order
        self.nulls_first = nulls_first
        self.sort_tuple_slot_exprs = sort_tuple_slot_exprs
        self.sorting_order = sorting_order
        self.num_lexical_keys_in_zorder = num_lexical_keys_in_zorder

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.ordering_exprs = []
                    (_etype163, _size160) = iprot.readListBegin()
                    for _i164 in range(_size160):
                        _elem165 = Exprs.ttypes.TExpr()
                        _elem165.read(iprot)
                        self.ordering_exprs.append(_elem165)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.is_asc_order = []
                    (_etype169, _size166) = iprot.readListBegin()
                    for _i170 in range(_size166):
                        _elem171 = iprot.readBool()
                        self.is_asc_order.append(_elem171)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.nulls_first = []
                    (_etype175, _size172) = iprot.readListBegin()
                    for _i176 in range(_size172):
                        _elem177 = iprot.readBool()
                        self.nulls_first.append(_elem177)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.sort_tuple_slot_exprs = []
                    (_etype181, _size178) = iprot.readListBegin()
                    for _i182 in range(_size178):
                        _elem183 = Exprs.ttypes.TExpr()
                        _elem183.read(iprot)
                        self.sort_tuple_slot_exprs.append(_elem183)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.sorting_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.num_lexical_keys_in_zorder = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSortInfo')
        if self.ordering_exprs is not None:
            oprot.writeFieldBegin('ordering_exprs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.ordering_exprs))
            for iter184 in self.ordering_exprs:
                iter184.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_asc_order is not None:
            oprot.writeFieldBegin('is_asc_order', TType.LIST, 2)
            oprot.writeListBegin(TType.BOOL, len(self.is_asc_order))
            for iter185 in self.is_asc_order:
                oprot.writeBool(iter185)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nulls_first is not None:
            oprot.writeFieldBegin('nulls_first', TType.LIST, 3)
            oprot.writeListBegin(TType.BOOL, len(self.nulls_first))
            for iter186 in self.nulls_first:
                oprot.writeBool(iter186)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sort_tuple_slot_exprs is not None:
            oprot.writeFieldBegin('sort_tuple_slot_exprs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.sort_tuple_slot_exprs))
            for iter187 in self.sort_tuple_slot_exprs:
                iter187.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sorting_order is not None:
            oprot.writeFieldBegin('sorting_order', TType.I32, 5)
            oprot.writeI32(self.sorting_order)
            oprot.writeFieldEnd()
        if self.num_lexical_keys_in_zorder is not None:
            oprot.writeFieldBegin('num_lexical_keys_in_zorder', TType.I32, 6)
            oprot.writeI32(self.num_lexical_keys_in_zorder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.ordering_exprs is None:
            raise TProtocolException(message='Required field ordering_exprs is unset!')
        if self.is_asc_order is None:
            raise TProtocolException(message='Required field is_asc_order is unset!')
        if self.nulls_first is None:
            raise TProtocolException(message='Required field nulls_first is unset!')
        if self.sorting_order is None:
            raise TProtocolException(message='Required field sorting_order is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSortNode(object):
    """
    Attributes:
     - sort_info
     - type
     - offset
     - estimated_full_input_size
     - include_ties
     - limit_with_ties
     - per_partition_limit
     - partition_exprs
     - intra_partition_sort_info

    """


    def __init__(self, sort_info=None, type=None, offset=None, estimated_full_input_size=None, include_ties=None, limit_with_ties=None, per_partition_limit=None, partition_exprs=None, intra_partition_sort_info=None,):
        self.sort_info = sort_info
        self.type = type
        self.offset = offset
        self.estimated_full_input_size = estimated_full_input_size
        self.include_ties = include_ties
        self.limit_with_ties = limit_with_ties
        self.per_partition_limit = per_partition_limit
        self.partition_exprs = partition_exprs
        self.intra_partition_sort_info = intra_partition_sort_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.sort_info = TSortInfo()
                    self.sort_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.estimated_full_input_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.include_ties = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.limit_with_ties = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.per_partition_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.partition_exprs = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = Exprs.ttypes.TExpr()
                        _elem193.read(iprot)
                        self.partition_exprs.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.intra_partition_sort_info = TSortInfo()
                    self.intra_partition_sort_info.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSortNode')
        if self.sort_info is not None:
            oprot.writeFieldBegin('sort_info', TType.STRUCT, 1)
            self.sort_info.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.estimated_full_input_size is not None:
            oprot.writeFieldBegin('estimated_full_input_size', TType.I64, 4)
            oprot.writeI64(self.estimated_full_input_size)
            oprot.writeFieldEnd()
        if self.include_ties is not None:
            oprot.writeFieldBegin('include_ties', TType.BOOL, 5)
            oprot.writeBool(self.include_ties)
            oprot.writeFieldEnd()
        if self.limit_with_ties is not None:
            oprot.writeFieldBegin('limit_with_ties', TType.I64, 6)
            oprot.writeI64(self.limit_with_ties)
            oprot.writeFieldEnd()
        if self.per_partition_limit is not None:
            oprot.writeFieldBegin('per_partition_limit', TType.I64, 7)
            oprot.writeI64(self.per_partition_limit)
            oprot.writeFieldEnd()
        if self.partition_exprs is not None:
            oprot.writeFieldBegin('partition_exprs', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_exprs))
            for iter194 in self.partition_exprs:
                iter194.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.intra_partition_sort_info is not None:
            oprot.writeFieldBegin('intra_partition_sort_info', TType.STRUCT, 9)
            self.intra_partition_sort_info.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sort_info is None:
            raise TProtocolException(message='Required field sort_info is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAnalyticWindowBoundary(object):
    """
    Attributes:
     - type
     - range_offset_predicate
     - rows_offset_value

    """


    def __init__(self, type=None, range_offset_predicate=None, rows_offset_value=None,):
        self.type = type
        self.range_offset_predicate = range_offset_predicate
        self.rows_offset_value = rows_offset_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.range_offset_predicate = Exprs.ttypes.TExpr()
                    self.range_offset_predicate.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.rows_offset_value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAnalyticWindowBoundary')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.range_offset_predicate is not None:
            oprot.writeFieldBegin('range_offset_predicate', TType.STRUCT, 2)
            self.range_offset_predicate.write(oprot)
            oprot.writeFieldEnd()
        if self.rows_offset_value is not None:
            oprot.writeFieldBegin('rows_offset_value', TType.I64, 3)
            oprot.writeI64(self.rows_offset_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAnalyticWindow(object):
    """
    Attributes:
     - type
     - window_start
     - window_end

    """


    def __init__(self, type=None, window_start=None, window_end=None,):
        self.type = type
        self.window_start = window_start
        self.window_end = window_end

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.window_start = TAnalyticWindowBoundary()
                    self.window_start.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.window_end = TAnalyticWindowBoundary()
                    self.window_end.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAnalyticWindow')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.window_start is not None:
            oprot.writeFieldBegin('window_start', TType.STRUCT, 2)
            self.window_start.write(oprot)
            oprot.writeFieldEnd()
        if self.window_end is not None:
            oprot.writeFieldBegin('window_end', TType.STRUCT, 3)
            self.window_end.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAnalyticNode(object):
    """
    Attributes:
     - partition_exprs
     - order_by_exprs
     - analytic_functions
     - window
     - intermediate_tuple_id
     - output_tuple_id
     - buffered_tuple_id
     - partition_by_eq
     - order_by_eq

    """


    def __init__(self, partition_exprs=None, order_by_exprs=None, analytic_functions=None, window=None, intermediate_tuple_id=None, output_tuple_id=None, buffered_tuple_id=None, partition_by_eq=None, order_by_eq=None,):
        self.partition_exprs = partition_exprs
        self.order_by_exprs = order_by_exprs
        self.analytic_functions = analytic_functions
        self.window = window
        self.intermediate_tuple_id = intermediate_tuple_id
        self.output_tuple_id = output_tuple_id
        self.buffered_tuple_id = buffered_tuple_id
        self.partition_by_eq = partition_by_eq
        self.order_by_eq = order_by_eq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partition_exprs = []
                    (_etype198, _size195) = iprot.readListBegin()
                    for _i199 in range(_size195):
                        _elem200 = Exprs.ttypes.TExpr()
                        _elem200.read(iprot)
                        self.partition_exprs.append(_elem200)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.order_by_exprs = []
                    (_etype204, _size201) = iprot.readListBegin()
                    for _i205 in range(_size201):
                        _elem206 = Exprs.ttypes.TExpr()
                        _elem206.read(iprot)
                        self.order_by_exprs.append(_elem206)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.analytic_functions = []
                    (_etype210, _size207) = iprot.readListBegin()
                    for _i211 in range(_size207):
                        _elem212 = Exprs.ttypes.TExpr()
                        _elem212.read(iprot)
                        self.analytic_functions.append(_elem212)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.window = TAnalyticWindow()
                    self.window.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.intermediate_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.output_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.buffered_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.partition_by_eq = Exprs.ttypes.TExpr()
                    self.partition_by_eq.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.order_by_eq = Exprs.ttypes.TExpr()
                    self.order_by_eq.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAnalyticNode')
        if self.partition_exprs is not None:
            oprot.writeFieldBegin('partition_exprs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_exprs))
            for iter213 in self.partition_exprs:
                iter213.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.order_by_exprs is not None:
            oprot.writeFieldBegin('order_by_exprs', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.order_by_exprs))
            for iter214 in self.order_by_exprs:
                iter214.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.analytic_functions is not None:
            oprot.writeFieldBegin('analytic_functions', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.analytic_functions))
            for iter215 in self.analytic_functions:
                iter215.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.window is not None:
            oprot.writeFieldBegin('window', TType.STRUCT, 4)
            self.window.write(oprot)
            oprot.writeFieldEnd()
        if self.intermediate_tuple_id is not None:
            oprot.writeFieldBegin('intermediate_tuple_id', TType.I32, 5)
            oprot.writeI32(self.intermediate_tuple_id)
            oprot.writeFieldEnd()
        if self.output_tuple_id is not None:
            oprot.writeFieldBegin('output_tuple_id', TType.I32, 6)
            oprot.writeI32(self.output_tuple_id)
            oprot.writeFieldEnd()
        if self.buffered_tuple_id is not None:
            oprot.writeFieldBegin('buffered_tuple_id', TType.I32, 7)
            oprot.writeI32(self.buffered_tuple_id)
            oprot.writeFieldEnd()
        if self.partition_by_eq is not None:
            oprot.writeFieldBegin('partition_by_eq', TType.STRUCT, 8)
            self.partition_by_eq.write(oprot)
            oprot.writeFieldEnd()
        if self.order_by_eq is not None:
            oprot.writeFieldBegin('order_by_eq', TType.STRUCT, 9)
            self.order_by_eq.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partition_exprs is None:
            raise TProtocolException(message='Required field partition_exprs is unset!')
        if self.order_by_exprs is None:
            raise TProtocolException(message='Required field order_by_exprs is unset!')
        if self.analytic_functions is None:
            raise TProtocolException(message='Required field analytic_functions is unset!')
        if self.intermediate_tuple_id is None:
            raise TProtocolException(message='Required field intermediate_tuple_id is unset!')
        if self.output_tuple_id is None:
            raise TProtocolException(message='Required field output_tuple_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUnionNode(object):
    """
    Attributes:
     - tuple_id
     - result_expr_lists
     - const_expr_lists
     - first_materialized_child_idx

    """


    def __init__(self, tuple_id=None, result_expr_lists=None, const_expr_lists=None, first_materialized_child_idx=None,):
        self.tuple_id = tuple_id
        self.result_expr_lists = result_expr_lists
        self.const_expr_lists = const_expr_lists
        self.first_materialized_child_idx = first_materialized_child_idx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.result_expr_lists = []
                    (_etype219, _size216) = iprot.readListBegin()
                    for _i220 in range(_size216):
                        _elem221 = []
                        (_etype225, _size222) = iprot.readListBegin()
                        for _i226 in range(_size222):
                            _elem227 = Exprs.ttypes.TExpr()
                            _elem227.read(iprot)
                            _elem221.append(_elem227)
                        iprot.readListEnd()
                        self.result_expr_lists.append(_elem221)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.const_expr_lists = []
                    (_etype231, _size228) = iprot.readListBegin()
                    for _i232 in range(_size228):
                        _elem233 = []
                        (_etype237, _size234) = iprot.readListBegin()
                        for _i238 in range(_size234):
                            _elem239 = Exprs.ttypes.TExpr()
                            _elem239.read(iprot)
                            _elem233.append(_elem239)
                        iprot.readListEnd()
                        self.const_expr_lists.append(_elem233)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.first_materialized_child_idx = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUnionNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.result_expr_lists is not None:
            oprot.writeFieldBegin('result_expr_lists', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.result_expr_lists))
            for iter240 in self.result_expr_lists:
                oprot.writeListBegin(TType.STRUCT, len(iter240))
                for iter241 in iter240:
                    iter241.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.const_expr_lists is not None:
            oprot.writeFieldBegin('const_expr_lists', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.const_expr_lists))
            for iter242 in self.const_expr_lists:
                oprot.writeListBegin(TType.STRUCT, len(iter242))
                for iter243 in iter242:
                    iter243.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.first_materialized_child_idx is not None:
            oprot.writeFieldBegin('first_materialized_child_idx', TType.I64, 4)
            oprot.writeI64(self.first_materialized_child_idx)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        if self.result_expr_lists is None:
            raise TProtocolException(message='Required field result_expr_lists is unset!')
        if self.const_expr_lists is None:
            raise TProtocolException(message='Required field const_expr_lists is unset!')
        if self.first_materialized_child_idx is None:
            raise TProtocolException(message='Required field first_materialized_child_idx is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExchangeNode(object):
    """
    Attributes:
     - input_row_tuples
     - sort_info
     - offset

    """


    def __init__(self, input_row_tuples=None, sort_info=None, offset=None,):
        self.input_row_tuples = input_row_tuples
        self.sort_info = sort_info
        self.offset = offset

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.input_row_tuples = []
                    (_etype247, _size244) = iprot.readListBegin()
                    for _i248 in range(_size244):
                        _elem249 = iprot.readI32()
                        self.input_row_tuples.append(_elem249)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.sort_info = TSortInfo()
                    self.sort_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExchangeNode')
        if self.input_row_tuples is not None:
            oprot.writeFieldBegin('input_row_tuples', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.input_row_tuples))
            for iter250 in self.input_row_tuples:
                oprot.writeI32(iter250)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sort_info is not None:
            oprot.writeFieldBegin('sort_info', TType.STRUCT, 2)
            self.sort_info.write(oprot)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 3)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.input_row_tuples is None:
            raise TProtocolException(message='Required field input_row_tuples is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUnnestNode(object):
    """
    Attributes:
     - collection_exprs

    """


    def __init__(self, collection_exprs=None,):
        self.collection_exprs = collection_exprs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.collection_exprs = []
                    (_etype254, _size251) = iprot.readListBegin()
                    for _i255 in range(_size251):
                        _elem256 = Exprs.ttypes.TExpr()
                        _elem256.read(iprot)
                        self.collection_exprs.append(_elem256)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUnnestNode')
        if self.collection_exprs is not None:
            oprot.writeFieldBegin('collection_exprs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.collection_exprs))
            for iter257 in self.collection_exprs:
                iter257.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.collection_exprs is None:
            raise TProtocolException(message='Required field collection_exprs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCardinalityCheckNode(object):
    """
    Attributes:
     - display_statement

    """


    def __init__(self, display_statement=None,):
        self.display_statement = display_statement

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.display_statement = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCardinalityCheckNode')
        if self.display_statement is not None:
            oprot.writeFieldBegin('display_statement', TType.STRING, 1)
            oprot.writeString(self.display_statement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.display_statement is None:
            raise TProtocolException(message='Required field display_statement is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergMetadataScanNode(object):
    """
    Attributes:
     - tuple_id
     - table_name
     - metadata_table_name

    """


    def __init__(self, tuple_id=None, table_name=None, metadata_table_name=None,):
        self.tuple_id = tuple_id
        self.table_name = table_name
        self.metadata_table_name = metadata_table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.metadata_table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergMetadataScanNode')
        if self.tuple_id is not None:
            oprot.writeFieldBegin('tuple_id', TType.I32, 1)
            oprot.writeI32(self.tuple_id)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata_table_name is not None:
            oprot.writeFieldBegin('metadata_table_name', TType.STRING, 3)
            oprot.writeString(self.metadata_table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tuple_id is None:
            raise TProtocolException(message='Required field tuple_id is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.metadata_table_name is None:
            raise TProtocolException(message='Required field metadata_table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTupleCacheNode(object):
    """
    Attributes:
     - compile_time_key
     - input_scan_node_ids

    """


    def __init__(self, compile_time_key=None, input_scan_node_ids=None,):
        self.compile_time_key = compile_time_key
        self.input_scan_node_ids = input_scan_node_ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.compile_time_key = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.input_scan_node_ids = []
                    (_etype261, _size258) = iprot.readListBegin()
                    for _i262 in range(_size258):
                        _elem263 = iprot.readI32()
                        self.input_scan_node_ids.append(_elem263)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTupleCacheNode')
        if self.compile_time_key is not None:
            oprot.writeFieldBegin('compile_time_key', TType.STRING, 1)
            oprot.writeString(self.compile_time_key)
            oprot.writeFieldEnd()
        if self.input_scan_node_ids is not None:
            oprot.writeFieldBegin('input_scan_node_ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.input_scan_node_ids))
            for iter264 in self.input_scan_node_ids:
                oprot.writeI32(iter264)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.compile_time_key is None:
            raise TProtocolException(message='Required field compile_time_key is unset!')
        if self.input_scan_node_ids is None:
            raise TProtocolException(message='Required field input_scan_node_ids is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergMergeCase(object):
    """
    Attributes:
     - output_expressions
     - filter_conjuncts
     - type
     - match_type

    """


    def __init__(self, output_expressions=None, filter_conjuncts=None, type=None, match_type=None,):
        self.output_expressions = output_expressions
        self.filter_conjuncts = filter_conjuncts
        self.type = type
        self.match_type = match_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.output_expressions = []
                    (_etype268, _size265) = iprot.readListBegin()
                    for _i269 in range(_size265):
                        _elem270 = Exprs.ttypes.TExpr()
                        _elem270.read(iprot)
                        self.output_expressions.append(_elem270)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.filter_conjuncts = []
                    (_etype274, _size271) = iprot.readListBegin()
                    for _i275 in range(_size271):
                        _elem276 = Exprs.ttypes.TExpr()
                        _elem276.read(iprot)
                        self.filter_conjuncts.append(_elem276)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.match_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergMergeCase')
        if self.output_expressions is not None:
            oprot.writeFieldBegin('output_expressions', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.output_expressions))
            for iter277 in self.output_expressions:
                iter277.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.filter_conjuncts is not None:
            oprot.writeFieldBegin('filter_conjuncts', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.filter_conjuncts))
            for iter278 in self.filter_conjuncts:
                iter278.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.match_type is not None:
            oprot.writeFieldBegin('match_type', TType.I32, 4)
            oprot.writeI32(self.match_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.output_expressions is None:
            raise TProtocolException(message='Required field output_expressions is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.match_type is None:
            raise TProtocolException(message='Required field match_type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergMergeNode(object):
    """
    Attributes:
     - cases
     - row_present
     - position_meta_exprs
     - partition_meta_exprs
     - merge_action_tuple_id
     - target_tuple_id

    """


    def __init__(self, cases=None, row_present=None, position_meta_exprs=None, partition_meta_exprs=None, merge_action_tuple_id=None, target_tuple_id=None,):
        self.cases = cases
        self.row_present = row_present
        self.position_meta_exprs = position_meta_exprs
        self.partition_meta_exprs = partition_meta_exprs
        self.merge_action_tuple_id = merge_action_tuple_id
        self.target_tuple_id = target_tuple_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.cases = []
                    (_etype282, _size279) = iprot.readListBegin()
                    for _i283 in range(_size279):
                        _elem284 = TIcebergMergeCase()
                        _elem284.read(iprot)
                        self.cases.append(_elem284)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.row_present = Exprs.ttypes.TExpr()
                    self.row_present.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.position_meta_exprs = []
                    (_etype288, _size285) = iprot.readListBegin()
                    for _i289 in range(_size285):
                        _elem290 = Exprs.ttypes.TExpr()
                        _elem290.read(iprot)
                        self.position_meta_exprs.append(_elem290)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partition_meta_exprs = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = Exprs.ttypes.TExpr()
                        _elem296.read(iprot)
                        self.partition_meta_exprs.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.merge_action_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.target_tuple_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergMergeNode')
        if self.cases is not None:
            oprot.writeFieldBegin('cases', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.cases))
            for iter297 in self.cases:
                iter297.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.row_present is not None:
            oprot.writeFieldBegin('row_present', TType.STRUCT, 2)
            self.row_present.write(oprot)
            oprot.writeFieldEnd()
        if self.position_meta_exprs is not None:
            oprot.writeFieldBegin('position_meta_exprs', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.position_meta_exprs))
            for iter298 in self.position_meta_exprs:
                iter298.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_meta_exprs is not None:
            oprot.writeFieldBegin('partition_meta_exprs', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_meta_exprs))
            for iter299 in self.partition_meta_exprs:
                iter299.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.merge_action_tuple_id is not None:
            oprot.writeFieldBegin('merge_action_tuple_id', TType.I32, 5)
            oprot.writeI32(self.merge_action_tuple_id)
            oprot.writeFieldEnd()
        if self.target_tuple_id is not None:
            oprot.writeFieldBegin('target_tuple_id', TType.I32, 6)
            oprot.writeI32(self.target_tuple_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cases is None:
            raise TProtocolException(message='Required field cases is unset!')
        if self.row_present is None:
            raise TProtocolException(message='Required field row_present is unset!')
        if self.position_meta_exprs is None:
            raise TProtocolException(message='Required field position_meta_exprs is unset!')
        if self.partition_meta_exprs is None:
            raise TProtocolException(message='Required field partition_meta_exprs is unset!')
        if self.merge_action_tuple_id is None:
            raise TProtocolException(message='Required field merge_action_tuple_id is unset!')
        if self.target_tuple_id is None:
            raise TProtocolException(message='Required field target_tuple_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPipelineMembership(object):
    """
    Attributes:
     - pipe_id
     - height
     - phase

    """


    def __init__(self, pipe_id=None, height=None, phase=None,):
        self.pipe_id = pipe_id
        self.height = height
        self.phase = phase

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.pipe_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.height = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.phase = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPipelineMembership')
        if self.pipe_id is not None:
            oprot.writeFieldBegin('pipe_id', TType.I32, 1)
            oprot.writeI32(self.pipe_id)
            oprot.writeFieldEnd()
        if self.height is not None:
            oprot.writeFieldBegin('height', TType.I32, 2)
            oprot.writeI32(self.height)
            oprot.writeFieldEnd()
        if self.phase is not None:
            oprot.writeFieldBegin('phase', TType.I32, 3)
            oprot.writeI32(self.phase)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pipe_id is None:
            raise TProtocolException(message='Required field pipe_id is unset!')
        if self.height is None:
            raise TProtocolException(message='Required field height is unset!')
        if self.phase is None:
            raise TProtocolException(message='Required field phase is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanNode(object):
    """
    Attributes:
     - node_id
     - node_type
     - num_children
     - limit
     - row_tuples
     - nullable_tuples
     - conjuncts
     - disable_codegen
     - pipelines
     - hdfs_scan_node
     - hbase_scan_node
     - kudu_scan_node
     - data_source_node
     - join_node
     - agg_node
     - sort_node
     - union_node
     - exchange_node
     - analytic_node
     - unnest_node
     - iceberg_scan_metadata_node
     - merge_node
     - label
     - label_detail
     - estimated_stats
     - runtime_filters
     - resource_profile
     - cardinality_check_node
     - tuple_cache_node
     - system_table_scan_node

    """


    def __init__(self, node_id=None, node_type=None, num_children=None, limit=None, row_tuples=None, nullable_tuples=None, conjuncts=None, disable_codegen=None, pipelines=None, hdfs_scan_node=None, hbase_scan_node=None, kudu_scan_node=None, data_source_node=None, join_node=None, agg_node=None, sort_node=None, union_node=None, exchange_node=None, analytic_node=None, unnest_node=None, iceberg_scan_metadata_node=None, merge_node=None, label=None, label_detail=None, estimated_stats=None, runtime_filters=None, resource_profile=None, cardinality_check_node=None, tuple_cache_node=None, system_table_scan_node=None,):
        self.node_id = node_id
        self.node_type = node_type
        self.num_children = num_children
        self.limit = limit
        self.row_tuples = row_tuples
        self.nullable_tuples = nullable_tuples
        self.conjuncts = conjuncts
        self.disable_codegen = disable_codegen
        self.pipelines = pipelines
        self.hdfs_scan_node = hdfs_scan_node
        self.hbase_scan_node = hbase_scan_node
        self.kudu_scan_node = kudu_scan_node
        self.data_source_node = data_source_node
        self.join_node = join_node
        self.agg_node = agg_node
        self.sort_node = sort_node
        self.union_node = union_node
        self.exchange_node = exchange_node
        self.analytic_node = analytic_node
        self.unnest_node = unnest_node
        self.iceberg_scan_metadata_node = iceberg_scan_metadata_node
        self.merge_node = merge_node
        self.label = label
        self.label_detail = label_detail
        self.estimated_stats = estimated_stats
        self.runtime_filters = runtime_filters
        self.resource_profile = resource_profile
        self.cardinality_check_node = cardinality_check_node
        self.tuple_cache_node = tuple_cache_node
        self.system_table_scan_node = system_table_scan_node

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.node_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.num_children = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.row_tuples = []
                    (_etype303, _size300) = iprot.readListBegin()
                    for _i304 in range(_size300):
                        _elem305 = iprot.readI32()
                        self.row_tuples.append(_elem305)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.nullable_tuples = []
                    (_etype309, _size306) = iprot.readListBegin()
                    for _i310 in range(_size306):
                        _elem311 = iprot.readBool()
                        self.nullable_tuples.append(_elem311)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.conjuncts = []
                    (_etype315, _size312) = iprot.readListBegin()
                    for _i316 in range(_size312):
                        _elem317 = Exprs.ttypes.TExpr()
                        _elem317.read(iprot)
                        self.conjuncts.append(_elem317)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.disable_codegen = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.pipelines = []
                    (_etype321, _size318) = iprot.readListBegin()
                    for _i322 in range(_size318):
                        _elem323 = TPipelineMembership()
                        _elem323.read(iprot)
                        self.pipelines.append(_elem323)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.hdfs_scan_node = THdfsScanNode()
                    self.hdfs_scan_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.hbase_scan_node = THBaseScanNode()
                    self.hbase_scan_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.kudu_scan_node = TKuduScanNode()
                    self.kudu_scan_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.data_source_node = TDataSourceScanNode()
                    self.data_source_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.join_node = TJoinNode()
                    self.join_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.agg_node = TAggregationNode()
                    self.agg_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.sort_node = TSortNode()
                    self.sort_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.union_node = TUnionNode()
                    self.union_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.exchange_node = TExchangeNode()
                    self.exchange_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRUCT:
                    self.analytic_node = TAnalyticNode()
                    self.analytic_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.unnest_node = TUnnestNode()
                    self.unnest_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRUCT:
                    self.iceberg_scan_metadata_node = TIcebergMetadataScanNode()
                    self.iceberg_scan_metadata_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 30:
                if ftype == TType.STRUCT:
                    self.merge_node = TIcebergMergeNode()
                    self.merge_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRING:
                    self.label = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.STRING:
                    self.label_detail = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.STRUCT:
                    self.estimated_stats = ExecStats.ttypes.TExecStats()
                    self.estimated_stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.LIST:
                    self.runtime_filters = []
                    (_etype327, _size324) = iprot.readListBegin()
                    for _i328 in range(_size324):
                        _elem329 = TRuntimeFilterDesc()
                        _elem329.read(iprot)
                        self.runtime_filters.append(_elem329)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.STRUCT:
                    self.resource_profile = ResourceProfile.ttypes.TBackendResourceProfile()
                    self.resource_profile.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.STRUCT:
                    self.cardinality_check_node = TCardinalityCheckNode()
                    self.cardinality_check_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 28:
                if ftype == TType.STRUCT:
                    self.tuple_cache_node = TTupleCacheNode()
                    self.tuple_cache_node.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 29:
                if ftype == TType.STRUCT:
                    self.system_table_scan_node = TSystemTableScanNode()
                    self.system_table_scan_node.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanNode')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.node_type is not None:
            oprot.writeFieldBegin('node_type', TType.I32, 2)
            oprot.writeI32(self.node_type)
            oprot.writeFieldEnd()
        if self.num_children is not None:
            oprot.writeFieldBegin('num_children', TType.I32, 3)
            oprot.writeI32(self.num_children)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 4)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.row_tuples is not None:
            oprot.writeFieldBegin('row_tuples', TType.LIST, 5)
            oprot.writeListBegin(TType.I32, len(self.row_tuples))
            for iter330 in self.row_tuples:
                oprot.writeI32(iter330)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nullable_tuples is not None:
            oprot.writeFieldBegin('nullable_tuples', TType.LIST, 6)
            oprot.writeListBegin(TType.BOOL, len(self.nullable_tuples))
            for iter331 in self.nullable_tuples:
                oprot.writeBool(iter331)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.conjuncts is not None:
            oprot.writeFieldBegin('conjuncts', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.conjuncts))
            for iter332 in self.conjuncts:
                iter332.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.disable_codegen is not None:
            oprot.writeFieldBegin('disable_codegen', TType.BOOL, 8)
            oprot.writeBool(self.disable_codegen)
            oprot.writeFieldEnd()
        if self.pipelines is not None:
            oprot.writeFieldBegin('pipelines', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.pipelines))
            for iter333 in self.pipelines:
                iter333.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hdfs_scan_node is not None:
            oprot.writeFieldBegin('hdfs_scan_node', TType.STRUCT, 10)
            self.hdfs_scan_node.write(oprot)
            oprot.writeFieldEnd()
        if self.hbase_scan_node is not None:
            oprot.writeFieldBegin('hbase_scan_node', TType.STRUCT, 11)
            self.hbase_scan_node.write(oprot)
            oprot.writeFieldEnd()
        if self.kudu_scan_node is not None:
            oprot.writeFieldBegin('kudu_scan_node', TType.STRUCT, 12)
            self.kudu_scan_node.write(oprot)
            oprot.writeFieldEnd()
        if self.data_source_node is not None:
            oprot.writeFieldBegin('data_source_node', TType.STRUCT, 13)
            self.data_source_node.write(oprot)
            oprot.writeFieldEnd()
        if self.join_node is not None:
            oprot.writeFieldBegin('join_node', TType.STRUCT, 14)
            self.join_node.write(oprot)
            oprot.writeFieldEnd()
        if self.agg_node is not None:
            oprot.writeFieldBegin('agg_node', TType.STRUCT, 15)
            self.agg_node.write(oprot)
            oprot.writeFieldEnd()
        if self.sort_node is not None:
            oprot.writeFieldBegin('sort_node', TType.STRUCT, 16)
            self.sort_node.write(oprot)
            oprot.writeFieldEnd()
        if self.union_node is not None:
            oprot.writeFieldBegin('union_node', TType.STRUCT, 17)
            self.union_node.write(oprot)
            oprot.writeFieldEnd()
        if self.exchange_node is not None:
            oprot.writeFieldBegin('exchange_node', TType.STRUCT, 18)
            self.exchange_node.write(oprot)
            oprot.writeFieldEnd()
        if self.analytic_node is not None:
            oprot.writeFieldBegin('analytic_node', TType.STRUCT, 19)
            self.analytic_node.write(oprot)
            oprot.writeFieldEnd()
        if self.unnest_node is not None:
            oprot.writeFieldBegin('unnest_node', TType.STRUCT, 20)
            self.unnest_node.write(oprot)
            oprot.writeFieldEnd()
        if self.iceberg_scan_metadata_node is not None:
            oprot.writeFieldBegin('iceberg_scan_metadata_node', TType.STRUCT, 21)
            self.iceberg_scan_metadata_node.write(oprot)
            oprot.writeFieldEnd()
        if self.label is not None:
            oprot.writeFieldBegin('label', TType.STRING, 22)
            oprot.writeString(self.label)
            oprot.writeFieldEnd()
        if self.label_detail is not None:
            oprot.writeFieldBegin('label_detail', TType.STRING, 23)
            oprot.writeString(self.label_detail)
            oprot.writeFieldEnd()
        if self.estimated_stats is not None:
            oprot.writeFieldBegin('estimated_stats', TType.STRUCT, 24)
            self.estimated_stats.write(oprot)
            oprot.writeFieldEnd()
        if self.runtime_filters is not None:
            oprot.writeFieldBegin('runtime_filters', TType.LIST, 25)
            oprot.writeListBegin(TType.STRUCT, len(self.runtime_filters))
            for iter334 in self.runtime_filters:
                iter334.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.resource_profile is not None:
            oprot.writeFieldBegin('resource_profile', TType.STRUCT, 26)
            self.resource_profile.write(oprot)
            oprot.writeFieldEnd()
        if self.cardinality_check_node is not None:
            oprot.writeFieldBegin('cardinality_check_node', TType.STRUCT, 27)
            self.cardinality_check_node.write(oprot)
            oprot.writeFieldEnd()
        if self.tuple_cache_node is not None:
            oprot.writeFieldBegin('tuple_cache_node', TType.STRUCT, 28)
            self.tuple_cache_node.write(oprot)
            oprot.writeFieldEnd()
        if self.system_table_scan_node is not None:
            oprot.writeFieldBegin('system_table_scan_node', TType.STRUCT, 29)
            self.system_table_scan_node.write(oprot)
            oprot.writeFieldEnd()
        if self.merge_node is not None:
            oprot.writeFieldBegin('merge_node', TType.STRUCT, 30)
            self.merge_node.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.node_id is None:
            raise TProtocolException(message='Required field node_id is unset!')
        if self.node_type is None:
            raise TProtocolException(message='Required field node_type is unset!')
        if self.num_children is None:
            raise TProtocolException(message='Required field num_children is unset!')
        if self.limit is None:
            raise TProtocolException(message='Required field limit is unset!')
        if self.row_tuples is None:
            raise TProtocolException(message='Required field row_tuples is unset!')
        if self.nullable_tuples is None:
            raise TProtocolException(message='Required field nullable_tuples is unset!')
        if self.disable_codegen is None:
            raise TProtocolException(message='Required field disable_codegen is unset!')
        if self.pipelines is None:
            raise TProtocolException(message='Required field pipelines is unset!')
        if self.resource_profile is None:
            raise TProtocolException(message='Required field resource_profile is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlan(object):
    """
    Attributes:
     - nodes

    """


    def __init__(self, nodes=None,):
        self.nodes = nodes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.nodes = []
                    (_etype338, _size335) = iprot.readListBegin()
                    for _i339 in range(_size335):
                        _elem340 = TPlanNode()
                        _elem340.read(iprot)
                        self.nodes.append(_elem340)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlan')
        if self.nodes is not None:
            oprot.writeFieldBegin('nodes', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.nodes))
            for iter341 in self.nodes:
                iter341.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.nodes is None:
            raise TProtocolException(message='Required field nodes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TRuntimeFilterTargetDesc)
TRuntimeFilterTargetDesc.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.STRUCT, 'target_expr', [Exprs.ttypes.TExpr, None], None, ),  # 2
    (3, TType.BOOL, 'is_bound_by_partition_columns', None, None, ),  # 3
    (4, TType.LIST, 'target_expr_slotids', (TType.I32, None, False), None, ),  # 4
    (5, TType.BOOL, 'is_local_target', None, None, ),  # 5
    (6, TType.STRING, 'kudu_col_name', None, None, ),  # 6
    (7, TType.STRUCT, 'kudu_col_type', [Types.ttypes.TColumnType, None], None, ),  # 7
    (8, TType.STRUCT, 'low_value', [Data.ttypes.TColumnValue, None], None, ),  # 8
    (9, TType.STRUCT, 'high_value', [Data.ttypes.TColumnValue, None], None, ),  # 9
    (10, TType.BOOL, 'is_min_max_value_present', None, None, ),  # 10
    (11, TType.BOOL, 'is_column_in_data_file', None, None, ),  # 11
)
all_structs.append(TRuntimeFilterDesc)
TRuntimeFilterDesc.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'filter_id', None, None, ),  # 1
    (2, TType.STRUCT, 'src_expr', [Exprs.ttypes.TExpr, None], None, ),  # 2
    (3, TType.LIST, 'targets', (TType.STRUCT, [TRuntimeFilterTargetDesc, None], False), None, ),  # 3
    (4, TType.MAP, 'planid_to_target_ndx', (TType.I32, None, TType.I32, None, False), None, ),  # 4
    (5, TType.BOOL, 'is_broadcast_join', None, None, ),  # 5
    (6, TType.BOOL, 'has_local_targets', None, None, ),  # 6
    (7, TType.BOOL, 'has_remote_targets', None, None, ),  # 7
    (8, TType.BOOL, 'applied_on_partition_columns', None, None, ),  # 8
    (9, TType.I64, 'ndv_estimate', None, None, ),  # 9
    (10, TType.I32, 'type', None, None, ),  # 10
    (11, TType.I32, 'compareOp', None, None, ),  # 11
    (12, TType.I64, 'filter_size_bytes', None, None, ),  # 12
    (13, TType.I32, 'src_node_id', None, None, ),  # 13
)
all_structs.append(THdfsFileSplit)
THdfsFileSplit.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'relative_path', None, None, ),  # 1
    (2, TType.I64, 'offset', None, None, ),  # 2
    (3, TType.I64, 'length', None, None, ),  # 3
    (4, TType.I64, 'partition_id', None, None, ),  # 4
    (5, TType.I64, 'file_length', None, None, ),  # 5
    (6, TType.I32, 'file_compression', None, None, ),  # 6
    (7, TType.I64, 'mtime', None, None, ),  # 7
    (8, TType.BOOL, 'is_erasure_coded', None, None, ),  # 8
    (9, TType.I32, 'partition_path_hash', None, None, ),  # 9
    (10, TType.STRING, 'absolute_path', None, None, ),  # 10
    (11, TType.BOOL, 'is_encrypted', None, None, ),  # 11
)
all_structs.append(THBaseKeyRange)
THBaseKeyRange.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'startKey', None, None, ),  # 1
    (2, TType.STRING, 'stopKey', None, None, ),  # 2
)
all_structs.append(TFileSplitGeneratorSpec)
TFileSplitGeneratorSpec.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'file_desc', [CatalogObjects.ttypes.THdfsFileDesc, None], None, ),  # 1
    (2, TType.I64, 'max_block_size', None, None, ),  # 2
    (3, TType.BOOL, 'is_splittable', None, None, ),  # 3
    (4, TType.I64, 'partition_id', None, None, ),  # 4
    (5, TType.I32, 'partition_path_hash', None, None, ),  # 5
    (6, TType.BOOL, 'is_footer_only', None, None, ),  # 6
)
all_structs.append(TScanRange)
TScanRange.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hdfs_file_split', [THdfsFileSplit, None], None, ),  # 1
    (2, TType.STRUCT, 'hbase_key_range', [THBaseKeyRange, None], None, ),  # 2
    (3, TType.STRING, 'kudu_scan_token', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'file_metadata', 'BINARY', None, ),  # 4
    (5, TType.BOOL, 'is_system_scan', None, None, ),  # 5
)
all_structs.append(TOverlapPredicateDesc)
TOverlapPredicateDesc.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'filter_id', None, None, ),  # 1
    (2, TType.I32, 'slot_index', None, None, ),  # 2
)
all_structs.append(THdfsScanNode)
THdfsScanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.MAP, 'collection_conjuncts', (TType.I32, None, TType.LIST, (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), False), None, ),  # 2
    (3, TType.I32, 'replica_preference', None, None, ),  # 3
    (4, TType.BOOL, 'random_replica', None, None, ),  # 4
    (5, TType.I32, 'skip_header_line_count', None, None, ),  # 5
    (6, TType.BOOL, 'use_mt_scan_node', None, None, ),  # 6
    (7, TType.LIST, 'stats_conjuncts', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 7
    (8, TType.I32, 'stats_tuple_id', None, None, ),  # 8
    (9, TType.MAP, 'dictionary_filter_conjuncts', (TType.I32, None, TType.LIST, (TType.I32, None, False), False), None, ),  # 9
    (10, TType.I32, 'count_star_slot_offset', None, None, ),  # 10
    (11, TType.BOOL, 'is_partition_key_scan', None, None, ),  # 11
    (12, TType.SET, 'file_formats', (TType.I32, None, False), None, ),  # 12
    (13, TType.LIST, 'overlap_predicate_descs', (TType.STRUCT, [TOverlapPredicateDesc, None], False), None, ),  # 13
    (14, TType.I32, 'deleteFileScanNodeId', None, None, ),  # 14
    (15, TType.BOOL, 'deterministic_scanrange_assignment', None, None, ),  # 15
)
all_structs.append(TDataSourceScanNode)
TDataSourceScanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.STRUCT, 'data_source', [CatalogObjects.ttypes.TDataSource, None], None, ),  # 2
    (3, TType.STRING, 'init_string', None, None, ),  # 3
    (4, TType.LIST, 'accepted_predicates', (TType.LIST, (TType.STRUCT, [ExternalDataSource.ttypes.TBinaryPredicate, None], False), False), None, ),  # 4
)
all_structs.append(THBaseFilter)
THBaseFilter.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'family', None, None, ),  # 1
    (2, TType.STRING, 'qualifier', None, None, ),  # 2
    (3, TType.I32, 'op_ordinal', None, None, ),  # 3
    (4, TType.STRING, 'filter_constant', None, None, ),  # 4
)
all_structs.append(THBaseScanNode)
THBaseScanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.LIST, 'filters', (TType.STRUCT, [THBaseFilter, None], False), None, ),  # 3
    (4, TType.I32, 'suggested_max_caching', None, None, ),  # 4
)
all_structs.append(TKuduScanNode)
TKuduScanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.BOOL, 'use_mt_scan_node', None, None, ),  # 2
    (3, TType.I32, 'count_star_slot_offset', None, None, ),  # 3
)
all_structs.append(TSystemTableScanNode)
TSystemTableScanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.I32, 'table_name', None, None, ),  # 2
)
all_structs.append(TEqJoinCondition)
TEqJoinCondition.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'left', [Exprs.ttypes.TExpr, None], None, ),  # 1
    (2, TType.STRUCT, 'right', [Exprs.ttypes.TExpr, None], None, ),  # 2
    (3, TType.BOOL, 'is_not_distinct_from', None, None, ),  # 3
)
all_structs.append(THashJoinNode)
THashJoinNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'eq_join_conjuncts', (TType.STRUCT, [TEqJoinCondition, None], False), None, ),  # 1
    (2, TType.LIST, 'other_join_conjuncts', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 2
    (3, TType.I32, 'hash_seed', None, None, ),  # 3
)
all_structs.append(TNestedLoopJoinNode)
TNestedLoopJoinNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'join_conjuncts', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
)
all_structs.append(TIcebergDeleteNode)
TIcebergDeleteNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'eq_join_conjuncts', (TType.STRUCT, [TEqJoinCondition, None], False), None, ),  # 1
)
all_structs.append(TJoinNode)
TJoinNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'join_op', None, None, ),  # 1
    (2, TType.LIST, 'build_tuples', (TType.I32, None, False), None, ),  # 2
    (3, TType.LIST, 'nullable_build_tuples', (TType.BOOL, None, False), None, ),  # 3
    (4, TType.STRUCT, 'hash_join_node', [THashJoinNode, None], None, ),  # 4
    (5, TType.STRUCT, 'nested_loop_join_node', [TNestedLoopJoinNode, None], None, ),  # 5
    (6, TType.STRUCT, 'iceberg_delete_node', [TIcebergDeleteNode, None], None, ),  # 6
)
all_structs.append(TAggregator)
TAggregator.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'grouping_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
    (2, TType.LIST, 'aggregate_functions', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 2
    (3, TType.I32, 'intermediate_tuple_id', None, None, ),  # 3
    (4, TType.I32, 'output_tuple_id', None, None, ),  # 4
    (5, TType.BOOL, 'need_finalize', None, None, ),  # 5
    (6, TType.BOOL, 'use_streaming_preaggregation', None, None, ),  # 6
    (7, TType.STRUCT, 'resource_profile', [ResourceProfile.ttypes.TBackendResourceProfile, None], None, ),  # 7
)
all_structs.append(TAggregationNode)
TAggregationNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'aggregators', (TType.STRUCT, [TAggregator, None], False), None, ),  # 1
    (2, TType.I64, 'estimated_input_cardinality', None, None, ),  # 2
    (3, TType.BOOL, 'replicate_input', None, None, ),  # 3
    (4, TType.BOOL, 'fast_limit_check', None, None, ),  # 4
)
all_structs.append(TSortInfo)
TSortInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'ordering_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
    (2, TType.LIST, 'is_asc_order', (TType.BOOL, None, False), None, ),  # 2
    (3, TType.LIST, 'nulls_first', (TType.BOOL, None, False), None, ),  # 3
    (4, TType.LIST, 'sort_tuple_slot_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 4
    (5, TType.I32, 'sorting_order', None, None, ),  # 5
    (6, TType.I32, 'num_lexical_keys_in_zorder', None, None, ),  # 6
)
all_structs.append(TSortNode)
TSortNode.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'sort_info', [TSortInfo, None], None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
    (4, TType.I64, 'estimated_full_input_size', None, None, ),  # 4
    (5, TType.BOOL, 'include_ties', None, None, ),  # 5
    (6, TType.I64, 'limit_with_ties', None, None, ),  # 6
    (7, TType.I64, 'per_partition_limit', None, None, ),  # 7
    (8, TType.LIST, 'partition_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 8
    (9, TType.STRUCT, 'intra_partition_sort_info', [TSortInfo, None], None, ),  # 9
)
all_structs.append(TAnalyticWindowBoundary)
TAnalyticWindowBoundary.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'range_offset_predicate', [Exprs.ttypes.TExpr, None], None, ),  # 2
    (3, TType.I64, 'rows_offset_value', None, None, ),  # 3
)
all_structs.append(TAnalyticWindow)
TAnalyticWindow.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'window_start', [TAnalyticWindowBoundary, None], None, ),  # 2
    (3, TType.STRUCT, 'window_end', [TAnalyticWindowBoundary, None], None, ),  # 3
)
all_structs.append(TAnalyticNode)
TAnalyticNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partition_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
    (2, TType.LIST, 'order_by_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 2
    (3, TType.LIST, 'analytic_functions', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 3
    (4, TType.STRUCT, 'window', [TAnalyticWindow, None], None, ),  # 4
    (5, TType.I32, 'intermediate_tuple_id', None, None, ),  # 5
    (6, TType.I32, 'output_tuple_id', None, None, ),  # 6
    (7, TType.I32, 'buffered_tuple_id', None, None, ),  # 7
    (8, TType.STRUCT, 'partition_by_eq', [Exprs.ttypes.TExpr, None], None, ),  # 8
    (9, TType.STRUCT, 'order_by_eq', [Exprs.ttypes.TExpr, None], None, ),  # 9
)
all_structs.append(TUnionNode)
TUnionNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.LIST, 'result_expr_lists', (TType.LIST, (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), False), None, ),  # 2
    (3, TType.LIST, 'const_expr_lists', (TType.LIST, (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), False), None, ),  # 3
    (4, TType.I64, 'first_materialized_child_idx', None, None, ),  # 4
)
all_structs.append(TExchangeNode)
TExchangeNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'input_row_tuples', (TType.I32, None, False), None, ),  # 1
    (2, TType.STRUCT, 'sort_info', [TSortInfo, None], None, ),  # 2
    (3, TType.I64, 'offset', None, None, ),  # 3
)
all_structs.append(TUnnestNode)
TUnnestNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'collection_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
)
all_structs.append(TCardinalityCheckNode)
TCardinalityCheckNode.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'display_statement', None, None, ),  # 1
)
all_structs.append(TIcebergMetadataScanNode)
TIcebergMetadataScanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'tuple_id', None, None, ),  # 1
    (2, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
    (3, TType.STRING, 'metadata_table_name', None, None, ),  # 3
)
all_structs.append(TTupleCacheNode)
TTupleCacheNode.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'compile_time_key', None, None, ),  # 1
    (2, TType.LIST, 'input_scan_node_ids', (TType.I32, None, False), None, ),  # 2
)
all_structs.append(TIcebergMergeCase)
TIcebergMergeCase.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'output_expressions', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
    (2, TType.LIST, 'filter_conjuncts', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
    (4, TType.I32, 'match_type', None, None, ),  # 4
)
all_structs.append(TIcebergMergeNode)
TIcebergMergeNode.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'cases', (TType.STRUCT, [TIcebergMergeCase, None], False), None, ),  # 1
    (2, TType.STRUCT, 'row_present', [Exprs.ttypes.TExpr, None], None, ),  # 2
    (3, TType.LIST, 'position_meta_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 3
    (4, TType.LIST, 'partition_meta_exprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 4
    (5, TType.I32, 'merge_action_tuple_id', None, None, ),  # 5
    (6, TType.I32, 'target_tuple_id', None, None, ),  # 6
)
all_structs.append(TPipelineMembership)
TPipelineMembership.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'pipe_id', None, None, ),  # 1
    (2, TType.I32, 'height', None, None, ),  # 2
    (3, TType.I32, 'phase', None, None, ),  # 3
)
all_structs.append(TPlanNode)
TPlanNode.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'node_type', None, None, ),  # 2
    (3, TType.I32, 'num_children', None, None, ),  # 3
    (4, TType.I64, 'limit', None, None, ),  # 4
    (5, TType.LIST, 'row_tuples', (TType.I32, None, False), None, ),  # 5
    (6, TType.LIST, 'nullable_tuples', (TType.BOOL, None, False), None, ),  # 6
    (7, TType.LIST, 'conjuncts', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 7
    (8, TType.BOOL, 'disable_codegen', None, None, ),  # 8
    (9, TType.LIST, 'pipelines', (TType.STRUCT, [TPipelineMembership, None], False), None, ),  # 9
    (10, TType.STRUCT, 'hdfs_scan_node', [THdfsScanNode, None], None, ),  # 10
    (11, TType.STRUCT, 'hbase_scan_node', [THBaseScanNode, None], None, ),  # 11
    (12, TType.STRUCT, 'kudu_scan_node', [TKuduScanNode, None], None, ),  # 12
    (13, TType.STRUCT, 'data_source_node', [TDataSourceScanNode, None], None, ),  # 13
    (14, TType.STRUCT, 'join_node', [TJoinNode, None], None, ),  # 14
    (15, TType.STRUCT, 'agg_node', [TAggregationNode, None], None, ),  # 15
    (16, TType.STRUCT, 'sort_node', [TSortNode, None], None, ),  # 16
    (17, TType.STRUCT, 'union_node', [TUnionNode, None], None, ),  # 17
    (18, TType.STRUCT, 'exchange_node', [TExchangeNode, None], None, ),  # 18
    (19, TType.STRUCT, 'analytic_node', [TAnalyticNode, None], None, ),  # 19
    (20, TType.STRUCT, 'unnest_node', [TUnnestNode, None], None, ),  # 20
    (21, TType.STRUCT, 'iceberg_scan_metadata_node', [TIcebergMetadataScanNode, None], None, ),  # 21
    (22, TType.STRING, 'label', None, None, ),  # 22
    (23, TType.STRING, 'label_detail', None, None, ),  # 23
    (24, TType.STRUCT, 'estimated_stats', [ExecStats.ttypes.TExecStats, None], None, ),  # 24
    (25, TType.LIST, 'runtime_filters', (TType.STRUCT, [TRuntimeFilterDesc, None], False), None, ),  # 25
    (26, TType.STRUCT, 'resource_profile', [ResourceProfile.ttypes.TBackendResourceProfile, None], None, ),  # 26
    (27, TType.STRUCT, 'cardinality_check_node', [TCardinalityCheckNode, None], None, ),  # 27
    (28, TType.STRUCT, 'tuple_cache_node', [TTupleCacheNode, None], None, ),  # 28
    (29, TType.STRUCT, 'system_table_scan_node', [TSystemTableScanNode, None], None, ),  # 29
    (30, TType.STRUCT, 'merge_node', [TIcebergMergeNode, None], None, ),  # 30
)
all_structs.append(TPlan)
TPlan.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'nodes', (TType.STRUCT, [TPlanNode, None], False), None, ),  # 1
)
fix_spec(all_structs)
del all_structs
