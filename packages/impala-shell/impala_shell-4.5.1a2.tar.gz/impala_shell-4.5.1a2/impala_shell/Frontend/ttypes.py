#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:no_utf8strings
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import Types.ttypes
import RuntimeProfile.ttypes
import Descriptors.ttypes
import Data.ttypes
import Results.ttypes
import TCLIService.ttypes
import Status.ttypes
import CatalogObjects.ttypes
import CatalogService.ttypes
import LineageGraph.ttypes
import Query.ttypes

from thrift.transport import TTransport
all_structs = []


class TDescribeOutputStyle(object):
    MINIMAL = 0
    EXTENDED = 1
    FORMATTED = 2

    _VALUES_TO_NAMES = {
        0: "MINIMAL",
        1: "EXTENDED",
        2: "FORMATTED",
    }

    _NAMES_TO_VALUES = {
        "MINIMAL": 0,
        "EXTENDED": 1,
        "FORMATTED": 2,
    }


class TShowStatsOp(object):
    TABLE_STATS = 0
    COLUMN_STATS = 1
    PARTITIONS = 2
    RANGE_PARTITIONS = 3
    HASH_SCHEMA = 4

    _VALUES_TO_NAMES = {
        0: "TABLE_STATS",
        1: "COLUMN_STATS",
        2: "PARTITIONS",
        3: "RANGE_PARTITIONS",
        4: "HASH_SCHEMA",
    }

    _NAMES_TO_VALUES = {
        "TABLE_STATS": 0,
        "COLUMN_STATS": 1,
        "PARTITIONS": 2,
        "RANGE_PARTITIONS": 3,
        "HASH_SCHEMA": 4,
    }


class TCatalogOpType(object):
    SHOW_TABLES = 0
    SHOW_DBS = 1
    SHOW_STATS = 2
    USE = 3
    DESCRIBE_TABLE = 4
    DESCRIBE_DB = 5
    SHOW_FUNCTIONS = 6
    RESET_METADATA = 7
    DDL = 8
    SHOW_CREATE_TABLE = 9
    SHOW_DATA_SRCS = 10
    SHOW_ROLES = 11
    SHOW_GRANT_PRINCIPAL = 12
    SHOW_FILES = 13
    SHOW_CREATE_FUNCTION = 14
    DESCRIBE_HISTORY = 15
    SHOW_VIEWS = 16
    SHOW_METADATA_TABLES = 17

    _VALUES_TO_NAMES = {
        0: "SHOW_TABLES",
        1: "SHOW_DBS",
        2: "SHOW_STATS",
        3: "USE",
        4: "DESCRIBE_TABLE",
        5: "DESCRIBE_DB",
        6: "SHOW_FUNCTIONS",
        7: "RESET_METADATA",
        8: "DDL",
        9: "SHOW_CREATE_TABLE",
        10: "SHOW_DATA_SRCS",
        11: "SHOW_ROLES",
        12: "SHOW_GRANT_PRINCIPAL",
        13: "SHOW_FILES",
        14: "SHOW_CREATE_FUNCTION",
        15: "DESCRIBE_HISTORY",
        16: "SHOW_VIEWS",
        17: "SHOW_METADATA_TABLES",
    }

    _NAMES_TO_VALUES = {
        "SHOW_TABLES": 0,
        "SHOW_DBS": 1,
        "SHOW_STATS": 2,
        "USE": 3,
        "DESCRIBE_TABLE": 4,
        "DESCRIBE_DB": 5,
        "SHOW_FUNCTIONS": 6,
        "RESET_METADATA": 7,
        "DDL": 8,
        "SHOW_CREATE_TABLE": 9,
        "SHOW_DATA_SRCS": 10,
        "SHOW_ROLES": 11,
        "SHOW_GRANT_PRINCIPAL": 12,
        "SHOW_FILES": 13,
        "SHOW_CREATE_FUNCTION": 14,
        "DESCRIBE_HISTORY": 15,
        "SHOW_VIEWS": 16,
        "SHOW_METADATA_TABLES": 17,
    }


class TQueryOptionType(object):
    SET_ONE = 0
    SET_ALL = 1
    UNSET_ALL = 2

    _VALUES_TO_NAMES = {
        0: "SET_ONE",
        1: "SET_ALL",
        2: "UNSET_ALL",
    }

    _NAMES_TO_VALUES = {
        "SET_ONE": 0,
        "SET_ALL": 1,
        "UNSET_ALL": 2,
    }


class TAdminRequestType(object):
    SHUTDOWN = 0
    EVENT_PROCESSOR = 1

    _VALUES_TO_NAMES = {
        0: "SHUTDOWN",
        1: "EVENT_PROCESSOR",
    }

    _NAMES_TO_VALUES = {
        "SHUTDOWN": 0,
        "EVENT_PROCESSOR": 1,
    }


class TMetadataOpcode(object):
    GET_TYPE_INFO = 0
    GET_CATALOGS = 1
    GET_SCHEMAS = 2
    GET_TABLES = 3
    GET_TABLE_TYPES = 4
    GET_COLUMNS = 5
    GET_FUNCTIONS = 6
    GET_PRIMARY_KEYS = 7
    GET_CROSS_REFERENCE = 8

    _VALUES_TO_NAMES = {
        0: "GET_TYPE_INFO",
        1: "GET_CATALOGS",
        2: "GET_SCHEMAS",
        3: "GET_TABLES",
        4: "GET_TABLE_TYPES",
        5: "GET_COLUMNS",
        6: "GET_FUNCTIONS",
        7: "GET_PRIMARY_KEYS",
        8: "GET_CROSS_REFERENCE",
    }

    _NAMES_TO_VALUES = {
        "GET_TYPE_INFO": 0,
        "GET_CATALOGS": 1,
        "GET_SCHEMAS": 2,
        "GET_TABLES": 3,
        "GET_TABLE_TYPES": 4,
        "GET_COLUMNS": 5,
        "GET_FUNCTIONS": 6,
        "GET_PRIMARY_KEYS": 7,
        "GET_CROSS_REFERENCE": 8,
    }


class TSymbolType(object):
    UDF_EVALUATE = 0
    UDF_PREPARE = 1
    UDF_CLOSE = 2

    _VALUES_TO_NAMES = {
        0: "UDF_EVALUATE",
        1: "UDF_PREPARE",
        2: "UDF_CLOSE",
    }

    _NAMES_TO_VALUES = {
        "UDF_EVALUATE": 0,
        "UDF_PREPARE": 1,
        "UDF_CLOSE": 2,
    }


class TSymbolLookupResultCode(object):
    SYMBOL_FOUND = 0
    BINARY_NOT_FOUND = 1
    SYMBOL_NOT_FOUND = 2

    _VALUES_TO_NAMES = {
        0: "SYMBOL_FOUND",
        1: "BINARY_NOT_FOUND",
        2: "SYMBOL_NOT_FOUND",
    }

    _NAMES_TO_VALUES = {
        "SYMBOL_FOUND": 0,
        "BINARY_NOT_FOUND": 1,
        "SYMBOL_NOT_FOUND": 2,
    }


class THiveUdfExecutorCtorParams(object):
    """
    Attributes:
     - fn
     - local_location
     - input_byte_offsets
     - input_nulls_ptr
     - input_buffer_ptr
     - output_null_ptr
     - output_buffer_ptr

    """


    def __init__(self, fn=None, local_location=None, input_byte_offsets=None, input_nulls_ptr=None, input_buffer_ptr=None, output_null_ptr=None, output_buffer_ptr=None,):
        self.fn = fn
        self.local_location = local_location
        self.input_byte_offsets = input_byte_offsets
        self.input_nulls_ptr = input_nulls_ptr
        self.input_buffer_ptr = input_buffer_ptr
        self.output_null_ptr = output_null_ptr
        self.output_buffer_ptr = output_buffer_ptr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fn = Types.ttypes.TFunction()
                    self.fn.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.local_location = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.input_byte_offsets = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readI32()
                        self.input_byte_offsets.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.input_nulls_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.input_buffer_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.output_null_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.output_buffer_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THiveUdfExecutorCtorParams')
        if self.fn is not None:
            oprot.writeFieldBegin('fn', TType.STRUCT, 1)
            self.fn.write(oprot)
            oprot.writeFieldEnd()
        if self.local_location is not None:
            oprot.writeFieldBegin('local_location', TType.STRING, 2)
            oprot.writeString(self.local_location)
            oprot.writeFieldEnd()
        if self.input_byte_offsets is not None:
            oprot.writeFieldBegin('input_byte_offsets', TType.LIST, 3)
            oprot.writeListBegin(TType.I32, len(self.input_byte_offsets))
            for iter6 in self.input_byte_offsets:
                oprot.writeI32(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.input_nulls_ptr is not None:
            oprot.writeFieldBegin('input_nulls_ptr', TType.I64, 4)
            oprot.writeI64(self.input_nulls_ptr)
            oprot.writeFieldEnd()
        if self.input_buffer_ptr is not None:
            oprot.writeFieldBegin('input_buffer_ptr', TType.I64, 5)
            oprot.writeI64(self.input_buffer_ptr)
            oprot.writeFieldEnd()
        if self.output_null_ptr is not None:
            oprot.writeFieldBegin('output_null_ptr', TType.I64, 6)
            oprot.writeI64(self.output_null_ptr)
            oprot.writeFieldEnd()
        if self.output_buffer_ptr is not None:
            oprot.writeFieldBegin('output_buffer_ptr', TType.I64, 7)
            oprot.writeI64(self.output_buffer_ptr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fn is None:
            raise TProtocolException(message='Required field fn is unset!')
        if self.local_location is None:
            raise TProtocolException(message='Required field local_location is unset!')
        if self.input_byte_offsets is None:
            raise TProtocolException(message='Required field input_byte_offsets is unset!')
        if self.input_nulls_ptr is None:
            raise TProtocolException(message='Required field input_nulls_ptr is unset!')
        if self.input_buffer_ptr is None:
            raise TProtocolException(message='Required field input_buffer_ptr is unset!')
        if self.output_null_ptr is None:
            raise TProtocolException(message='Required field output_null_ptr is unset!')
        if self.output_buffer_ptr is None:
            raise TProtocolException(message='Required field output_buffer_ptr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTablesParams(object):
    """
    Attributes:
     - db
     - pattern
     - session
     - table_types

    """


    def __init__(self, db=None, pattern=None, session=None, table_types=set((
    )),):
        self.db = db
        self.pattern = pattern
        self.session = session
        if table_types is self.thrift_spec[4][4]:
            table_types = set((
            ))
        self.table_types = table_types

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.session = Query.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.table_types = set()
                    (_etype10, _size7) = iprot.readSetBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readI32()
                        self.table_types.add(_elem12)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTablesParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 2)
            oprot.writeString(self.pattern)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 3)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        if self.table_types is not None:
            oprot.writeFieldBegin('table_types', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.table_types))
            for iter13 in self.table_types:
                oprot.writeI32(iter13)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetMetadataTablesParams(object):
    """
    Attributes:
     - db
     - tbl
     - pattern
     - session

    """


    def __init__(self, db=None, tbl=None, pattern=None, session=None,):
        self.db = db
        self.tbl = tbl
        self.pattern = pattern
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.session = Query.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetMetadataTablesParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        if self.tbl is not None:
            oprot.writeFieldBegin('tbl', TType.STRING, 2)
            oprot.writeString(self.tbl)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 3)
            oprot.writeString(self.pattern)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 4)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        if self.tbl is None:
            raise TProtocolException(message='Required field tbl is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTablesResult(object):
    """
    Attributes:
     - tables

    """


    def __init__(self, tables=None,):
        self.tables = tables

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.tables = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readString()
                        self.tables.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTablesResult')
        if self.tables is not None:
            oprot.writeFieldBegin('tables', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.tables))
            for iter20 in self.tables:
                oprot.writeString(iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTableMetricsParams(object):
    """
    Attributes:
     - table_name

    """


    def __init__(self, table_name=None,):
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTableMetricsParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTableMetricsResponse(object):
    """
    Attributes:
     - metrics

    """


    def __init__(self, metrics=None,):
        self.metrics = metrics

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.metrics = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTableMetricsResponse')
        if self.metrics is not None:
            oprot.writeFieldBegin('metrics', TType.STRING, 1)
            oprot.writeString(self.metrics)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.metrics is None:
            raise TProtocolException(message='Required field metrics is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetCatalogMetricsResult(object):
    """
    Attributes:
     - num_dbs
     - num_tables
     - cache_eviction_count
     - cache_hit_count
     - cache_load_count
     - cache_load_exception_count
     - cache_load_success_count
     - cache_miss_count
     - cache_request_count
     - cache_total_load_time
     - cache_avg_load_time
     - cache_hit_rate
     - cache_load_exception_rate
     - cache_miss_rate
     - cache_entry_median_size
     - cache_entry_99th_size

    """


    def __init__(self, num_dbs=None, num_tables=None, cache_eviction_count=None, cache_hit_count=None, cache_load_count=None, cache_load_exception_count=None, cache_load_success_count=None, cache_miss_count=None, cache_request_count=None, cache_total_load_time=None, cache_avg_load_time=None, cache_hit_rate=None, cache_load_exception_rate=None, cache_miss_rate=None, cache_entry_median_size=None, cache_entry_99th_size=None,):
        self.num_dbs = num_dbs
        self.num_tables = num_tables
        self.cache_eviction_count = cache_eviction_count
        self.cache_hit_count = cache_hit_count
        self.cache_load_count = cache_load_count
        self.cache_load_exception_count = cache_load_exception_count
        self.cache_load_success_count = cache_load_success_count
        self.cache_miss_count = cache_miss_count
        self.cache_request_count = cache_request_count
        self.cache_total_load_time = cache_total_load_time
        self.cache_avg_load_time = cache_avg_load_time
        self.cache_hit_rate = cache_hit_rate
        self.cache_load_exception_rate = cache_load_exception_rate
        self.cache_miss_rate = cache_miss_rate
        self.cache_entry_median_size = cache_entry_median_size
        self.cache_entry_99th_size = cache_entry_99th_size

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num_dbs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_tables = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.cache_eviction_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.cache_hit_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.cache_load_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.cache_load_exception_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.cache_load_success_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.cache_miss_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.cache_request_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.cache_total_load_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.cache_avg_load_time = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.DOUBLE:
                    self.cache_hit_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.DOUBLE:
                    self.cache_load_exception_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.DOUBLE:
                    self.cache_miss_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.DOUBLE:
                    self.cache_entry_median_size = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.DOUBLE:
                    self.cache_entry_99th_size = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetCatalogMetricsResult')
        if self.num_dbs is not None:
            oprot.writeFieldBegin('num_dbs', TType.I32, 1)
            oprot.writeI32(self.num_dbs)
            oprot.writeFieldEnd()
        if self.num_tables is not None:
            oprot.writeFieldBegin('num_tables', TType.I32, 2)
            oprot.writeI32(self.num_tables)
            oprot.writeFieldEnd()
        if self.cache_eviction_count is not None:
            oprot.writeFieldBegin('cache_eviction_count', TType.I64, 3)
            oprot.writeI64(self.cache_eviction_count)
            oprot.writeFieldEnd()
        if self.cache_hit_count is not None:
            oprot.writeFieldBegin('cache_hit_count', TType.I64, 4)
            oprot.writeI64(self.cache_hit_count)
            oprot.writeFieldEnd()
        if self.cache_load_count is not None:
            oprot.writeFieldBegin('cache_load_count', TType.I64, 5)
            oprot.writeI64(self.cache_load_count)
            oprot.writeFieldEnd()
        if self.cache_load_exception_count is not None:
            oprot.writeFieldBegin('cache_load_exception_count', TType.I64, 6)
            oprot.writeI64(self.cache_load_exception_count)
            oprot.writeFieldEnd()
        if self.cache_load_success_count is not None:
            oprot.writeFieldBegin('cache_load_success_count', TType.I64, 7)
            oprot.writeI64(self.cache_load_success_count)
            oprot.writeFieldEnd()
        if self.cache_miss_count is not None:
            oprot.writeFieldBegin('cache_miss_count', TType.I64, 8)
            oprot.writeI64(self.cache_miss_count)
            oprot.writeFieldEnd()
        if self.cache_request_count is not None:
            oprot.writeFieldBegin('cache_request_count', TType.I64, 9)
            oprot.writeI64(self.cache_request_count)
            oprot.writeFieldEnd()
        if self.cache_total_load_time is not None:
            oprot.writeFieldBegin('cache_total_load_time', TType.I64, 10)
            oprot.writeI64(self.cache_total_load_time)
            oprot.writeFieldEnd()
        if self.cache_avg_load_time is not None:
            oprot.writeFieldBegin('cache_avg_load_time', TType.DOUBLE, 11)
            oprot.writeDouble(self.cache_avg_load_time)
            oprot.writeFieldEnd()
        if self.cache_hit_rate is not None:
            oprot.writeFieldBegin('cache_hit_rate', TType.DOUBLE, 12)
            oprot.writeDouble(self.cache_hit_rate)
            oprot.writeFieldEnd()
        if self.cache_load_exception_rate is not None:
            oprot.writeFieldBegin('cache_load_exception_rate', TType.DOUBLE, 13)
            oprot.writeDouble(self.cache_load_exception_rate)
            oprot.writeFieldEnd()
        if self.cache_miss_rate is not None:
            oprot.writeFieldBegin('cache_miss_rate', TType.DOUBLE, 14)
            oprot.writeDouble(self.cache_miss_rate)
            oprot.writeFieldEnd()
        if self.cache_entry_median_size is not None:
            oprot.writeFieldBegin('cache_entry_median_size', TType.DOUBLE, 15)
            oprot.writeDouble(self.cache_entry_median_size)
            oprot.writeFieldEnd()
        if self.cache_entry_99th_size is not None:
            oprot.writeFieldBegin('cache_entry_99th_size', TType.DOUBLE, 16)
            oprot.writeDouble(self.cache_entry_99th_size)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_dbs is None:
            raise TProtocolException(message='Required field num_dbs is unset!')
        if self.num_tables is None:
            raise TProtocolException(message='Required field num_tables is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDbsParams(object):
    """
    Attributes:
     - pattern
     - session

    """


    def __init__(self, pattern=None, session=None,):
        self.pattern = pattern
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.session = Query.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDbsParams')
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 1)
            oprot.writeString(self.pattern)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 2)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDbsResult(object):
    """
    Attributes:
     - dbs

    """


    def __init__(self, dbs=None,):
        self.dbs = dbs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.dbs = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = CatalogObjects.ttypes.TDatabase()
                        _elem26.read(iprot)
                        self.dbs.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDbsResult')
        if self.dbs is not None:
            oprot.writeFieldBegin('dbs', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.dbs))
            for iter27 in self.dbs:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataSrcsParams(object):
    """
    Attributes:
     - pattern

    """


    def __init__(self, pattern=None,):
        self.pattern = pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataSrcsParams')
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 1)
            oprot.writeString(self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetDataSrcsResult(object):
    """
    Attributes:
     - data_src_names
     - locations
     - class_names
     - api_versions

    """


    def __init__(self, data_src_names=None, locations=None, class_names=None, api_versions=None,):
        self.data_src_names = data_src_names
        self.locations = locations
        self.class_names = class_names
        self.api_versions = api_versions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.data_src_names = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readString()
                        self.data_src_names.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.locations = []
                    (_etype37, _size34) = iprot.readListBegin()
                    for _i38 in range(_size34):
                        _elem39 = iprot.readString()
                        self.locations.append(_elem39)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.class_names = []
                    (_etype43, _size40) = iprot.readListBegin()
                    for _i44 in range(_size40):
                        _elem45 = iprot.readString()
                        self.class_names.append(_elem45)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.api_versions = []
                    (_etype49, _size46) = iprot.readListBegin()
                    for _i50 in range(_size46):
                        _elem51 = iprot.readString()
                        self.api_versions.append(_elem51)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetDataSrcsResult')
        if self.data_src_names is not None:
            oprot.writeFieldBegin('data_src_names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.data_src_names))
            for iter52 in self.data_src_names:
                oprot.writeString(iter52)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.locations is not None:
            oprot.writeFieldBegin('locations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.locations))
            for iter53 in self.locations:
                oprot.writeString(iter53)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.class_names is not None:
            oprot.writeFieldBegin('class_names', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.class_names))
            for iter54 in self.class_names:
                oprot.writeString(iter54)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.api_versions is not None:
            oprot.writeFieldBegin('api_versions', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.api_versions))
            for iter55 in self.api_versions:
                oprot.writeString(iter55)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.data_src_names is None:
            raise TProtocolException(message='Required field data_src_names is unset!')
        if self.locations is None:
            raise TProtocolException(message='Required field locations is unset!')
        if self.class_names is None:
            raise TProtocolException(message='Required field class_names is unset!')
        if self.api_versions is None:
            raise TProtocolException(message='Required field api_versions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDescribeDbParams(object):
    """
    Attributes:
     - db
     - output_style

    """


    def __init__(self, db=None, output_style=None,):
        self.db = db
        self.output_style = output_style

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.output_style = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDescribeDbParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        if self.output_style is not None:
            oprot.writeFieldBegin('output_style', TType.I32, 2)
            oprot.writeI32(self.output_style)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        if self.output_style is None:
            raise TProtocolException(message='Required field output_style is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDescribeTableParams(object):
    """
    Attributes:
     - output_style
     - table_name
     - metadata_table_name
     - result_struct
     - session

    """


    def __init__(self, output_style=None, table_name=None, metadata_table_name=None, result_struct=None, session=None,):
        self.output_style = output_style
        self.table_name = table_name
        self.metadata_table_name = metadata_table_name
        self.result_struct = result_struct
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.output_style = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.metadata_table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.result_struct = Types.ttypes.TColumnType()
                    self.result_struct.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.session = Query.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDescribeTableParams')
        if self.output_style is not None:
            oprot.writeFieldBegin('output_style', TType.I32, 1)
            oprot.writeI32(self.output_style)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.metadata_table_name is not None:
            oprot.writeFieldBegin('metadata_table_name', TType.STRING, 3)
            oprot.writeString(self.metadata_table_name)
            oprot.writeFieldEnd()
        if self.result_struct is not None:
            oprot.writeFieldBegin('result_struct', TType.STRUCT, 4)
            self.result_struct.write(oprot)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 5)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.output_style is None:
            raise TProtocolException(message='Required field output_style is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDescribeResult(object):
    """
    Attributes:
     - results

    """


    def __init__(self, results=None,):
        self.results = results

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.results = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = Data.ttypes.TResultRow()
                        _elem61.read(iprot)
                        self.results.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDescribeResult')
        if self.results is not None:
            oprot.writeFieldBegin('results', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.results))
            for iter62 in self.results:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.results is None:
            raise TProtocolException(message='Required field results is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowDataSrcsParams(object):
    """
    Attributes:
     - show_pattern

    """


    def __init__(self, show_pattern=None,):
        self.show_pattern = show_pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.show_pattern = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowDataSrcsParams')
        if self.show_pattern is not None:
            oprot.writeFieldBegin('show_pattern', TType.STRING, 1)
            oprot.writeString(self.show_pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowDbsParams(object):
    """
    Attributes:
     - show_pattern

    """


    def __init__(self, show_pattern=None,):
        self.show_pattern = show_pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.show_pattern = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowDbsParams')
        if self.show_pattern is not None:
            oprot.writeFieldBegin('show_pattern', TType.STRING, 1)
            oprot.writeString(self.show_pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowStatsParams(object):
    """
    Attributes:
     - op
     - table_name
     - show_column_minmax_stats

    """


    def __init__(self, op=None, table_name=None, show_column_minmax_stats=None,):
        self.op = op
        self.table_name = table_name
        self.show_column_minmax_stats = show_column_minmax_stats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.show_column_minmax_stats = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowStatsParams')
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 1)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.show_column_minmax_stats is not None:
            oprot.writeFieldBegin('show_column_minmax_stats', TType.BOOL, 3)
            oprot.writeBool(self.show_column_minmax_stats)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDescribeHistoryParams(object):
    """
    Attributes:
     - table_name
     - between_start_time
     - between_end_time
     - from_time

    """


    def __init__(self, table_name=None, between_start_time=None, between_end_time=None, from_time=None,):
        self.table_name = table_name
        self.between_start_time = between_start_time
        self.between_end_time = between_end_time
        self.from_time = from_time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.between_start_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.between_end_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.from_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDescribeHistoryParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.between_start_time is not None:
            oprot.writeFieldBegin('between_start_time', TType.I64, 2)
            oprot.writeI64(self.between_start_time)
            oprot.writeFieldEnd()
        if self.between_end_time is not None:
            oprot.writeFieldBegin('between_end_time', TType.I64, 3)
            oprot.writeI64(self.between_end_time)
            oprot.writeFieldEnd()
        if self.from_time is not None:
            oprot.writeFieldBegin('from_time', TType.I64, 4)
            oprot.writeI64(self.from_time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowFunctionsParams(object):
    """
    Attributes:
     - category
     - db
     - show_pattern

    """


    def __init__(self, category=None, db=None, show_pattern=None,):
        self.category = category
        self.db = db
        self.show_pattern = show_pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.category = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.show_pattern = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowFunctionsParams')
        if self.category is not None:
            oprot.writeFieldBegin('category', TType.I32, 1)
            oprot.writeI32(self.category)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 2)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        if self.show_pattern is not None:
            oprot.writeFieldBegin('show_pattern', TType.STRING, 3)
            oprot.writeString(self.show_pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowTablesParams(object):
    """
    Attributes:
     - db
     - tbl
     - show_pattern
     - table_types

    """


    def __init__(self, db=None, tbl=None, show_pattern=None, table_types=set((
    )),):
        self.db = db
        self.tbl = tbl
        self.show_pattern = show_pattern
        if table_types is self.thrift_spec[4][4]:
            table_types = set((
            ))
        self.table_types = table_types

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.show_pattern = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.SET:
                    self.table_types = set()
                    (_etype66, _size63) = iprot.readSetBegin()
                    for _i67 in range(_size63):
                        _elem68 = iprot.readI32()
                        self.table_types.add(_elem68)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowTablesParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        if self.tbl is not None:
            oprot.writeFieldBegin('tbl', TType.STRING, 2)
            oprot.writeString(self.tbl)
            oprot.writeFieldEnd()
        if self.show_pattern is not None:
            oprot.writeFieldBegin('show_pattern', TType.STRING, 3)
            oprot.writeString(self.show_pattern)
            oprot.writeFieldEnd()
        if self.table_types is not None:
            oprot.writeFieldBegin('table_types', TType.SET, 4)
            oprot.writeSetBegin(TType.I32, len(self.table_types))
            for iter69 in self.table_types:
                oprot.writeI32(iter69)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowFilesParams(object):
    """
    Attributes:
     - table_name
     - partition_set

    """


    def __init__(self, table_name=None, partition_set=None,):
        self.table_name = table_name
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = []
                        (_etype79, _size76) = iprot.readListBegin()
                        for _i80 in range(_size76):
                            _elem81 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem81.read(iprot)
                            _elem75.append(_elem81)
                        iprot.readListEnd()
                        self.partition_set.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowFilesParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter82 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter82))
                for iter83 in iter82:
                    iter83.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowRolesParams(object):
    """
    Attributes:
     - requesting_user
     - is_show_current_roles
     - grant_group

    """


    def __init__(self, requesting_user=None, is_show_current_roles=None, grant_group=None,):
        self.requesting_user = requesting_user
        self.is_show_current_roles = is_show_current_roles
        self.grant_group = grant_group

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.requesting_user = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_show_current_roles = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.grant_group = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowRolesParams')
        if self.requesting_user is not None:
            oprot.writeFieldBegin('requesting_user', TType.STRING, 1)
            oprot.writeString(self.requesting_user)
            oprot.writeFieldEnd()
        if self.is_show_current_roles is not None:
            oprot.writeFieldBegin('is_show_current_roles', TType.BOOL, 3)
            oprot.writeBool(self.is_show_current_roles)
            oprot.writeFieldEnd()
        if self.grant_group is not None:
            oprot.writeFieldBegin('grant_group', TType.STRING, 4)
            oprot.writeString(self.grant_group)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_show_current_roles is None:
            raise TProtocolException(message='Required field is_show_current_roles is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowRolesResult(object):
    """
    Attributes:
     - role_names

    """


    def __init__(self, role_names=None,):
        self.role_names = role_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.role_names = []
                    (_etype87, _size84) = iprot.readListBegin()
                    for _i88 in range(_size84):
                        _elem89 = iprot.readString()
                        self.role_names.append(_elem89)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowRolesResult')
        if self.role_names is not None:
            oprot.writeFieldBegin('role_names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.role_names))
            for iter90 in self.role_names:
                oprot.writeString(iter90)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.role_names is None:
            raise TProtocolException(message='Required field role_names is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTableHistoryResultItem(object):
    """
    Attributes:
     - creation_time
     - snapshot_id
     - parent_id
     - is_current_ancestor

    """


    def __init__(self, creation_time=None, snapshot_id=None, parent_id=None, is_current_ancestor=None,):
        self.creation_time = creation_time
        self.snapshot_id = snapshot_id
        self.parent_id = parent_id
        self.is_current_ancestor = is_current_ancestor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.creation_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.snapshot_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.parent_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_current_ancestor = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTableHistoryResultItem')
        if self.creation_time is not None:
            oprot.writeFieldBegin('creation_time', TType.I64, 1)
            oprot.writeI64(self.creation_time)
            oprot.writeFieldEnd()
        if self.snapshot_id is not None:
            oprot.writeFieldBegin('snapshot_id', TType.I64, 2)
            oprot.writeI64(self.snapshot_id)
            oprot.writeFieldEnd()
        if self.parent_id is not None:
            oprot.writeFieldBegin('parent_id', TType.I64, 3)
            oprot.writeI64(self.parent_id)
            oprot.writeFieldEnd()
        if self.is_current_ancestor is not None:
            oprot.writeFieldBegin('is_current_ancestor', TType.BOOL, 4)
            oprot.writeBool(self.is_current_ancestor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.creation_time is None:
            raise TProtocolException(message='Required field creation_time is unset!')
        if self.snapshot_id is None:
            raise TProtocolException(message='Required field snapshot_id is unset!')
        if self.is_current_ancestor is None:
            raise TProtocolException(message='Required field is_current_ancestor is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetTableHistoryResult(object):
    """
    Attributes:
     - result

    """


    def __init__(self, result=None,):
        self.result = result

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.result = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = TGetTableHistoryResultItem()
                        _elem96.read(iprot)
                        self.result.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetTableHistoryResult')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.result))
            for iter97 in self.result:
                iter97.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.result is None:
            raise TProtocolException(message='Required field result is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShowGrantPrincipalParams(object):
    """
    Attributes:
     - requesting_user
     - name
     - principal_type
     - privilege

    """


    def __init__(self, requesting_user=None, name=None, principal_type=None, privilege=None,):
        self.requesting_user = requesting_user
        self.name = name
        self.principal_type = principal_type
        self.privilege = privilege

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.requesting_user = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.privilege = CatalogObjects.ttypes.TPrivilege()
                    self.privilege.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShowGrantPrincipalParams')
        if self.requesting_user is not None:
            oprot.writeFieldBegin('requesting_user', TType.STRING, 1)
            oprot.writeString(self.requesting_user)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 3)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.STRUCT, 5)
            self.privilege.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.principal_type is None:
            raise TProtocolException(message='Required field principal_type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetFunctionsParams(object):
    """
    Attributes:
     - category
     - db
     - pattern
     - session

    """


    def __init__(self, category=None, db=None, pattern=None, session=None,):
        self.category = category
        self.db = db
        self.pattern = pattern
        self.session = session

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.category = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.session = Query.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetFunctionsParams')
        if self.category is not None:
            oprot.writeFieldBegin('category', TType.I32, 1)
            oprot.writeI32(self.category)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 2)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 3)
            oprot.writeString(self.pattern)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 4)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.category is None:
            raise TProtocolException(message='Required field category is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetFunctionsResult(object):
    """
    Attributes:
     - fn_signatures
     - fn_ret_types
     - fn_binary_types
     - fn_persistence

    """


    def __init__(self, fn_signatures=None, fn_ret_types=None, fn_binary_types=None, fn_persistence=None,):
        self.fn_signatures = fn_signatures
        self.fn_ret_types = fn_ret_types
        self.fn_binary_types = fn_binary_types
        self.fn_persistence = fn_persistence

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fn_signatures = []
                    (_etype101, _size98) = iprot.readListBegin()
                    for _i102 in range(_size98):
                        _elem103 = iprot.readString()
                        self.fn_signatures.append(_elem103)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fn_ret_types = []
                    (_etype107, _size104) = iprot.readListBegin()
                    for _i108 in range(_size104):
                        _elem109 = iprot.readString()
                        self.fn_ret_types.append(_elem109)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.fn_binary_types = []
                    (_etype113, _size110) = iprot.readListBegin()
                    for _i114 in range(_size110):
                        _elem115 = iprot.readString()
                        self.fn_binary_types.append(_elem115)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.fn_persistence = []
                    (_etype119, _size116) = iprot.readListBegin()
                    for _i120 in range(_size116):
                        _elem121 = iprot.readString()
                        self.fn_persistence.append(_elem121)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetFunctionsResult')
        if self.fn_signatures is not None:
            oprot.writeFieldBegin('fn_signatures', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.fn_signatures))
            for iter122 in self.fn_signatures:
                oprot.writeString(iter122)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fn_ret_types is not None:
            oprot.writeFieldBegin('fn_ret_types', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.fn_ret_types))
            for iter123 in self.fn_ret_types:
                oprot.writeString(iter123)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fn_binary_types is not None:
            oprot.writeFieldBegin('fn_binary_types', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.fn_binary_types))
            for iter124 in self.fn_binary_types:
                oprot.writeString(iter124)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fn_persistence is not None:
            oprot.writeFieldBegin('fn_persistence', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.fn_persistence))
            for iter125 in self.fn_persistence:
                oprot.writeString(iter125)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUseDbParams(object):
    """
    Attributes:
     - db

    """


    def __init__(self, db=None,):
        self.db = db

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUseDbParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExplainResult(object):
    """
    Attributes:
     - results

    """


    def __init__(self, results=None,):
        self.results = results

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.results = []
                    (_etype129, _size126) = iprot.readListBegin()
                    for _i130 in range(_size126):
                        _elem131 = Data.ttypes.TResultRow()
                        _elem131.read(iprot)
                        self.results.append(_elem131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExplainResult')
        if self.results is not None:
            oprot.writeFieldBegin('results', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.results))
            for iter132 in self.results:
                iter132.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.results is None:
            raise TProtocolException(message='Required field results is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadDataReq(object):
    """
    Attributes:
     - table_name
     - source_path
     - overwrite
     - partition_spec
     - iceberg_tbl
     - create_tmp_tbl_query_template
     - insert_into_dst_tbl_query
     - drop_tmp_tbl_query

    """


    def __init__(self, table_name=None, source_path=None, overwrite=None, partition_spec=None, iceberg_tbl=None, create_tmp_tbl_query_template=None, insert_into_dst_tbl_query=None, drop_tmp_tbl_query=None,):
        self.table_name = table_name
        self.source_path = source_path
        self.overwrite = overwrite
        self.partition_spec = partition_spec
        self.iceberg_tbl = iceberg_tbl
        self.create_tmp_tbl_query_template = create_tmp_tbl_query_template
        self.insert_into_dst_tbl_query = insert_into_dst_tbl_query
        self.drop_tmp_tbl_query = drop_tmp_tbl_query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.source_path = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.overwrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partition_spec = []
                    (_etype136, _size133) = iprot.readListBegin()
                    for _i137 in range(_size133):
                        _elem138 = CatalogObjects.ttypes.TPartitionKeyValue()
                        _elem138.read(iprot)
                        self.partition_spec.append(_elem138)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.iceberg_tbl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.create_tmp_tbl_query_template = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.insert_into_dst_tbl_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.drop_tmp_tbl_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadDataReq')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.source_path is not None:
            oprot.writeFieldBegin('source_path', TType.STRING, 2)
            oprot.writeString(self.source_path)
            oprot.writeFieldEnd()
        if self.overwrite is not None:
            oprot.writeFieldBegin('overwrite', TType.BOOL, 3)
            oprot.writeBool(self.overwrite)
            oprot.writeFieldEnd()
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
            for iter139 in self.partition_spec:
                iter139.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.iceberg_tbl is not None:
            oprot.writeFieldBegin('iceberg_tbl', TType.BOOL, 5)
            oprot.writeBool(self.iceberg_tbl)
            oprot.writeFieldEnd()
        if self.create_tmp_tbl_query_template is not None:
            oprot.writeFieldBegin('create_tmp_tbl_query_template', TType.STRING, 6)
            oprot.writeString(self.create_tmp_tbl_query_template)
            oprot.writeFieldEnd()
        if self.insert_into_dst_tbl_query is not None:
            oprot.writeFieldBegin('insert_into_dst_tbl_query', TType.STRING, 7)
            oprot.writeString(self.insert_into_dst_tbl_query)
            oprot.writeFieldEnd()
        if self.drop_tmp_tbl_query is not None:
            oprot.writeFieldBegin('drop_tmp_tbl_query', TType.STRING, 8)
            oprot.writeString(self.drop_tmp_tbl_query)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.source_path is None:
            raise TProtocolException(message='Required field source_path is unset!')
        if self.overwrite is None:
            raise TProtocolException(message='Required field overwrite is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TLoadDataResp(object):
    """
    Attributes:
     - load_summary
     - loaded_files
     - partition_name
     - create_tmp_tbl_query
     - create_location

    """


    def __init__(self, load_summary=None, loaded_files=None, partition_name="", create_tmp_tbl_query=None, create_location=None,):
        self.load_summary = load_summary
        self.loaded_files = loaded_files
        self.partition_name = partition_name
        self.create_tmp_tbl_query = create_tmp_tbl_query
        self.create_location = create_location

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.load_summary = Data.ttypes.TResultRow()
                    self.load_summary.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.loaded_files = []
                    (_etype143, _size140) = iprot.readListBegin()
                    for _i144 in range(_size140):
                        _elem145 = iprot.readString()
                        self.loaded_files.append(_elem145)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.partition_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.create_tmp_tbl_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.create_location = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TLoadDataResp')
        if self.load_summary is not None:
            oprot.writeFieldBegin('load_summary', TType.STRUCT, 1)
            self.load_summary.write(oprot)
            oprot.writeFieldEnd()
        if self.loaded_files is not None:
            oprot.writeFieldBegin('loaded_files', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.loaded_files))
            for iter146 in self.loaded_files:
                oprot.writeString(iter146)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_name is not None:
            oprot.writeFieldBegin('partition_name', TType.STRING, 3)
            oprot.writeString(self.partition_name)
            oprot.writeFieldEnd()
        if self.create_tmp_tbl_query is not None:
            oprot.writeFieldBegin('create_tmp_tbl_query', TType.STRING, 4)
            oprot.writeString(self.create_tmp_tbl_query)
            oprot.writeFieldEnd()
        if self.create_location is not None:
            oprot.writeFieldBegin('create_location', TType.STRING, 5)
            oprot.writeString(self.create_location)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.load_summary is None:
            raise TProtocolException(message='Required field load_summary is unset!')
        if self.loaded_files is None:
            raise TProtocolException(message='Required field loaded_files is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogOpRequest(object):
    """
    Attributes:
     - op_type
     - sync_ddl
     - use_db_params
     - describe_db_params
     - describe_table_params
     - show_dbs_params
     - show_tables_params
     - show_fns_params
     - show_data_srcs_params
     - show_roles_params
     - show_grant_principal_params
     - ddl_params
     - reset_metadata_params
     - show_stats_params
     - show_create_table_params
     - show_files_params
     - lineage_graph
     - show_create_function_params
     - describe_history_params

    """


    def __init__(self, op_type=None, sync_ddl=None, use_db_params=None, describe_db_params=None, describe_table_params=None, show_dbs_params=None, show_tables_params=None, show_fns_params=None, show_data_srcs_params=None, show_roles_params=None, show_grant_principal_params=None, ddl_params=None, reset_metadata_params=None, show_stats_params=None, show_create_table_params=None, show_files_params=None, lineage_graph=None, show_create_function_params=None, describe_history_params=None,):
        self.op_type = op_type
        self.sync_ddl = sync_ddl
        self.use_db_params = use_db_params
        self.describe_db_params = describe_db_params
        self.describe_table_params = describe_table_params
        self.show_dbs_params = show_dbs_params
        self.show_tables_params = show_tables_params
        self.show_fns_params = show_fns_params
        self.show_data_srcs_params = show_data_srcs_params
        self.show_roles_params = show_roles_params
        self.show_grant_principal_params = show_grant_principal_params
        self.ddl_params = ddl_params
        self.reset_metadata_params = reset_metadata_params
        self.show_stats_params = show_stats_params
        self.show_create_table_params = show_create_table_params
        self.show_files_params = show_files_params
        self.lineage_graph = lineage_graph
        self.show_create_function_params = show_create_function_params
        self.describe_history_params = describe_history_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.op_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.sync_ddl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.use_db_params = TUseDbParams()
                    self.use_db_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.describe_db_params = TDescribeDbParams()
                    self.describe_db_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.describe_table_params = TDescribeTableParams()
                    self.describe_table_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.show_dbs_params = TShowDbsParams()
                    self.show_dbs_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.show_tables_params = TShowTablesParams()
                    self.show_tables_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.show_fns_params = TShowFunctionsParams()
                    self.show_fns_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.show_data_srcs_params = TShowDataSrcsParams()
                    self.show_data_srcs_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.show_roles_params = TShowRolesParams()
                    self.show_roles_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.show_grant_principal_params = TShowGrantPrincipalParams()
                    self.show_grant_principal_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.ddl_params = CatalogService.ttypes.TDdlExecRequest()
                    self.ddl_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.reset_metadata_params = CatalogService.ttypes.TResetMetadataRequest()
                    self.reset_metadata_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.show_stats_params = TShowStatsParams()
                    self.show_stats_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.show_create_table_params = CatalogObjects.ttypes.TTableName()
                    self.show_create_table_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.show_files_params = TShowFilesParams()
                    self.show_files_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.lineage_graph = LineageGraph.ttypes.TLineageGraph()
                    self.lineage_graph.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.show_create_function_params = TGetFunctionsParams()
                    self.show_create_function_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRUCT:
                    self.describe_history_params = TDescribeHistoryParams()
                    self.describe_history_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogOpRequest')
        if self.op_type is not None:
            oprot.writeFieldBegin('op_type', TType.I32, 1)
            oprot.writeI32(self.op_type)
            oprot.writeFieldEnd()
        if self.sync_ddl is not None:
            oprot.writeFieldBegin('sync_ddl', TType.BOOL, 2)
            oprot.writeBool(self.sync_ddl)
            oprot.writeFieldEnd()
        if self.use_db_params is not None:
            oprot.writeFieldBegin('use_db_params', TType.STRUCT, 3)
            self.use_db_params.write(oprot)
            oprot.writeFieldEnd()
        if self.describe_db_params is not None:
            oprot.writeFieldBegin('describe_db_params', TType.STRUCT, 4)
            self.describe_db_params.write(oprot)
            oprot.writeFieldEnd()
        if self.describe_table_params is not None:
            oprot.writeFieldBegin('describe_table_params', TType.STRUCT, 5)
            self.describe_table_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_dbs_params is not None:
            oprot.writeFieldBegin('show_dbs_params', TType.STRUCT, 6)
            self.show_dbs_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_tables_params is not None:
            oprot.writeFieldBegin('show_tables_params', TType.STRUCT, 7)
            self.show_tables_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_fns_params is not None:
            oprot.writeFieldBegin('show_fns_params', TType.STRUCT, 8)
            self.show_fns_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_data_srcs_params is not None:
            oprot.writeFieldBegin('show_data_srcs_params', TType.STRUCT, 9)
            self.show_data_srcs_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_roles_params is not None:
            oprot.writeFieldBegin('show_roles_params', TType.STRUCT, 10)
            self.show_roles_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_grant_principal_params is not None:
            oprot.writeFieldBegin('show_grant_principal_params', TType.STRUCT, 11)
            self.show_grant_principal_params.write(oprot)
            oprot.writeFieldEnd()
        if self.ddl_params is not None:
            oprot.writeFieldBegin('ddl_params', TType.STRUCT, 12)
            self.ddl_params.write(oprot)
            oprot.writeFieldEnd()
        if self.reset_metadata_params is not None:
            oprot.writeFieldBegin('reset_metadata_params', TType.STRUCT, 13)
            self.reset_metadata_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_stats_params is not None:
            oprot.writeFieldBegin('show_stats_params', TType.STRUCT, 14)
            self.show_stats_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_create_table_params is not None:
            oprot.writeFieldBegin('show_create_table_params', TType.STRUCT, 15)
            self.show_create_table_params.write(oprot)
            oprot.writeFieldEnd()
        if self.show_files_params is not None:
            oprot.writeFieldBegin('show_files_params', TType.STRUCT, 16)
            self.show_files_params.write(oprot)
            oprot.writeFieldEnd()
        if self.lineage_graph is not None:
            oprot.writeFieldBegin('lineage_graph', TType.STRUCT, 17)
            self.lineage_graph.write(oprot)
            oprot.writeFieldEnd()
        if self.show_create_function_params is not None:
            oprot.writeFieldBegin('show_create_function_params', TType.STRUCT, 18)
            self.show_create_function_params.write(oprot)
            oprot.writeFieldEnd()
        if self.describe_history_params is not None:
            oprot.writeFieldBegin('describe_history_params', TType.STRUCT, 19)
            self.describe_history_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.op_type is None:
            raise TProtocolException(message='Required field op_type is unset!')
        if self.sync_ddl is None:
            raise TProtocolException(message='Required field sync_ddl is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetQueryOptionRequest(object):
    """
    Attributes:
     - key
     - value
     - query_option_type

    """


    def __init__(self, key=None, value=None, query_option_type=None,):
        self.key = key
        self.value = value
        self.query_option_type = query_option_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.query_option_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetQueryOptionRequest')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        if self.query_option_type is not None:
            oprot.writeFieldBegin('query_option_type', TType.I32, 3)
            oprot.writeI32(self.query_option_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TShutdownParams(object):
    """
    Attributes:
     - backend
     - deadline_s

    """


    def __init__(self, backend=None, deadline_s=None,):
        self.backend = backend
        self.deadline_s = deadline_s

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.backend = Types.ttypes.TNetworkAddress()
                    self.backend.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.deadline_s = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TShutdownParams')
        if self.backend is not None:
            oprot.writeFieldBegin('backend', TType.STRUCT, 1)
            self.backend.write(oprot)
            oprot.writeFieldEnd()
        if self.deadline_s is not None:
            oprot.writeFieldBegin('deadline_s', TType.I64, 2)
            oprot.writeI64(self.deadline_s)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAdminRequest(object):
    """
    Attributes:
     - type
     - shutdown_params
     - event_processor_cmd_params

    """


    def __init__(self, type=None, shutdown_params=None, event_processor_cmd_params=None,):
        self.type = type
        self.shutdown_params = shutdown_params
        self.event_processor_cmd_params = event_processor_cmd_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.shutdown_params = TShutdownParams()
                    self.shutdown_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.event_processor_cmd_params = CatalogService.ttypes.TEventProcessorCmdParams()
                    self.event_processor_cmd_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAdminRequest')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.shutdown_params is not None:
            oprot.writeFieldBegin('shutdown_params', TType.STRUCT, 2)
            self.shutdown_params.write(oprot)
            oprot.writeFieldEnd()
        if self.event_processor_cmd_params is not None:
            oprot.writeFieldBegin('event_processor_cmd_params', TType.STRUCT, 3)
            self.event_processor_cmd_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMetadataOpRequest(object):
    """
    Attributes:
     - opcode
     - get_info_req
     - get_type_info_req
     - get_catalogs_req
     - get_schemas_req
     - get_tables_req
     - get_table_types_req
     - get_columns_req
     - get_functions_req
     - session
     - get_primary_keys_req
     - get_cross_reference_req

    """


    def __init__(self, opcode=None, get_info_req=None, get_type_info_req=None, get_catalogs_req=None, get_schemas_req=None, get_tables_req=None, get_table_types_req=None, get_columns_req=None, get_functions_req=None, session=None, get_primary_keys_req=None, get_cross_reference_req=None,):
        self.opcode = opcode
        self.get_info_req = get_info_req
        self.get_type_info_req = get_type_info_req
        self.get_catalogs_req = get_catalogs_req
        self.get_schemas_req = get_schemas_req
        self.get_tables_req = get_tables_req
        self.get_table_types_req = get_table_types_req
        self.get_columns_req = get_columns_req
        self.get_functions_req = get_functions_req
        self.session = session
        self.get_primary_keys_req = get_primary_keys_req
        self.get_cross_reference_req = get_cross_reference_req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.opcode = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.get_info_req = TCLIService.ttypes.TGetInfoReq()
                    self.get_info_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.get_type_info_req = TCLIService.ttypes.TGetTypeInfoReq()
                    self.get_type_info_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.get_catalogs_req = TCLIService.ttypes.TGetCatalogsReq()
                    self.get_catalogs_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.get_schemas_req = TCLIService.ttypes.TGetSchemasReq()
                    self.get_schemas_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.get_tables_req = TCLIService.ttypes.TGetTablesReq()
                    self.get_tables_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.get_table_types_req = TCLIService.ttypes.TGetTableTypesReq()
                    self.get_table_types_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.get_columns_req = TCLIService.ttypes.TGetColumnsReq()
                    self.get_columns_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.get_functions_req = TCLIService.ttypes.TGetFunctionsReq()
                    self.get_functions_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.session = Query.ttypes.TSessionState()
                    self.session.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.get_primary_keys_req = TCLIService.ttypes.TGetPrimaryKeysReq()
                    self.get_primary_keys_req.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.get_cross_reference_req = TCLIService.ttypes.TGetCrossReferenceReq()
                    self.get_cross_reference_req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMetadataOpRequest')
        if self.opcode is not None:
            oprot.writeFieldBegin('opcode', TType.I32, 1)
            oprot.writeI32(self.opcode)
            oprot.writeFieldEnd()
        if self.get_info_req is not None:
            oprot.writeFieldBegin('get_info_req', TType.STRUCT, 2)
            self.get_info_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_type_info_req is not None:
            oprot.writeFieldBegin('get_type_info_req', TType.STRUCT, 3)
            self.get_type_info_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_catalogs_req is not None:
            oprot.writeFieldBegin('get_catalogs_req', TType.STRUCT, 4)
            self.get_catalogs_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_schemas_req is not None:
            oprot.writeFieldBegin('get_schemas_req', TType.STRUCT, 5)
            self.get_schemas_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_tables_req is not None:
            oprot.writeFieldBegin('get_tables_req', TType.STRUCT, 6)
            self.get_tables_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_table_types_req is not None:
            oprot.writeFieldBegin('get_table_types_req', TType.STRUCT, 7)
            self.get_table_types_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_columns_req is not None:
            oprot.writeFieldBegin('get_columns_req', TType.STRUCT, 8)
            self.get_columns_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_functions_req is not None:
            oprot.writeFieldBegin('get_functions_req', TType.STRUCT, 9)
            self.get_functions_req.write(oprot)
            oprot.writeFieldEnd()
        if self.session is not None:
            oprot.writeFieldBegin('session', TType.STRUCT, 10)
            self.session.write(oprot)
            oprot.writeFieldEnd()
        if self.get_primary_keys_req is not None:
            oprot.writeFieldBegin('get_primary_keys_req', TType.STRUCT, 11)
            self.get_primary_keys_req.write(oprot)
            oprot.writeFieldEnd()
        if self.get_cross_reference_req is not None:
            oprot.writeFieldBegin('get_cross_reference_req', TType.STRUCT, 12)
            self.get_cross_reference_req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.opcode is None:
            raise TProtocolException(message='Required field opcode is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAccessEvent(object):
    """
    Attributes:
     - name
     - object_type
     - privilege

    """


    def __init__(self, name=None, object_type=None, privilege=None,):
        self.name = name
        self.object_type = object_type
        self.privilege = privilege

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.object_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.privilege = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAccessEvent')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.object_type is not None:
            oprot.writeFieldBegin('object_type', TType.I32, 2)
            oprot.writeI32(self.object_type)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.STRING, 3)
            oprot.writeString(self.privilege)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.object_type is None:
            raise TProtocolException(message='Required field object_type is unset!')
        if self.privilege is None:
            raise TProtocolException(message='Required field privilege is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConvertTableRequest(object):
    """
    Attributes:
     - table_name
     - hdfs_table_name
     - file_format
     - properties
     - set_hdfs_table_properties_query
     - rename_hdfs_table_to_temporary_query
     - refresh_temporary_hdfs_table_query
     - reset_table_name_query
     - create_iceberg_table_query
     - invalidate_metadata_query
     - post_create_alter_table_query
     - drop_temporary_hdfs_table_query

    """


    def __init__(self, table_name=None, hdfs_table_name=None, file_format=None, properties=None, set_hdfs_table_properties_query=None, rename_hdfs_table_to_temporary_query=None, refresh_temporary_hdfs_table_query=None, reset_table_name_query=None, create_iceberg_table_query=None, invalidate_metadata_query=None, post_create_alter_table_query=None, drop_temporary_hdfs_table_query=None,):
        self.table_name = table_name
        self.hdfs_table_name = hdfs_table_name
        self.file_format = file_format
        self.properties = properties
        self.set_hdfs_table_properties_query = set_hdfs_table_properties_query
        self.rename_hdfs_table_to_temporary_query = rename_hdfs_table_to_temporary_query
        self.refresh_temporary_hdfs_table_query = refresh_temporary_hdfs_table_query
        self.reset_table_name_query = reset_table_name_query
        self.create_iceberg_table_query = create_iceberg_table_query
        self.invalidate_metadata_query = invalidate_metadata_query
        self.post_create_alter_table_query = post_create_alter_table_query
        self.drop_temporary_hdfs_table_query = drop_temporary_hdfs_table_query

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.hdfs_table_name = CatalogObjects.ttypes.TTableName()
                    self.hdfs_table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.file_format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.properties = {}
                    (_ktype148, _vtype149, _size147) = iprot.readMapBegin()
                    for _i151 in range(_size147):
                        _key152 = iprot.readString()
                        _val153 = iprot.readString()
                        self.properties[_key152] = _val153
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.set_hdfs_table_properties_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.rename_hdfs_table_to_temporary_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.refresh_temporary_hdfs_table_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.reset_table_name_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.create_iceberg_table_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.invalidate_metadata_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.post_create_alter_table_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.drop_temporary_hdfs_table_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConvertTableRequest')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.hdfs_table_name is not None:
            oprot.writeFieldBegin('hdfs_table_name', TType.STRUCT, 2)
            self.hdfs_table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.file_format is not None:
            oprot.writeFieldBegin('file_format', TType.I32, 3)
            oprot.writeI32(self.file_format)
            oprot.writeFieldEnd()
        if self.properties is not None:
            oprot.writeFieldBegin('properties', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
            for kiter154, viter155 in self.properties.items():
                oprot.writeString(kiter154)
                oprot.writeString(viter155)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.set_hdfs_table_properties_query is not None:
            oprot.writeFieldBegin('set_hdfs_table_properties_query', TType.STRING, 5)
            oprot.writeString(self.set_hdfs_table_properties_query)
            oprot.writeFieldEnd()
        if self.rename_hdfs_table_to_temporary_query is not None:
            oprot.writeFieldBegin('rename_hdfs_table_to_temporary_query', TType.STRING, 6)
            oprot.writeString(self.rename_hdfs_table_to_temporary_query)
            oprot.writeFieldEnd()
        if self.refresh_temporary_hdfs_table_query is not None:
            oprot.writeFieldBegin('refresh_temporary_hdfs_table_query', TType.STRING, 7)
            oprot.writeString(self.refresh_temporary_hdfs_table_query)
            oprot.writeFieldEnd()
        if self.reset_table_name_query is not None:
            oprot.writeFieldBegin('reset_table_name_query', TType.STRING, 8)
            oprot.writeString(self.reset_table_name_query)
            oprot.writeFieldEnd()
        if self.create_iceberg_table_query is not None:
            oprot.writeFieldBegin('create_iceberg_table_query', TType.STRING, 9)
            oprot.writeString(self.create_iceberg_table_query)
            oprot.writeFieldEnd()
        if self.invalidate_metadata_query is not None:
            oprot.writeFieldBegin('invalidate_metadata_query', TType.STRING, 10)
            oprot.writeString(self.invalidate_metadata_query)
            oprot.writeFieldEnd()
        if self.post_create_alter_table_query is not None:
            oprot.writeFieldBegin('post_create_alter_table_query', TType.STRING, 11)
            oprot.writeString(self.post_create_alter_table_query)
            oprot.writeFieldEnd()
        if self.drop_temporary_hdfs_table_query is not None:
            oprot.writeFieldBegin('drop_temporary_hdfs_table_query', TType.STRING, 12)
            oprot.writeString(self.drop_temporary_hdfs_table_query)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.hdfs_table_name is None:
            raise TProtocolException(message='Required field hdfs_table_name is unset!')
        if self.file_format is None:
            raise TProtocolException(message='Required field file_format is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKillQueryReq(object):
    """
    Attributes:
     - query_id
     - requesting_user
     - is_admin

    """


    def __init__(self, query_id=None, requesting_user=None, is_admin=None,):
        self.query_id = query_id
        self.requesting_user = requesting_user
        self.is_admin = is_admin

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.query_id = Types.ttypes.TUniqueId()
                    self.query_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.requesting_user = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_admin = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKillQueryReq')
        if self.query_id is not None:
            oprot.writeFieldBegin('query_id', TType.STRUCT, 1)
            self.query_id.write(oprot)
            oprot.writeFieldEnd()
        if self.requesting_user is not None:
            oprot.writeFieldBegin('requesting_user', TType.STRING, 2)
            oprot.writeString(self.requesting_user)
            oprot.writeFieldEnd()
        if self.is_admin is not None:
            oprot.writeFieldBegin('is_admin', TType.BOOL, 3)
            oprot.writeBool(self.is_admin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.query_id is None:
            raise TProtocolException(message='Required field query_id is unset!')
        if self.requesting_user is None:
            raise TProtocolException(message='Required field requesting_user is unset!')
        if self.is_admin is None:
            raise TProtocolException(message='Required field is_admin is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExecRequest(object):
    """
    Attributes:
     - stmt_type
     - query_options
     - query_exec_request
     - catalog_op_request
     - result_set_metadata
     - explain_result
     - load_data_request
     - access_events
     - analysis_warnings
     - set_query_option_request
     - timeline
     - user_has_profile_access
     - admin_request
     - profile
     - testcase_data_path
     - remote_submit_time
     - profile_children
     - request_pool_set_by_frontend
     - convert_table_request
     - tables
     - select_columns
     - where_columns
     - join_columns
     - aggregate_columns
     - orderby_columns
     - kill_query_request

    """


    def __init__(self, stmt_type=9, query_options=None, query_exec_request=None, catalog_op_request=None, result_set_metadata=None, explain_result=None, load_data_request=None, access_events=None, analysis_warnings=None, set_query_option_request=None, timeline=None, user_has_profile_access=None, admin_request=None, profile=None, testcase_data_path=None, remote_submit_time=None, profile_children=None, request_pool_set_by_frontend=False, convert_table_request=None, tables=None, select_columns=None, where_columns=None, join_columns=None, aggregate_columns=None, orderby_columns=None, kill_query_request=None,):
        self.stmt_type = stmt_type
        self.query_options = query_options
        self.query_exec_request = query_exec_request
        self.catalog_op_request = catalog_op_request
        self.result_set_metadata = result_set_metadata
        self.explain_result = explain_result
        self.load_data_request = load_data_request
        self.access_events = access_events
        self.analysis_warnings = analysis_warnings
        self.set_query_option_request = set_query_option_request
        self.timeline = timeline
        self.user_has_profile_access = user_has_profile_access
        self.admin_request = admin_request
        self.profile = profile
        self.testcase_data_path = testcase_data_path
        self.remote_submit_time = remote_submit_time
        self.profile_children = profile_children
        self.request_pool_set_by_frontend = request_pool_set_by_frontend
        self.convert_table_request = convert_table_request
        self.tables = tables
        self.select_columns = select_columns
        self.where_columns = where_columns
        self.join_columns = join_columns
        self.aggregate_columns = aggregate_columns
        self.orderby_columns = orderby_columns
        self.kill_query_request = kill_query_request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.stmt_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.query_options = Query.ttypes.TQueryOptions()
                    self.query_options.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.query_exec_request = Query.ttypes.TQueryExecRequest()
                    self.query_exec_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.catalog_op_request = TCatalogOpRequest()
                    self.catalog_op_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.result_set_metadata = Results.ttypes.TResultSetMetadata()
                    self.result_set_metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.explain_result = TExplainResult()
                    self.explain_result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.load_data_request = TLoadDataReq()
                    self.load_data_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.access_events = []
                    (_etype159, _size156) = iprot.readListBegin()
                    for _i160 in range(_size156):
                        _elem161 = TAccessEvent()
                        _elem161.read(iprot)
                        self.access_events.append(_elem161)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.analysis_warnings = []
                    (_etype165, _size162) = iprot.readListBegin()
                    for _i166 in range(_size162):
                        _elem167 = iprot.readString()
                        self.analysis_warnings.append(_elem167)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.set_query_option_request = TSetQueryOptionRequest()
                    self.set_query_option_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.timeline = RuntimeProfile.ttypes.TEventSequence()
                    self.timeline.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.user_has_profile_access = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.admin_request = TAdminRequest()
                    self.admin_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.profile = RuntimeProfile.ttypes.TRuntimeProfileNode()
                    self.profile.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.testcase_data_path = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I64:
                    self.remote_submit_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.LIST:
                    self.profile_children = []
                    (_etype171, _size168) = iprot.readListBegin()
                    for _i172 in range(_size168):
                        _elem173 = RuntimeProfile.ttypes.TRuntimeProfileNode()
                        _elem173.read(iprot)
                        self.profile_children.append(_elem173)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.BOOL:
                    self.request_pool_set_by_frontend = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRUCT:
                    self.convert_table_request = TConvertTableRequest()
                    self.convert_table_request.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.LIST:
                    self.tables = []
                    (_etype177, _size174) = iprot.readListBegin()
                    for _i178 in range(_size174):
                        _elem179 = CatalogObjects.ttypes.TTableName()
                        _elem179.read(iprot)
                        self.tables.append(_elem179)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.LIST:
                    self.select_columns = []
                    (_etype183, _size180) = iprot.readListBegin()
                    for _i184 in range(_size180):
                        _elem185 = iprot.readString()
                        self.select_columns.append(_elem185)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.LIST:
                    self.where_columns = []
                    (_etype189, _size186) = iprot.readListBegin()
                    for _i190 in range(_size186):
                        _elem191 = iprot.readString()
                        self.where_columns.append(_elem191)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.LIST:
                    self.join_columns = []
                    (_etype195, _size192) = iprot.readListBegin()
                    for _i196 in range(_size192):
                        _elem197 = iprot.readString()
                        self.join_columns.append(_elem197)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.LIST:
                    self.aggregate_columns = []
                    (_etype201, _size198) = iprot.readListBegin()
                    for _i202 in range(_size198):
                        _elem203 = iprot.readString()
                        self.aggregate_columns.append(_elem203)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.LIST:
                    self.orderby_columns = []
                    (_etype207, _size204) = iprot.readListBegin()
                    for _i208 in range(_size204):
                        _elem209 = iprot.readString()
                        self.orderby_columns.append(_elem209)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.STRUCT:
                    self.kill_query_request = TKillQueryReq()
                    self.kill_query_request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExecRequest')
        if self.stmt_type is not None:
            oprot.writeFieldBegin('stmt_type', TType.I32, 1)
            oprot.writeI32(self.stmt_type)
            oprot.writeFieldEnd()
        if self.query_options is not None:
            oprot.writeFieldBegin('query_options', TType.STRUCT, 2)
            self.query_options.write(oprot)
            oprot.writeFieldEnd()
        if self.query_exec_request is not None:
            oprot.writeFieldBegin('query_exec_request', TType.STRUCT, 3)
            self.query_exec_request.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_op_request is not None:
            oprot.writeFieldBegin('catalog_op_request', TType.STRUCT, 4)
            self.catalog_op_request.write(oprot)
            oprot.writeFieldEnd()
        if self.result_set_metadata is not None:
            oprot.writeFieldBegin('result_set_metadata', TType.STRUCT, 5)
            self.result_set_metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.explain_result is not None:
            oprot.writeFieldBegin('explain_result', TType.STRUCT, 6)
            self.explain_result.write(oprot)
            oprot.writeFieldEnd()
        if self.load_data_request is not None:
            oprot.writeFieldBegin('load_data_request', TType.STRUCT, 7)
            self.load_data_request.write(oprot)
            oprot.writeFieldEnd()
        if self.access_events is not None:
            oprot.writeFieldBegin('access_events', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.access_events))
            for iter210 in self.access_events:
                iter210.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.analysis_warnings is not None:
            oprot.writeFieldBegin('analysis_warnings', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.analysis_warnings))
            for iter211 in self.analysis_warnings:
                oprot.writeString(iter211)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.set_query_option_request is not None:
            oprot.writeFieldBegin('set_query_option_request', TType.STRUCT, 10)
            self.set_query_option_request.write(oprot)
            oprot.writeFieldEnd()
        if self.timeline is not None:
            oprot.writeFieldBegin('timeline', TType.STRUCT, 11)
            self.timeline.write(oprot)
            oprot.writeFieldEnd()
        if self.user_has_profile_access is not None:
            oprot.writeFieldBegin('user_has_profile_access', TType.BOOL, 12)
            oprot.writeBool(self.user_has_profile_access)
            oprot.writeFieldEnd()
        if self.admin_request is not None:
            oprot.writeFieldBegin('admin_request', TType.STRUCT, 13)
            self.admin_request.write(oprot)
            oprot.writeFieldEnd()
        if self.profile is not None:
            oprot.writeFieldBegin('profile', TType.STRUCT, 14)
            self.profile.write(oprot)
            oprot.writeFieldEnd()
        if self.testcase_data_path is not None:
            oprot.writeFieldBegin('testcase_data_path', TType.STRING, 15)
            oprot.writeString(self.testcase_data_path)
            oprot.writeFieldEnd()
        if self.remote_submit_time is not None:
            oprot.writeFieldBegin('remote_submit_time', TType.I64, 16)
            oprot.writeI64(self.remote_submit_time)
            oprot.writeFieldEnd()
        if self.profile_children is not None:
            oprot.writeFieldBegin('profile_children', TType.LIST, 17)
            oprot.writeListBegin(TType.STRUCT, len(self.profile_children))
            for iter212 in self.profile_children:
                iter212.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.request_pool_set_by_frontend is not None:
            oprot.writeFieldBegin('request_pool_set_by_frontend', TType.BOOL, 18)
            oprot.writeBool(self.request_pool_set_by_frontend)
            oprot.writeFieldEnd()
        if self.convert_table_request is not None:
            oprot.writeFieldBegin('convert_table_request', TType.STRUCT, 19)
            self.convert_table_request.write(oprot)
            oprot.writeFieldEnd()
        if self.tables is not None:
            oprot.writeFieldBegin('tables', TType.LIST, 20)
            oprot.writeListBegin(TType.STRUCT, len(self.tables))
            for iter213 in self.tables:
                iter213.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.select_columns is not None:
            oprot.writeFieldBegin('select_columns', TType.LIST, 21)
            oprot.writeListBegin(TType.STRING, len(self.select_columns))
            for iter214 in self.select_columns:
                oprot.writeString(iter214)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.where_columns is not None:
            oprot.writeFieldBegin('where_columns', TType.LIST, 22)
            oprot.writeListBegin(TType.STRING, len(self.where_columns))
            for iter215 in self.where_columns:
                oprot.writeString(iter215)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.join_columns is not None:
            oprot.writeFieldBegin('join_columns', TType.LIST, 23)
            oprot.writeListBegin(TType.STRING, len(self.join_columns))
            for iter216 in self.join_columns:
                oprot.writeString(iter216)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aggregate_columns is not None:
            oprot.writeFieldBegin('aggregate_columns', TType.LIST, 24)
            oprot.writeListBegin(TType.STRING, len(self.aggregate_columns))
            for iter217 in self.aggregate_columns:
                oprot.writeString(iter217)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.orderby_columns is not None:
            oprot.writeFieldBegin('orderby_columns', TType.LIST, 25)
            oprot.writeListBegin(TType.STRING, len(self.orderby_columns))
            for iter218 in self.orderby_columns:
                oprot.writeString(iter218)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.kill_query_request is not None:
            oprot.writeFieldBegin('kill_query_request', TType.STRUCT, 26)
            self.kill_query_request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.stmt_type is None:
            raise TProtocolException(message='Required field stmt_type is unset!')
        if self.query_options is None:
            raise TProtocolException(message='Required field query_options is unset!')
        if self.analysis_warnings is None:
            raise TProtocolException(message='Required field analysis_warnings is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCacheJarParams(object):
    """
    Attributes:
     - hdfs_location

    """


    def __init__(self, hdfs_location=None,):
        self.hdfs_location = hdfs_location

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hdfs_location = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCacheJarParams')
        if self.hdfs_location is not None:
            oprot.writeFieldBegin('hdfs_location', TType.STRING, 1)
            oprot.writeString(self.hdfs_location)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hdfs_location is None:
            raise TProtocolException(message='Required field hdfs_location is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCacheJarResult(object):
    """
    Attributes:
     - status
     - local_path

    """


    def __init__(self, status=None, local_path=None,):
        self.status = status
        self.local_path = local_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.local_path = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCacheJarResult')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.local_path is not None:
            oprot.writeFieldBegin('local_path', TType.STRING, 2)
            oprot.writeString(self.local_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSymbolLookupParams(object):
    """
    Attributes:
     - location
     - symbol
     - fn_binary_type
     - arg_types
     - has_var_args
     - ret_arg_type
     - symbol_type
     - needs_refresh

    """


    def __init__(self, location=None, symbol=None, fn_binary_type=None, arg_types=None, has_var_args=None, ret_arg_type=None, symbol_type=None, needs_refresh=None,):
        self.location = location
        self.symbol = symbol
        self.fn_binary_type = fn_binary_type
        self.arg_types = arg_types
        self.has_var_args = has_var_args
        self.ret_arg_type = ret_arg_type
        self.symbol_type = symbol_type
        self.needs_refresh = needs_refresh

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.location = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.symbol = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fn_binary_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.arg_types = []
                    (_etype222, _size219) = iprot.readListBegin()
                    for _i223 in range(_size219):
                        _elem224 = Types.ttypes.TColumnType()
                        _elem224.read(iprot)
                        self.arg_types.append(_elem224)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.has_var_args = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.ret_arg_type = Types.ttypes.TColumnType()
                    self.ret_arg_type.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.symbol_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.needs_refresh = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSymbolLookupParams')
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 1)
            oprot.writeString(self.location)
            oprot.writeFieldEnd()
        if self.symbol is not None:
            oprot.writeFieldBegin('symbol', TType.STRING, 2)
            oprot.writeString(self.symbol)
            oprot.writeFieldEnd()
        if self.fn_binary_type is not None:
            oprot.writeFieldBegin('fn_binary_type', TType.I32, 3)
            oprot.writeI32(self.fn_binary_type)
            oprot.writeFieldEnd()
        if self.arg_types is not None:
            oprot.writeFieldBegin('arg_types', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.arg_types))
            for iter225 in self.arg_types:
                iter225.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.has_var_args is not None:
            oprot.writeFieldBegin('has_var_args', TType.BOOL, 5)
            oprot.writeBool(self.has_var_args)
            oprot.writeFieldEnd()
        if self.ret_arg_type is not None:
            oprot.writeFieldBegin('ret_arg_type', TType.STRUCT, 6)
            self.ret_arg_type.write(oprot)
            oprot.writeFieldEnd()
        if self.symbol_type is not None:
            oprot.writeFieldBegin('symbol_type', TType.I32, 7)
            oprot.writeI32(self.symbol_type)
            oprot.writeFieldEnd()
        if self.needs_refresh is not None:
            oprot.writeFieldBegin('needs_refresh', TType.BOOL, 8)
            oprot.writeBool(self.needs_refresh)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.location is None:
            raise TProtocolException(message='Required field location is unset!')
        if self.symbol is None:
            raise TProtocolException(message='Required field symbol is unset!')
        if self.fn_binary_type is None:
            raise TProtocolException(message='Required field fn_binary_type is unset!')
        if self.arg_types is None:
            raise TProtocolException(message='Required field arg_types is unset!')
        if self.has_var_args is None:
            raise TProtocolException(message='Required field has_var_args is unset!')
        if self.symbol_type is None:
            raise TProtocolException(message='Required field symbol_type is unset!')
        if self.needs_refresh is None:
            raise TProtocolException(message='Required field needs_refresh is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSymbolLookupResult(object):
    """
    Attributes:
     - result_code
     - symbol
     - error_msg
     - last_modified_time

    """


    def __init__(self, result_code=None, symbol=None, error_msg=None, last_modified_time=None,):
        self.result_code = result_code
        self.symbol = symbol
        self.error_msg = error_msg
        self.last_modified_time = last_modified_time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.result_code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.symbol = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.error_msg = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.last_modified_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSymbolLookupResult')
        if self.result_code is not None:
            oprot.writeFieldBegin('result_code', TType.I32, 1)
            oprot.writeI32(self.result_code)
            oprot.writeFieldEnd()
        if self.symbol is not None:
            oprot.writeFieldBegin('symbol', TType.STRING, 2)
            oprot.writeString(self.symbol)
            oprot.writeFieldEnd()
        if self.error_msg is not None:
            oprot.writeFieldBegin('error_msg', TType.STRING, 3)
            oprot.writeString(self.error_msg)
            oprot.writeFieldEnd()
        if self.last_modified_time is not None:
            oprot.writeFieldBegin('last_modified_time', TType.I64, 4)
            oprot.writeI64(self.last_modified_time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.result_code is None:
            raise TProtocolException(message='Required field result_code is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateCatalogCacheRequest(object):
    """
    Attributes:
     - is_delta
     - catalog_service_id
     - updated_objects_deprecated
     - removed_objects_deprecated
     - native_iterator_ptr

    """


    def __init__(self, is_delta=None, catalog_service_id=None, updated_objects_deprecated=None, removed_objects_deprecated=None, native_iterator_ptr=None,):
        self.is_delta = is_delta
        self.catalog_service_id = catalog_service_id
        self.updated_objects_deprecated = updated_objects_deprecated
        self.removed_objects_deprecated = removed_objects_deprecated
        self.native_iterator_ptr = native_iterator_ptr

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.is_delta = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.catalog_service_id = Types.ttypes.TUniqueId()
                    self.catalog_service_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.updated_objects_deprecated = []
                    (_etype229, _size226) = iprot.readListBegin()
                    for _i230 in range(_size226):
                        _elem231 = CatalogObjects.ttypes.TCatalogObject()
                        _elem231.read(iprot)
                        self.updated_objects_deprecated.append(_elem231)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.removed_objects_deprecated = []
                    (_etype235, _size232) = iprot.readListBegin()
                    for _i236 in range(_size232):
                        _elem237 = CatalogObjects.ttypes.TCatalogObject()
                        _elem237.read(iprot)
                        self.removed_objects_deprecated.append(_elem237)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.native_iterator_ptr = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateCatalogCacheRequest')
        if self.is_delta is not None:
            oprot.writeFieldBegin('is_delta', TType.BOOL, 1)
            oprot.writeBool(self.is_delta)
            oprot.writeFieldEnd()
        if self.catalog_service_id is not None:
            oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 2)
            self.catalog_service_id.write(oprot)
            oprot.writeFieldEnd()
        if self.updated_objects_deprecated is not None:
            oprot.writeFieldBegin('updated_objects_deprecated', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.updated_objects_deprecated))
            for iter238 in self.updated_objects_deprecated:
                iter238.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.removed_objects_deprecated is not None:
            oprot.writeFieldBegin('removed_objects_deprecated', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.removed_objects_deprecated))
            for iter239 in self.removed_objects_deprecated:
                iter239.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.native_iterator_ptr is not None:
            oprot.writeFieldBegin('native_iterator_ptr', TType.I64, 5)
            oprot.writeI64(self.native_iterator_ptr)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_delta is None:
            raise TProtocolException(message='Required field is_delta is unset!')
        if self.native_iterator_ptr is None:
            raise TProtocolException(message='Required field native_iterator_ptr is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateCatalogCacheResponse(object):
    """
    Attributes:
     - catalog_service_id
     - catalog_object_version_lower_bound
     - new_catalog_version

    """


    def __init__(self, catalog_service_id=None, catalog_object_version_lower_bound=None, new_catalog_version=None,):
        self.catalog_service_id = catalog_service_id
        self.catalog_object_version_lower_bound = catalog_object_version_lower_bound
        self.new_catalog_version = new_catalog_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catalog_service_id = Types.ttypes.TUniqueId()
                    self.catalog_service_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.catalog_object_version_lower_bound = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.new_catalog_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateCatalogCacheResponse')
        if self.catalog_service_id is not None:
            oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
            self.catalog_service_id.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_object_version_lower_bound is not None:
            oprot.writeFieldBegin('catalog_object_version_lower_bound', TType.I64, 2)
            oprot.writeI64(self.catalog_object_version_lower_bound)
            oprot.writeFieldEnd()
        if self.new_catalog_version is not None:
            oprot.writeFieldBegin('new_catalog_version', TType.I64, 3)
            oprot.writeI64(self.new_catalog_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_service_id is None:
            raise TProtocolException(message='Required field catalog_service_id is unset!')
        if self.catalog_object_version_lower_bound is None:
            raise TProtocolException(message='Required field catalog_object_version_lower_bound is unset!')
        if self.new_catalog_version is None:
            raise TProtocolException(message='Required field new_catalog_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExecutorGroupSet(object):
    """
    Attributes:
     - curr_num_executors
     - expected_num_executors
     - exec_group_name_prefix
     - max_mem_limit
     - num_cores_per_executor

    """


    def __init__(self, curr_num_executors=0, expected_num_executors=0, exec_group_name_prefix=None, max_mem_limit=None, num_cores_per_executor=None,):
        self.curr_num_executors = curr_num_executors
        self.expected_num_executors = expected_num_executors
        self.exec_group_name_prefix = exec_group_name_prefix
        self.max_mem_limit = max_mem_limit
        self.num_cores_per_executor = num_cores_per_executor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.curr_num_executors = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.expected_num_executors = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.exec_group_name_prefix = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.max_mem_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.num_cores_per_executor = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExecutorGroupSet')
        if self.curr_num_executors is not None:
            oprot.writeFieldBegin('curr_num_executors', TType.I32, 1)
            oprot.writeI32(self.curr_num_executors)
            oprot.writeFieldEnd()
        if self.expected_num_executors is not None:
            oprot.writeFieldBegin('expected_num_executors', TType.I32, 2)
            oprot.writeI32(self.expected_num_executors)
            oprot.writeFieldEnd()
        if self.exec_group_name_prefix is not None:
            oprot.writeFieldBegin('exec_group_name_prefix', TType.STRING, 3)
            oprot.writeString(self.exec_group_name_prefix)
            oprot.writeFieldEnd()
        if self.max_mem_limit is not None:
            oprot.writeFieldBegin('max_mem_limit', TType.I64, 4)
            oprot.writeI64(self.max_mem_limit)
            oprot.writeFieldEnd()
        if self.num_cores_per_executor is not None:
            oprot.writeFieldBegin('num_cores_per_executor', TType.I32, 5)
            oprot.writeI32(self.num_cores_per_executor)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateExecutorMembershipRequest(object):
    """
    Attributes:
     - hostnames
     - ip_addresses
     - exec_group_sets

    """


    def __init__(self, hostnames=None, ip_addresses=None, exec_group_sets=None,):
        self.hostnames = hostnames
        self.ip_addresses = ip_addresses
        self.exec_group_sets = exec_group_sets

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.hostnames = set()
                    (_etype243, _size240) = iprot.readSetBegin()
                    for _i244 in range(_size240):
                        _elem245 = iprot.readString()
                        self.hostnames.add(_elem245)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.SET:
                    self.ip_addresses = set()
                    (_etype249, _size246) = iprot.readSetBegin()
                    for _i250 in range(_size246):
                        _elem251 = iprot.readString()
                        self.ip_addresses.add(_elem251)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.exec_group_sets = []
                    (_etype255, _size252) = iprot.readListBegin()
                    for _i256 in range(_size252):
                        _elem257 = TExecutorGroupSet()
                        _elem257.read(iprot)
                        self.exec_group_sets.append(_elem257)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateExecutorMembershipRequest')
        if self.hostnames is not None:
            oprot.writeFieldBegin('hostnames', TType.SET, 1)
            oprot.writeSetBegin(TType.STRING, len(self.hostnames))
            for iter258 in self.hostnames:
                oprot.writeString(iter258)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.ip_addresses is not None:
            oprot.writeFieldBegin('ip_addresses', TType.SET, 2)
            oprot.writeSetBegin(TType.STRING, len(self.ip_addresses))
            for iter259 in self.ip_addresses:
                oprot.writeString(iter259)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        if self.exec_group_sets is not None:
            oprot.writeFieldBegin('exec_group_sets', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.exec_group_sets))
            for iter260 in self.exec_group_sets:
                iter260.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hostnames is None:
            raise TProtocolException(message='Required field hostnames is unset!')
        if self.ip_addresses is None:
            raise TProtocolException(message='Required field ip_addresses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TJvmMemoryPool(object):
    """
    Attributes:
     - committed
     - init
     - max
     - used
     - peak_committed
     - peak_init
     - peak_max
     - peak_used
     - name

    """


    def __init__(self, committed=None, init=None, max=None, used=None, peak_committed=None, peak_init=None, peak_max=None, peak_used=None, name=None,):
        self.committed = committed
        self.init = init
        self.max = max
        self.used = used
        self.peak_committed = peak_committed
        self.peak_init = peak_init
        self.peak_max = peak_max
        self.peak_used = peak_used
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.committed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.init = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.max = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.used = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.peak_committed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.peak_init = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.peak_max = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.peak_used = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TJvmMemoryPool')
        if self.committed is not None:
            oprot.writeFieldBegin('committed', TType.I64, 1)
            oprot.writeI64(self.committed)
            oprot.writeFieldEnd()
        if self.init is not None:
            oprot.writeFieldBegin('init', TType.I64, 2)
            oprot.writeI64(self.init)
            oprot.writeFieldEnd()
        if self.max is not None:
            oprot.writeFieldBegin('max', TType.I64, 3)
            oprot.writeI64(self.max)
            oprot.writeFieldEnd()
        if self.used is not None:
            oprot.writeFieldBegin('used', TType.I64, 4)
            oprot.writeI64(self.used)
            oprot.writeFieldEnd()
        if self.peak_committed is not None:
            oprot.writeFieldBegin('peak_committed', TType.I64, 5)
            oprot.writeI64(self.peak_committed)
            oprot.writeFieldEnd()
        if self.peak_init is not None:
            oprot.writeFieldBegin('peak_init', TType.I64, 6)
            oprot.writeI64(self.peak_init)
            oprot.writeFieldEnd()
        if self.peak_max is not None:
            oprot.writeFieldBegin('peak_max', TType.I64, 7)
            oprot.writeI64(self.peak_max)
            oprot.writeFieldEnd()
        if self.peak_used is not None:
            oprot.writeFieldBegin('peak_used', TType.I64, 8)
            oprot.writeI64(self.peak_used)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 9)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.committed is None:
            raise TProtocolException(message='Required field committed is unset!')
        if self.init is None:
            raise TProtocolException(message='Required field init is unset!')
        if self.max is None:
            raise TProtocolException(message='Required field max is unset!')
        if self.used is None:
            raise TProtocolException(message='Required field used is unset!')
        if self.peak_committed is None:
            raise TProtocolException(message='Required field peak_committed is unset!')
        if self.peak_init is None:
            raise TProtocolException(message='Required field peak_init is unset!')
        if self.peak_max is None:
            raise TProtocolException(message='Required field peak_max is unset!')
        if self.peak_used is None:
            raise TProtocolException(message='Required field peak_used is unset!')
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJvmMemoryMetricsResponse(object):
    """
    Attributes:
     - memory_pools
     - gc_num_warn_threshold_exceeded
     - gc_num_info_threshold_exceeded
     - gc_total_extra_sleep_time_millis
     - gc_count
     - gc_time_millis

    """


    def __init__(self, memory_pools=None, gc_num_warn_threshold_exceeded=None, gc_num_info_threshold_exceeded=None, gc_total_extra_sleep_time_millis=None, gc_count=None, gc_time_millis=None,):
        self.memory_pools = memory_pools
        self.gc_num_warn_threshold_exceeded = gc_num_warn_threshold_exceeded
        self.gc_num_info_threshold_exceeded = gc_num_info_threshold_exceeded
        self.gc_total_extra_sleep_time_millis = gc_total_extra_sleep_time_millis
        self.gc_count = gc_count
        self.gc_time_millis = gc_time_millis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.memory_pools = []
                    (_etype264, _size261) = iprot.readListBegin()
                    for _i265 in range(_size261):
                        _elem266 = TJvmMemoryPool()
                        _elem266.read(iprot)
                        self.memory_pools.append(_elem266)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.gc_num_warn_threshold_exceeded = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.gc_num_info_threshold_exceeded = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.gc_total_extra_sleep_time_millis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.gc_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.gc_time_millis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJvmMemoryMetricsResponse')
        if self.memory_pools is not None:
            oprot.writeFieldBegin('memory_pools', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.memory_pools))
            for iter267 in self.memory_pools:
                iter267.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.gc_num_warn_threshold_exceeded is not None:
            oprot.writeFieldBegin('gc_num_warn_threshold_exceeded', TType.I64, 2)
            oprot.writeI64(self.gc_num_warn_threshold_exceeded)
            oprot.writeFieldEnd()
        if self.gc_num_info_threshold_exceeded is not None:
            oprot.writeFieldBegin('gc_num_info_threshold_exceeded', TType.I64, 3)
            oprot.writeI64(self.gc_num_info_threshold_exceeded)
            oprot.writeFieldEnd()
        if self.gc_total_extra_sleep_time_millis is not None:
            oprot.writeFieldBegin('gc_total_extra_sleep_time_millis', TType.I64, 4)
            oprot.writeI64(self.gc_total_extra_sleep_time_millis)
            oprot.writeFieldEnd()
        if self.gc_count is not None:
            oprot.writeFieldBegin('gc_count', TType.I64, 5)
            oprot.writeI64(self.gc_count)
            oprot.writeFieldEnd()
        if self.gc_time_millis is not None:
            oprot.writeFieldBegin('gc_time_millis', TType.I64, 6)
            oprot.writeI64(self.gc_time_millis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.memory_pools is None:
            raise TProtocolException(message='Required field memory_pools is unset!')
        if self.gc_num_warn_threshold_exceeded is None:
            raise TProtocolException(message='Required field gc_num_warn_threshold_exceeded is unset!')
        if self.gc_num_info_threshold_exceeded is None:
            raise TProtocolException(message='Required field gc_num_info_threshold_exceeded is unset!')
        if self.gc_total_extra_sleep_time_millis is None:
            raise TProtocolException(message='Required field gc_total_extra_sleep_time_millis is unset!')
        if self.gc_count is None:
            raise TProtocolException(message='Required field gc_count is unset!')
        if self.gc_time_millis is None:
            raise TProtocolException(message='Required field gc_time_millis is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TJvmThreadInfo(object):
    """
    Attributes:
     - summary
     - cpu_time_in_ns
     - user_time_in_ns
     - blocked_count
     - blocked_time_in_ms
     - is_in_native

    """


    def __init__(self, summary=None, cpu_time_in_ns=None, user_time_in_ns=None, blocked_count=None, blocked_time_in_ms=None, is_in_native=None,):
        self.summary = summary
        self.cpu_time_in_ns = cpu_time_in_ns
        self.user_time_in_ns = user_time_in_ns
        self.blocked_count = blocked_count
        self.blocked_time_in_ms = blocked_time_in_ms
        self.is_in_native = is_in_native

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.summary = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.cpu_time_in_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.user_time_in_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.blocked_count = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.blocked_time_in_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.is_in_native = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TJvmThreadInfo')
        if self.summary is not None:
            oprot.writeFieldBegin('summary', TType.STRING, 1)
            oprot.writeString(self.summary)
            oprot.writeFieldEnd()
        if self.cpu_time_in_ns is not None:
            oprot.writeFieldBegin('cpu_time_in_ns', TType.I64, 2)
            oprot.writeI64(self.cpu_time_in_ns)
            oprot.writeFieldEnd()
        if self.user_time_in_ns is not None:
            oprot.writeFieldBegin('user_time_in_ns', TType.I64, 3)
            oprot.writeI64(self.user_time_in_ns)
            oprot.writeFieldEnd()
        if self.blocked_count is not None:
            oprot.writeFieldBegin('blocked_count', TType.I64, 4)
            oprot.writeI64(self.blocked_count)
            oprot.writeFieldEnd()
        if self.blocked_time_in_ms is not None:
            oprot.writeFieldBegin('blocked_time_in_ms', TType.I64, 5)
            oprot.writeI64(self.blocked_time_in_ms)
            oprot.writeFieldEnd()
        if self.is_in_native is not None:
            oprot.writeFieldBegin('is_in_native', TType.BOOL, 6)
            oprot.writeBool(self.is_in_native)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.summary is None:
            raise TProtocolException(message='Required field summary is unset!')
        if self.cpu_time_in_ns is None:
            raise TProtocolException(message='Required field cpu_time_in_ns is unset!')
        if self.user_time_in_ns is None:
            raise TProtocolException(message='Required field user_time_in_ns is unset!')
        if self.blocked_count is None:
            raise TProtocolException(message='Required field blocked_count is unset!')
        if self.blocked_time_in_ms is None:
            raise TProtocolException(message='Required field blocked_time_in_ms is unset!')
        if self.is_in_native is None:
            raise TProtocolException(message='Required field is_in_native is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJvmThreadsInfoRequest(object):
    """
    Attributes:
     - get_complete_info

    """


    def __init__(self, get_complete_info=None,):
        self.get_complete_info = get_complete_info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.get_complete_info = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJvmThreadsInfoRequest')
        if self.get_complete_info is not None:
            oprot.writeFieldBegin('get_complete_info', TType.BOOL, 1)
            oprot.writeBool(self.get_complete_info)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.get_complete_info is None:
            raise TProtocolException(message='Required field get_complete_info is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJvmThreadsInfoResponse(object):
    """
    Attributes:
     - total_thread_count
     - daemon_thread_count
     - peak_thread_count
     - threads

    """


    def __init__(self, total_thread_count=None, daemon_thread_count=None, peak_thread_count=None, threads=None,):
        self.total_thread_count = total_thread_count
        self.daemon_thread_count = daemon_thread_count
        self.peak_thread_count = peak_thread_count
        self.threads = threads

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.total_thread_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.daemon_thread_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.peak_thread_count = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.threads = []
                    (_etype271, _size268) = iprot.readListBegin()
                    for _i272 in range(_size268):
                        _elem273 = TJvmThreadInfo()
                        _elem273.read(iprot)
                        self.threads.append(_elem273)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJvmThreadsInfoResponse')
        if self.total_thread_count is not None:
            oprot.writeFieldBegin('total_thread_count', TType.I32, 1)
            oprot.writeI32(self.total_thread_count)
            oprot.writeFieldEnd()
        if self.daemon_thread_count is not None:
            oprot.writeFieldBegin('daemon_thread_count', TType.I32, 2)
            oprot.writeI32(self.daemon_thread_count)
            oprot.writeFieldEnd()
        if self.peak_thread_count is not None:
            oprot.writeFieldBegin('peak_thread_count', TType.I32, 3)
            oprot.writeI32(self.peak_thread_count)
            oprot.writeFieldEnd()
        if self.threads is not None:
            oprot.writeFieldBegin('threads', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.threads))
            for iter274 in self.threads:
                iter274.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.total_thread_count is None:
            raise TProtocolException(message='Required field total_thread_count is unset!')
        if self.daemon_thread_count is None:
            raise TProtocolException(message='Required field daemon_thread_count is unset!')
        if self.peak_thread_count is None:
            raise TProtocolException(message='Required field peak_thread_count is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetJMXJsonResponse(object):
    """
    Attributes:
     - jmx_json

    """


    def __init__(self, jmx_json=None,):
        self.jmx_json = jmx_json

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jmx_json = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetJMXJsonResponse')
        if self.jmx_json is not None:
            oprot.writeFieldBegin('jmx_json', TType.STRING, 1)
            oprot.writeString(self.jmx_json)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.jmx_json is None:
            raise TProtocolException(message='Required field jmx_json is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetHadoopConfigRequest(object):
    """
    Attributes:
     - name

    """


    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetHadoopConfigRequest')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetHadoopConfigResponse(object):
    """
    Attributes:
     - value

    """


    def __init__(self, value=None,):
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetHadoopConfigResponse')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 1)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetAllHadoopConfigsResponse(object):
    """
    Attributes:
     - configs

    """


    def __init__(self, configs=None,):
        self.configs = configs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.configs = {}
                    (_ktype276, _vtype277, _size275) = iprot.readMapBegin()
                    for _i279 in range(_size275):
                        _key280 = iprot.readString()
                        _val281 = iprot.readString()
                        self.configs[_key280] = _val281
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetAllHadoopConfigsResponse')
        if self.configs is not None:
            oprot.writeFieldBegin('configs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configs))
            for kiter282, viter283 in self.configs.items():
                oprot.writeString(kiter282)
                oprot.writeString(viter283)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetHadoopGroupsRequest(object):
    """
    Attributes:
     - user

    """


    def __init__(self, user=None,):
        self.user = user

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetHadoopGroupsRequest')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 1)
            oprot.writeString(self.user)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetHadoopGroupsResponse(object):
    """
    Attributes:
     - groups

    """


    def __init__(self, groups=None,):
        self.groups = groups

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.groups = []
                    (_etype287, _size284) = iprot.readListBegin()
                    for _i288 in range(_size284):
                        _elem289 = iprot.readString()
                        self.groups.append(_elem289)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetHadoopGroupsResponse')
        if self.groups is not None:
            oprot.writeFieldBegin('groups', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.groups))
            for iter290 in self.groups:
                oprot.writeString(iter290)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.groups is None:
            raise TProtocolException(message='Required field groups is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TBuildTestDescriptorTableParams(object):
    """
    Attributes:
     - slot_types

    """


    def __init__(self, slot_types=None,):
        self.slot_types = slot_types

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.slot_types = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = []
                        (_etype300, _size297) = iprot.readListBegin()
                        for _i301 in range(_size297):
                            _elem302 = Types.ttypes.TColumnType()
                            _elem302.read(iprot)
                            _elem296.append(_elem302)
                        iprot.readListEnd()
                        self.slot_types.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TBuildTestDescriptorTableParams')
        if self.slot_types is not None:
            oprot.writeFieldBegin('slot_types', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.slot_types))
            for iter303 in self.slot_types:
                oprot.writeListBegin(TType.STRUCT, len(iter303))
                for iter304 in iter303:
                    iter304.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.slot_types is None:
            raise TProtocolException(message='Required field slot_types is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTestCaseData(object):
    """
    Attributes:
     - query_stmt
     - tables_and_views
     - dbs
     - testcase_data_path
     - impala_version

    """


    def __init__(self, query_stmt=None, tables_and_views=None, dbs=None, testcase_data_path=None, impala_version=None,):
        self.query_stmt = query_stmt
        self.tables_and_views = tables_and_views
        self.dbs = dbs
        self.testcase_data_path = testcase_data_path
        self.impala_version = impala_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.query_stmt = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tables_and_views = []
                    (_etype308, _size305) = iprot.readListBegin()
                    for _i309 in range(_size305):
                        _elem310 = CatalogObjects.ttypes.TTable()
                        _elem310.read(iprot)
                        self.tables_and_views.append(_elem310)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.dbs = []
                    (_etype314, _size311) = iprot.readListBegin()
                    for _i315 in range(_size311):
                        _elem316 = CatalogObjects.ttypes.TDatabase()
                        _elem316.read(iprot)
                        self.dbs.append(_elem316)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.testcase_data_path = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.impala_version = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTestCaseData')
        if self.query_stmt is not None:
            oprot.writeFieldBegin('query_stmt', TType.STRING, 1)
            oprot.writeString(self.query_stmt)
            oprot.writeFieldEnd()
        if self.tables_and_views is not None:
            oprot.writeFieldBegin('tables_and_views', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.tables_and_views))
            for iter317 in self.tables_and_views:
                iter317.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.dbs is not None:
            oprot.writeFieldBegin('dbs', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.dbs))
            for iter318 in self.dbs:
                iter318.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.testcase_data_path is not None:
            oprot.writeFieldBegin('testcase_data_path', TType.STRING, 4)
            oprot.writeString(self.testcase_data_path)
            oprot.writeFieldEnd()
        if self.impala_version is not None:
            oprot.writeFieldBegin('impala_version', TType.STRING, 5)
            oprot.writeString(self.impala_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.query_stmt is None:
            raise TProtocolException(message='Required field query_stmt is unset!')
        if self.testcase_data_path is None:
            raise TProtocolException(message='Required field testcase_data_path is unset!')
        if self.impala_version is None:
            raise TProtocolException(message='Required field impala_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TQueryCompleteContext(object):
    """
    Attributes:
     - lineage_string

    """


    def __init__(self, lineage_string=None,):
        self.lineage_string = lineage_string

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.lineage_string = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TQueryCompleteContext')
        if self.lineage_string is not None:
            oprot.writeFieldBegin('lineage_string', TType.STRING, 1)
            oprot.writeString(self.lineage_string)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lineage_string is None:
            raise TProtocolException(message='Required field lineage_string is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TWrappedHttpRequest(object):
    """
    Attributes:
     - method
     - server_name
     - server_port
     - path
     - params
     - headers
     - cookies
     - content
     - remote_ip
     - secure

    """


    def __init__(self, method=None, server_name=None, server_port=None, path=None, params=None, headers=None, cookies=None, content=None, remote_ip=None, secure=None,):
        self.method = method
        self.server_name = server_name
        self.server_port = server_port
        self.path = path
        self.params = params
        self.headers = headers
        self.cookies = cookies
        self.content = content
        self.remote_ip = remote_ip
        self.secure = secure

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.method = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.server_port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.path = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.params = {}
                    (_ktype320, _vtype321, _size319) = iprot.readMapBegin()
                    for _i323 in range(_size319):
                        _key324 = iprot.readString()
                        _val325 = iprot.readString()
                        self.params[_key324] = _val325
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.headers = {}
                    (_ktype327, _vtype328, _size326) = iprot.readMapBegin()
                    for _i330 in range(_size326):
                        _key331 = iprot.readString()
                        _val332 = iprot.readString()
                        self.headers[_key331] = _val332
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.cookies = {}
                    (_ktype334, _vtype335, _size333) = iprot.readMapBegin()
                    for _i337 in range(_size333):
                        _key338 = iprot.readString()
                        _val339 = iprot.readString()
                        self.cookies[_key338] = _val339
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.content = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.remote_ip = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.secure = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TWrappedHttpRequest')
        if self.method is not None:
            oprot.writeFieldBegin('method', TType.STRING, 1)
            oprot.writeString(self.method)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 2)
            oprot.writeString(self.server_name)
            oprot.writeFieldEnd()
        if self.server_port is not None:
            oprot.writeFieldBegin('server_port', TType.I32, 3)
            oprot.writeI32(self.server_port)
            oprot.writeFieldEnd()
        if self.path is not None:
            oprot.writeFieldBegin('path', TType.STRING, 4)
            oprot.writeString(self.path)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.params))
            for kiter340, viter341 in self.params.items():
                oprot.writeString(kiter340)
                oprot.writeString(viter341)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.headers is not None:
            oprot.writeFieldBegin('headers', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.headers))
            for kiter342, viter343 in self.headers.items():
                oprot.writeString(kiter342)
                oprot.writeString(viter343)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.cookies is not None:
            oprot.writeFieldBegin('cookies', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.cookies))
            for kiter344, viter345 in self.cookies.items():
                oprot.writeString(kiter344)
                oprot.writeString(viter345)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.content is not None:
            oprot.writeFieldBegin('content', TType.STRING, 8)
            oprot.writeString(self.content)
            oprot.writeFieldEnd()
        if self.remote_ip is not None:
            oprot.writeFieldBegin('remote_ip', TType.STRING, 9)
            oprot.writeString(self.remote_ip)
            oprot.writeFieldEnd()
        if self.secure is not None:
            oprot.writeFieldBegin('secure', TType.BOOL, 10)
            oprot.writeBool(self.secure)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.method is None:
            raise TProtocolException(message='Required field method is unset!')
        if self.server_name is None:
            raise TProtocolException(message='Required field server_name is unset!')
        if self.server_port is None:
            raise TProtocolException(message='Required field server_port is unset!')
        if self.path is None:
            raise TProtocolException(message='Required field path is unset!')
        if self.params is None:
            raise TProtocolException(message='Required field params is unset!')
        if self.headers is None:
            raise TProtocolException(message='Required field headers is unset!')
        if self.cookies is None:
            raise TProtocolException(message='Required field cookies is unset!')
        if self.remote_ip is None:
            raise TProtocolException(message='Required field remote_ip is unset!')
        if self.secure is None:
            raise TProtocolException(message='Required field secure is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TWrappedHttpResponse(object):
    """
    Attributes:
     - status_code
     - status_text
     - headers
     - cookies
     - content
     - content_type

    """


    def __init__(self, status_code=None, status_text=None, headers=None, cookies=None, content=None, content_type=None,):
        self.status_code = status_code
        self.status_text = status_text
        self.headers = headers
        self.cookies = cookies
        self.content = content
        self.content_type = content_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.status_code = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.status_text = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.headers = {}
                    (_ktype347, _vtype348, _size346) = iprot.readMapBegin()
                    for _i350 in range(_size346):
                        _key351 = iprot.readString()
                        _val352 = iprot.readString()
                        self.headers[_key351] = _val352
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.cookies = {}
                    (_ktype354, _vtype355, _size353) = iprot.readMapBegin()
                    for _i357 in range(_size353):
                        _key358 = iprot.readString()
                        _val359 = iprot.readString()
                        self.cookies[_key358] = _val359
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.content = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.content_type = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TWrappedHttpResponse')
        if self.status_code is not None:
            oprot.writeFieldBegin('status_code', TType.I16, 1)
            oprot.writeI16(self.status_code)
            oprot.writeFieldEnd()
        if self.status_text is not None:
            oprot.writeFieldBegin('status_text', TType.STRING, 2)
            oprot.writeString(self.status_text)
            oprot.writeFieldEnd()
        if self.headers is not None:
            oprot.writeFieldBegin('headers', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.headers))
            for kiter360, viter361 in self.headers.items():
                oprot.writeString(kiter360)
                oprot.writeString(viter361)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.cookies is not None:
            oprot.writeFieldBegin('cookies', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.cookies))
            for kiter362, viter363 in self.cookies.items():
                oprot.writeString(kiter362)
                oprot.writeString(viter363)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.content is not None:
            oprot.writeFieldBegin('content', TType.STRING, 5)
            oprot.writeString(self.content)
            oprot.writeFieldEnd()
        if self.content_type is not None:
            oprot.writeFieldBegin('content_type', TType.STRING, 6)
            oprot.writeString(self.content_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status_code is None:
            raise TProtocolException(message='Required field status_code is unset!')
        if self.status_text is None:
            raise TProtocolException(message='Required field status_text is unset!')
        if self.headers is None:
            raise TProtocolException(message='Required field headers is unset!')
        if self.cookies is None:
            raise TProtocolException(message='Required field cookies is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(THiveUdfExecutorCtorParams)
THiveUdfExecutorCtorParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fn', [Types.ttypes.TFunction, None], None, ),  # 1
    (2, TType.STRING, 'local_location', None, None, ),  # 2
    (3, TType.LIST, 'input_byte_offsets', (TType.I32, None, False), None, ),  # 3
    (4, TType.I64, 'input_nulls_ptr', None, None, ),  # 4
    (5, TType.I64, 'input_buffer_ptr', None, None, ),  # 5
    (6, TType.I64, 'output_null_ptr', None, None, ),  # 6
    (7, TType.I64, 'output_buffer_ptr', None, None, ),  # 7
)
all_structs.append(TGetTablesParams)
TGetTablesParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', None, None, ),  # 1
    (2, TType.STRING, 'pattern', None, None, ),  # 2
    (3, TType.STRUCT, 'session', [Query.ttypes.TSessionState, None], None, ),  # 3
    (4, TType.SET, 'table_types', (TType.I32, None, False), set((
    )), ),  # 4
)
all_structs.append(TGetMetadataTablesParams)
TGetMetadataTablesParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', None, None, ),  # 1
    (2, TType.STRING, 'tbl', None, None, ),  # 2
    (3, TType.STRING, 'pattern', None, None, ),  # 3
    (4, TType.STRUCT, 'session', [Query.ttypes.TSessionState, None], None, ),  # 4
)
all_structs.append(TGetTablesResult)
TGetTablesResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'tables', (TType.STRING, None, False), None, ),  # 1
)
all_structs.append(TGetTableMetricsParams)
TGetTableMetricsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
)
all_structs.append(TGetTableMetricsResponse)
TGetTableMetricsResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'metrics', None, None, ),  # 1
)
all_structs.append(TGetCatalogMetricsResult)
TGetCatalogMetricsResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_dbs', None, None, ),  # 1
    (2, TType.I32, 'num_tables', None, None, ),  # 2
    (3, TType.I64, 'cache_eviction_count', None, None, ),  # 3
    (4, TType.I64, 'cache_hit_count', None, None, ),  # 4
    (5, TType.I64, 'cache_load_count', None, None, ),  # 5
    (6, TType.I64, 'cache_load_exception_count', None, None, ),  # 6
    (7, TType.I64, 'cache_load_success_count', None, None, ),  # 7
    (8, TType.I64, 'cache_miss_count', None, None, ),  # 8
    (9, TType.I64, 'cache_request_count', None, None, ),  # 9
    (10, TType.I64, 'cache_total_load_time', None, None, ),  # 10
    (11, TType.DOUBLE, 'cache_avg_load_time', None, None, ),  # 11
    (12, TType.DOUBLE, 'cache_hit_rate', None, None, ),  # 12
    (13, TType.DOUBLE, 'cache_load_exception_rate', None, None, ),  # 13
    (14, TType.DOUBLE, 'cache_miss_rate', None, None, ),  # 14
    (15, TType.DOUBLE, 'cache_entry_median_size', None, None, ),  # 15
    (16, TType.DOUBLE, 'cache_entry_99th_size', None, None, ),  # 16
)
all_structs.append(TGetDbsParams)
TGetDbsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pattern', None, None, ),  # 1
    (2, TType.STRUCT, 'session', [Query.ttypes.TSessionState, None], None, ),  # 2
)
all_structs.append(TGetDbsResult)
TGetDbsResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'dbs', (TType.STRUCT, [CatalogObjects.ttypes.TDatabase, None], False), None, ),  # 1
)
all_structs.append(TGetDataSrcsParams)
TGetDataSrcsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pattern', None, None, ),  # 1
)
all_structs.append(TGetDataSrcsResult)
TGetDataSrcsResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'data_src_names', (TType.STRING, None, False), None, ),  # 1
    (2, TType.LIST, 'locations', (TType.STRING, None, False), None, ),  # 2
    (3, TType.LIST, 'class_names', (TType.STRING, None, False), None, ),  # 3
    (4, TType.LIST, 'api_versions', (TType.STRING, None, False), None, ),  # 4
)
all_structs.append(TDescribeDbParams)
TDescribeDbParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', None, None, ),  # 1
    (2, TType.I32, 'output_style', None, None, ),  # 2
)
all_structs.append(TDescribeTableParams)
TDescribeTableParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'output_style', None, None, ),  # 1
    (2, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
    (3, TType.STRING, 'metadata_table_name', None, None, ),  # 3
    (4, TType.STRUCT, 'result_struct', [Types.ttypes.TColumnType, None], None, ),  # 4
    (5, TType.STRUCT, 'session', [Query.ttypes.TSessionState, None], None, ),  # 5
)
all_structs.append(TDescribeResult)
TDescribeResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'results', (TType.STRUCT, [Data.ttypes.TResultRow, None], False), None, ),  # 1
)
all_structs.append(TShowDataSrcsParams)
TShowDataSrcsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'show_pattern', None, None, ),  # 1
)
all_structs.append(TShowDbsParams)
TShowDbsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'show_pattern', None, None, ),  # 1
)
all_structs.append(TShowStatsParams)
TShowStatsParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'op', None, None, ),  # 1
    (2, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
    (3, TType.BOOL, 'show_column_minmax_stats', None, None, ),  # 3
)
all_structs.append(TDescribeHistoryParams)
TDescribeHistoryParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.I64, 'between_start_time', None, None, ),  # 2
    (3, TType.I64, 'between_end_time', None, None, ),  # 3
    (4, TType.I64, 'from_time', None, None, ),  # 4
)
all_structs.append(TShowFunctionsParams)
TShowFunctionsParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'category', None, None, ),  # 1
    (2, TType.STRING, 'db', None, None, ),  # 2
    (3, TType.STRING, 'show_pattern', None, None, ),  # 3
)
all_structs.append(TShowTablesParams)
TShowTablesParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', None, None, ),  # 1
    (2, TType.STRING, 'tbl', None, None, ),  # 2
    (3, TType.STRING, 'show_pattern', None, None, ),  # 3
    (4, TType.SET, 'table_types', (TType.I32, None, False), set((
    )), ),  # 4
)
all_structs.append(TShowFilesParams)
TShowFilesParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 2
)
all_structs.append(TShowRolesParams)
TShowRolesParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'requesting_user', None, None, ),  # 1
    None,  # 2
    (3, TType.BOOL, 'is_show_current_roles', None, None, ),  # 3
    (4, TType.STRING, 'grant_group', None, None, ),  # 4
)
all_structs.append(TShowRolesResult)
TShowRolesResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'role_names', (TType.STRING, None, False), None, ),  # 1
)
all_structs.append(TGetTableHistoryResultItem)
TGetTableHistoryResultItem.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'creation_time', None, None, ),  # 1
    (2, TType.I64, 'snapshot_id', None, None, ),  # 2
    (3, TType.I64, 'parent_id', None, None, ),  # 3
    (4, TType.BOOL, 'is_current_ancestor', None, None, ),  # 4
)
all_structs.append(TGetTableHistoryResult)
TGetTableHistoryResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'result', (TType.STRUCT, [TGetTableHistoryResultItem, None], False), None, ),  # 1
)
all_structs.append(TShowGrantPrincipalParams)
TShowGrantPrincipalParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'requesting_user', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
    (3, TType.I32, 'principal_type', None, None, ),  # 3
    None,  # 4
    (5, TType.STRUCT, 'privilege', [CatalogObjects.ttypes.TPrivilege, None], None, ),  # 5
)
all_structs.append(TGetFunctionsParams)
TGetFunctionsParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'category', None, None, ),  # 1
    (2, TType.STRING, 'db', None, None, ),  # 2
    (3, TType.STRING, 'pattern', None, None, ),  # 3
    (4, TType.STRUCT, 'session', [Query.ttypes.TSessionState, None], None, ),  # 4
)
all_structs.append(TGetFunctionsResult)
TGetFunctionsResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fn_signatures', (TType.STRING, None, False), None, ),  # 1
    (2, TType.LIST, 'fn_ret_types', (TType.STRING, None, False), None, ),  # 2
    (3, TType.LIST, 'fn_binary_types', (TType.STRING, None, False), None, ),  # 3
    (4, TType.LIST, 'fn_persistence', (TType.STRING, None, False), None, ),  # 4
)
all_structs.append(TUseDbParams)
TUseDbParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', None, None, ),  # 1
)
all_structs.append(TExplainResult)
TExplainResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'results', (TType.STRUCT, [Data.ttypes.TResultRow, None], False), None, ),  # 1
)
all_structs.append(TLoadDataReq)
TLoadDataReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRING, 'source_path', None, None, ),  # 2
    (3, TType.BOOL, 'overwrite', None, None, ),  # 3
    (4, TType.LIST, 'partition_spec', (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), None, ),  # 4
    (5, TType.BOOL, 'iceberg_tbl', None, None, ),  # 5
    (6, TType.STRING, 'create_tmp_tbl_query_template', None, None, ),  # 6
    (7, TType.STRING, 'insert_into_dst_tbl_query', None, None, ),  # 7
    (8, TType.STRING, 'drop_tmp_tbl_query', None, None, ),  # 8
)
all_structs.append(TLoadDataResp)
TLoadDataResp.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'load_summary', [Data.ttypes.TResultRow, None], None, ),  # 1
    (2, TType.LIST, 'loaded_files', (TType.STRING, None, False), None, ),  # 2
    (3, TType.STRING, 'partition_name', None, "", ),  # 3
    (4, TType.STRING, 'create_tmp_tbl_query', None, None, ),  # 4
    (5, TType.STRING, 'create_location', None, None, ),  # 5
)
all_structs.append(TCatalogOpRequest)
TCatalogOpRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'op_type', None, None, ),  # 1
    (2, TType.BOOL, 'sync_ddl', None, None, ),  # 2
    (3, TType.STRUCT, 'use_db_params', [TUseDbParams, None], None, ),  # 3
    (4, TType.STRUCT, 'describe_db_params', [TDescribeDbParams, None], None, ),  # 4
    (5, TType.STRUCT, 'describe_table_params', [TDescribeTableParams, None], None, ),  # 5
    (6, TType.STRUCT, 'show_dbs_params', [TShowDbsParams, None], None, ),  # 6
    (7, TType.STRUCT, 'show_tables_params', [TShowTablesParams, None], None, ),  # 7
    (8, TType.STRUCT, 'show_fns_params', [TShowFunctionsParams, None], None, ),  # 8
    (9, TType.STRUCT, 'show_data_srcs_params', [TShowDataSrcsParams, None], None, ),  # 9
    (10, TType.STRUCT, 'show_roles_params', [TShowRolesParams, None], None, ),  # 10
    (11, TType.STRUCT, 'show_grant_principal_params', [TShowGrantPrincipalParams, None], None, ),  # 11
    (12, TType.STRUCT, 'ddl_params', [CatalogService.ttypes.TDdlExecRequest, None], None, ),  # 12
    (13, TType.STRUCT, 'reset_metadata_params', [CatalogService.ttypes.TResetMetadataRequest, None], None, ),  # 13
    (14, TType.STRUCT, 'show_stats_params', [TShowStatsParams, None], None, ),  # 14
    (15, TType.STRUCT, 'show_create_table_params', [CatalogObjects.ttypes.TTableName, None], None, ),  # 15
    (16, TType.STRUCT, 'show_files_params', [TShowFilesParams, None], None, ),  # 16
    (17, TType.STRUCT, 'lineage_graph', [LineageGraph.ttypes.TLineageGraph, None], None, ),  # 17
    (18, TType.STRUCT, 'show_create_function_params', [TGetFunctionsParams, None], None, ),  # 18
    (19, TType.STRUCT, 'describe_history_params', [TDescribeHistoryParams, None], None, ),  # 19
)
all_structs.append(TSetQueryOptionRequest)
TSetQueryOptionRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', None, None, ),  # 1
    (2, TType.STRING, 'value', None, None, ),  # 2
    (3, TType.I32, 'query_option_type', None, None, ),  # 3
)
all_structs.append(TShutdownParams)
TShutdownParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'backend', [Types.ttypes.TNetworkAddress, None], None, ),  # 1
    (2, TType.I64, 'deadline_s', None, None, ),  # 2
)
all_structs.append(TAdminRequest)
TAdminRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.STRUCT, 'shutdown_params', [TShutdownParams, None], None, ),  # 2
    (3, TType.STRUCT, 'event_processor_cmd_params', [CatalogService.ttypes.TEventProcessorCmdParams, None], None, ),  # 3
)
all_structs.append(TMetadataOpRequest)
TMetadataOpRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'opcode', None, None, ),  # 1
    (2, TType.STRUCT, 'get_info_req', [TCLIService.ttypes.TGetInfoReq, None], None, ),  # 2
    (3, TType.STRUCT, 'get_type_info_req', [TCLIService.ttypes.TGetTypeInfoReq, None], None, ),  # 3
    (4, TType.STRUCT, 'get_catalogs_req', [TCLIService.ttypes.TGetCatalogsReq, None], None, ),  # 4
    (5, TType.STRUCT, 'get_schemas_req', [TCLIService.ttypes.TGetSchemasReq, None], None, ),  # 5
    (6, TType.STRUCT, 'get_tables_req', [TCLIService.ttypes.TGetTablesReq, None], None, ),  # 6
    (7, TType.STRUCT, 'get_table_types_req', [TCLIService.ttypes.TGetTableTypesReq, None], None, ),  # 7
    (8, TType.STRUCT, 'get_columns_req', [TCLIService.ttypes.TGetColumnsReq, None], None, ),  # 8
    (9, TType.STRUCT, 'get_functions_req', [TCLIService.ttypes.TGetFunctionsReq, None], None, ),  # 9
    (10, TType.STRUCT, 'session', [Query.ttypes.TSessionState, None], None, ),  # 10
    (11, TType.STRUCT, 'get_primary_keys_req', [TCLIService.ttypes.TGetPrimaryKeysReq, None], None, ),  # 11
    (12, TType.STRUCT, 'get_cross_reference_req', [TCLIService.ttypes.TGetCrossReferenceReq, None], None, ),  # 12
)
all_structs.append(TAccessEvent)
TAccessEvent.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', None, None, ),  # 1
    (2, TType.I32, 'object_type', None, None, ),  # 2
    (3, TType.STRING, 'privilege', None, None, ),  # 3
)
all_structs.append(TConvertTableRequest)
TConvertTableRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRUCT, 'hdfs_table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
    (3, TType.I32, 'file_format', None, None, ),  # 3
    (4, TType.MAP, 'properties', (TType.STRING, None, TType.STRING, None, False), None, ),  # 4
    (5, TType.STRING, 'set_hdfs_table_properties_query', None, None, ),  # 5
    (6, TType.STRING, 'rename_hdfs_table_to_temporary_query', None, None, ),  # 6
    (7, TType.STRING, 'refresh_temporary_hdfs_table_query', None, None, ),  # 7
    (8, TType.STRING, 'reset_table_name_query', None, None, ),  # 8
    (9, TType.STRING, 'create_iceberg_table_query', None, None, ),  # 9
    (10, TType.STRING, 'invalidate_metadata_query', None, None, ),  # 10
    (11, TType.STRING, 'post_create_alter_table_query', None, None, ),  # 11
    (12, TType.STRING, 'drop_temporary_hdfs_table_query', None, None, ),  # 12
)
all_structs.append(TKillQueryReq)
TKillQueryReq.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'query_id', [Types.ttypes.TUniqueId, None], None, ),  # 1
    (2, TType.STRING, 'requesting_user', None, None, ),  # 2
    (3, TType.BOOL, 'is_admin', None, None, ),  # 3
)
all_structs.append(TExecRequest)
TExecRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'stmt_type', None, 9, ),  # 1
    (2, TType.STRUCT, 'query_options', [Query.ttypes.TQueryOptions, None], None, ),  # 2
    (3, TType.STRUCT, 'query_exec_request', [Query.ttypes.TQueryExecRequest, None], None, ),  # 3
    (4, TType.STRUCT, 'catalog_op_request', [TCatalogOpRequest, None], None, ),  # 4
    (5, TType.STRUCT, 'result_set_metadata', [Results.ttypes.TResultSetMetadata, None], None, ),  # 5
    (6, TType.STRUCT, 'explain_result', [TExplainResult, None], None, ),  # 6
    (7, TType.STRUCT, 'load_data_request', [TLoadDataReq, None], None, ),  # 7
    (8, TType.LIST, 'access_events', (TType.STRUCT, [TAccessEvent, None], False), None, ),  # 8
    (9, TType.LIST, 'analysis_warnings', (TType.STRING, None, False), None, ),  # 9
    (10, TType.STRUCT, 'set_query_option_request', [TSetQueryOptionRequest, None], None, ),  # 10
    (11, TType.STRUCT, 'timeline', [RuntimeProfile.ttypes.TEventSequence, None], None, ),  # 11
    (12, TType.BOOL, 'user_has_profile_access', None, None, ),  # 12
    (13, TType.STRUCT, 'admin_request', [TAdminRequest, None], None, ),  # 13
    (14, TType.STRUCT, 'profile', [RuntimeProfile.ttypes.TRuntimeProfileNode, None], None, ),  # 14
    (15, TType.STRING, 'testcase_data_path', None, None, ),  # 15
    (16, TType.I64, 'remote_submit_time', None, None, ),  # 16
    (17, TType.LIST, 'profile_children', (TType.STRUCT, [RuntimeProfile.ttypes.TRuntimeProfileNode, None], False), None, ),  # 17
    (18, TType.BOOL, 'request_pool_set_by_frontend', None, False, ),  # 18
    (19, TType.STRUCT, 'convert_table_request', [TConvertTableRequest, None], None, ),  # 19
    (20, TType.LIST, 'tables', (TType.STRUCT, [CatalogObjects.ttypes.TTableName, None], False), None, ),  # 20
    (21, TType.LIST, 'select_columns', (TType.STRING, None, False), None, ),  # 21
    (22, TType.LIST, 'where_columns', (TType.STRING, None, False), None, ),  # 22
    (23, TType.LIST, 'join_columns', (TType.STRING, None, False), None, ),  # 23
    (24, TType.LIST, 'aggregate_columns', (TType.STRING, None, False), None, ),  # 24
    (25, TType.LIST, 'orderby_columns', (TType.STRING, None, False), None, ),  # 25
    (26, TType.STRUCT, 'kill_query_request', [TKillQueryReq, None], None, ),  # 26
)
all_structs.append(TCacheJarParams)
TCacheJarParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hdfs_location', None, None, ),  # 1
)
all_structs.append(TCacheJarResult)
TCacheJarResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.STRING, 'local_path', None, None, ),  # 2
)
all_structs.append(TSymbolLookupParams)
TSymbolLookupParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'location', None, None, ),  # 1
    (2, TType.STRING, 'symbol', None, None, ),  # 2
    (3, TType.I32, 'fn_binary_type', None, None, ),  # 3
    (4, TType.LIST, 'arg_types', (TType.STRUCT, [Types.ttypes.TColumnType, None], False), None, ),  # 4
    (5, TType.BOOL, 'has_var_args', None, None, ),  # 5
    (6, TType.STRUCT, 'ret_arg_type', [Types.ttypes.TColumnType, None], None, ),  # 6
    (7, TType.I32, 'symbol_type', None, None, ),  # 7
    (8, TType.BOOL, 'needs_refresh', None, None, ),  # 8
)
all_structs.append(TSymbolLookupResult)
TSymbolLookupResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'result_code', None, None, ),  # 1
    (2, TType.STRING, 'symbol', None, None, ),  # 2
    (3, TType.STRING, 'error_msg', None, None, ),  # 3
    (4, TType.I64, 'last_modified_time', None, None, ),  # 4
)
all_structs.append(TUpdateCatalogCacheRequest)
TUpdateCatalogCacheRequest.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'is_delta', None, None, ),  # 1
    (2, TType.STRUCT, 'catalog_service_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.LIST, 'updated_objects_deprecated', (TType.STRUCT, [CatalogObjects.ttypes.TCatalogObject, None], False), None, ),  # 3
    (4, TType.LIST, 'removed_objects_deprecated', (TType.STRUCT, [CatalogObjects.ttypes.TCatalogObject, None], False), None, ),  # 4
    (5, TType.I64, 'native_iterator_ptr', None, None, ),  # 5
)
all_structs.append(TUpdateCatalogCacheResponse)
TUpdateCatalogCacheResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'catalog_service_id', [Types.ttypes.TUniqueId, None], None, ),  # 1
    (2, TType.I64, 'catalog_object_version_lower_bound', None, None, ),  # 2
    (3, TType.I64, 'new_catalog_version', None, None, ),  # 3
)
all_structs.append(TExecutorGroupSet)
TExecutorGroupSet.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'curr_num_executors', None, 0, ),  # 1
    (2, TType.I32, 'expected_num_executors', None, 0, ),  # 2
    (3, TType.STRING, 'exec_group_name_prefix', None, None, ),  # 3
    (4, TType.I64, 'max_mem_limit', None, None, ),  # 4
    (5, TType.I32, 'num_cores_per_executor', None, None, ),  # 5
)
all_structs.append(TUpdateExecutorMembershipRequest)
TUpdateExecutorMembershipRequest.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'hostnames', (TType.STRING, None, False), None, ),  # 1
    (2, TType.SET, 'ip_addresses', (TType.STRING, None, False), None, ),  # 2
    (3, TType.LIST, 'exec_group_sets', (TType.STRUCT, [TExecutorGroupSet, None], False), None, ),  # 3
)
all_structs.append(TJvmMemoryPool)
TJvmMemoryPool.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'committed', None, None, ),  # 1
    (2, TType.I64, 'init', None, None, ),  # 2
    (3, TType.I64, 'max', None, None, ),  # 3
    (4, TType.I64, 'used', None, None, ),  # 4
    (5, TType.I64, 'peak_committed', None, None, ),  # 5
    (6, TType.I64, 'peak_init', None, None, ),  # 6
    (7, TType.I64, 'peak_max', None, None, ),  # 7
    (8, TType.I64, 'peak_used', None, None, ),  # 8
    (9, TType.STRING, 'name', None, None, ),  # 9
)
all_structs.append(TGetJvmMemoryMetricsResponse)
TGetJvmMemoryMetricsResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'memory_pools', (TType.STRUCT, [TJvmMemoryPool, None], False), None, ),  # 1
    (2, TType.I64, 'gc_num_warn_threshold_exceeded', None, None, ),  # 2
    (3, TType.I64, 'gc_num_info_threshold_exceeded', None, None, ),  # 3
    (4, TType.I64, 'gc_total_extra_sleep_time_millis', None, None, ),  # 4
    (5, TType.I64, 'gc_count', None, None, ),  # 5
    (6, TType.I64, 'gc_time_millis', None, None, ),  # 6
)
all_structs.append(TJvmThreadInfo)
TJvmThreadInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'summary', None, None, ),  # 1
    (2, TType.I64, 'cpu_time_in_ns', None, None, ),  # 2
    (3, TType.I64, 'user_time_in_ns', None, None, ),  # 3
    (4, TType.I64, 'blocked_count', None, None, ),  # 4
    (5, TType.I64, 'blocked_time_in_ms', None, None, ),  # 5
    (6, TType.BOOL, 'is_in_native', None, None, ),  # 6
)
all_structs.append(TGetJvmThreadsInfoRequest)
TGetJvmThreadsInfoRequest.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'get_complete_info', None, None, ),  # 1
)
all_structs.append(TGetJvmThreadsInfoResponse)
TGetJvmThreadsInfoResponse.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'total_thread_count', None, None, ),  # 1
    (2, TType.I32, 'daemon_thread_count', None, None, ),  # 2
    (3, TType.I32, 'peak_thread_count', None, None, ),  # 3
    (4, TType.LIST, 'threads', (TType.STRUCT, [TJvmThreadInfo, None], False), None, ),  # 4
)
all_structs.append(TGetJMXJsonResponse)
TGetJMXJsonResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jmx_json', None, None, ),  # 1
)
all_structs.append(TGetHadoopConfigRequest)
TGetHadoopConfigRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', None, None, ),  # 1
)
all_structs.append(TGetHadoopConfigResponse)
TGetHadoopConfigResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'value', None, None, ),  # 1
)
all_structs.append(TGetAllHadoopConfigsResponse)
TGetAllHadoopConfigsResponse.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'configs', (TType.STRING, None, TType.STRING, None, False), None, ),  # 1
)
all_structs.append(TGetHadoopGroupsRequest)
TGetHadoopGroupsRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'user', None, None, ),  # 1
)
all_structs.append(TGetHadoopGroupsResponse)
TGetHadoopGroupsResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'groups', (TType.STRING, None, False), None, ),  # 1
)
all_structs.append(TBuildTestDescriptorTableParams)
TBuildTestDescriptorTableParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'slot_types', (TType.LIST, (TType.STRUCT, [Types.ttypes.TColumnType, None], False), False), None, ),  # 1
)
all_structs.append(TTestCaseData)
TTestCaseData.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'query_stmt', None, None, ),  # 1
    (2, TType.LIST, 'tables_and_views', (TType.STRUCT, [CatalogObjects.ttypes.TTable, None], False), None, ),  # 2
    (3, TType.LIST, 'dbs', (TType.STRUCT, [CatalogObjects.ttypes.TDatabase, None], False), None, ),  # 3
    (4, TType.STRING, 'testcase_data_path', None, None, ),  # 4
    (5, TType.STRING, 'impala_version', None, None, ),  # 5
)
all_structs.append(TQueryCompleteContext)
TQueryCompleteContext.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'lineage_string', None, None, ),  # 1
)
all_structs.append(TWrappedHttpRequest)
TWrappedHttpRequest.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'method', None, None, ),  # 1
    (2, TType.STRING, 'server_name', None, None, ),  # 2
    (3, TType.I32, 'server_port', None, None, ),  # 3
    (4, TType.STRING, 'path', None, None, ),  # 4
    (5, TType.MAP, 'params', (TType.STRING, None, TType.STRING, None, False), None, ),  # 5
    (6, TType.MAP, 'headers', (TType.STRING, None, TType.STRING, None, False), None, ),  # 6
    (7, TType.MAP, 'cookies', (TType.STRING, None, TType.STRING, None, False), None, ),  # 7
    (8, TType.STRING, 'content', None, None, ),  # 8
    (9, TType.STRING, 'remote_ip', None, None, ),  # 9
    (10, TType.BOOL, 'secure', None, None, ),  # 10
)
all_structs.append(TWrappedHttpResponse)
TWrappedHttpResponse.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'status_code', None, None, ),  # 1
    (2, TType.STRING, 'status_text', None, None, ),  # 2
    (3, TType.MAP, 'headers', (TType.STRING, None, TType.STRING, None, False), None, ),  # 3
    (4, TType.MAP, 'cookies', (TType.STRING, None, TType.STRING, None, False), None, ),  # 4
    (5, TType.STRING, 'content', None, None, ),  # 5
    (6, TType.STRING, 'content_type', None, None, ),  # 6
)
fix_spec(all_structs)
del all_structs
