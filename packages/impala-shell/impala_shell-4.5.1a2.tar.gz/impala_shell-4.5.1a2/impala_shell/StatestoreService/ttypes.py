#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:no_utf8strings
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import Status.ttypes
import Types.ttypes
import CatalogService.ttypes

from thrift.transport import TTransport
all_structs = []


class StatestoreServiceVersion(object):
    V1 = 0
    V2 = 1

    _VALUES_TO_NAMES = {
        0: "V1",
        1: "V2",
    }

    _NAMES_TO_VALUES = {
        "V1": 0,
        "V2": 1,
    }


class TStatestoreSubscriberType(object):
    UNKNOWN = 0
    ADMISSIOND = 1
    CATALOGD = 2
    COORDINATOR = 3
    EXECUTOR = 4
    COORDINATOR_EXECUTOR = 5

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "ADMISSIOND",
        2: "CATALOGD",
        3: "COORDINATOR",
        4: "EXECUTOR",
        5: "COORDINATOR_EXECUTOR",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "ADMISSIOND": 1,
        "CATALOGD": 2,
        "COORDINATOR": 3,
        "EXECUTOR": 4,
        "COORDINATOR_EXECUTOR": 5,
    }


class TStatestoreConnState(object):
    OK = 0
    FAILED = 1
    UNKNOWN = 2

    _VALUES_TO_NAMES = {
        0: "OK",
        1: "FAILED",
        2: "UNKNOWN",
    }

    _NAMES_TO_VALUES = {
        "OK": 0,
        "FAILED": 1,
        "UNKNOWN": 2,
    }


class THeavyMemoryQuery(object):
    """
    Attributes:
     - memory_consumed
     - queryId

    """


    def __init__(self, memory_consumed=None, queryId=None,):
        self.memory_consumed = memory_consumed
        self.queryId = queryId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.memory_consumed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.queryId = Types.ttypes.TUniqueId()
                    self.queryId.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THeavyMemoryQuery')
        if self.memory_consumed is not None:
            oprot.writeFieldBegin('memory_consumed', TType.I64, 1)
            oprot.writeI64(self.memory_consumed)
            oprot.writeFieldEnd()
        if self.queryId is not None:
            oprot.writeFieldBegin('queryId', TType.STRUCT, 2)
            self.queryId.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.memory_consumed is None:
            raise TProtocolException(message='Required field memory_consumed is unset!')
        if self.queryId is None:
            raise TProtocolException(message='Required field queryId is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPoolStats(object):
    """
    Attributes:
     - num_admitted_running
     - num_queued
     - backend_mem_reserved
     - heavy_memory_queries
     - min_memory_consumed
     - max_memory_consumed
     - total_memory_consumed
     - num_running
     - user_loads

    """


    def __init__(self, num_admitted_running=None, num_queued=None, backend_mem_reserved=None, heavy_memory_queries=None, min_memory_consumed=None, max_memory_consumed=None, total_memory_consumed=None, num_running=None, user_loads=None,):
        self.num_admitted_running = num_admitted_running
        self.num_queued = num_queued
        self.backend_mem_reserved = backend_mem_reserved
        self.heavy_memory_queries = heavy_memory_queries
        self.min_memory_consumed = min_memory_consumed
        self.max_memory_consumed = max_memory_consumed
        self.total_memory_consumed = total_memory_consumed
        self.num_running = num_running
        self.user_loads = user_loads

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.num_admitted_running = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.num_queued = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.backend_mem_reserved = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.heavy_memory_queries = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = THeavyMemoryQuery()
                        _elem5.read(iprot)
                        self.heavy_memory_queries.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.min_memory_consumed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.max_memory_consumed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.total_memory_consumed = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.num_running = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.user_loads = {}
                    (_ktype7, _vtype8, _size6) = iprot.readMapBegin()
                    for _i10 in range(_size6):
                        _key11 = iprot.readString()
                        _val12 = iprot.readI64()
                        self.user_loads[_key11] = _val12
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPoolStats')
        if self.num_admitted_running is not None:
            oprot.writeFieldBegin('num_admitted_running', TType.I64, 1)
            oprot.writeI64(self.num_admitted_running)
            oprot.writeFieldEnd()
        if self.num_queued is not None:
            oprot.writeFieldBegin('num_queued', TType.I64, 2)
            oprot.writeI64(self.num_queued)
            oprot.writeFieldEnd()
        if self.backend_mem_reserved is not None:
            oprot.writeFieldBegin('backend_mem_reserved', TType.I64, 3)
            oprot.writeI64(self.backend_mem_reserved)
            oprot.writeFieldEnd()
        if self.heavy_memory_queries is not None:
            oprot.writeFieldBegin('heavy_memory_queries', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.heavy_memory_queries))
            for iter13 in self.heavy_memory_queries:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.min_memory_consumed is not None:
            oprot.writeFieldBegin('min_memory_consumed', TType.I64, 5)
            oprot.writeI64(self.min_memory_consumed)
            oprot.writeFieldEnd()
        if self.max_memory_consumed is not None:
            oprot.writeFieldBegin('max_memory_consumed', TType.I64, 6)
            oprot.writeI64(self.max_memory_consumed)
            oprot.writeFieldEnd()
        if self.total_memory_consumed is not None:
            oprot.writeFieldBegin('total_memory_consumed', TType.I64, 7)
            oprot.writeI64(self.total_memory_consumed)
            oprot.writeFieldEnd()
        if self.num_running is not None:
            oprot.writeFieldBegin('num_running', TType.I64, 8)
            oprot.writeI64(self.num_running)
            oprot.writeFieldEnd()
        if self.user_loads is not None:
            oprot.writeFieldBegin('user_loads', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.user_loads))
            for kiter14, viter15 in self.user_loads.items():
                oprot.writeString(kiter14)
                oprot.writeI64(viter15)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_admitted_running is None:
            raise TProtocolException(message='Required field num_admitted_running is unset!')
        if self.num_queued is None:
            raise TProtocolException(message='Required field num_queued is unset!')
        if self.backend_mem_reserved is None:
            raise TProtocolException(message='Required field backend_mem_reserved is unset!')
        if self.heavy_memory_queries is None:
            raise TProtocolException(message='Required field heavy_memory_queries is unset!')
        if self.min_memory_consumed is None:
            raise TProtocolException(message='Required field min_memory_consumed is unset!')
        if self.max_memory_consumed is None:
            raise TProtocolException(message='Required field max_memory_consumed is unset!')
        if self.total_memory_consumed is None:
            raise TProtocolException(message='Required field total_memory_consumed is unset!')
        if self.num_running is None:
            raise TProtocolException(message='Required field num_running is unset!')
        if self.user_loads is None:
            raise TProtocolException(message='Required field user_loads is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THostStats(object):
    """
    Attributes:
     - mem_reserved
     - mem_admitted
     - num_admitted
     - slots_in_use

    """


    def __init__(self, mem_reserved=None, mem_admitted=None, num_admitted=None, slots_in_use=None,):
        self.mem_reserved = mem_reserved
        self.mem_admitted = mem_admitted
        self.num_admitted = num_admitted
        self.slots_in_use = slots_in_use

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mem_reserved = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.mem_admitted = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_admitted = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.slots_in_use = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THostStats')
        if self.mem_reserved is not None:
            oprot.writeFieldBegin('mem_reserved', TType.I64, 1)
            oprot.writeI64(self.mem_reserved)
            oprot.writeFieldEnd()
        if self.mem_admitted is not None:
            oprot.writeFieldBegin('mem_admitted', TType.I64, 2)
            oprot.writeI64(self.mem_admitted)
            oprot.writeFieldEnd()
        if self.num_admitted is not None:
            oprot.writeFieldBegin('num_admitted', TType.I64, 3)
            oprot.writeI64(self.num_admitted)
            oprot.writeFieldEnd()
        if self.slots_in_use is not None:
            oprot.writeFieldBegin('slots_in_use', TType.I64, 4)
            oprot.writeI64(self.slots_in_use)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.mem_reserved is None:
            raise TProtocolException(message='Required field mem_reserved is unset!')
        if self.mem_admitted is None:
            raise TProtocolException(message='Required field mem_admitted is unset!')
        if self.num_admitted is None:
            raise TProtocolException(message='Required field num_admitted is unset!')
        if self.slots_in_use is None:
            raise TProtocolException(message='Required field slots_in_use is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPerHostStatsUpdateElement(object):
    """
    Attributes:
     - host_addr
     - stats

    """


    def __init__(self, host_addr=None, stats=None,):
        self.host_addr = host_addr
        self.stats = stats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.host_addr = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.stats = THostStats()
                    self.stats.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPerHostStatsUpdateElement')
        if self.host_addr is not None:
            oprot.writeFieldBegin('host_addr', TType.STRING, 1)
            oprot.writeString(self.host_addr)
            oprot.writeFieldEnd()
        if self.stats is not None:
            oprot.writeFieldBegin('stats', TType.STRUCT, 2)
            self.stats.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.host_addr is None:
            raise TProtocolException(message='Required field host_addr is unset!')
        if self.stats is None:
            raise TProtocolException(message='Required field stats is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPerHostStatsUpdate(object):
    """
    Attributes:
     - per_host_stats

    """


    def __init__(self, per_host_stats=None,):
        self.per_host_stats = per_host_stats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.per_host_stats = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = TPerHostStatsUpdateElement()
                        _elem21.read(iprot)
                        self.per_host_stats.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPerHostStatsUpdate')
        if self.per_host_stats is not None:
            oprot.writeFieldBegin('per_host_stats', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.per_host_stats))
            for iter22 in self.per_host_stats:
                iter22.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.per_host_stats is None:
            raise TProtocolException(message='Required field per_host_stats is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTopicItem(object):
    """
    Attributes:
     - key
     - value
     - deleted

    """


    def __init__(self, key=None, value=None, deleted=False,):
        self.key = key
        self.value = value
        self.deleted = deleted

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.deleted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTopicItem')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        if self.deleted is not None:
            oprot.writeFieldBegin('deleted', TType.BOOL, 3)
            oprot.writeBool(self.deleted)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.key is None:
            raise TProtocolException(message='Required field key is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        if self.deleted is None:
            raise TProtocolException(message='Required field deleted is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTopicDelta(object):
    """
    Attributes:
     - topic_name
     - topic_entries
     - is_delta
     - from_version
     - to_version
     - min_subscriber_topic_version
     - clear_topic_entries

    """


    def __init__(self, topic_name=None, topic_entries=None, is_delta=None, from_version=None, to_version=None, min_subscriber_topic_version=None, clear_topic_entries=None,):
        self.topic_name = topic_name
        self.topic_entries = topic_entries
        self.is_delta = is_delta
        self.from_version = from_version
        self.to_version = to_version
        self.min_subscriber_topic_version = min_subscriber_topic_version
        self.clear_topic_entries = clear_topic_entries

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topic_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.topic_entries = []
                    (_etype26, _size23) = iprot.readListBegin()
                    for _i27 in range(_size23):
                        _elem28 = TTopicItem()
                        _elem28.read(iprot)
                        self.topic_entries.append(_elem28)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_delta = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.from_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.to_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.min_subscriber_topic_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.clear_topic_entries = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTopicDelta')
        if self.topic_name is not None:
            oprot.writeFieldBegin('topic_name', TType.STRING, 1)
            oprot.writeString(self.topic_name)
            oprot.writeFieldEnd()
        if self.topic_entries is not None:
            oprot.writeFieldBegin('topic_entries', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.topic_entries))
            for iter29 in self.topic_entries:
                iter29.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_delta is not None:
            oprot.writeFieldBegin('is_delta', TType.BOOL, 3)
            oprot.writeBool(self.is_delta)
            oprot.writeFieldEnd()
        if self.from_version is not None:
            oprot.writeFieldBegin('from_version', TType.I64, 4)
            oprot.writeI64(self.from_version)
            oprot.writeFieldEnd()
        if self.to_version is not None:
            oprot.writeFieldBegin('to_version', TType.I64, 5)
            oprot.writeI64(self.to_version)
            oprot.writeFieldEnd()
        if self.min_subscriber_topic_version is not None:
            oprot.writeFieldBegin('min_subscriber_topic_version', TType.I64, 6)
            oprot.writeI64(self.min_subscriber_topic_version)
            oprot.writeFieldEnd()
        if self.clear_topic_entries is not None:
            oprot.writeFieldBegin('clear_topic_entries', TType.BOOL, 7)
            oprot.writeBool(self.clear_topic_entries)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topic_name is None:
            raise TProtocolException(message='Required field topic_name is unset!')
        if self.topic_entries is None:
            raise TProtocolException(message='Required field topic_entries is unset!')
        if self.is_delta is None:
            raise TProtocolException(message='Required field is_delta is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTopicRegistration(object):
    """
    Attributes:
     - topic_name
     - is_transient
     - populate_min_subscriber_topic_version
     - filter_prefix

    """


    def __init__(self, topic_name=None, is_transient=None, populate_min_subscriber_topic_version=False, filter_prefix=None,):
        self.topic_name = topic_name
        self.is_transient = is_transient
        self.populate_min_subscriber_topic_version = populate_min_subscriber_topic_version
        self.filter_prefix = filter_prefix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.topic_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.is_transient = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.populate_min_subscriber_topic_version = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.filter_prefix = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTopicRegistration')
        if self.topic_name is not None:
            oprot.writeFieldBegin('topic_name', TType.STRING, 1)
            oprot.writeString(self.topic_name)
            oprot.writeFieldEnd()
        if self.is_transient is not None:
            oprot.writeFieldBegin('is_transient', TType.BOOL, 2)
            oprot.writeBool(self.is_transient)
            oprot.writeFieldEnd()
        if self.populate_min_subscriber_topic_version is not None:
            oprot.writeFieldBegin('populate_min_subscriber_topic_version', TType.BOOL, 3)
            oprot.writeBool(self.populate_min_subscriber_topic_version)
            oprot.writeFieldEnd()
        if self.filter_prefix is not None:
            oprot.writeFieldBegin('filter_prefix', TType.STRING, 4)
            oprot.writeString(self.filter_prefix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.topic_name is None:
            raise TProtocolException(message='Required field topic_name is unset!')
        if self.is_transient is None:
            raise TProtocolException(message='Required field is_transient is unset!')
        if self.populate_min_subscriber_topic_version is None:
            raise TProtocolException(message='Required field populate_min_subscriber_topic_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogRegistration(object):
    """
    Attributes:
     - protocol
     - address
     - enable_catalogd_ha
     - force_catalogd_active
     - registration_time

    """


    def __init__(self, protocol=None, address=None, enable_catalogd_ha=None, force_catalogd_active=None, registration_time=None,):
        self.protocol = protocol
        self.address = address
        self.enable_catalogd_ha = enable_catalogd_ha
        self.force_catalogd_active = force_catalogd_active
        self.registration_time = registration_time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.address = Types.ttypes.TNetworkAddress()
                    self.address.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.enable_catalogd_ha = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.force_catalogd_active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.registration_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogRegistration')
        if self.protocol is not None:
            oprot.writeFieldBegin('protocol', TType.I32, 1)
            oprot.writeI32(self.protocol)
            oprot.writeFieldEnd()
        if self.address is not None:
            oprot.writeFieldBegin('address', TType.STRUCT, 2)
            self.address.write(oprot)
            oprot.writeFieldEnd()
        if self.enable_catalogd_ha is not None:
            oprot.writeFieldBegin('enable_catalogd_ha', TType.BOOL, 3)
            oprot.writeBool(self.enable_catalogd_ha)
            oprot.writeFieldEnd()
        if self.force_catalogd_active is not None:
            oprot.writeFieldBegin('force_catalogd_active', TType.BOOL, 4)
            oprot.writeBool(self.force_catalogd_active)
            oprot.writeFieldEnd()
        if self.registration_time is not None:
            oprot.writeFieldBegin('registration_time', TType.I64, 5)
            oprot.writeI64(self.registration_time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol is None:
            raise TProtocolException(message='Required field protocol is unset!')
        if self.address is None:
            raise TProtocolException(message='Required field address is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegisterSubscriberRequest(object):
    """
    Attributes:
     - protocol_version
     - subscriber_id
     - subscriber_location
     - topic_registrations
     - subscriber_type
     - subscribe_catalogd_change
     - catalogd_registration

    """


    def __init__(self, protocol_version=1, subscriber_id=None, subscriber_location=None, topic_registrations=None, subscriber_type=None, subscribe_catalogd_change=None, catalogd_registration=None,):
        self.protocol_version = protocol_version
        self.subscriber_id = subscriber_id
        self.subscriber_location = subscriber_location
        self.topic_registrations = topic_registrations
        self.subscriber_type = subscriber_type
        self.subscribe_catalogd_change = subscribe_catalogd_change
        self.catalogd_registration = catalogd_registration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.subscriber_id = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.subscriber_location = Types.ttypes.TNetworkAddress()
                    self.subscriber_location.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.topic_registrations = []
                    (_etype33, _size30) = iprot.readListBegin()
                    for _i34 in range(_size30):
                        _elem35 = TTopicRegistration()
                        _elem35.read(iprot)
                        self.topic_registrations.append(_elem35)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.subscriber_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.subscribe_catalogd_change = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.catalogd_registration = TCatalogRegistration()
                    self.catalogd_registration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegisterSubscriberRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.subscriber_id is not None:
            oprot.writeFieldBegin('subscriber_id', TType.STRING, 2)
            oprot.writeString(self.subscriber_id)
            oprot.writeFieldEnd()
        if self.subscriber_location is not None:
            oprot.writeFieldBegin('subscriber_location', TType.STRUCT, 3)
            self.subscriber_location.write(oprot)
            oprot.writeFieldEnd()
        if self.topic_registrations is not None:
            oprot.writeFieldBegin('topic_registrations', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.topic_registrations))
            for iter36 in self.topic_registrations:
                iter36.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.subscriber_type is not None:
            oprot.writeFieldBegin('subscriber_type', TType.I32, 5)
            oprot.writeI32(self.subscriber_type)
            oprot.writeFieldEnd()
        if self.subscribe_catalogd_change is not None:
            oprot.writeFieldBegin('subscribe_catalogd_change', TType.BOOL, 6)
            oprot.writeBool(self.subscribe_catalogd_change)
            oprot.writeFieldEnd()
        if self.catalogd_registration is not None:
            oprot.writeFieldBegin('catalogd_registration', TType.STRUCT, 7)
            self.catalogd_registration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.subscriber_id is None:
            raise TProtocolException(message='Required field subscriber_id is unset!')
        if self.subscriber_location is None:
            raise TProtocolException(message='Required field subscriber_location is unset!')
        if self.topic_registrations is None:
            raise TProtocolException(message='Required field topic_registrations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRegisterSubscriberResponse(object):
    """
    Attributes:
     - status
     - registration_id
     - protocol_version
     - statestore_id
     - catalogd_registration
     - catalogd_version
     - statestore_is_active
     - active_statestored_version

    """


    def __init__(self, status=None, registration_id=None, protocol_version=None, statestore_id=None, catalogd_registration=None, catalogd_version=None, statestore_is_active=None, active_statestored_version=None,):
        self.status = status
        self.registration_id = registration_id
        self.protocol_version = protocol_version
        self.statestore_id = statestore_id
        self.catalogd_registration = catalogd_registration
        self.catalogd_version = catalogd_version
        self.statestore_is_active = statestore_is_active
        self.active_statestored_version = active_statestored_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.registration_id = Types.ttypes.TUniqueId()
                    self.registration_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.statestore_id = Types.ttypes.TUniqueId()
                    self.statestore_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.catalogd_registration = TCatalogRegistration()
                    self.catalogd_registration.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.catalogd_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.statestore_is_active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.active_statestored_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRegisterSubscriberResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.registration_id is not None:
            oprot.writeFieldBegin('registration_id', TType.STRUCT, 2)
            self.registration_id.write(oprot)
            oprot.writeFieldEnd()
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 3)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.statestore_id is not None:
            oprot.writeFieldBegin('statestore_id', TType.STRUCT, 4)
            self.statestore_id.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogd_registration is not None:
            oprot.writeFieldBegin('catalogd_registration', TType.STRUCT, 5)
            self.catalogd_registration.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogd_version is not None:
            oprot.writeFieldBegin('catalogd_version', TType.I64, 6)
            oprot.writeI64(self.catalogd_version)
            oprot.writeFieldEnd()
        if self.statestore_is_active is not None:
            oprot.writeFieldBegin('statestore_is_active', TType.BOOL, 7)
            oprot.writeBool(self.statestore_is_active)
            oprot.writeFieldEnd()
        if self.active_statestored_version is not None:
            oprot.writeFieldBegin('active_statestored_version', TType.I64, 8)
            oprot.writeI64(self.active_statestored_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetProtocolVersionRequest(object):
    """
    Attributes:
     - protocol_version

    """


    def __init__(self, protocol_version=1,):
        self.protocol_version = protocol_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetProtocolVersionRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetProtocolVersionResponse(object):
    """
    Attributes:
     - status
     - protocol_version
     - statestore_id

    """


    def __init__(self, status=None, protocol_version=None, statestore_id=None,):
        self.status = status
        self.protocol_version = protocol_version
        self.statestore_id = statestore_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.statestore_id = Types.ttypes.TUniqueId()
                    self.statestore_id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetProtocolVersionResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 2)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.statestore_id is not None:
            oprot.writeFieldBegin('statestore_id', TType.STRUCT, 3)
            self.statestore_id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetStatestoreDebugActionRequest(object):
    """
    Attributes:
     - protocol_version
     - disable_network

    """


    def __init__(self, protocol_version=1, disable_network=None,):
        self.protocol_version = protocol_version
        self.disable_network = disable_network

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.disable_network = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetStatestoreDebugActionRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.disable_network is not None:
            oprot.writeFieldBegin('disable_network', TType.BOOL, 2)
            oprot.writeBool(self.disable_network)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetStatestoreDebugActionResponse(object):
    """
    Attributes:
     - status

    """


    def __init__(self, status=None,):
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetStatestoreDebugActionResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateStateRequest(object):
    """
    Attributes:
     - protocol_version
     - topic_deltas
     - registration_id
     - statestore_id

    """


    def __init__(self, protocol_version=1, topic_deltas=None, registration_id=None, statestore_id=None,):
        self.protocol_version = protocol_version
        self.topic_deltas = topic_deltas
        self.registration_id = registration_id
        self.statestore_id = statestore_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.topic_deltas = {}
                    (_ktype38, _vtype39, _size37) = iprot.readMapBegin()
                    for _i41 in range(_size37):
                        _key42 = iprot.readString()
                        _val43 = TTopicDelta()
                        _val43.read(iprot)
                        self.topic_deltas[_key42] = _val43
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.registration_id = Types.ttypes.TUniqueId()
                    self.registration_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.statestore_id = Types.ttypes.TUniqueId()
                    self.statestore_id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateStateRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.topic_deltas is not None:
            oprot.writeFieldBegin('topic_deltas', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.topic_deltas))
            for kiter44, viter45 in self.topic_deltas.items():
                oprot.writeString(kiter44)
                viter45.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.registration_id is not None:
            oprot.writeFieldBegin('registration_id', TType.STRUCT, 3)
            self.registration_id.write(oprot)
            oprot.writeFieldEnd()
        if self.statestore_id is not None:
            oprot.writeFieldBegin('statestore_id', TType.STRUCT, 4)
            self.statestore_id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.topic_deltas is None:
            raise TProtocolException(message='Required field topic_deltas is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateStateResponse(object):
    """
    Attributes:
     - status
     - topic_updates
     - skipped

    """


    def __init__(self, status=None, topic_updates=None, skipped=None,):
        self.status = status
        self.topic_updates = topic_updates
        self.skipped = skipped

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.topic_updates = []
                    (_etype49, _size46) = iprot.readListBegin()
                    for _i50 in range(_size46):
                        _elem51 = TTopicDelta()
                        _elem51.read(iprot)
                        self.topic_updates.append(_elem51)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.skipped = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateStateResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.topic_updates is not None:
            oprot.writeFieldBegin('topic_updates', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.topic_updates))
            for iter52 in self.topic_updates:
                iter52.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.skipped is not None:
            oprot.writeFieldBegin('skipped', TType.BOOL, 3)
            oprot.writeBool(self.skipped)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.topic_updates is None:
            raise TProtocolException(message='Required field topic_updates is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THeartbeatRequest(object):
    """
    Attributes:
     - protocol_version
     - registration_id
     - statestore_id
     - request_statestore_conn_state

    """


    def __init__(self, protocol_version=1, registration_id=None, statestore_id=None, request_statestore_conn_state=None,):
        self.protocol_version = protocol_version
        self.registration_id = registration_id
        self.statestore_id = statestore_id
        self.request_statestore_conn_state = request_statestore_conn_state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.registration_id = Types.ttypes.TUniqueId()
                    self.registration_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.statestore_id = Types.ttypes.TUniqueId()
                    self.statestore_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.request_statestore_conn_state = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THeartbeatRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.registration_id is not None:
            oprot.writeFieldBegin('registration_id', TType.STRUCT, 2)
            self.registration_id.write(oprot)
            oprot.writeFieldEnd()
        if self.statestore_id is not None:
            oprot.writeFieldBegin('statestore_id', TType.STRUCT, 3)
            self.statestore_id.write(oprot)
            oprot.writeFieldEnd()
        if self.request_statestore_conn_state is not None:
            oprot.writeFieldBegin('request_statestore_conn_state', TType.BOOL, 4)
            oprot.writeBool(self.request_statestore_conn_state)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THeartbeatResponse(object):
    """
    Attributes:
     - status
     - statestore_conn_state

    """


    def __init__(self, status=None, statestore_conn_state=None,):
        self.status = status
        self.statestore_conn_state = statestore_conn_state

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.statestore_conn_state = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THeartbeatResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.statestore_conn_state is not None:
            oprot.writeFieldBegin('statestore_conn_state', TType.I32, 2)
            oprot.writeI32(self.statestore_conn_state)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateCatalogdRequest(object):
    """
    Attributes:
     - protocol_version
     - registration_id
     - statestore_id
     - catalogd_version
     - catalogd_registration

    """


    def __init__(self, protocol_version=1, registration_id=None, statestore_id=None, catalogd_version=None, catalogd_registration=None,):
        self.protocol_version = protocol_version
        self.registration_id = registration_id
        self.statestore_id = statestore_id
        self.catalogd_version = catalogd_version
        self.catalogd_registration = catalogd_registration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.registration_id = Types.ttypes.TUniqueId()
                    self.registration_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.statestore_id = Types.ttypes.TUniqueId()
                    self.statestore_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.catalogd_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.catalogd_registration = TCatalogRegistration()
                    self.catalogd_registration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateCatalogdRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.registration_id is not None:
            oprot.writeFieldBegin('registration_id', TType.STRUCT, 2)
            self.registration_id.write(oprot)
            oprot.writeFieldEnd()
        if self.statestore_id is not None:
            oprot.writeFieldBegin('statestore_id', TType.STRUCT, 3)
            self.statestore_id.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogd_version is not None:
            oprot.writeFieldBegin('catalogd_version', TType.I64, 4)
            oprot.writeI64(self.catalogd_version)
            oprot.writeFieldEnd()
        if self.catalogd_registration is not None:
            oprot.writeFieldBegin('catalogd_registration', TType.STRUCT, 5)
            self.catalogd_registration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.registration_id is None:
            raise TProtocolException(message='Required field registration_id is unset!')
        if self.statestore_id is None:
            raise TProtocolException(message='Required field statestore_id is unset!')
        if self.catalogd_version is None:
            raise TProtocolException(message='Required field catalogd_version is unset!')
        if self.catalogd_registration is None:
            raise TProtocolException(message='Required field catalogd_registration is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateCatalogdResponse(object):
    """
    Attributes:
     - status
     - skipped

    """


    def __init__(self, status=None, skipped=None,):
        self.status = status
        self.skipped = skipped

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.skipped = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateCatalogdResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.skipped is not None:
            oprot.writeFieldBegin('skipped', TType.BOOL, 2)
            oprot.writeBool(self.skipped)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateStatestoredRoleRequest(object):
    """
    Attributes:
     - protocol_version
     - registration_id
     - statestore_id
     - active_statestored_version
     - is_active
     - catalogd_version
     - catalogd_registration

    """


    def __init__(self, protocol_version=1, registration_id=None, statestore_id=None, active_statestored_version=None, is_active=None, catalogd_version=None, catalogd_registration=None,):
        self.protocol_version = protocol_version
        self.registration_id = registration_id
        self.statestore_id = statestore_id
        self.active_statestored_version = active_statestored_version
        self.is_active = is_active
        self.catalogd_version = catalogd_version
        self.catalogd_registration = catalogd_registration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.registration_id = Types.ttypes.TUniqueId()
                    self.registration_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.statestore_id = Types.ttypes.TUniqueId()
                    self.statestore_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.active_statestored_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.catalogd_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.catalogd_registration = TCatalogRegistration()
                    self.catalogd_registration.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateStatestoredRoleRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.registration_id is not None:
            oprot.writeFieldBegin('registration_id', TType.STRUCT, 2)
            self.registration_id.write(oprot)
            oprot.writeFieldEnd()
        if self.statestore_id is not None:
            oprot.writeFieldBegin('statestore_id', TType.STRUCT, 3)
            self.statestore_id.write(oprot)
            oprot.writeFieldEnd()
        if self.active_statestored_version is not None:
            oprot.writeFieldBegin('active_statestored_version', TType.I64, 4)
            oprot.writeI64(self.active_statestored_version)
            oprot.writeFieldEnd()
        if self.is_active is not None:
            oprot.writeFieldBegin('is_active', TType.BOOL, 5)
            oprot.writeBool(self.is_active)
            oprot.writeFieldEnd()
        if self.catalogd_version is not None:
            oprot.writeFieldBegin('catalogd_version', TType.I64, 6)
            oprot.writeI64(self.catalogd_version)
            oprot.writeFieldEnd()
        if self.catalogd_registration is not None:
            oprot.writeFieldBegin('catalogd_registration', TType.STRUCT, 7)
            self.catalogd_registration.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.registration_id is None:
            raise TProtocolException(message='Required field registration_id is unset!')
        if self.statestore_id is None:
            raise TProtocolException(message='Required field statestore_id is unset!')
        if self.active_statestored_version is None:
            raise TProtocolException(message='Required field active_statestored_version is unset!')
        if self.is_active is None:
            raise TProtocolException(message='Required field is_active is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateStatestoredRoleResponse(object):
    """
    Attributes:
     - status
     - skipped

    """


    def __init__(self, status=None, skipped=None,):
        self.status = status
        self.skipped = skipped

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.skipped = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateStatestoredRoleResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.skipped is not None:
            oprot.writeFieldBegin('skipped', TType.BOOL, 2)
            oprot.writeBool(self.skipped)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStatestoreHaHandshakeRequest(object):
    """
    Attributes:
     - src_protocol_version
     - src_statestore_id
     - src_statestore_address
     - src_force_active

    """


    def __init__(self, src_protocol_version=1, src_statestore_id=None, src_statestore_address=None, src_force_active=None,):
        self.src_protocol_version = src_protocol_version
        self.src_statestore_id = src_statestore_id
        self.src_statestore_address = src_statestore_address
        self.src_force_active = src_force_active

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.src_protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.src_statestore_id = Types.ttypes.TUniqueId()
                    self.src_statestore_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.src_statestore_address = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.src_force_active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStatestoreHaHandshakeRequest')
        if self.src_protocol_version is not None:
            oprot.writeFieldBegin('src_protocol_version', TType.I32, 1)
            oprot.writeI32(self.src_protocol_version)
            oprot.writeFieldEnd()
        if self.src_statestore_id is not None:
            oprot.writeFieldBegin('src_statestore_id', TType.STRUCT, 2)
            self.src_statestore_id.write(oprot)
            oprot.writeFieldEnd()
        if self.src_statestore_address is not None:
            oprot.writeFieldBegin('src_statestore_address', TType.STRING, 3)
            oprot.writeString(self.src_statestore_address)
            oprot.writeFieldEnd()
        if self.src_force_active is not None:
            oprot.writeFieldBegin('src_force_active', TType.BOOL, 4)
            oprot.writeBool(self.src_force_active)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.src_protocol_version is None:
            raise TProtocolException(message='Required field src_protocol_version is unset!')
        if self.src_statestore_id is None:
            raise TProtocolException(message='Required field src_statestore_id is unset!')
        if self.src_statestore_address is None:
            raise TProtocolException(message='Required field src_statestore_address is unset!')
        if self.src_force_active is None:
            raise TProtocolException(message='Required field src_force_active is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStatestoreHaHandshakeResponse(object):
    """
    Attributes:
     - status
     - dst_protocol_version
     - dst_statestore_id
     - dst_statestore_active

    """


    def __init__(self, status=None, dst_protocol_version=1, dst_statestore_id=None, dst_statestore_active=None,):
        self.status = status
        self.dst_protocol_version = dst_protocol_version
        self.dst_statestore_id = dst_statestore_id
        self.dst_statestore_active = dst_statestore_active

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.dst_protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.dst_statestore_id = Types.ttypes.TUniqueId()
                    self.dst_statestore_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.dst_statestore_active = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStatestoreHaHandshakeResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.dst_protocol_version is not None:
            oprot.writeFieldBegin('dst_protocol_version', TType.I32, 2)
            oprot.writeI32(self.dst_protocol_version)
            oprot.writeFieldEnd()
        if self.dst_statestore_id is not None:
            oprot.writeFieldBegin('dst_statestore_id', TType.STRUCT, 3)
            self.dst_statestore_id.write(oprot)
            oprot.writeFieldEnd()
        if self.dst_statestore_active is not None:
            oprot.writeFieldBegin('dst_statestore_active', TType.BOOL, 4)
            oprot.writeBool(self.dst_statestore_active)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.dst_protocol_version is None:
            raise TProtocolException(message='Required field dst_protocol_version is unset!')
        if self.dst_statestore_id is None:
            raise TProtocolException(message='Required field dst_statestore_id is unset!')
        if self.dst_statestore_active is None:
            raise TProtocolException(message='Required field dst_statestore_active is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStatestoreHaHeartbeatRequest(object):
    """
    Attributes:
     - protocol_version
     - dst_statestore_id
     - src_statestore_id

    """


    def __init__(self, protocol_version=1, dst_statestore_id=None, src_statestore_id=None,):
        self.protocol_version = protocol_version
        self.dst_statestore_id = dst_statestore_id
        self.src_statestore_id = src_statestore_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.dst_statestore_id = Types.ttypes.TUniqueId()
                    self.dst_statestore_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.src_statestore_id = Types.ttypes.TUniqueId()
                    self.src_statestore_id.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStatestoreHaHeartbeatRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.dst_statestore_id is not None:
            oprot.writeFieldBegin('dst_statestore_id', TType.STRUCT, 2)
            self.dst_statestore_id.write(oprot)
            oprot.writeFieldEnd()
        if self.src_statestore_id is not None:
            oprot.writeFieldBegin('src_statestore_id', TType.STRUCT, 3)
            self.src_statestore_id.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.dst_statestore_id is None:
            raise TProtocolException(message='Required field dst_statestore_id is unset!')
        if self.src_statestore_id is None:
            raise TProtocolException(message='Required field src_statestore_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStatestoreHaHeartbeatResponse(object):
    """
    Attributes:
     - status

    """


    def __init__(self, status=None,):
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStatestoreHaHeartbeatResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(THeavyMemoryQuery)
THeavyMemoryQuery.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'memory_consumed', None, None, ),  # 1
    (2, TType.STRUCT, 'queryId', [Types.ttypes.TUniqueId, None], None, ),  # 2
)
all_structs.append(TPoolStats)
TPoolStats.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'num_admitted_running', None, None, ),  # 1
    (2, TType.I64, 'num_queued', None, None, ),  # 2
    (3, TType.I64, 'backend_mem_reserved', None, None, ),  # 3
    (4, TType.LIST, 'heavy_memory_queries', (TType.STRUCT, [THeavyMemoryQuery, None], False), None, ),  # 4
    (5, TType.I64, 'min_memory_consumed', None, None, ),  # 5
    (6, TType.I64, 'max_memory_consumed', None, None, ),  # 6
    (7, TType.I64, 'total_memory_consumed', None, None, ),  # 7
    (8, TType.I64, 'num_running', None, None, ),  # 8
    (9, TType.MAP, 'user_loads', (TType.STRING, None, TType.I64, None, False), None, ),  # 9
)
all_structs.append(THostStats)
THostStats.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mem_reserved', None, None, ),  # 1
    (2, TType.I64, 'mem_admitted', None, None, ),  # 2
    (3, TType.I64, 'num_admitted', None, None, ),  # 3
    (4, TType.I64, 'slots_in_use', None, None, ),  # 4
)
all_structs.append(TPerHostStatsUpdateElement)
TPerHostStatsUpdateElement.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'host_addr', None, None, ),  # 1
    (2, TType.STRUCT, 'stats', [THostStats, None], None, ),  # 2
)
all_structs.append(TPerHostStatsUpdate)
TPerHostStatsUpdate.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'per_host_stats', (TType.STRUCT, [TPerHostStatsUpdateElement, None], False), None, ),  # 1
)
all_structs.append(TTopicItem)
TTopicItem.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'key', None, None, ),  # 1
    (2, TType.STRING, 'value', None, None, ),  # 2
    (3, TType.BOOL, 'deleted', None, False, ),  # 3
)
all_structs.append(TTopicDelta)
TTopicDelta.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topic_name', None, None, ),  # 1
    (2, TType.LIST, 'topic_entries', (TType.STRUCT, [TTopicItem, None], False), None, ),  # 2
    (3, TType.BOOL, 'is_delta', None, None, ),  # 3
    (4, TType.I64, 'from_version', None, None, ),  # 4
    (5, TType.I64, 'to_version', None, None, ),  # 5
    (6, TType.I64, 'min_subscriber_topic_version', None, None, ),  # 6
    (7, TType.BOOL, 'clear_topic_entries', None, None, ),  # 7
)
all_structs.append(TTopicRegistration)
TTopicRegistration.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'topic_name', None, None, ),  # 1
    (2, TType.BOOL, 'is_transient', None, None, ),  # 2
    (3, TType.BOOL, 'populate_min_subscriber_topic_version', None, False, ),  # 3
    (4, TType.STRING, 'filter_prefix', None, None, ),  # 4
)
all_structs.append(TCatalogRegistration)
TCatalogRegistration.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol', None, None, ),  # 1
    (2, TType.STRUCT, 'address', [Types.ttypes.TNetworkAddress, None], None, ),  # 2
    (3, TType.BOOL, 'enable_catalogd_ha', None, None, ),  # 3
    (4, TType.BOOL, 'force_catalogd_active', None, None, ),  # 4
    (5, TType.I64, 'registration_time', None, None, ),  # 5
)
all_structs.append(TRegisterSubscriberRequest)
TRegisterSubscriberRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRING, 'subscriber_id', None, None, ),  # 2
    (3, TType.STRUCT, 'subscriber_location', [Types.ttypes.TNetworkAddress, None], None, ),  # 3
    (4, TType.LIST, 'topic_registrations', (TType.STRUCT, [TTopicRegistration, None], False), None, ),  # 4
    (5, TType.I32, 'subscriber_type', None, None, ),  # 5
    (6, TType.BOOL, 'subscribe_catalogd_change', None, None, ),  # 6
    (7, TType.STRUCT, 'catalogd_registration', [TCatalogRegistration, None], None, ),  # 7
)
all_structs.append(TRegisterSubscriberResponse)
TRegisterSubscriberResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'registration_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.I32, 'protocol_version', None, None, ),  # 3
    (4, TType.STRUCT, 'statestore_id', [Types.ttypes.TUniqueId, None], None, ),  # 4
    (5, TType.STRUCT, 'catalogd_registration', [TCatalogRegistration, None], None, ),  # 5
    (6, TType.I64, 'catalogd_version', None, None, ),  # 6
    (7, TType.BOOL, 'statestore_is_active', None, None, ),  # 7
    (8, TType.I64, 'active_statestored_version', None, None, ),  # 8
)
all_structs.append(TGetProtocolVersionRequest)
TGetProtocolVersionRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
)
all_structs.append(TGetProtocolVersionResponse)
TGetProtocolVersionResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.I32, 'protocol_version', None, None, ),  # 2
    (3, TType.STRUCT, 'statestore_id', [Types.ttypes.TUniqueId, None], None, ),  # 3
)
all_structs.append(TSetStatestoreDebugActionRequest)
TSetStatestoreDebugActionRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.BOOL, 'disable_network', None, None, ),  # 2
)
all_structs.append(TSetStatestoreDebugActionResponse)
TSetStatestoreDebugActionResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
)
all_structs.append(TUpdateStateRequest)
TUpdateStateRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.MAP, 'topic_deltas', (TType.STRING, None, TType.STRUCT, [TTopicDelta, None], False), None, ),  # 2
    (3, TType.STRUCT, 'registration_id', [Types.ttypes.TUniqueId, None], None, ),  # 3
    (4, TType.STRUCT, 'statestore_id', [Types.ttypes.TUniqueId, None], None, ),  # 4
)
all_structs.append(TUpdateStateResponse)
TUpdateStateResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.LIST, 'topic_updates', (TType.STRUCT, [TTopicDelta, None], False), None, ),  # 2
    (3, TType.BOOL, 'skipped', None, None, ),  # 3
)
all_structs.append(THeartbeatRequest)
THeartbeatRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'registration_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.STRUCT, 'statestore_id', [Types.ttypes.TUniqueId, None], None, ),  # 3
    (4, TType.BOOL, 'request_statestore_conn_state', None, None, ),  # 4
)
all_structs.append(THeartbeatResponse)
THeartbeatResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.I32, 'statestore_conn_state', None, None, ),  # 2
)
all_structs.append(TUpdateCatalogdRequest)
TUpdateCatalogdRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'registration_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.STRUCT, 'statestore_id', [Types.ttypes.TUniqueId, None], None, ),  # 3
    (4, TType.I64, 'catalogd_version', None, None, ),  # 4
    (5, TType.STRUCT, 'catalogd_registration', [TCatalogRegistration, None], None, ),  # 5
)
all_structs.append(TUpdateCatalogdResponse)
TUpdateCatalogdResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.BOOL, 'skipped', None, None, ),  # 2
)
all_structs.append(TUpdateStatestoredRoleRequest)
TUpdateStatestoredRoleRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'registration_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.STRUCT, 'statestore_id', [Types.ttypes.TUniqueId, None], None, ),  # 3
    (4, TType.I64, 'active_statestored_version', None, None, ),  # 4
    (5, TType.BOOL, 'is_active', None, None, ),  # 5
    (6, TType.I64, 'catalogd_version', None, None, ),  # 6
    (7, TType.STRUCT, 'catalogd_registration', [TCatalogRegistration, None], None, ),  # 7
)
all_structs.append(TUpdateStatestoredRoleResponse)
TUpdateStatestoredRoleResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.BOOL, 'skipped', None, None, ),  # 2
)
all_structs.append(TStatestoreHaHandshakeRequest)
TStatestoreHaHandshakeRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'src_protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'src_statestore_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.STRING, 'src_statestore_address', None, None, ),  # 3
    (4, TType.BOOL, 'src_force_active', None, None, ),  # 4
)
all_structs.append(TStatestoreHaHandshakeResponse)
TStatestoreHaHandshakeResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.I32, 'dst_protocol_version', None, 1, ),  # 2
    (3, TType.STRUCT, 'dst_statestore_id', [Types.ttypes.TUniqueId, None], None, ),  # 3
    (4, TType.BOOL, 'dst_statestore_active', None, None, ),  # 4
)
all_structs.append(TStatestoreHaHeartbeatRequest)
TStatestoreHaHeartbeatRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'dst_statestore_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.STRUCT, 'src_statestore_id', [Types.ttypes.TUniqueId, None], None, ),  # 3
)
all_structs.append(TStatestoreHaHeartbeatResponse)
TStatestoreHaHeartbeatResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
)
fix_spec(all_structs)
del all_structs
