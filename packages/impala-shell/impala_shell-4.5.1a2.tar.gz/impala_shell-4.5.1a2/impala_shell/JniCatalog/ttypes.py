#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:no_utf8strings
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import CatalogObjects.ttypes
import Types.ttypes
import Status.ttypes
import TCLIService.ttypes
import hive_metastore.ttypes

from thrift.transport import TTransport
all_structs = []


class TDdlType(object):
    ALTER_TABLE = 0
    ALTER_VIEW = 1
    CREATE_DATABASE = 2
    CREATE_TABLE = 3
    CREATE_TABLE_AS_SELECT = 4
    CREATE_TABLE_LIKE = 5
    CREATE_VIEW = 6
    CREATE_FUNCTION = 7
    COMPUTE_STATS = 8
    DROP_DATABASE = 9
    DROP_TABLE = 10
    DROP_VIEW = 11
    DROP_FUNCTION = 12
    CREATE_DATA_SOURCE = 13
    DROP_DATA_SOURCE = 14
    DROP_STATS = 15
    CREATE_ROLE = 16
    DROP_ROLE = 17
    GRANT_ROLE = 18
    REVOKE_ROLE = 19
    GRANT_PRIVILEGE = 20
    REVOKE_PRIVILEGE = 21
    TRUNCATE_TABLE = 22
    COMMENT_ON = 23
    ALTER_DATABASE = 24
    COPY_TESTCASE = 25

    _VALUES_TO_NAMES = {
        0: "ALTER_TABLE",
        1: "ALTER_VIEW",
        2: "CREATE_DATABASE",
        3: "CREATE_TABLE",
        4: "CREATE_TABLE_AS_SELECT",
        5: "CREATE_TABLE_LIKE",
        6: "CREATE_VIEW",
        7: "CREATE_FUNCTION",
        8: "COMPUTE_STATS",
        9: "DROP_DATABASE",
        10: "DROP_TABLE",
        11: "DROP_VIEW",
        12: "DROP_FUNCTION",
        13: "CREATE_DATA_SOURCE",
        14: "DROP_DATA_SOURCE",
        15: "DROP_STATS",
        16: "CREATE_ROLE",
        17: "DROP_ROLE",
        18: "GRANT_ROLE",
        19: "REVOKE_ROLE",
        20: "GRANT_PRIVILEGE",
        21: "REVOKE_PRIVILEGE",
        22: "TRUNCATE_TABLE",
        23: "COMMENT_ON",
        24: "ALTER_DATABASE",
        25: "COPY_TESTCASE",
    }

    _NAMES_TO_VALUES = {
        "ALTER_TABLE": 0,
        "ALTER_VIEW": 1,
        "CREATE_DATABASE": 2,
        "CREATE_TABLE": 3,
        "CREATE_TABLE_AS_SELECT": 4,
        "CREATE_TABLE_LIKE": 5,
        "CREATE_VIEW": 6,
        "CREATE_FUNCTION": 7,
        "COMPUTE_STATS": 8,
        "DROP_DATABASE": 9,
        "DROP_TABLE": 10,
        "DROP_VIEW": 11,
        "DROP_FUNCTION": 12,
        "CREATE_DATA_SOURCE": 13,
        "DROP_DATA_SOURCE": 14,
        "DROP_STATS": 15,
        "CREATE_ROLE": 16,
        "DROP_ROLE": 17,
        "GRANT_ROLE": 18,
        "REVOKE_ROLE": 19,
        "GRANT_PRIVILEGE": 20,
        "REVOKE_PRIVILEGE": 21,
        "TRUNCATE_TABLE": 22,
        "COMMENT_ON": 23,
        "ALTER_DATABASE": 24,
        "COPY_TESTCASE": 25,
    }


class TOwnerType(object):
    USER = 0
    ROLE = 1

    _VALUES_TO_NAMES = {
        0: "USER",
        1: "ROLE",
    }

    _NAMES_TO_VALUES = {
        "USER": 0,
        "ROLE": 1,
    }


class TAlterDbType(object):
    SET_OWNER = 0

    _VALUES_TO_NAMES = {
        0: "SET_OWNER",
    }

    _NAMES_TO_VALUES = {
        "SET_OWNER": 0,
    }


class TAlterTableType(object):
    ADD_COLUMNS = 0
    REPLACE_COLUMNS = 1
    ADD_PARTITION = 2
    ADD_DROP_RANGE_PARTITION = 3
    ALTER_COLUMN = 4
    DROP_COLUMN = 5
    DROP_PARTITION = 6
    RENAME_TABLE = 7
    RENAME_VIEW = 8
    SET_FILE_FORMAT = 9
    SET_LOCATION = 10
    SET_TBL_PROPERTIES = 11
    UPDATE_STATS = 12
    SET_CACHED = 13
    RECOVER_PARTITIONS = 14
    SET_ROW_FORMAT = 15
    SET_OWNER = 16
    UNSET_TBL_PROPERTIES = 17
    SET_PARTITION_SPEC = 18
    EXECUTE = 19
    SET_VIEW_PROPERTIES = 20
    UNSET_VIEW_PROPERTIES = 21

    _VALUES_TO_NAMES = {
        0: "ADD_COLUMNS",
        1: "REPLACE_COLUMNS",
        2: "ADD_PARTITION",
        3: "ADD_DROP_RANGE_PARTITION",
        4: "ALTER_COLUMN",
        5: "DROP_COLUMN",
        6: "DROP_PARTITION",
        7: "RENAME_TABLE",
        8: "RENAME_VIEW",
        9: "SET_FILE_FORMAT",
        10: "SET_LOCATION",
        11: "SET_TBL_PROPERTIES",
        12: "UPDATE_STATS",
        13: "SET_CACHED",
        14: "RECOVER_PARTITIONS",
        15: "SET_ROW_FORMAT",
        16: "SET_OWNER",
        17: "UNSET_TBL_PROPERTIES",
        18: "SET_PARTITION_SPEC",
        19: "EXECUTE",
        20: "SET_VIEW_PROPERTIES",
        21: "UNSET_VIEW_PROPERTIES",
    }

    _NAMES_TO_VALUES = {
        "ADD_COLUMNS": 0,
        "REPLACE_COLUMNS": 1,
        "ADD_PARTITION": 2,
        "ADD_DROP_RANGE_PARTITION": 3,
        "ALTER_COLUMN": 4,
        "DROP_COLUMN": 5,
        "DROP_PARTITION": 6,
        "RENAME_TABLE": 7,
        "RENAME_VIEW": 8,
        "SET_FILE_FORMAT": 9,
        "SET_LOCATION": 10,
        "SET_TBL_PROPERTIES": 11,
        "UPDATE_STATS": 12,
        "SET_CACHED": 13,
        "RECOVER_PARTITIONS": 14,
        "SET_ROW_FORMAT": 15,
        "SET_OWNER": 16,
        "UNSET_TBL_PROPERTIES": 17,
        "SET_PARTITION_SPEC": 18,
        "EXECUTE": 19,
        "SET_VIEW_PROPERTIES": 20,
        "UNSET_VIEW_PROPERTIES": 21,
    }


class TRangePartitionOperationType(object):
    ADD = 0
    DROP = 1

    _VALUES_TO_NAMES = {
        0: "ADD",
        1: "DROP",
    }

    _NAMES_TO_VALUES = {
        "ADD": 0,
        "DROP": 1,
    }


class TRollbackType(object):
    TIME_ID = 0
    VERSION_ID = 1

    _VALUES_TO_NAMES = {
        0: "TIME_ID",
        1: "VERSION_ID",
    }

    _NAMES_TO_VALUES = {
        "TIME_ID": 0,
        "VERSION_ID": 1,
    }


class TAlterDbSetOwnerParams(object):
    """
    Attributes:
     - owner_type
     - owner_name
     - server_name

    """


    def __init__(self, owner_type=None, owner_name=None, server_name=None,):
        self.owner_type = owner_type
        self.owner_name = owner_name
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.owner_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.owner_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterDbSetOwnerParams')
        if self.owner_type is not None:
            oprot.writeFieldBegin('owner_type', TType.I32, 1)
            oprot.writeI32(self.owner_type)
            oprot.writeFieldEnd()
        if self.owner_name is not None:
            oprot.writeFieldBegin('owner_name', TType.STRING, 2)
            oprot.writeString(self.owner_name)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 3)
            oprot.writeString(self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.owner_type is None:
            raise TProtocolException(message='Required field owner_type is unset!')
        if self.owner_name is None:
            raise TProtocolException(message='Required field owner_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterDbParams(object):
    """
    Attributes:
     - alter_type
     - db
     - set_owner_params

    """


    def __init__(self, alter_type=None, db=None, set_owner_params=None,):
        self.alter_type = alter_type
        self.db = db
        self.set_owner_params = set_owner_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.alter_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.set_owner_params = TAlterDbSetOwnerParams()
                    self.set_owner_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterDbParams')
        if self.alter_type is not None:
            oprot.writeFieldBegin('alter_type', TType.I32, 1)
            oprot.writeI32(self.alter_type)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 2)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        if self.set_owner_params is not None:
            oprot.writeFieldBegin('set_owner_params', TType.STRUCT, 3)
            self.set_owner_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.alter_type is None:
            raise TProtocolException(message='Required field alter_type is unset!')
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateDbParams(object):
    """
    Attributes:
     - db
     - comment
     - location
     - if_not_exists
     - owner
     - server_name
     - managed_location

    """


    def __init__(self, db=None, comment=None, location=None, if_not_exists=None, owner=None, server_name=None, managed_location=None,):
        self.db = db
        self.comment = comment
        self.location = location
        self.if_not_exists = if_not_exists
        self.owner = owner
        self.server_name = server_name
        self.managed_location = managed_location

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.comment = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.location = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.owner = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.managed_location = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateDbParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 2)
            oprot.writeString(self.comment)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 3)
            oprot.writeString(self.location)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRING, 5)
            oprot.writeString(self.owner)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 6)
            oprot.writeString(self.server_name)
            oprot.writeFieldEnd()
        if self.managed_location is not None:
            oprot.writeFieldBegin('managed_location', TType.STRING, 7)
            oprot.writeString(self.managed_location)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        if self.owner is None:
            raise TProtocolException(message='Required field owner is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateDataSourceParams(object):
    """
    Attributes:
     - data_source
     - if_not_exists

    """


    def __init__(self, data_source=None, if_not_exists=None,):
        self.data_source = data_source
        self.if_not_exists = if_not_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.data_source = CatalogObjects.ttypes.TDataSource()
                    self.data_source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateDataSourceParams')
        if self.data_source is not None:
            oprot.writeFieldBegin('data_source', TType.STRUCT, 1)
            self.data_source.write(oprot)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.data_source is None:
            raise TProtocolException(message='Required field data_source is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropDataSourceParams(object):
    """
    Attributes:
     - data_source
     - if_exists

    """


    def __init__(self, data_source=None, if_exists=None,):
        self.data_source = data_source
        self.if_exists = if_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.data_source = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropDataSourceParams')
        if self.data_source is not None:
            oprot.writeFieldBegin('data_source', TType.STRING, 1)
            oprot.writeString(self.data_source)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.data_source is None:
            raise TProtocolException(message='Required field data_source is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropStatsParams(object):
    """
    Attributes:
     - table_name
     - partition_set

    """


    def __init__(self, table_name=None, partition_set=None,):
        self.table_name = table_name
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = []
                        (_etype9, _size6) = iprot.readListBegin()
                        for _i10 in range(_size6):
                            _elem11 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem11.read(iprot)
                            _elem5.append(_elem11)
                        iprot.readListEnd()
                        self.partition_set.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropStatsParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter12 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter12))
                for iter13 in iter12:
                    iter13.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateFunctionParams(object):
    """
    Attributes:
     - fn
     - if_not_exists

    """


    def __init__(self, fn=None, if_not_exists=None,):
        self.fn = fn
        self.if_not_exists = if_not_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fn = Types.ttypes.TFunction()
                    self.fn.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateFunctionParams')
        if self.fn is not None:
            oprot.writeFieldBegin('fn', TType.STRUCT, 1)
            self.fn.write(oprot)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fn is None:
            raise TProtocolException(message='Required field fn is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableRowFormat(object):
    """
    Attributes:
     - field_terminator
     - line_terminator
     - escaped_by

    """


    def __init__(self, field_terminator=None, line_terminator=None, escaped_by=None,):
        self.field_terminator = field_terminator
        self.line_terminator = line_terminator
        self.escaped_by = escaped_by

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.field_terminator = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.line_terminator = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.escaped_by = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableRowFormat')
        if self.field_terminator is not None:
            oprot.writeFieldBegin('field_terminator', TType.STRING, 1)
            oprot.writeString(self.field_terminator)
            oprot.writeFieldEnd()
        if self.line_terminator is not None:
            oprot.writeFieldBegin('line_terminator', TType.STRING, 2)
            oprot.writeString(self.line_terminator)
            oprot.writeFieldEnd()
        if self.escaped_by is not None:
            oprot.writeFieldBegin('escaped_by', TType.STRING, 3)
            oprot.writeString(self.escaped_by)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsCachingOp(object):
    """
    Attributes:
     - set_cached
     - cache_pool_name
     - replication

    """


    def __init__(self, set_cached=None, cache_pool_name=None, replication=None,):
        self.set_cached = set_cached
        self.cache_pool_name = cache_pool_name
        self.replication = replication

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.set_cached = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.cache_pool_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.replication = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsCachingOp')
        if self.set_cached is not None:
            oprot.writeFieldBegin('set_cached', TType.BOOL, 1)
            oprot.writeBool(self.set_cached)
            oprot.writeFieldEnd()
        if self.cache_pool_name is not None:
            oprot.writeFieldBegin('cache_pool_name', TType.STRING, 2)
            oprot.writeString(self.cache_pool_name)
            oprot.writeFieldEnd()
        if self.replication is not None:
            oprot.writeFieldBegin('replication', TType.I16, 3)
            oprot.writeI16(self.replication)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.set_cached is None:
            raise TProtocolException(message='Required field set_cached is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableOrViewRenameParams(object):
    """
    Attributes:
     - new_table_name

    """


    def __init__(self, new_table_name=None,):
        self.new_table_name = new_table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.new_table_name = CatalogObjects.ttypes.TTableName()
                    self.new_table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableOrViewRenameParams')
        if self.new_table_name is not None:
            oprot.writeFieldBegin('new_table_name', TType.STRUCT, 1)
            self.new_table_name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.new_table_name is None:
            raise TProtocolException(message='Required field new_table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableAddColsParams(object):
    """
    Attributes:
     - columns
     - if_not_exists

    """


    def __init__(self, columns=None, if_not_exists=None,):
        self.columns = columns
        self.if_not_exists = if_not_exists

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = CatalogObjects.ttypes.TColumn()
                        _elem19.read(iprot)
                        self.columns.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableAddColsParams')
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter20 in self.columns:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.if_not_exists is None:
            raise TProtocolException(message='Required field if_not_exists is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableReplaceColsParams(object):
    """
    Attributes:
     - columns

    """


    def __init__(self, columns=None,):
        self.columns = columns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = CatalogObjects.ttypes.TColumn()
                        _elem26.read(iprot)
                        self.columns.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableReplaceColsParams')
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter27 in self.columns:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartitionDef(object):
    """
    Attributes:
     - partition_spec
     - location
     - cache_op

    """


    def __init__(self, partition_spec=None, location=None, cache_op=None,):
        self.partition_spec = partition_spec
        self.location = location
        self.cache_op = cache_op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partition_spec = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = CatalogObjects.ttypes.TPartitionKeyValue()
                        _elem33.read(iprot)
                        self.partition_spec.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.location = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.cache_op = THdfsCachingOp()
                    self.cache_op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartitionDef')
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
            for iter34 in self.partition_spec:
                iter34.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 2)
            oprot.writeString(self.location)
            oprot.writeFieldEnd()
        if self.cache_op is not None:
            oprot.writeFieldBegin('cache_op', TType.STRUCT, 3)
            self.cache_op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partition_spec is None:
            raise TProtocolException(message='Required field partition_spec is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableAddPartitionParams(object):
    """
    Attributes:
     - if_not_exists
     - partitions

    """


    def __init__(self, if_not_exists=None, partitions=None,):
        self.if_not_exists = if_not_exists
        self.partitions = partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = TPartitionDef()
                        _elem40.read(iprot)
                        self.partitions.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableAddPartitionParams')
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 1)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter41 in self.partitions:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.if_not_exists is None:
            raise TProtocolException(message='Required field if_not_exists is unset!')
        if self.partitions is None:
            raise TProtocolException(message='Required field partitions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableAddDropRangePartitionParams(object):
    """
    Attributes:
     - range_partition_spec
     - ignore_errors
     - type

    """


    def __init__(self, range_partition_spec=None, ignore_errors=None, type=None,):
        self.range_partition_spec = range_partition_spec
        self.ignore_errors = ignore_errors
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.range_partition_spec = CatalogObjects.ttypes.TRangePartition()
                    self.range_partition_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.ignore_errors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableAddDropRangePartitionParams')
        if self.range_partition_spec is not None:
            oprot.writeFieldBegin('range_partition_spec', TType.STRUCT, 1)
            self.range_partition_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.ignore_errors is not None:
            oprot.writeFieldBegin('ignore_errors', TType.BOOL, 2)
            oprot.writeBool(self.ignore_errors)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 3)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.range_partition_spec is None:
            raise TProtocolException(message='Required field range_partition_spec is unset!')
        if self.ignore_errors is None:
            raise TProtocolException(message='Required field ignore_errors is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableDropColParams(object):
    """
    Attributes:
     - col_name

    """


    def __init__(self, col_name=None,):
        self.col_name = col_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableDropColParams')
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 1)
            oprot.writeString(self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.col_name is None:
            raise TProtocolException(message='Required field col_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableDropPartitionParams(object):
    """
    Attributes:
     - partition_set
     - if_exists
     - purge
     - iceberg_drop_partition_request

    """


    def __init__(self, partition_set=None, if_exists=None, purge=None, iceberg_drop_partition_request=None,):
        self.partition_set = partition_set
        self.if_exists = if_exists
        self.purge = purge
        self.iceberg_drop_partition_request = iceberg_drop_partition_request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = []
                        (_etype51, _size48) = iprot.readListBegin()
                        for _i52 in range(_size48):
                            _elem53 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem53.read(iprot)
                            _elem47.append(_elem53)
                        iprot.readListEnd()
                        self.partition_set.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.purge = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.iceberg_drop_partition_request = CatalogObjects.ttypes.TIcebergDropPartitionRequest()
                    self.iceberg_drop_partition_request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableDropPartitionParams')
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 1)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter54 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter54))
                for iter55 in iter54:
                    iter55.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        if self.purge is not None:
            oprot.writeFieldBegin('purge', TType.BOOL, 3)
            oprot.writeBool(self.purge)
            oprot.writeFieldEnd()
        if self.iceberg_drop_partition_request is not None:
            oprot.writeFieldBegin('iceberg_drop_partition_request', TType.STRUCT, 4)
            self.iceberg_drop_partition_request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partition_set is None:
            raise TProtocolException(message='Required field partition_set is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        if self.purge is None:
            raise TProtocolException(message='Required field purge is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableAlterColParams(object):
    """
    Attributes:
     - col_name
     - new_col_def

    """


    def __init__(self, col_name=None, new_col_def=None,):
        self.col_name = col_name
        self.new_col_def = new_col_def

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.new_col_def = CatalogObjects.ttypes.TColumn()
                    self.new_col_def.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableAlterColParams')
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 1)
            oprot.writeString(self.col_name)
            oprot.writeFieldEnd()
        if self.new_col_def is not None:
            oprot.writeFieldBegin('new_col_def', TType.STRUCT, 2)
            self.new_col_def.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.col_name is None:
            raise TProtocolException(message='Required field col_name is unset!')
        if self.new_col_def is None:
            raise TProtocolException(message='Required field new_col_def is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetTblPropertiesParams(object):
    """
    Attributes:
     - target
     - properties
     - partition_set

    """


    def __init__(self, target=None, properties=None, partition_set=None,):
        self.target = target
        self.properties = properties
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.target = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.properties = {}
                    (_ktype57, _vtype58, _size56) = iprot.readMapBegin()
                    for _i60 in range(_size56):
                        _key61 = iprot.readString()
                        _val62 = iprot.readString()
                        self.properties[_key61] = _val62
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = []
                        (_etype72, _size69) = iprot.readListBegin()
                        for _i73 in range(_size69):
                            _elem74 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem74.read(iprot)
                            _elem68.append(_elem74)
                        iprot.readListEnd()
                        self.partition_set.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetTblPropertiesParams')
        if self.target is not None:
            oprot.writeFieldBegin('target', TType.I32, 1)
            oprot.writeI32(self.target)
            oprot.writeFieldEnd()
        if self.properties is not None:
            oprot.writeFieldBegin('properties', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.properties))
            for kiter75, viter76 in self.properties.items():
                oprot.writeString(kiter75)
                oprot.writeString(viter76)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter77 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter77))
                for iter78 in iter77:
                    iter78.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.target is None:
            raise TProtocolException(message='Required field target is unset!')
        if self.properties is None:
            raise TProtocolException(message='Required field properties is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetFileFormatParams(object):
    """
    Attributes:
     - file_format
     - partition_set

    """


    def __init__(self, file_format=None, partition_set=None,):
        self.file_format = file_format
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.file_format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = []
                        (_etype88, _size85) = iprot.readListBegin()
                        for _i89 in range(_size85):
                            _elem90 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem90.read(iprot)
                            _elem84.append(_elem90)
                        iprot.readListEnd()
                        self.partition_set.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetFileFormatParams')
        if self.file_format is not None:
            oprot.writeFieldBegin('file_format', TType.I32, 1)
            oprot.writeI32(self.file_format)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter91 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter91))
                for iter92 in iter91:
                    iter92.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.file_format is None:
            raise TProtocolException(message='Required field file_format is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetRowFormatParams(object):
    """
    Attributes:
     - row_format
     - partition_set

    """


    def __init__(self, row_format=None, partition_set=None,):
        self.row_format = row_format
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.row_format = TTableRowFormat()
                    self.row_format.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype96, _size93) = iprot.readListBegin()
                    for _i97 in range(_size93):
                        _elem98 = []
                        (_etype102, _size99) = iprot.readListBegin()
                        for _i103 in range(_size99):
                            _elem104 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem104.read(iprot)
                            _elem98.append(_elem104)
                        iprot.readListEnd()
                        self.partition_set.append(_elem98)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetRowFormatParams')
        if self.row_format is not None:
            oprot.writeFieldBegin('row_format', TType.STRUCT, 1)
            self.row_format.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter105 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter105))
                for iter106 in iter105:
                    iter106.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.row_format is None:
            raise TProtocolException(message='Required field row_format is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetLocationParams(object):
    """
    Attributes:
     - location
     - partition_spec

    """


    def __init__(self, location=None, partition_spec=None,):
        self.location = location
        self.partition_spec = partition_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.location = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_spec = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = CatalogObjects.ttypes.TPartitionKeyValue()
                        _elem112.read(iprot)
                        self.partition_spec.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetLocationParams')
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 1)
            oprot.writeString(self.location)
            oprot.writeFieldEnd()
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
            for iter113 in self.partition_spec:
                iter113.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.location is None:
            raise TProtocolException(message='Required field location is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableOrViewSetOwnerParams(object):
    """
    Attributes:
     - owner_type
     - owner_name
     - server_name

    """


    def __init__(self, owner_type=None, owner_name=None, server_name=None,):
        self.owner_type = owner_type
        self.owner_name = owner_name
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.owner_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.owner_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableOrViewSetOwnerParams')
        if self.owner_type is not None:
            oprot.writeFieldBegin('owner_type', TType.I32, 1)
            oprot.writeI32(self.owner_type)
            oprot.writeFieldEnd()
        if self.owner_name is not None:
            oprot.writeFieldBegin('owner_name', TType.STRING, 2)
            oprot.writeString(self.owner_name)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 3)
            oprot.writeString(self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.owner_type is None:
            raise TProtocolException(message='Required field owner_type is unset!')
        if self.owner_name is None:
            raise TProtocolException(message='Required field owner_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableUpdateStatsParams(object):
    """
    Attributes:
     - table_name
     - table_stats
     - partition_stats
     - column_stats
     - expect_all_partitions
     - is_incremental

    """


    def __init__(self, table_name=None, table_stats=None, partition_stats=None, column_stats=None, expect_all_partitions=None, is_incremental=None,):
        self.table_name = table_name
        self.table_stats = table_stats
        self.partition_stats = partition_stats
        self.column_stats = column_stats
        self.expect_all_partitions = expect_all_partitions
        self.is_incremental = is_incremental

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_stats = CatalogObjects.ttypes.TTableStats()
                    self.table_stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.partition_stats = {}
                    (_ktype115, _vtype116, _size114) = iprot.readMapBegin()
                    for _i118 in range(_size114):
                        _key119 = []
                        (_etype124, _size121) = iprot.readListBegin()
                        for _i125 in range(_size121):
                            _elem126 = iprot.readString()
                            _key119.append(_elem126)
                        iprot.readListEnd()
                        _val120 = CatalogObjects.ttypes.TPartitionStats()
                        _val120.read(iprot)
                        self.partition_stats[_key119] = _val120
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.column_stats = {}
                    (_ktype128, _vtype129, _size127) = iprot.readMapBegin()
                    for _i131 in range(_size127):
                        _key132 = iprot.readString()
                        _val133 = CatalogObjects.ttypes.TColumnStats()
                        _val133.read(iprot)
                        self.column_stats[_key132] = _val133
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.expect_all_partitions = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.is_incremental = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableUpdateStatsParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.table_stats is not None:
            oprot.writeFieldBegin('table_stats', TType.STRUCT, 2)
            self.table_stats.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_stats is not None:
            oprot.writeFieldBegin('partition_stats', TType.MAP, 3)
            oprot.writeMapBegin(TType.LIST, TType.STRUCT, len(self.partition_stats))
            for kiter134, viter135 in self.partition_stats.items():
                oprot.writeListBegin(TType.STRING, len(kiter134))
                for iter136 in kiter134:
                    oprot.writeString(iter136)
                oprot.writeListEnd()
                viter135.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.column_stats is not None:
            oprot.writeFieldBegin('column_stats', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.column_stats))
            for kiter137, viter138 in self.column_stats.items():
                oprot.writeString(kiter137)
                viter138.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.expect_all_partitions is not None:
            oprot.writeFieldBegin('expect_all_partitions', TType.BOOL, 5)
            oprot.writeBool(self.expect_all_partitions)
            oprot.writeFieldEnd()
        if self.is_incremental is not None:
            oprot.writeFieldBegin('is_incremental', TType.BOOL, 6)
            oprot.writeBool(self.is_incremental)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetCachedParams(object):
    """
    Attributes:
     - cache_op
     - partition_set

    """


    def __init__(self, cache_op=None, partition_set=None,):
        self.cache_op = cache_op
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cache_op = THdfsCachingOp()
                    self.cache_op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype142, _size139) = iprot.readListBegin()
                    for _i143 in range(_size139):
                        _elem144 = []
                        (_etype148, _size145) = iprot.readListBegin()
                        for _i149 in range(_size145):
                            _elem150 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem150.read(iprot)
                            _elem144.append(_elem150)
                        iprot.readListEnd()
                        self.partition_set.append(_elem144)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetCachedParams')
        if self.cache_op is not None:
            oprot.writeFieldBegin('cache_op', TType.STRUCT, 1)
            self.cache_op.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 2)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter151 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter151))
                for iter152 in iter151:
                    iter152.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.cache_op is None:
            raise TProtocolException(message='Required field cache_op is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableUnSetTblPropertiesParams(object):
    """
    Attributes:
     - target
     - property_keys
     - if_exists
     - partition_set

    """


    def __init__(self, target=None, property_keys=None, if_exists=None, partition_set=None,):
        self.target = target
        self.property_keys = property_keys
        self.if_exists = if_exists
        self.partition_set = partition_set

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.target = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.property_keys = []
                    (_etype156, _size153) = iprot.readListBegin()
                    for _i157 in range(_size153):
                        _elem158 = iprot.readString()
                        self.property_keys.append(_elem158)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partition_set = []
                    (_etype162, _size159) = iprot.readListBegin()
                    for _i163 in range(_size159):
                        _elem164 = []
                        (_etype168, _size165) = iprot.readListBegin()
                        for _i169 in range(_size165):
                            _elem170 = CatalogObjects.ttypes.TPartitionKeyValue()
                            _elem170.read(iprot)
                            _elem164.append(_elem170)
                        iprot.readListEnd()
                        self.partition_set.append(_elem164)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableUnSetTblPropertiesParams')
        if self.target is not None:
            oprot.writeFieldBegin('target', TType.I32, 1)
            oprot.writeI32(self.target)
            oprot.writeFieldEnd()
        if self.property_keys is not None:
            oprot.writeFieldBegin('property_keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.property_keys))
            for iter171 in self.property_keys:
                oprot.writeString(iter171)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        if self.partition_set is not None:
            oprot.writeFieldBegin('partition_set', TType.LIST, 4)
            oprot.writeListBegin(TType.LIST, len(self.partition_set))
            for iter172 in self.partition_set:
                oprot.writeListBegin(TType.STRUCT, len(iter172))
                for iter173 in iter172:
                    iter173.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.target is None:
            raise TProtocolException(message='Required field target is unset!')
        if self.property_keys is None:
            raise TProtocolException(message='Required field property_keys is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableSetPartitionSpecParams(object):
    """
    Attributes:
     - partition_spec

    """


    def __init__(self, partition_spec=None,):
        self.partition_spec = partition_spec

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.partition_spec = CatalogObjects.ttypes.TIcebergPartitionSpec()
                    self.partition_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableSetPartitionSpecParams')
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.STRUCT, 1)
            self.partition_spec.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.partition_spec is None:
            raise TProtocolException(message='Required field partition_spec is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableExecuteExpireSnapshotsParams(object):
    """
    Attributes:
     - older_than_millis

    """


    def __init__(self, older_than_millis=None,):
        self.older_than_millis = older_than_millis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.older_than_millis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableExecuteExpireSnapshotsParams')
        if self.older_than_millis is not None:
            oprot.writeFieldBegin('older_than_millis', TType.I64, 1)
            oprot.writeI64(self.older_than_millis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.older_than_millis is None:
            raise TProtocolException(message='Required field older_than_millis is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableExecuteRollbackParams(object):
    """
    Attributes:
     - kind
     - timestamp_millis
     - snapshot_id

    """


    def __init__(self, kind=None, timestamp_millis=None, snapshot_id=None,):
        self.kind = kind
        self.timestamp_millis = timestamp_millis
        self.snapshot_id = snapshot_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.kind = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timestamp_millis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.snapshot_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableExecuteRollbackParams')
        if self.kind is not None:
            oprot.writeFieldBegin('kind', TType.I32, 1)
            oprot.writeI32(self.kind)
            oprot.writeFieldEnd()
        if self.timestamp_millis is not None:
            oprot.writeFieldBegin('timestamp_millis', TType.I64, 2)
            oprot.writeI64(self.timestamp_millis)
            oprot.writeFieldEnd()
        if self.snapshot_id is not None:
            oprot.writeFieldBegin('snapshot_id', TType.I64, 3)
            oprot.writeI64(self.snapshot_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.kind is None:
            raise TProtocolException(message='Required field kind is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableExecuteParams(object):
    """
    Attributes:
     - expire_snapshots_params
     - execute_rollback_params

    """


    def __init__(self, expire_snapshots_params=None, execute_rollback_params=None,):
        self.expire_snapshots_params = expire_snapshots_params
        self.execute_rollback_params = execute_rollback_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.expire_snapshots_params = TAlterTableExecuteExpireSnapshotsParams()
                    self.expire_snapshots_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.execute_rollback_params = TAlterTableExecuteRollbackParams()
                    self.execute_rollback_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableExecuteParams')
        if self.expire_snapshots_params is not None:
            oprot.writeFieldBegin('expire_snapshots_params', TType.STRUCT, 1)
            self.expire_snapshots_params.write(oprot)
            oprot.writeFieldEnd()
        if self.execute_rollback_params is not None:
            oprot.writeFieldBegin('execute_rollback_params', TType.STRUCT, 2)
            self.execute_rollback_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAlterTableParams(object):
    """
    Attributes:
     - alter_type
     - table_name
     - rename_params
     - add_cols_params
     - add_partition_params
     - alter_col_params
     - drop_col_params
     - drop_partition_params
     - set_file_format_params
     - set_location_params
     - set_tbl_properties_params
     - update_stats_params
     - set_cached_params
     - add_drop_range_partition_params
     - set_row_format_params
     - set_owner_params
     - replace_cols_params
     - unset_tbl_properties_params
     - set_partition_spec_params
     - set_execute_params

    """


    def __init__(self, alter_type=None, table_name=None, rename_params=None, add_cols_params=None, add_partition_params=None, alter_col_params=None, drop_col_params=None, drop_partition_params=None, set_file_format_params=None, set_location_params=None, set_tbl_properties_params=None, update_stats_params=None, set_cached_params=None, add_drop_range_partition_params=None, set_row_format_params=None, set_owner_params=None, replace_cols_params=None, unset_tbl_properties_params=None, set_partition_spec_params=None, set_execute_params=None,):
        self.alter_type = alter_type
        self.table_name = table_name
        self.rename_params = rename_params
        self.add_cols_params = add_cols_params
        self.add_partition_params = add_partition_params
        self.alter_col_params = alter_col_params
        self.drop_col_params = drop_col_params
        self.drop_partition_params = drop_partition_params
        self.set_file_format_params = set_file_format_params
        self.set_location_params = set_location_params
        self.set_tbl_properties_params = set_tbl_properties_params
        self.update_stats_params = update_stats_params
        self.set_cached_params = set_cached_params
        self.add_drop_range_partition_params = add_drop_range_partition_params
        self.set_row_format_params = set_row_format_params
        self.set_owner_params = set_owner_params
        self.replace_cols_params = replace_cols_params
        self.unset_tbl_properties_params = unset_tbl_properties_params
        self.set_partition_spec_params = set_partition_spec_params
        self.set_execute_params = set_execute_params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.alter_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.rename_params = TAlterTableOrViewRenameParams()
                    self.rename_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.add_cols_params = TAlterTableAddColsParams()
                    self.add_cols_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.add_partition_params = TAlterTableAddPartitionParams()
                    self.add_partition_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.alter_col_params = TAlterTableAlterColParams()
                    self.alter_col_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.drop_col_params = TAlterTableDropColParams()
                    self.drop_col_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.drop_partition_params = TAlterTableDropPartitionParams()
                    self.drop_partition_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.set_file_format_params = TAlterTableSetFileFormatParams()
                    self.set_file_format_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.set_location_params = TAlterTableSetLocationParams()
                    self.set_location_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.set_tbl_properties_params = TAlterTableSetTblPropertiesParams()
                    self.set_tbl_properties_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.update_stats_params = TAlterTableUpdateStatsParams()
                    self.update_stats_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.set_cached_params = TAlterTableSetCachedParams()
                    self.set_cached_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.add_drop_range_partition_params = TAlterTableAddDropRangePartitionParams()
                    self.add_drop_range_partition_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.set_row_format_params = TAlterTableSetRowFormatParams()
                    self.set_row_format_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.set_owner_params = TAlterTableOrViewSetOwnerParams()
                    self.set_owner_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.replace_cols_params = TAlterTableReplaceColsParams()
                    self.replace_cols_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.unset_tbl_properties_params = TAlterTableUnSetTblPropertiesParams()
                    self.unset_tbl_properties_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRUCT:
                    self.set_partition_spec_params = TAlterTableSetPartitionSpecParams()
                    self.set_partition_spec_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.set_execute_params = TAlterTableExecuteParams()
                    self.set_execute_params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAlterTableParams')
        if self.alter_type is not None:
            oprot.writeFieldBegin('alter_type', TType.I32, 1)
            oprot.writeI32(self.alter_type)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.rename_params is not None:
            oprot.writeFieldBegin('rename_params', TType.STRUCT, 3)
            self.rename_params.write(oprot)
            oprot.writeFieldEnd()
        if self.add_cols_params is not None:
            oprot.writeFieldBegin('add_cols_params', TType.STRUCT, 4)
            self.add_cols_params.write(oprot)
            oprot.writeFieldEnd()
        if self.add_partition_params is not None:
            oprot.writeFieldBegin('add_partition_params', TType.STRUCT, 5)
            self.add_partition_params.write(oprot)
            oprot.writeFieldEnd()
        if self.alter_col_params is not None:
            oprot.writeFieldBegin('alter_col_params', TType.STRUCT, 6)
            self.alter_col_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_col_params is not None:
            oprot.writeFieldBegin('drop_col_params', TType.STRUCT, 7)
            self.drop_col_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_partition_params is not None:
            oprot.writeFieldBegin('drop_partition_params', TType.STRUCT, 8)
            self.drop_partition_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_file_format_params is not None:
            oprot.writeFieldBegin('set_file_format_params', TType.STRUCT, 9)
            self.set_file_format_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_location_params is not None:
            oprot.writeFieldBegin('set_location_params', TType.STRUCT, 10)
            self.set_location_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_tbl_properties_params is not None:
            oprot.writeFieldBegin('set_tbl_properties_params', TType.STRUCT, 11)
            self.set_tbl_properties_params.write(oprot)
            oprot.writeFieldEnd()
        if self.update_stats_params is not None:
            oprot.writeFieldBegin('update_stats_params', TType.STRUCT, 12)
            self.update_stats_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_cached_params is not None:
            oprot.writeFieldBegin('set_cached_params', TType.STRUCT, 13)
            self.set_cached_params.write(oprot)
            oprot.writeFieldEnd()
        if self.add_drop_range_partition_params is not None:
            oprot.writeFieldBegin('add_drop_range_partition_params', TType.STRUCT, 14)
            self.add_drop_range_partition_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_row_format_params is not None:
            oprot.writeFieldBegin('set_row_format_params', TType.STRUCT, 15)
            self.set_row_format_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_owner_params is not None:
            oprot.writeFieldBegin('set_owner_params', TType.STRUCT, 16)
            self.set_owner_params.write(oprot)
            oprot.writeFieldEnd()
        if self.replace_cols_params is not None:
            oprot.writeFieldBegin('replace_cols_params', TType.STRUCT, 17)
            self.replace_cols_params.write(oprot)
            oprot.writeFieldEnd()
        if self.unset_tbl_properties_params is not None:
            oprot.writeFieldBegin('unset_tbl_properties_params', TType.STRUCT, 18)
            self.unset_tbl_properties_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_partition_spec_params is not None:
            oprot.writeFieldBegin('set_partition_spec_params', TType.STRUCT, 19)
            self.set_partition_spec_params.write(oprot)
            oprot.writeFieldEnd()
        if self.set_execute_params is not None:
            oprot.writeFieldBegin('set_execute_params', TType.STRUCT, 20)
            self.set_execute_params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.alter_type is None:
            raise TProtocolException(message='Required field alter_type is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTableLikeParams(object):
    """
    Attributes:
     - table_name
     - src_table_name
     - is_external
     - if_not_exists
     - owner
     - file_format
     - comment
     - location
     - sort_columns
     - server_name
     - sorting_order

    """


    def __init__(self, table_name=None, src_table_name=None, is_external=None, if_not_exists=None, owner=None, file_format=None, comment=None, location=None, sort_columns=None, server_name=None, sorting_order=None,):
        self.table_name = table_name
        self.src_table_name = src_table_name
        self.is_external = is_external
        self.if_not_exists = if_not_exists
        self.owner = owner
        self.file_format = file_format
        self.comment = comment
        self.location = location
        self.sort_columns = sort_columns
        self.server_name = server_name
        self.sorting_order = sorting_order

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.src_table_name = CatalogObjects.ttypes.TTableName()
                    self.src_table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_external = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.owner = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.file_format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.comment = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.location = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.sort_columns = []
                    (_etype177, _size174) = iprot.readListBegin()
                    for _i178 in range(_size174):
                        _elem179 = iprot.readString()
                        self.sort_columns.append(_elem179)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.sorting_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTableLikeParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.src_table_name is not None:
            oprot.writeFieldBegin('src_table_name', TType.STRUCT, 2)
            self.src_table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.is_external is not None:
            oprot.writeFieldBegin('is_external', TType.BOOL, 3)
            oprot.writeBool(self.is_external)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 4)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRING, 5)
            oprot.writeString(self.owner)
            oprot.writeFieldEnd()
        if self.file_format is not None:
            oprot.writeFieldBegin('file_format', TType.I32, 6)
            oprot.writeI32(self.file_format)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 7)
            oprot.writeString(self.comment)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 8)
            oprot.writeString(self.location)
            oprot.writeFieldEnd()
        if self.sort_columns is not None:
            oprot.writeFieldBegin('sort_columns', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.sort_columns))
            for iter180 in self.sort_columns:
                oprot.writeString(iter180)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 10)
            oprot.writeString(self.server_name)
            oprot.writeFieldEnd()
        if self.sorting_order is not None:
            oprot.writeFieldBegin('sorting_order', TType.I32, 11)
            oprot.writeI32(self.sorting_order)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.src_table_name is None:
            raise TProtocolException(message='Required field src_table_name is unset!')
        if self.is_external is None:
            raise TProtocolException(message='Required field is_external is unset!')
        if self.if_not_exists is None:
            raise TProtocolException(message='Required field if_not_exists is unset!')
        if self.owner is None:
            raise TProtocolException(message='Required field owner is unset!')
        if self.sorting_order is None:
            raise TProtocolException(message='Required field sorting_order is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateTableParams(object):
    """
    Attributes:
     - table_name
     - columns
     - partition_columns
     - file_format
     - is_external
     - if_not_exists
     - owner
     - row_format
     - comment
     - location
     - table_properties
     - serde_properties
     - cache_op
     - partition_by
     - primary_key_column_names
     - sort_columns
     - server_name
     - sorting_order
     - primary_keys
     - foreign_keys
     - partition_spec
     - bucket_info
     - is_primary_key_unique

    """


    def __init__(self, table_name=None, columns=None, partition_columns=None, file_format=None, is_external=None, if_not_exists=None, owner=None, row_format=None, comment=None, location=None, table_properties=None, serde_properties=None, cache_op=None, partition_by=None, primary_key_column_names=None, sort_columns=None, server_name=None, sorting_order=None, primary_keys=None, foreign_keys=None, partition_spec=None, bucket_info=None, is_primary_key_unique=None,):
        self.table_name = table_name
        self.columns = columns
        self.partition_columns = partition_columns
        self.file_format = file_format
        self.is_external = is_external
        self.if_not_exists = if_not_exists
        self.owner = owner
        self.row_format = row_format
        self.comment = comment
        self.location = location
        self.table_properties = table_properties
        self.serde_properties = serde_properties
        self.cache_op = cache_op
        self.partition_by = partition_by
        self.primary_key_column_names = primary_key_column_names
        self.sort_columns = sort_columns
        self.server_name = server_name
        self.sorting_order = sorting_order
        self.primary_keys = primary_keys
        self.foreign_keys = foreign_keys
        self.partition_spec = partition_spec
        self.bucket_info = bucket_info
        self.is_primary_key_unique = is_primary_key_unique

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype184, _size181) = iprot.readListBegin()
                    for _i185 in range(_size181):
                        _elem186 = CatalogObjects.ttypes.TColumn()
                        _elem186.read(iprot)
                        self.columns.append(_elem186)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.partition_columns = []
                    (_etype190, _size187) = iprot.readListBegin()
                    for _i191 in range(_size187):
                        _elem192 = CatalogObjects.ttypes.TColumn()
                        _elem192.read(iprot)
                        self.partition_columns.append(_elem192)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.file_format = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_external = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.owner = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.row_format = TTableRowFormat()
                    self.row_format.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.comment = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.location = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.MAP:
                    self.table_properties = {}
                    (_ktype194, _vtype195, _size193) = iprot.readMapBegin()
                    for _i197 in range(_size193):
                        _key198 = iprot.readString()
                        _val199 = iprot.readString()
                        self.table_properties[_key198] = _val199
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.MAP:
                    self.serde_properties = {}
                    (_ktype201, _vtype202, _size200) = iprot.readMapBegin()
                    for _i204 in range(_size200):
                        _key205 = iprot.readString()
                        _val206 = iprot.readString()
                        self.serde_properties[_key205] = _val206
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.cache_op = THdfsCachingOp()
                    self.cache_op.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.partition_by = []
                    (_etype210, _size207) = iprot.readListBegin()
                    for _i211 in range(_size207):
                        _elem212 = CatalogObjects.ttypes.TKuduPartitionParam()
                        _elem212.read(iprot)
                        self.partition_by.append(_elem212)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.LIST:
                    self.primary_key_column_names = []
                    (_etype216, _size213) = iprot.readListBegin()
                    for _i217 in range(_size213):
                        _elem218 = iprot.readString()
                        self.primary_key_column_names.append(_elem218)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.LIST:
                    self.sort_columns = []
                    (_etype222, _size219) = iprot.readListBegin()
                    for _i223 in range(_size219):
                        _elem224 = iprot.readString()
                        self.sort_columns.append(_elem224)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I32:
                    self.sorting_order = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.LIST:
                    self.primary_keys = []
                    (_etype228, _size225) = iprot.readListBegin()
                    for _i229 in range(_size225):
                        _elem230 = hive_metastore.ttypes.SQLPrimaryKey()
                        _elem230.read(iprot)
                        self.primary_keys.append(_elem230)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.LIST:
                    self.foreign_keys = []
                    (_etype234, _size231) = iprot.readListBegin()
                    for _i235 in range(_size231):
                        _elem236 = hive_metastore.ttypes.SQLForeignKey()
                        _elem236.read(iprot)
                        self.foreign_keys.append(_elem236)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRUCT:
                    self.partition_spec = CatalogObjects.ttypes.TIcebergPartitionSpec()
                    self.partition_spec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRUCT:
                    self.bucket_info = CatalogObjects.ttypes.TBucketInfo()
                    self.bucket_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.BOOL:
                    self.is_primary_key_unique = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateTableParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter237 in self.columns:
                iter237.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_columns is not None:
            oprot.writeFieldBegin('partition_columns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_columns))
            for iter238 in self.partition_columns:
                iter238.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.file_format is not None:
            oprot.writeFieldBegin('file_format', TType.I32, 4)
            oprot.writeI32(self.file_format)
            oprot.writeFieldEnd()
        if self.is_external is not None:
            oprot.writeFieldBegin('is_external', TType.BOOL, 5)
            oprot.writeBool(self.is_external)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 6)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRING, 7)
            oprot.writeString(self.owner)
            oprot.writeFieldEnd()
        if self.row_format is not None:
            oprot.writeFieldBegin('row_format', TType.STRUCT, 8)
            self.row_format.write(oprot)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 9)
            oprot.writeString(self.comment)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRING, 10)
            oprot.writeString(self.location)
            oprot.writeFieldEnd()
        if self.table_properties is not None:
            oprot.writeFieldBegin('table_properties', TType.MAP, 11)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.table_properties))
            for kiter239, viter240 in self.table_properties.items():
                oprot.writeString(kiter239)
                oprot.writeString(viter240)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.serde_properties is not None:
            oprot.writeFieldBegin('serde_properties', TType.MAP, 12)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.serde_properties))
            for kiter241, viter242 in self.serde_properties.items():
                oprot.writeString(kiter241)
                oprot.writeString(viter242)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.cache_op is not None:
            oprot.writeFieldBegin('cache_op', TType.STRUCT, 13)
            self.cache_op.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_by is not None:
            oprot.writeFieldBegin('partition_by', TType.LIST, 14)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_by))
            for iter243 in self.partition_by:
                iter243.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.primary_key_column_names is not None:
            oprot.writeFieldBegin('primary_key_column_names', TType.LIST, 15)
            oprot.writeListBegin(TType.STRING, len(self.primary_key_column_names))
            for iter244 in self.primary_key_column_names:
                oprot.writeString(iter244)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sort_columns is not None:
            oprot.writeFieldBegin('sort_columns', TType.LIST, 16)
            oprot.writeListBegin(TType.STRING, len(self.sort_columns))
            for iter245 in self.sort_columns:
                oprot.writeString(iter245)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 17)
            oprot.writeString(self.server_name)
            oprot.writeFieldEnd()
        if self.sorting_order is not None:
            oprot.writeFieldBegin('sorting_order', TType.I32, 18)
            oprot.writeI32(self.sorting_order)
            oprot.writeFieldEnd()
        if self.primary_keys is not None:
            oprot.writeFieldBegin('primary_keys', TType.LIST, 19)
            oprot.writeListBegin(TType.STRUCT, len(self.primary_keys))
            for iter246 in self.primary_keys:
                iter246.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.foreign_keys is not None:
            oprot.writeFieldBegin('foreign_keys', TType.LIST, 20)
            oprot.writeListBegin(TType.STRUCT, len(self.foreign_keys))
            for iter247 in self.foreign_keys:
                iter247.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.STRUCT, 21)
            self.partition_spec.write(oprot)
            oprot.writeFieldEnd()
        if self.bucket_info is not None:
            oprot.writeFieldBegin('bucket_info', TType.STRUCT, 22)
            self.bucket_info.write(oprot)
            oprot.writeFieldEnd()
        if self.is_primary_key_unique is not None:
            oprot.writeFieldBegin('is_primary_key_unique', TType.BOOL, 23)
            oprot.writeBool(self.is_primary_key_unique)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        if self.file_format is None:
            raise TProtocolException(message='Required field file_format is unset!')
        if self.is_external is None:
            raise TProtocolException(message='Required field is_external is unset!')
        if self.if_not_exists is None:
            raise TProtocolException(message='Required field if_not_exists is unset!')
        if self.owner is None:
            raise TProtocolException(message='Required field owner is unset!')
        if self.sorting_order is None:
            raise TProtocolException(message='Required field sorting_order is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateOrAlterViewParams(object):
    """
    Attributes:
     - view_name
     - columns
     - owner
     - original_view_def
     - expanded_view_def
     - comment
     - if_not_exists
     - server_name
     - tblproperties

    """


    def __init__(self, view_name=None, columns=None, owner=None, original_view_def=None, expanded_view_def=None, comment=None, if_not_exists=None, server_name=None, tblproperties=None,):
        self.view_name = view_name
        self.columns = columns
        self.owner = owner
        self.original_view_def = original_view_def
        self.expanded_view_def = expanded_view_def
        self.comment = comment
        self.if_not_exists = if_not_exists
        self.server_name = server_name
        self.tblproperties = tblproperties

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.view_name = CatalogObjects.ttypes.TTableName()
                    self.view_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype251, _size248) = iprot.readListBegin()
                    for _i252 in range(_size248):
                        _elem253 = CatalogObjects.ttypes.TColumn()
                        _elem253.read(iprot)
                        self.columns.append(_elem253)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.owner = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.original_view_def = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.expanded_view_def = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.comment = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.if_not_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.tblproperties = {}
                    (_ktype255, _vtype256, _size254) = iprot.readMapBegin()
                    for _i258 in range(_size254):
                        _key259 = iprot.readString()
                        _val260 = iprot.readString()
                        self.tblproperties[_key259] = _val260
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateOrAlterViewParams')
        if self.view_name is not None:
            oprot.writeFieldBegin('view_name', TType.STRUCT, 1)
            self.view_name.write(oprot)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter261 in self.columns:
                iter261.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.owner is not None:
            oprot.writeFieldBegin('owner', TType.STRING, 3)
            oprot.writeString(self.owner)
            oprot.writeFieldEnd()
        if self.original_view_def is not None:
            oprot.writeFieldBegin('original_view_def', TType.STRING, 4)
            oprot.writeString(self.original_view_def)
            oprot.writeFieldEnd()
        if self.expanded_view_def is not None:
            oprot.writeFieldBegin('expanded_view_def', TType.STRING, 5)
            oprot.writeString(self.expanded_view_def)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 6)
            oprot.writeString(self.comment)
            oprot.writeFieldEnd()
        if self.if_not_exists is not None:
            oprot.writeFieldBegin('if_not_exists', TType.BOOL, 7)
            oprot.writeBool(self.if_not_exists)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 8)
            oprot.writeString(self.server_name)
            oprot.writeFieldEnd()
        if self.tblproperties is not None:
            oprot.writeFieldBegin('tblproperties', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.tblproperties))
            for kiter262, viter263 in self.tblproperties.items():
                oprot.writeString(kiter262)
                oprot.writeString(viter263)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.view_name is None:
            raise TProtocolException(message='Required field view_name is unset!')
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        if self.owner is None:
            raise TProtocolException(message='Required field owner is unset!')
        if self.original_view_def is None:
            raise TProtocolException(message='Required field original_view_def is unset!')
        if self.expanded_view_def is None:
            raise TProtocolException(message='Required field expanded_view_def is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TComputeStatsParams(object):
    """
    Attributes:
     - table_name
     - tbl_stats_query
     - col_stats_query
     - is_incremental
     - existing_part_stats
     - expected_partitions
     - expect_all_partitions
     - num_partition_cols
     - total_file_bytes

    """


    def __init__(self, table_name=None, tbl_stats_query=None, col_stats_query=None, is_incremental=None, existing_part_stats=None, expected_partitions=None, expect_all_partitions=None, num_partition_cols=None, total_file_bytes=None,):
        self.table_name = table_name
        self.tbl_stats_query = tbl_stats_query
        self.col_stats_query = col_stats_query
        self.is_incremental = is_incremental
        self.existing_part_stats = existing_part_stats
        self.expected_partitions = expected_partitions
        self.expect_all_partitions = expect_all_partitions
        self.num_partition_cols = num_partition_cols
        self.total_file_bytes = total_file_bytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_stats_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.col_stats_query = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_incremental = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.existing_part_stats = []
                    (_etype267, _size264) = iprot.readListBegin()
                    for _i268 in range(_size264):
                        _elem269 = CatalogObjects.ttypes.TPartitionStats()
                        _elem269.read(iprot)
                        self.existing_part_stats.append(_elem269)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.expected_partitions = []
                    (_etype273, _size270) = iprot.readListBegin()
                    for _i274 in range(_size270):
                        _elem275 = []
                        (_etype279, _size276) = iprot.readListBegin()
                        for _i280 in range(_size276):
                            _elem281 = iprot.readString()
                            _elem275.append(_elem281)
                        iprot.readListEnd()
                        self.expected_partitions.append(_elem275)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.expect_all_partitions = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.num_partition_cols = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.total_file_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TComputeStatsParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.tbl_stats_query is not None:
            oprot.writeFieldBegin('tbl_stats_query', TType.STRING, 2)
            oprot.writeString(self.tbl_stats_query)
            oprot.writeFieldEnd()
        if self.col_stats_query is not None:
            oprot.writeFieldBegin('col_stats_query', TType.STRING, 3)
            oprot.writeString(self.col_stats_query)
            oprot.writeFieldEnd()
        if self.is_incremental is not None:
            oprot.writeFieldBegin('is_incremental', TType.BOOL, 4)
            oprot.writeBool(self.is_incremental)
            oprot.writeFieldEnd()
        if self.existing_part_stats is not None:
            oprot.writeFieldBegin('existing_part_stats', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.existing_part_stats))
            for iter282 in self.existing_part_stats:
                iter282.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.expected_partitions is not None:
            oprot.writeFieldBegin('expected_partitions', TType.LIST, 6)
            oprot.writeListBegin(TType.LIST, len(self.expected_partitions))
            for iter283 in self.expected_partitions:
                oprot.writeListBegin(TType.STRING, len(iter283))
                for iter284 in iter283:
                    oprot.writeString(iter284)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.expect_all_partitions is not None:
            oprot.writeFieldBegin('expect_all_partitions', TType.BOOL, 7)
            oprot.writeBool(self.expect_all_partitions)
            oprot.writeFieldEnd()
        if self.num_partition_cols is not None:
            oprot.writeFieldBegin('num_partition_cols', TType.I32, 8)
            oprot.writeI32(self.num_partition_cols)
            oprot.writeFieldEnd()
        if self.total_file_bytes is not None:
            oprot.writeFieldBegin('total_file_bytes', TType.I64, 9)
            oprot.writeI64(self.total_file_bytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCreateDropRoleParams(object):
    """
    Attributes:
     - is_drop
     - role_name

    """


    def __init__(self, is_drop=None, role_name=None,):
        self.is_drop = is_drop
        self.role_name = role_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.is_drop = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.role_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCreateDropRoleParams')
        if self.is_drop is not None:
            oprot.writeFieldBegin('is_drop', TType.BOOL, 1)
            oprot.writeBool(self.is_drop)
            oprot.writeFieldEnd()
        if self.role_name is not None:
            oprot.writeFieldBegin('role_name', TType.STRING, 2)
            oprot.writeString(self.role_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.is_drop is None:
            raise TProtocolException(message='Required field is_drop is unset!')
        if self.role_name is None:
            raise TProtocolException(message='Required field role_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGrantRevokeRoleParams(object):
    """
    Attributes:
     - role_names
     - group_names
     - is_grant

    """


    def __init__(self, role_names=None, group_names=None, is_grant=None,):
        self.role_names = role_names
        self.group_names = group_names
        self.is_grant = is_grant

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.role_names = []
                    (_etype288, _size285) = iprot.readListBegin()
                    for _i289 in range(_size285):
                        _elem290 = iprot.readString()
                        self.role_names.append(_elem290)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype294, _size291) = iprot.readListBegin()
                    for _i295 in range(_size291):
                        _elem296 = iprot.readString()
                        self.group_names.append(_elem296)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_grant = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGrantRevokeRoleParams')
        if self.role_names is not None:
            oprot.writeFieldBegin('role_names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.role_names))
            for iter297 in self.role_names:
                oprot.writeString(iter297)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter298 in self.group_names:
                oprot.writeString(iter298)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_grant is not None:
            oprot.writeFieldBegin('is_grant', TType.BOOL, 3)
            oprot.writeBool(self.is_grant)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.role_names is None:
            raise TProtocolException(message='Required field role_names is unset!')
        if self.group_names is None:
            raise TProtocolException(message='Required field group_names is unset!')
        if self.is_grant is None:
            raise TProtocolException(message='Required field is_grant is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGrantRevokePrivParams(object):
    """
    Attributes:
     - privileges
     - principal_name
     - is_grant
     - has_grant_opt
     - principal_type
     - owner_name

    """


    def __init__(self, privileges=None, principal_name=None, is_grant=None, has_grant_opt=None, principal_type=None, owner_name=None,):
        self.privileges = privileges
        self.principal_name = principal_name
        self.is_grant = is_grant
        self.has_grant_opt = has_grant_opt
        self.principal_type = principal_type
        self.owner_name = owner_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.privileges = []
                    (_etype302, _size299) = iprot.readListBegin()
                    for _i303 in range(_size299):
                        _elem304 = CatalogObjects.ttypes.TPrivilege()
                        _elem304.read(iprot)
                        self.privileges.append(_elem304)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_grant = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.has_grant_opt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.owner_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGrantRevokePrivParams')
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.privileges))
            for iter305 in self.privileges:
                iter305.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 2)
            oprot.writeString(self.principal_name)
            oprot.writeFieldEnd()
        if self.is_grant is not None:
            oprot.writeFieldBegin('is_grant', TType.BOOL, 3)
            oprot.writeBool(self.is_grant)
            oprot.writeFieldEnd()
        if self.has_grant_opt is not None:
            oprot.writeFieldBegin('has_grant_opt', TType.BOOL, 4)
            oprot.writeBool(self.has_grant_opt)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 5)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.owner_name is not None:
            oprot.writeFieldBegin('owner_name', TType.STRING, 6)
            oprot.writeString(self.owner_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.privileges is None:
            raise TProtocolException(message='Required field privileges is unset!')
        if self.principal_name is None:
            raise TProtocolException(message='Required field principal_name is unset!')
        if self.is_grant is None:
            raise TProtocolException(message='Required field is_grant is unset!')
        if self.has_grant_opt is None:
            raise TProtocolException(message='Required field has_grant_opt is unset!')
        if self.principal_type is None:
            raise TProtocolException(message='Required field principal_type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropDbParams(object):
    """
    Attributes:
     - db
     - if_exists
     - cascade
     - server_name

    """


    def __init__(self, db=None, if_exists=None, cascade=None, server_name=None,):
        self.db = db
        self.if_exists = if_exists
        self.cascade = cascade
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.cascade = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropDbParams')
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 1)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        if self.cascade is not None:
            oprot.writeFieldBegin('cascade', TType.BOOL, 3)
            oprot.writeBool(self.cascade)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 4)
            oprot.writeString(self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db is None:
            raise TProtocolException(message='Required field db is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        if self.cascade is None:
            raise TProtocolException(message='Required field cascade is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropTableOrViewParams(object):
    """
    Attributes:
     - table_name
     - if_exists
     - purge
     - is_table
     - server_name

    """


    def __init__(self, table_name=None, if_exists=None, purge=None, is_table=None, server_name=None,):
        self.table_name = table_name
        self.if_exists = if_exists
        self.purge = purge
        self.is_table = is_table
        self.server_name = server_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.purge = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_table = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropTableOrViewParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        if self.purge is not None:
            oprot.writeFieldBegin('purge', TType.BOOL, 3)
            oprot.writeBool(self.purge)
            oprot.writeFieldEnd()
        if self.is_table is not None:
            oprot.writeFieldBegin('is_table', TType.BOOL, 4)
            oprot.writeBool(self.is_table)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 5)
            oprot.writeString(self.server_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        if self.purge is None:
            raise TProtocolException(message='Required field purge is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTruncateParams(object):
    """
    Attributes:
     - table_name
     - if_exists
     - delete_stats

    """


    def __init__(self, table_name=None, if_exists=None, delete_stats=True,):
        self.table_name = table_name
        self.if_exists = if_exists
        self.delete_stats = delete_stats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.delete_stats = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTruncateParams')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 2)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        if self.delete_stats is not None:
            oprot.writeFieldBegin('delete_stats', TType.BOOL, 3)
            oprot.writeBool(self.delete_stats)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDropFunctionParams(object):
    """
    Attributes:
     - fn_name
     - arg_types
     - if_exists
     - signature

    """


    def __init__(self, fn_name=None, arg_types=None, if_exists=None, signature=None,):
        self.fn_name = fn_name
        self.arg_types = arg_types
        self.if_exists = if_exists
        self.signature = signature

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fn_name = Types.ttypes.TFunctionName()
                    self.fn_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.arg_types = []
                    (_etype309, _size306) = iprot.readListBegin()
                    for _i310 in range(_size306):
                        _elem311 = Types.ttypes.TColumnType()
                        _elem311.read(iprot)
                        self.arg_types.append(_elem311)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.if_exists = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.signature = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDropFunctionParams')
        if self.fn_name is not None:
            oprot.writeFieldBegin('fn_name', TType.STRUCT, 1)
            self.fn_name.write(oprot)
            oprot.writeFieldEnd()
        if self.arg_types is not None:
            oprot.writeFieldBegin('arg_types', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.arg_types))
            for iter312 in self.arg_types:
                iter312.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.if_exists is not None:
            oprot.writeFieldBegin('if_exists', TType.BOOL, 3)
            oprot.writeBool(self.if_exists)
            oprot.writeFieldEnd()
        if self.signature is not None:
            oprot.writeFieldBegin('signature', TType.STRING, 4)
            oprot.writeString(self.signature)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fn_name is None:
            raise TProtocolException(message='Required field fn_name is unset!')
        if self.arg_types is None:
            raise TProtocolException(message='Required field arg_types is unset!')
        if self.if_exists is None:
            raise TProtocolException(message='Required field if_exists is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableUsageMetrics(object):
    """
    Attributes:
     - table_name
     - memory_estimate_bytes
     - num_metadata_operations
     - num_files
     - median_table_loading_ns
     - max_table_loading_ns
     - num_table_loading
     - p75_loading_time_ns
     - p95_loading_time_ns
     - p99_loading_time_ns

    """


    def __init__(self, table_name=None, memory_estimate_bytes=None, num_metadata_operations=None, num_files=None, median_table_loading_ns=None, max_table_loading_ns=None, num_table_loading=None, p75_loading_time_ns=None, p95_loading_time_ns=None, p99_loading_time_ns=None,):
        self.table_name = table_name
        self.memory_estimate_bytes = memory_estimate_bytes
        self.num_metadata_operations = num_metadata_operations
        self.num_files = num_files
        self.median_table_loading_ns = median_table_loading_ns
        self.max_table_loading_ns = max_table_loading_ns
        self.num_table_loading = num_table_loading
        self.p75_loading_time_ns = p75_loading_time_ns
        self.p95_loading_time_ns = p95_loading_time_ns
        self.p99_loading_time_ns = p99_loading_time_ns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.memory_estimate_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_metadata_operations = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.num_files = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.median_table_loading_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.max_table_loading_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.num_table_loading = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.p75_loading_time_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.p95_loading_time_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.p99_loading_time_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableUsageMetrics')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.memory_estimate_bytes is not None:
            oprot.writeFieldBegin('memory_estimate_bytes', TType.I64, 2)
            oprot.writeI64(self.memory_estimate_bytes)
            oprot.writeFieldEnd()
        if self.num_metadata_operations is not None:
            oprot.writeFieldBegin('num_metadata_operations', TType.I64, 3)
            oprot.writeI64(self.num_metadata_operations)
            oprot.writeFieldEnd()
        if self.num_files is not None:
            oprot.writeFieldBegin('num_files', TType.I64, 4)
            oprot.writeI64(self.num_files)
            oprot.writeFieldEnd()
        if self.median_table_loading_ns is not None:
            oprot.writeFieldBegin('median_table_loading_ns', TType.I64, 5)
            oprot.writeI64(self.median_table_loading_ns)
            oprot.writeFieldEnd()
        if self.max_table_loading_ns is not None:
            oprot.writeFieldBegin('max_table_loading_ns', TType.I64, 6)
            oprot.writeI64(self.max_table_loading_ns)
            oprot.writeFieldEnd()
        if self.num_table_loading is not None:
            oprot.writeFieldBegin('num_table_loading', TType.I64, 7)
            oprot.writeI64(self.num_table_loading)
            oprot.writeFieldEnd()
        if self.p75_loading_time_ns is not None:
            oprot.writeFieldBegin('p75_loading_time_ns', TType.I64, 8)
            oprot.writeI64(self.p75_loading_time_ns)
            oprot.writeFieldEnd()
        if self.p95_loading_time_ns is not None:
            oprot.writeFieldBegin('p95_loading_time_ns', TType.I64, 9)
            oprot.writeI64(self.p95_loading_time_ns)
            oprot.writeFieldEnd()
        if self.p99_loading_time_ns is not None:
            oprot.writeFieldBegin('p99_loading_time_ns', TType.I64, 10)
            oprot.writeI64(self.p99_loading_time_ns)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetCatalogUsageResponse(object):
    """
    Attributes:
     - large_tables
     - frequently_accessed_tables
     - high_file_count_tables
     - long_metadata_loading_tables

    """


    def __init__(self, large_tables=None, frequently_accessed_tables=None, high_file_count_tables=None, long_metadata_loading_tables=None,):
        self.large_tables = large_tables
        self.frequently_accessed_tables = frequently_accessed_tables
        self.high_file_count_tables = high_file_count_tables
        self.long_metadata_loading_tables = long_metadata_loading_tables

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.large_tables = []
                    (_etype316, _size313) = iprot.readListBegin()
                    for _i317 in range(_size313):
                        _elem318 = TTableUsageMetrics()
                        _elem318.read(iprot)
                        self.large_tables.append(_elem318)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.frequently_accessed_tables = []
                    (_etype322, _size319) = iprot.readListBegin()
                    for _i323 in range(_size319):
                        _elem324 = TTableUsageMetrics()
                        _elem324.read(iprot)
                        self.frequently_accessed_tables.append(_elem324)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.high_file_count_tables = []
                    (_etype328, _size325) = iprot.readListBegin()
                    for _i329 in range(_size325):
                        _elem330 = TTableUsageMetrics()
                        _elem330.read(iprot)
                        self.high_file_count_tables.append(_elem330)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.long_metadata_loading_tables = []
                    (_etype334, _size331) = iprot.readListBegin()
                    for _i335 in range(_size331):
                        _elem336 = TTableUsageMetrics()
                        _elem336.read(iprot)
                        self.long_metadata_loading_tables.append(_elem336)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetCatalogUsageResponse')
        if self.large_tables is not None:
            oprot.writeFieldBegin('large_tables', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.large_tables))
            for iter337 in self.large_tables:
                iter337.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.frequently_accessed_tables is not None:
            oprot.writeFieldBegin('frequently_accessed_tables', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.frequently_accessed_tables))
            for iter338 in self.frequently_accessed_tables:
                iter338.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.high_file_count_tables is not None:
            oprot.writeFieldBegin('high_file_count_tables', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.high_file_count_tables))
            for iter339 in self.high_file_count_tables:
                iter339.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.long_metadata_loading_tables is not None:
            oprot.writeFieldBegin('long_metadata_loading_tables', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.long_metadata_loading_tables))
            for iter340 in self.long_metadata_loading_tables:
                iter340.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.large_tables is None:
            raise TProtocolException(message='Required field large_tables is unset!')
        if self.frequently_accessed_tables is None:
            raise TProtocolException(message='Required field frequently_accessed_tables is unset!')
        if self.high_file_count_tables is None:
            raise TProtocolException(message='Required field high_file_count_tables is unset!')
        if self.long_metadata_loading_tables is None:
            raise TProtocolException(message='Required field long_metadata_loading_tables is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TOperationUsageCounter(object):
    """
    Attributes:
     - catalog_op_name
     - table_name
     - op_counter

    """


    def __init__(self, catalog_op_name=None, table_name=None, op_counter=None,):
        self.catalog_op_name = catalog_op_name
        self.table_name = table_name
        self.op_counter = op_counter

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.catalog_op_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.op_counter = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TOperationUsageCounter')
        if self.catalog_op_name is not None:
            oprot.writeFieldBegin('catalog_op_name', TType.STRING, 1)
            oprot.writeString(self.catalog_op_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.op_counter is not None:
            oprot.writeFieldBegin('op_counter', TType.I64, 3)
            oprot.writeI64(self.op_counter)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_op_name is None:
            raise TProtocolException(message='Required field catalog_op_name is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogOpRecord(object):
    """
    Attributes:
     - thread_id
     - query_id
     - client_ip
     - coordinator_hostname
     - catalog_op_name
     - target_name
     - user
     - start_time_ms
     - finish_time_ms
     - status
     - details

    """


    def __init__(self, thread_id=None, query_id=None, client_ip=None, coordinator_hostname=None, catalog_op_name=None, target_name=None, user=None, start_time_ms=None, finish_time_ms=None, status=None, details=None,):
        self.thread_id = thread_id
        self.query_id = query_id
        self.client_ip = client_ip
        self.coordinator_hostname = coordinator_hostname
        self.catalog_op_name = catalog_op_name
        self.target_name = target_name
        self.user = user
        self.start_time_ms = start_time_ms
        self.finish_time_ms = finish_time_ms
        self.status = status
        self.details = details

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.thread_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.query_id = Types.ttypes.TUniqueId()
                    self.query_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.client_ip = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.coordinator_hostname = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.catalog_op_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.target_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.user = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.start_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.finish_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.status = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.details = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogOpRecord')
        if self.thread_id is not None:
            oprot.writeFieldBegin('thread_id', TType.I64, 1)
            oprot.writeI64(self.thread_id)
            oprot.writeFieldEnd()
        if self.query_id is not None:
            oprot.writeFieldBegin('query_id', TType.STRUCT, 2)
            self.query_id.write(oprot)
            oprot.writeFieldEnd()
        if self.client_ip is not None:
            oprot.writeFieldBegin('client_ip', TType.STRING, 3)
            oprot.writeString(self.client_ip)
            oprot.writeFieldEnd()
        if self.coordinator_hostname is not None:
            oprot.writeFieldBegin('coordinator_hostname', TType.STRING, 4)
            oprot.writeString(self.coordinator_hostname)
            oprot.writeFieldEnd()
        if self.catalog_op_name is not None:
            oprot.writeFieldBegin('catalog_op_name', TType.STRING, 5)
            oprot.writeString(self.catalog_op_name)
            oprot.writeFieldEnd()
        if self.target_name is not None:
            oprot.writeFieldBegin('target_name', TType.STRING, 6)
            oprot.writeString(self.target_name)
            oprot.writeFieldEnd()
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 7)
            oprot.writeString(self.user)
            oprot.writeFieldEnd()
        if self.start_time_ms is not None:
            oprot.writeFieldBegin('start_time_ms', TType.I64, 8)
            oprot.writeI64(self.start_time_ms)
            oprot.writeFieldEnd()
        if self.finish_time_ms is not None:
            oprot.writeFieldBegin('finish_time_ms', TType.I64, 9)
            oprot.writeI64(self.finish_time_ms)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 10)
            oprot.writeString(self.status)
            oprot.writeFieldEnd()
        if self.details is not None:
            oprot.writeFieldBegin('details', TType.STRING, 11)
            oprot.writeString(self.details)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.thread_id is None:
            raise TProtocolException(message='Required field thread_id is unset!')
        if self.query_id is None:
            raise TProtocolException(message='Required field query_id is unset!')
        if self.client_ip is None:
            raise TProtocolException(message='Required field client_ip is unset!')
        if self.coordinator_hostname is None:
            raise TProtocolException(message='Required field coordinator_hostname is unset!')
        if self.catalog_op_name is None:
            raise TProtocolException(message='Required field catalog_op_name is unset!')
        if self.target_name is None:
            raise TProtocolException(message='Required field target_name is unset!')
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        if self.start_time_ms is None:
            raise TProtocolException(message='Required field start_time_ms is unset!')
        if self.finish_time_ms is None:
            raise TProtocolException(message='Required field finish_time_ms is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.details is None:
            raise TProtocolException(message='Required field details is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetOperationUsageResponse(object):
    """
    Attributes:
     - catalog_op_counters
     - in_flight_catalog_operations
     - finished_catalog_operations

    """


    def __init__(self, catalog_op_counters=None, in_flight_catalog_operations=None, finished_catalog_operations=None,):
        self.catalog_op_counters = catalog_op_counters
        self.in_flight_catalog_operations = in_flight_catalog_operations
        self.finished_catalog_operations = finished_catalog_operations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.catalog_op_counters = []
                    (_etype344, _size341) = iprot.readListBegin()
                    for _i345 in range(_size341):
                        _elem346 = TOperationUsageCounter()
                        _elem346.read(iprot)
                        self.catalog_op_counters.append(_elem346)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.in_flight_catalog_operations = []
                    (_etype350, _size347) = iprot.readListBegin()
                    for _i351 in range(_size347):
                        _elem352 = TCatalogOpRecord()
                        _elem352.read(iprot)
                        self.in_flight_catalog_operations.append(_elem352)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.finished_catalog_operations = []
                    (_etype356, _size353) = iprot.readListBegin()
                    for _i357 in range(_size353):
                        _elem358 = TCatalogOpRecord()
                        _elem358.read(iprot)
                        self.finished_catalog_operations.append(_elem358)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetOperationUsageResponse')
        if self.catalog_op_counters is not None:
            oprot.writeFieldBegin('catalog_op_counters', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.catalog_op_counters))
            for iter359 in self.catalog_op_counters:
                iter359.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.in_flight_catalog_operations is not None:
            oprot.writeFieldBegin('in_flight_catalog_operations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.in_flight_catalog_operations))
            for iter360 in self.in_flight_catalog_operations:
                iter360.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.finished_catalog_operations is not None:
            oprot.writeFieldBegin('finished_catalog_operations', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.finished_catalog_operations))
            for iter361 in self.finished_catalog_operations:
                iter361.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_op_counters is None:
            raise TProtocolException(message='Required field catalog_op_counters is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColumnName(object):
    """
    Attributes:
     - table_name
     - column_name

    """


    def __init__(self, table_name=None, column_name=None,):
        self.table_name = table_name
        self.column_name = column_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.column_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColumnName')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.column_name is not None:
            oprot.writeFieldBegin('column_name', TType.STRING, 2)
            oprot.writeString(self.column_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.column_name is None:
            raise TProtocolException(message='Required field column_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCommentOnParams(object):
    """
    Attributes:
     - comment
     - db
     - table_name
     - column_name

    """


    def __init__(self, comment=None, db=None, table_name=None, column_name=None,):
        self.comment = comment
        self.db = db
        self.table_name = table_name
        self.column_name = column_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.comment = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.column_name = TColumnName()
                    self.column_name.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCommentOnParams')
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 1)
            oprot.writeString(self.comment)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRING, 2)
            oprot.writeString(self.db)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 3)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.column_name is not None:
            oprot.writeFieldBegin('column_name', TType.STRUCT, 4)
            self.column_name.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEventProcessorMetrics(object):
    """
    Attributes:
     - status
     - events_received
     - events_skipped
     - events_fetch_duration_mean
     - events_fetch_duration_p75
     - events_fetch_duration_p95
     - events_fetch_duration_p99
     - last_events_fetch_duration
     - events_process_duration_mean
     - events_process_duration_p75
     - events_process_duration_p95
     - events_process_duration_p99
     - last_events_process_duration
     - events_received_1min_rate
     - events_received_5min_rate
     - events_received_15min_rate
     - events_skipped_per_poll_mean
     - last_synced_event_id
     - last_synced_event_time
     - latest_event_id
     - latest_event_time

    """


    def __init__(self, status=None, events_received=None, events_skipped=None, events_fetch_duration_mean=None, events_fetch_duration_p75=None, events_fetch_duration_p95=None, events_fetch_duration_p99=None, last_events_fetch_duration=None, events_process_duration_mean=None, events_process_duration_p75=None, events_process_duration_p95=None, events_process_duration_p99=None, last_events_process_duration=None, events_received_1min_rate=None, events_received_5min_rate=None, events_received_15min_rate=None, events_skipped_per_poll_mean=None, last_synced_event_id=None, last_synced_event_time=None, latest_event_id=None, latest_event_time=None,):
        self.status = status
        self.events_received = events_received
        self.events_skipped = events_skipped
        self.events_fetch_duration_mean = events_fetch_duration_mean
        self.events_fetch_duration_p75 = events_fetch_duration_p75
        self.events_fetch_duration_p95 = events_fetch_duration_p95
        self.events_fetch_duration_p99 = events_fetch_duration_p99
        self.last_events_fetch_duration = last_events_fetch_duration
        self.events_process_duration_mean = events_process_duration_mean
        self.events_process_duration_p75 = events_process_duration_p75
        self.events_process_duration_p95 = events_process_duration_p95
        self.events_process_duration_p99 = events_process_duration_p99
        self.last_events_process_duration = last_events_process_duration
        self.events_received_1min_rate = events_received_1min_rate
        self.events_received_5min_rate = events_received_5min_rate
        self.events_received_15min_rate = events_received_15min_rate
        self.events_skipped_per_poll_mean = events_skipped_per_poll_mean
        self.last_synced_event_id = last_synced_event_id
        self.last_synced_event_time = last_synced_event_time
        self.latest_event_id = latest_event_id
        self.latest_event_time = latest_event_time

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.status = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.events_received = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.events_skipped = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.events_fetch_duration_mean = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.events_fetch_duration_p75 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.events_fetch_duration_p95 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.events_fetch_duration_p99 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.last_events_fetch_duration = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.events_process_duration_mean = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.events_process_duration_p75 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.events_process_duration_p95 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.DOUBLE:
                    self.events_process_duration_p99 = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.DOUBLE:
                    self.last_events_process_duration = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.DOUBLE:
                    self.events_received_1min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.DOUBLE:
                    self.events_received_5min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.DOUBLE:
                    self.events_received_15min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.DOUBLE:
                    self.events_skipped_per_poll_mean = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I64:
                    self.last_synced_event_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.I64:
                    self.last_synced_event_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I64:
                    self.latest_event_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I64:
                    self.latest_event_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEventProcessorMetrics')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRING, 1)
            oprot.writeString(self.status)
            oprot.writeFieldEnd()
        if self.events_received is not None:
            oprot.writeFieldBegin('events_received', TType.I64, 2)
            oprot.writeI64(self.events_received)
            oprot.writeFieldEnd()
        if self.events_skipped is not None:
            oprot.writeFieldBegin('events_skipped', TType.I64, 3)
            oprot.writeI64(self.events_skipped)
            oprot.writeFieldEnd()
        if self.events_fetch_duration_mean is not None:
            oprot.writeFieldBegin('events_fetch_duration_mean', TType.DOUBLE, 4)
            oprot.writeDouble(self.events_fetch_duration_mean)
            oprot.writeFieldEnd()
        if self.events_fetch_duration_p75 is not None:
            oprot.writeFieldBegin('events_fetch_duration_p75', TType.DOUBLE, 5)
            oprot.writeDouble(self.events_fetch_duration_p75)
            oprot.writeFieldEnd()
        if self.events_fetch_duration_p95 is not None:
            oprot.writeFieldBegin('events_fetch_duration_p95', TType.DOUBLE, 6)
            oprot.writeDouble(self.events_fetch_duration_p95)
            oprot.writeFieldEnd()
        if self.events_fetch_duration_p99 is not None:
            oprot.writeFieldBegin('events_fetch_duration_p99', TType.DOUBLE, 7)
            oprot.writeDouble(self.events_fetch_duration_p99)
            oprot.writeFieldEnd()
        if self.last_events_fetch_duration is not None:
            oprot.writeFieldBegin('last_events_fetch_duration', TType.DOUBLE, 8)
            oprot.writeDouble(self.last_events_fetch_duration)
            oprot.writeFieldEnd()
        if self.events_process_duration_mean is not None:
            oprot.writeFieldBegin('events_process_duration_mean', TType.DOUBLE, 9)
            oprot.writeDouble(self.events_process_duration_mean)
            oprot.writeFieldEnd()
        if self.events_process_duration_p75 is not None:
            oprot.writeFieldBegin('events_process_duration_p75', TType.DOUBLE, 10)
            oprot.writeDouble(self.events_process_duration_p75)
            oprot.writeFieldEnd()
        if self.events_process_duration_p95 is not None:
            oprot.writeFieldBegin('events_process_duration_p95', TType.DOUBLE, 11)
            oprot.writeDouble(self.events_process_duration_p95)
            oprot.writeFieldEnd()
        if self.events_process_duration_p99 is not None:
            oprot.writeFieldBegin('events_process_duration_p99', TType.DOUBLE, 12)
            oprot.writeDouble(self.events_process_duration_p99)
            oprot.writeFieldEnd()
        if self.last_events_process_duration is not None:
            oprot.writeFieldBegin('last_events_process_duration', TType.DOUBLE, 13)
            oprot.writeDouble(self.last_events_process_duration)
            oprot.writeFieldEnd()
        if self.events_received_1min_rate is not None:
            oprot.writeFieldBegin('events_received_1min_rate', TType.DOUBLE, 14)
            oprot.writeDouble(self.events_received_1min_rate)
            oprot.writeFieldEnd()
        if self.events_received_5min_rate is not None:
            oprot.writeFieldBegin('events_received_5min_rate', TType.DOUBLE, 15)
            oprot.writeDouble(self.events_received_5min_rate)
            oprot.writeFieldEnd()
        if self.events_received_15min_rate is not None:
            oprot.writeFieldBegin('events_received_15min_rate', TType.DOUBLE, 16)
            oprot.writeDouble(self.events_received_15min_rate)
            oprot.writeFieldEnd()
        if self.events_skipped_per_poll_mean is not None:
            oprot.writeFieldBegin('events_skipped_per_poll_mean', TType.DOUBLE, 17)
            oprot.writeDouble(self.events_skipped_per_poll_mean)
            oprot.writeFieldEnd()
        if self.last_synced_event_id is not None:
            oprot.writeFieldBegin('last_synced_event_id', TType.I64, 18)
            oprot.writeI64(self.last_synced_event_id)
            oprot.writeFieldEnd()
        if self.last_synced_event_time is not None:
            oprot.writeFieldBegin('last_synced_event_time', TType.I64, 19)
            oprot.writeI64(self.last_synced_event_time)
            oprot.writeFieldEnd()
        if self.latest_event_id is not None:
            oprot.writeFieldBegin('latest_event_id', TType.I64, 20)
            oprot.writeI64(self.latest_event_id)
            oprot.writeFieldEnd()
        if self.latest_event_time is not None:
            oprot.writeFieldBegin('latest_event_time', TType.I64, 21)
            oprot.writeI64(self.latest_event_time)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogHmsCacheApiMetrics(object):
    """
    Attributes:
     - api_name
     - api_requests
     - p99_response_time_ms
     - p95_response_time_ms
     - response_time_mean_ms
     - response_time_max_ms
     - response_time_min_ms
     - api_requests_1min_rate
     - api_requests_5min_rate
     - api_requests_15min_rate
     - cache_hit_ratio

    """


    def __init__(self, api_name=None, api_requests=None, p99_response_time_ms=None, p95_response_time_ms=None, response_time_mean_ms=None, response_time_max_ms=None, response_time_min_ms=None, api_requests_1min_rate=None, api_requests_5min_rate=None, api_requests_15min_rate=None, cache_hit_ratio=None,):
        self.api_name = api_name
        self.api_requests = api_requests
        self.p99_response_time_ms = p99_response_time_ms
        self.p95_response_time_ms = p95_response_time_ms
        self.response_time_mean_ms = response_time_mean_ms
        self.response_time_max_ms = response_time_max_ms
        self.response_time_min_ms = response_time_min_ms
        self.api_requests_1min_rate = api_requests_1min_rate
        self.api_requests_5min_rate = api_requests_5min_rate
        self.api_requests_15min_rate = api_requests_15min_rate
        self.cache_hit_ratio = cache_hit_ratio

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.api_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.api_requests = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.p99_response_time_ms = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.p95_response_time_ms = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.response_time_mean_ms = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.response_time_max_ms = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.DOUBLE:
                    self.response_time_min_ms = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.DOUBLE:
                    self.api_requests_1min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.DOUBLE:
                    self.api_requests_5min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.DOUBLE:
                    self.api_requests_15min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.DOUBLE:
                    self.cache_hit_ratio = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogHmsCacheApiMetrics')
        if self.api_name is not None:
            oprot.writeFieldBegin('api_name', TType.STRING, 1)
            oprot.writeString(self.api_name)
            oprot.writeFieldEnd()
        if self.api_requests is not None:
            oprot.writeFieldBegin('api_requests', TType.I64, 2)
            oprot.writeI64(self.api_requests)
            oprot.writeFieldEnd()
        if self.p99_response_time_ms is not None:
            oprot.writeFieldBegin('p99_response_time_ms', TType.DOUBLE, 3)
            oprot.writeDouble(self.p99_response_time_ms)
            oprot.writeFieldEnd()
        if self.p95_response_time_ms is not None:
            oprot.writeFieldBegin('p95_response_time_ms', TType.DOUBLE, 4)
            oprot.writeDouble(self.p95_response_time_ms)
            oprot.writeFieldEnd()
        if self.response_time_mean_ms is not None:
            oprot.writeFieldBegin('response_time_mean_ms', TType.DOUBLE, 5)
            oprot.writeDouble(self.response_time_mean_ms)
            oprot.writeFieldEnd()
        if self.response_time_max_ms is not None:
            oprot.writeFieldBegin('response_time_max_ms', TType.DOUBLE, 6)
            oprot.writeDouble(self.response_time_max_ms)
            oprot.writeFieldEnd()
        if self.response_time_min_ms is not None:
            oprot.writeFieldBegin('response_time_min_ms', TType.DOUBLE, 7)
            oprot.writeDouble(self.response_time_min_ms)
            oprot.writeFieldEnd()
        if self.api_requests_1min_rate is not None:
            oprot.writeFieldBegin('api_requests_1min_rate', TType.DOUBLE, 8)
            oprot.writeDouble(self.api_requests_1min_rate)
            oprot.writeFieldEnd()
        if self.api_requests_5min_rate is not None:
            oprot.writeFieldBegin('api_requests_5min_rate', TType.DOUBLE, 9)
            oprot.writeDouble(self.api_requests_5min_rate)
            oprot.writeFieldEnd()
        if self.api_requests_15min_rate is not None:
            oprot.writeFieldBegin('api_requests_15min_rate', TType.DOUBLE, 10)
            oprot.writeDouble(self.api_requests_15min_rate)
            oprot.writeFieldEnd()
        if self.cache_hit_ratio is not None:
            oprot.writeFieldBegin('cache_hit_ratio', TType.DOUBLE, 11)
            oprot.writeDouble(self.cache_hit_ratio)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.api_name is None:
            raise TProtocolException(message='Required field api_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogdHmsCacheMetrics(object):
    """
    Attributes:
     - api_metrics
     - cache_hit_ratio
     - api_requests
     - api_requests_1min_rate
     - api_requests_5min_rate
     - api_requests_15min_rate

    """


    def __init__(self, api_metrics=None, cache_hit_ratio=None, api_requests=None, api_requests_1min_rate=None, api_requests_5min_rate=None, api_requests_15min_rate=None,):
        self.api_metrics = api_metrics
        self.cache_hit_ratio = cache_hit_ratio
        self.api_requests = api_requests
        self.api_requests_1min_rate = api_requests_1min_rate
        self.api_requests_5min_rate = api_requests_5min_rate
        self.api_requests_15min_rate = api_requests_15min_rate

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.api_metrics = []
                    (_etype365, _size362) = iprot.readListBegin()
                    for _i366 in range(_size362):
                        _elem367 = TCatalogHmsCacheApiMetrics()
                        _elem367.read(iprot)
                        self.api_metrics.append(_elem367)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.cache_hit_ratio = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.api_requests = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.DOUBLE:
                    self.api_requests_1min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.api_requests_5min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.DOUBLE:
                    self.api_requests_15min_rate = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogdHmsCacheMetrics')
        if self.api_metrics is not None:
            oprot.writeFieldBegin('api_metrics', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.api_metrics))
            for iter368 in self.api_metrics:
                iter368.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cache_hit_ratio is not None:
            oprot.writeFieldBegin('cache_hit_ratio', TType.DOUBLE, 2)
            oprot.writeDouble(self.cache_hit_ratio)
            oprot.writeFieldEnd()
        if self.api_requests is not None:
            oprot.writeFieldBegin('api_requests', TType.I64, 3)
            oprot.writeI64(self.api_requests)
            oprot.writeFieldEnd()
        if self.api_requests_1min_rate is not None:
            oprot.writeFieldBegin('api_requests_1min_rate', TType.DOUBLE, 4)
            oprot.writeDouble(self.api_requests_1min_rate)
            oprot.writeFieldEnd()
        if self.api_requests_5min_rate is not None:
            oprot.writeFieldBegin('api_requests_5min_rate', TType.DOUBLE, 5)
            oprot.writeDouble(self.api_requests_5min_rate)
            oprot.writeFieldEnd()
        if self.api_requests_15min_rate is not None:
            oprot.writeFieldBegin('api_requests_15min_rate', TType.DOUBLE, 6)
            oprot.writeDouble(self.api_requests_15min_rate)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.api_metrics is None:
            raise TProtocolException(message='Required field api_metrics is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetCatalogServerMetricsResponse(object):
    """
    Attributes:
     - catalog_partial_fetch_rpc_queue_len
     - event_metrics
     - catalogd_hms_cache_metrics
     - catalog_num_file_metadata_loading_threads
     - catalog_num_file_metadata_loading_tasks
     - catalog_num_tables_loading_file_metadata
     - catalog_num_tables_loading_metadata
     - catalog_num_tables_async_loading_metadata
     - catalog_num_tables_waiting_for_async_loading
     - catalog_num_dbs
     - catalog_num_tables
     - catalog_num_functions
     - catalog_num_hms_clients_idle
     - catalog_num_hms_clients_in_use

    """


    def __init__(self, catalog_partial_fetch_rpc_queue_len=None, event_metrics=None, catalogd_hms_cache_metrics=None, catalog_num_file_metadata_loading_threads=None, catalog_num_file_metadata_loading_tasks=None, catalog_num_tables_loading_file_metadata=None, catalog_num_tables_loading_metadata=None, catalog_num_tables_async_loading_metadata=None, catalog_num_tables_waiting_for_async_loading=None, catalog_num_dbs=None, catalog_num_tables=None, catalog_num_functions=None, catalog_num_hms_clients_idle=None, catalog_num_hms_clients_in_use=None,):
        self.catalog_partial_fetch_rpc_queue_len = catalog_partial_fetch_rpc_queue_len
        self.event_metrics = event_metrics
        self.catalogd_hms_cache_metrics = catalogd_hms_cache_metrics
        self.catalog_num_file_metadata_loading_threads = catalog_num_file_metadata_loading_threads
        self.catalog_num_file_metadata_loading_tasks = catalog_num_file_metadata_loading_tasks
        self.catalog_num_tables_loading_file_metadata = catalog_num_tables_loading_file_metadata
        self.catalog_num_tables_loading_metadata = catalog_num_tables_loading_metadata
        self.catalog_num_tables_async_loading_metadata = catalog_num_tables_async_loading_metadata
        self.catalog_num_tables_waiting_for_async_loading = catalog_num_tables_waiting_for_async_loading
        self.catalog_num_dbs = catalog_num_dbs
        self.catalog_num_tables = catalog_num_tables
        self.catalog_num_functions = catalog_num_functions
        self.catalog_num_hms_clients_idle = catalog_num_hms_clients_idle
        self.catalog_num_hms_clients_in_use = catalog_num_hms_clients_in_use

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.catalog_partial_fetch_rpc_queue_len = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.event_metrics = TEventProcessorMetrics()
                    self.event_metrics.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.catalogd_hms_cache_metrics = TCatalogdHmsCacheMetrics()
                    self.catalogd_hms_cache_metrics.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.catalog_num_file_metadata_loading_threads = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.catalog_num_file_metadata_loading_tasks = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.catalog_num_tables_loading_file_metadata = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.catalog_num_tables_loading_metadata = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.catalog_num_tables_async_loading_metadata = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.catalog_num_tables_waiting_for_async_loading = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.catalog_num_dbs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.catalog_num_tables = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.catalog_num_functions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.catalog_num_hms_clients_idle = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.catalog_num_hms_clients_in_use = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetCatalogServerMetricsResponse')
        if self.catalog_partial_fetch_rpc_queue_len is not None:
            oprot.writeFieldBegin('catalog_partial_fetch_rpc_queue_len', TType.I32, 1)
            oprot.writeI32(self.catalog_partial_fetch_rpc_queue_len)
            oprot.writeFieldEnd()
        if self.event_metrics is not None:
            oprot.writeFieldBegin('event_metrics', TType.STRUCT, 2)
            self.event_metrics.write(oprot)
            oprot.writeFieldEnd()
        if self.catalogd_hms_cache_metrics is not None:
            oprot.writeFieldBegin('catalogd_hms_cache_metrics', TType.STRUCT, 3)
            self.catalogd_hms_cache_metrics.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_num_file_metadata_loading_threads is not None:
            oprot.writeFieldBegin('catalog_num_file_metadata_loading_threads', TType.I32, 4)
            oprot.writeI32(self.catalog_num_file_metadata_loading_threads)
            oprot.writeFieldEnd()
        if self.catalog_num_file_metadata_loading_tasks is not None:
            oprot.writeFieldBegin('catalog_num_file_metadata_loading_tasks', TType.I32, 5)
            oprot.writeI32(self.catalog_num_file_metadata_loading_tasks)
            oprot.writeFieldEnd()
        if self.catalog_num_tables_loading_file_metadata is not None:
            oprot.writeFieldBegin('catalog_num_tables_loading_file_metadata', TType.I32, 6)
            oprot.writeI32(self.catalog_num_tables_loading_file_metadata)
            oprot.writeFieldEnd()
        if self.catalog_num_tables_loading_metadata is not None:
            oprot.writeFieldBegin('catalog_num_tables_loading_metadata', TType.I32, 7)
            oprot.writeI32(self.catalog_num_tables_loading_metadata)
            oprot.writeFieldEnd()
        if self.catalog_num_tables_async_loading_metadata is not None:
            oprot.writeFieldBegin('catalog_num_tables_async_loading_metadata', TType.I32, 8)
            oprot.writeI32(self.catalog_num_tables_async_loading_metadata)
            oprot.writeFieldEnd()
        if self.catalog_num_tables_waiting_for_async_loading is not None:
            oprot.writeFieldBegin('catalog_num_tables_waiting_for_async_loading', TType.I32, 9)
            oprot.writeI32(self.catalog_num_tables_waiting_for_async_loading)
            oprot.writeFieldEnd()
        if self.catalog_num_dbs is not None:
            oprot.writeFieldBegin('catalog_num_dbs', TType.I32, 10)
            oprot.writeI32(self.catalog_num_dbs)
            oprot.writeFieldEnd()
        if self.catalog_num_tables is not None:
            oprot.writeFieldBegin('catalog_num_tables', TType.I32, 11)
            oprot.writeI32(self.catalog_num_tables)
            oprot.writeFieldEnd()
        if self.catalog_num_functions is not None:
            oprot.writeFieldBegin('catalog_num_functions', TType.I32, 12)
            oprot.writeI32(self.catalog_num_functions)
            oprot.writeFieldEnd()
        if self.catalog_num_hms_clients_idle is not None:
            oprot.writeFieldBegin('catalog_num_hms_clients_idle', TType.I32, 13)
            oprot.writeI32(self.catalog_num_hms_clients_idle)
            oprot.writeFieldEnd()
        if self.catalog_num_hms_clients_in_use is not None:
            oprot.writeFieldBegin('catalog_num_hms_clients_in_use', TType.I32, 14)
            oprot.writeI32(self.catalog_num_hms_clients_in_use)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_partial_fetch_rpc_queue_len is None:
            raise TProtocolException(message='Required field catalog_partial_fetch_rpc_queue_len is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCopyTestCaseReq(object):
    """
    Attributes:
     - input_path

    """


    def __init__(self, input_path=None,):
        self.input_path = input_path

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.input_path = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCopyTestCaseReq')
        if self.input_path is not None:
            oprot.writeFieldBegin('input_path', TType.STRING, 1)
            oprot.writeString(self.input_path)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.input_path is None:
            raise TProtocolException(message='Required field input_path is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEventBatchProgressInfo(object):
    """
    Attributes:
     - num_hms_events
     - num_filtered_events
     - current_event_index
     - current_event_batch_size
     - min_event_id
     - min_event_time_s
     - max_event_id
     - max_event_time_s
     - current_batch_start_time_ms
     - current_event_start_time_ms
     - last_synced_event_id
     - last_synced_event_time_s
     - latest_event_id
     - latest_event_time_s
     - current_event

    """


    def __init__(self, num_hms_events=None, num_filtered_events=None, current_event_index=None, current_event_batch_size=None, min_event_id=None, min_event_time_s=None, max_event_id=None, max_event_time_s=None, current_batch_start_time_ms=None, current_event_start_time_ms=None, last_synced_event_id=None, last_synced_event_time_s=None, latest_event_id=None, latest_event_time_s=None, current_event=None,):
        self.num_hms_events = num_hms_events
        self.num_filtered_events = num_filtered_events
        self.current_event_index = current_event_index
        self.current_event_batch_size = current_event_batch_size
        self.min_event_id = min_event_id
        self.min_event_time_s = min_event_time_s
        self.max_event_id = max_event_id
        self.max_event_time_s = max_event_time_s
        self.current_batch_start_time_ms = current_batch_start_time_ms
        self.current_event_start_time_ms = current_event_start_time_ms
        self.last_synced_event_id = last_synced_event_id
        self.last_synced_event_time_s = last_synced_event_time_s
        self.latest_event_id = latest_event_id
        self.latest_event_time_s = latest_event_time_s
        self.current_event = current_event

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.num_hms_events = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_filtered_events = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.current_event_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.current_event_batch_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.min_event_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.min_event_time_s = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.max_event_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.max_event_time_s = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.current_batch_start_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.current_event_start_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.last_synced_event_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I64:
                    self.last_synced_event_time_s = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I64:
                    self.latest_event_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.latest_event_time_s = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.current_event = hive_metastore.ttypes.NotificationEvent()
                    self.current_event.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEventBatchProgressInfo')
        if self.num_hms_events is not None:
            oprot.writeFieldBegin('num_hms_events', TType.I32, 1)
            oprot.writeI32(self.num_hms_events)
            oprot.writeFieldEnd()
        if self.num_filtered_events is not None:
            oprot.writeFieldBegin('num_filtered_events', TType.I32, 2)
            oprot.writeI32(self.num_filtered_events)
            oprot.writeFieldEnd()
        if self.current_event_index is not None:
            oprot.writeFieldBegin('current_event_index', TType.I32, 3)
            oprot.writeI32(self.current_event_index)
            oprot.writeFieldEnd()
        if self.current_event_batch_size is not None:
            oprot.writeFieldBegin('current_event_batch_size', TType.I32, 4)
            oprot.writeI32(self.current_event_batch_size)
            oprot.writeFieldEnd()
        if self.min_event_id is not None:
            oprot.writeFieldBegin('min_event_id', TType.I64, 5)
            oprot.writeI64(self.min_event_id)
            oprot.writeFieldEnd()
        if self.min_event_time_s is not None:
            oprot.writeFieldBegin('min_event_time_s', TType.I64, 6)
            oprot.writeI64(self.min_event_time_s)
            oprot.writeFieldEnd()
        if self.max_event_id is not None:
            oprot.writeFieldBegin('max_event_id', TType.I64, 7)
            oprot.writeI64(self.max_event_id)
            oprot.writeFieldEnd()
        if self.max_event_time_s is not None:
            oprot.writeFieldBegin('max_event_time_s', TType.I64, 8)
            oprot.writeI64(self.max_event_time_s)
            oprot.writeFieldEnd()
        if self.current_batch_start_time_ms is not None:
            oprot.writeFieldBegin('current_batch_start_time_ms', TType.I64, 9)
            oprot.writeI64(self.current_batch_start_time_ms)
            oprot.writeFieldEnd()
        if self.current_event_start_time_ms is not None:
            oprot.writeFieldBegin('current_event_start_time_ms', TType.I64, 10)
            oprot.writeI64(self.current_event_start_time_ms)
            oprot.writeFieldEnd()
        if self.last_synced_event_id is not None:
            oprot.writeFieldBegin('last_synced_event_id', TType.I64, 11)
            oprot.writeI64(self.last_synced_event_id)
            oprot.writeFieldEnd()
        if self.last_synced_event_time_s is not None:
            oprot.writeFieldBegin('last_synced_event_time_s', TType.I64, 12)
            oprot.writeI64(self.last_synced_event_time_s)
            oprot.writeFieldEnd()
        if self.latest_event_id is not None:
            oprot.writeFieldBegin('latest_event_id', TType.I64, 13)
            oprot.writeI64(self.latest_event_id)
            oprot.writeFieldEnd()
        if self.latest_event_time_s is not None:
            oprot.writeFieldBegin('latest_event_time_s', TType.I64, 14)
            oprot.writeI64(self.latest_event_time_s)
            oprot.writeFieldEnd()
        if self.current_event is not None:
            oprot.writeFieldBegin('current_event', TType.STRUCT, 15)
            self.current_event.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_hms_events is None:
            raise TProtocolException(message='Required field num_hms_events is unset!')
        if self.num_filtered_events is None:
            raise TProtocolException(message='Required field num_filtered_events is unset!')
        if self.current_event_index is None:
            raise TProtocolException(message='Required field current_event_index is unset!')
        if self.current_event_batch_size is None:
            raise TProtocolException(message='Required field current_event_batch_size is unset!')
        if self.min_event_id is None:
            raise TProtocolException(message='Required field min_event_id is unset!')
        if self.min_event_time_s is None:
            raise TProtocolException(message='Required field min_event_time_s is unset!')
        if self.max_event_id is None:
            raise TProtocolException(message='Required field max_event_id is unset!')
        if self.max_event_time_s is None:
            raise TProtocolException(message='Required field max_event_time_s is unset!')
        if self.current_batch_start_time_ms is None:
            raise TProtocolException(message='Required field current_batch_start_time_ms is unset!')
        if self.current_event_start_time_ms is None:
            raise TProtocolException(message='Required field current_event_start_time_ms is unset!')
        if self.last_synced_event_id is None:
            raise TProtocolException(message='Required field last_synced_event_id is unset!')
        if self.last_synced_event_time_s is None:
            raise TProtocolException(message='Required field last_synced_event_time_s is unset!')
        if self.latest_event_id is None:
            raise TProtocolException(message='Required field latest_event_id is unset!')
        if self.latest_event_time_s is None:
            raise TProtocolException(message='Required field latest_event_time_s is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEventProcessorMetricsSummaryResponse(object):
    """
    Attributes:
     - summary
     - error_msg
     - progress

    """


    def __init__(self, summary=None, error_msg=None, progress=None,):
        self.summary = summary
        self.error_msg = error_msg
        self.progress = progress

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.summary = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.error_msg = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.progress = TEventBatchProgressInfo()
                    self.progress.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEventProcessorMetricsSummaryResponse')
        if self.summary is not None:
            oprot.writeFieldBegin('summary', TType.STRING, 1)
            oprot.writeString(self.summary)
            oprot.writeFieldEnd()
        if self.error_msg is not None:
            oprot.writeFieldBegin('error_msg', TType.STRING, 2)
            oprot.writeString(self.error_msg)
            oprot.writeFieldEnd()
        if self.progress is not None:
            oprot.writeFieldBegin('progress', TType.STRUCT, 3)
            self.progress.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.summary is None:
            raise TProtocolException(message='Required field summary is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TAlterDbSetOwnerParams)
TAlterDbSetOwnerParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'owner_type', None, None, ),  # 1
    (2, TType.STRING, 'owner_name', None, None, ),  # 2
    (3, TType.STRING, 'server_name', None, None, ),  # 3
)
all_structs.append(TAlterDbParams)
TAlterDbParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'alter_type', None, None, ),  # 1
    (2, TType.STRING, 'db', None, None, ),  # 2
    (3, TType.STRUCT, 'set_owner_params', [TAlterDbSetOwnerParams, None], None, ),  # 3
)
all_structs.append(TCreateDbParams)
TCreateDbParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', None, None, ),  # 1
    (2, TType.STRING, 'comment', None, None, ),  # 2
    (3, TType.STRING, 'location', None, None, ),  # 3
    (4, TType.BOOL, 'if_not_exists', None, None, ),  # 4
    (5, TType.STRING, 'owner', None, None, ),  # 5
    (6, TType.STRING, 'server_name', None, None, ),  # 6
    (7, TType.STRING, 'managed_location', None, None, ),  # 7
)
all_structs.append(TCreateDataSourceParams)
TCreateDataSourceParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'data_source', [CatalogObjects.ttypes.TDataSource, None], None, ),  # 1
    (2, TType.BOOL, 'if_not_exists', None, None, ),  # 2
)
all_structs.append(TDropDataSourceParams)
TDropDataSourceParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'data_source', None, None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, None, ),  # 2
)
all_structs.append(TDropStatsParams)
TDropStatsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 2
)
all_structs.append(TCreateFunctionParams)
TCreateFunctionParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fn', [Types.ttypes.TFunction, None], None, ),  # 1
    (2, TType.BOOL, 'if_not_exists', None, None, ),  # 2
)
all_structs.append(TTableRowFormat)
TTableRowFormat.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'field_terminator', None, None, ),  # 1
    (2, TType.STRING, 'line_terminator', None, None, ),  # 2
    (3, TType.STRING, 'escaped_by', None, None, ),  # 3
)
all_structs.append(THdfsCachingOp)
THdfsCachingOp.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'set_cached', None, None, ),  # 1
    (2, TType.STRING, 'cache_pool_name', None, None, ),  # 2
    (3, TType.I16, 'replication', None, None, ),  # 3
)
all_structs.append(TAlterTableOrViewRenameParams)
TAlterTableOrViewRenameParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'new_table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
)
all_structs.append(TAlterTableAddColsParams)
TAlterTableAddColsParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 1
    (2, TType.BOOL, 'if_not_exists', None, None, ),  # 2
)
all_structs.append(TAlterTableReplaceColsParams)
TAlterTableReplaceColsParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 1
)
all_structs.append(TPartitionDef)
TPartitionDef.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partition_spec', (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), None, ),  # 1
    (2, TType.STRING, 'location', None, None, ),  # 2
    (3, TType.STRUCT, 'cache_op', [THdfsCachingOp, None], None, ),  # 3
)
all_structs.append(TAlterTableAddPartitionParams)
TAlterTableAddPartitionParams.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'if_not_exists', None, None, ),  # 1
    (2, TType.LIST, 'partitions', (TType.STRUCT, [TPartitionDef, None], False), None, ),  # 2
)
all_structs.append(TAlterTableAddDropRangePartitionParams)
TAlterTableAddDropRangePartitionParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'range_partition_spec', [CatalogObjects.ttypes.TRangePartition, None], None, ),  # 1
    (2, TType.BOOL, 'ignore_errors', None, None, ),  # 2
    (3, TType.I32, 'type', None, None, ),  # 3
)
all_structs.append(TAlterTableDropColParams)
TAlterTableDropColParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'col_name', None, None, ),  # 1
)
all_structs.append(TAlterTableDropPartitionParams)
TAlterTableDropPartitionParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, None, ),  # 2
    (3, TType.BOOL, 'purge', None, None, ),  # 3
    (4, TType.STRUCT, 'iceberg_drop_partition_request', [CatalogObjects.ttypes.TIcebergDropPartitionRequest, None], None, ),  # 4
)
all_structs.append(TAlterTableAlterColParams)
TAlterTableAlterColParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'col_name', None, None, ),  # 1
    (2, TType.STRUCT, 'new_col_def', [CatalogObjects.ttypes.TColumn, None], None, ),  # 2
)
all_structs.append(TAlterTableSetTblPropertiesParams)
TAlterTableSetTblPropertiesParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'target', None, None, ),  # 1
    (2, TType.MAP, 'properties', (TType.STRING, None, TType.STRING, None, False), None, ),  # 2
    (3, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 3
)
all_structs.append(TAlterTableSetFileFormatParams)
TAlterTableSetFileFormatParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'file_format', None, None, ),  # 1
    (2, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 2
)
all_structs.append(TAlterTableSetRowFormatParams)
TAlterTableSetRowFormatParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'row_format', [TTableRowFormat, None], None, ),  # 1
    (2, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 2
)
all_structs.append(TAlterTableSetLocationParams)
TAlterTableSetLocationParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'location', None, None, ),  # 1
    (2, TType.LIST, 'partition_spec', (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), None, ),  # 2
)
all_structs.append(TAlterTableOrViewSetOwnerParams)
TAlterTableOrViewSetOwnerParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'owner_type', None, None, ),  # 1
    (2, TType.STRING, 'owner_name', None, None, ),  # 2
    (3, TType.STRING, 'server_name', None, None, ),  # 3
)
all_structs.append(TAlterTableUpdateStatsParams)
TAlterTableUpdateStatsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRUCT, 'table_stats', [CatalogObjects.ttypes.TTableStats, None], None, ),  # 2
    (3, TType.MAP, 'partition_stats', (TType.LIST, (TType.STRING, None, False), TType.STRUCT, [CatalogObjects.ttypes.TPartitionStats, None], False), None, ),  # 3
    (4, TType.MAP, 'column_stats', (TType.STRING, None, TType.STRUCT, [CatalogObjects.ttypes.TColumnStats, None], False), None, ),  # 4
    (5, TType.BOOL, 'expect_all_partitions', None, None, ),  # 5
    (6, TType.BOOL, 'is_incremental', None, None, ),  # 6
)
all_structs.append(TAlterTableSetCachedParams)
TAlterTableSetCachedParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'cache_op', [THdfsCachingOp, None], None, ),  # 1
    (2, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 2
)
all_structs.append(TAlterTableUnSetTblPropertiesParams)
TAlterTableUnSetTblPropertiesParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'target', None, None, ),  # 1
    (2, TType.LIST, 'property_keys', (TType.STRING, None, False), None, ),  # 2
    (3, TType.BOOL, 'if_exists', None, None, ),  # 3
    (4, TType.LIST, 'partition_set', (TType.LIST, (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), False), None, ),  # 4
)
all_structs.append(TAlterTableSetPartitionSpecParams)
TAlterTableSetPartitionSpecParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'partition_spec', [CatalogObjects.ttypes.TIcebergPartitionSpec, None], None, ),  # 1
)
all_structs.append(TAlterTableExecuteExpireSnapshotsParams)
TAlterTableExecuteExpireSnapshotsParams.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'older_than_millis', None, None, ),  # 1
)
all_structs.append(TAlterTableExecuteRollbackParams)
TAlterTableExecuteRollbackParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'kind', None, None, ),  # 1
    (2, TType.I64, 'timestamp_millis', None, None, ),  # 2
    (3, TType.I64, 'snapshot_id', None, None, ),  # 3
)
all_structs.append(TAlterTableExecuteParams)
TAlterTableExecuteParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'expire_snapshots_params', [TAlterTableExecuteExpireSnapshotsParams, None], None, ),  # 1
    (2, TType.STRUCT, 'execute_rollback_params', [TAlterTableExecuteRollbackParams, None], None, ),  # 2
)
all_structs.append(TAlterTableParams)
TAlterTableParams.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'alter_type', None, None, ),  # 1
    (2, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
    (3, TType.STRUCT, 'rename_params', [TAlterTableOrViewRenameParams, None], None, ),  # 3
    (4, TType.STRUCT, 'add_cols_params', [TAlterTableAddColsParams, None], None, ),  # 4
    (5, TType.STRUCT, 'add_partition_params', [TAlterTableAddPartitionParams, None], None, ),  # 5
    (6, TType.STRUCT, 'alter_col_params', [TAlterTableAlterColParams, None], None, ),  # 6
    (7, TType.STRUCT, 'drop_col_params', [TAlterTableDropColParams, None], None, ),  # 7
    (8, TType.STRUCT, 'drop_partition_params', [TAlterTableDropPartitionParams, None], None, ),  # 8
    (9, TType.STRUCT, 'set_file_format_params', [TAlterTableSetFileFormatParams, None], None, ),  # 9
    (10, TType.STRUCT, 'set_location_params', [TAlterTableSetLocationParams, None], None, ),  # 10
    (11, TType.STRUCT, 'set_tbl_properties_params', [TAlterTableSetTblPropertiesParams, None], None, ),  # 11
    (12, TType.STRUCT, 'update_stats_params', [TAlterTableUpdateStatsParams, None], None, ),  # 12
    (13, TType.STRUCT, 'set_cached_params', [TAlterTableSetCachedParams, None], None, ),  # 13
    (14, TType.STRUCT, 'add_drop_range_partition_params', [TAlterTableAddDropRangePartitionParams, None], None, ),  # 14
    (15, TType.STRUCT, 'set_row_format_params', [TAlterTableSetRowFormatParams, None], None, ),  # 15
    (16, TType.STRUCT, 'set_owner_params', [TAlterTableOrViewSetOwnerParams, None], None, ),  # 16
    (17, TType.STRUCT, 'replace_cols_params', [TAlterTableReplaceColsParams, None], None, ),  # 17
    (18, TType.STRUCT, 'unset_tbl_properties_params', [TAlterTableUnSetTblPropertiesParams, None], None, ),  # 18
    (19, TType.STRUCT, 'set_partition_spec_params', [TAlterTableSetPartitionSpecParams, None], None, ),  # 19
    (20, TType.STRUCT, 'set_execute_params', [TAlterTableExecuteParams, None], None, ),  # 20
)
all_structs.append(TCreateTableLikeParams)
TCreateTableLikeParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRUCT, 'src_table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
    (3, TType.BOOL, 'is_external', None, None, ),  # 3
    (4, TType.BOOL, 'if_not_exists', None, None, ),  # 4
    (5, TType.STRING, 'owner', None, None, ),  # 5
    (6, TType.I32, 'file_format', None, None, ),  # 6
    (7, TType.STRING, 'comment', None, None, ),  # 7
    (8, TType.STRING, 'location', None, None, ),  # 8
    (9, TType.LIST, 'sort_columns', (TType.STRING, None, False), None, ),  # 9
    (10, TType.STRING, 'server_name', None, None, ),  # 10
    (11, TType.I32, 'sorting_order', None, None, ),  # 11
)
all_structs.append(TCreateTableParams)
TCreateTableParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 2
    (3, TType.LIST, 'partition_columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 3
    (4, TType.I32, 'file_format', None, None, ),  # 4
    (5, TType.BOOL, 'is_external', None, None, ),  # 5
    (6, TType.BOOL, 'if_not_exists', None, None, ),  # 6
    (7, TType.STRING, 'owner', None, None, ),  # 7
    (8, TType.STRUCT, 'row_format', [TTableRowFormat, None], None, ),  # 8
    (9, TType.STRING, 'comment', None, None, ),  # 9
    (10, TType.STRING, 'location', None, None, ),  # 10
    (11, TType.MAP, 'table_properties', (TType.STRING, None, TType.STRING, None, False), None, ),  # 11
    (12, TType.MAP, 'serde_properties', (TType.STRING, None, TType.STRING, None, False), None, ),  # 12
    (13, TType.STRUCT, 'cache_op', [THdfsCachingOp, None], None, ),  # 13
    (14, TType.LIST, 'partition_by', (TType.STRUCT, [CatalogObjects.ttypes.TKuduPartitionParam, None], False), None, ),  # 14
    (15, TType.LIST, 'primary_key_column_names', (TType.STRING, None, False), None, ),  # 15
    (16, TType.LIST, 'sort_columns', (TType.STRING, None, False), None, ),  # 16
    (17, TType.STRING, 'server_name', None, None, ),  # 17
    (18, TType.I32, 'sorting_order', None, None, ),  # 18
    (19, TType.LIST, 'primary_keys', (TType.STRUCT, [hive_metastore.ttypes.SQLPrimaryKey, None], False), None, ),  # 19
    (20, TType.LIST, 'foreign_keys', (TType.STRUCT, [hive_metastore.ttypes.SQLForeignKey, None], False), None, ),  # 20
    (21, TType.STRUCT, 'partition_spec', [CatalogObjects.ttypes.TIcebergPartitionSpec, None], None, ),  # 21
    (22, TType.STRUCT, 'bucket_info', [CatalogObjects.ttypes.TBucketInfo, None], None, ),  # 22
    (23, TType.BOOL, 'is_primary_key_unique', None, None, ),  # 23
)
all_structs.append(TCreateOrAlterViewParams)
TCreateOrAlterViewParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'view_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 2
    (3, TType.STRING, 'owner', None, None, ),  # 3
    (4, TType.STRING, 'original_view_def', None, None, ),  # 4
    (5, TType.STRING, 'expanded_view_def', None, None, ),  # 5
    (6, TType.STRING, 'comment', None, None, ),  # 6
    (7, TType.BOOL, 'if_not_exists', None, None, ),  # 7
    (8, TType.STRING, 'server_name', None, None, ),  # 8
    (9, TType.MAP, 'tblproperties', (TType.STRING, None, TType.STRING, None, False), None, ),  # 9
)
all_structs.append(TComputeStatsParams)
TComputeStatsParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRING, 'tbl_stats_query', None, None, ),  # 2
    (3, TType.STRING, 'col_stats_query', None, None, ),  # 3
    (4, TType.BOOL, 'is_incremental', None, None, ),  # 4
    (5, TType.LIST, 'existing_part_stats', (TType.STRUCT, [CatalogObjects.ttypes.TPartitionStats, None], False), None, ),  # 5
    (6, TType.LIST, 'expected_partitions', (TType.LIST, (TType.STRING, None, False), False), None, ),  # 6
    (7, TType.BOOL, 'expect_all_partitions', None, None, ),  # 7
    (8, TType.I32, 'num_partition_cols', None, None, ),  # 8
    (9, TType.I64, 'total_file_bytes', None, None, ),  # 9
)
all_structs.append(TCreateDropRoleParams)
TCreateDropRoleParams.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'is_drop', None, None, ),  # 1
    (2, TType.STRING, 'role_name', None, None, ),  # 2
)
all_structs.append(TGrantRevokeRoleParams)
TGrantRevokeRoleParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'role_names', (TType.STRING, None, False), None, ),  # 1
    (2, TType.LIST, 'group_names', (TType.STRING, None, False), None, ),  # 2
    (3, TType.BOOL, 'is_grant', None, None, ),  # 3
)
all_structs.append(TGrantRevokePrivParams)
TGrantRevokePrivParams.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'privileges', (TType.STRUCT, [CatalogObjects.ttypes.TPrivilege, None], False), None, ),  # 1
    (2, TType.STRING, 'principal_name', None, None, ),  # 2
    (3, TType.BOOL, 'is_grant', None, None, ),  # 3
    (4, TType.BOOL, 'has_grant_opt', None, None, ),  # 4
    (5, TType.I32, 'principal_type', None, None, ),  # 5
    (6, TType.STRING, 'owner_name', None, None, ),  # 6
)
all_structs.append(TDropDbParams)
TDropDbParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db', None, None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, None, ),  # 2
    (3, TType.BOOL, 'cascade', None, None, ),  # 3
    (4, TType.STRING, 'server_name', None, None, ),  # 4
)
all_structs.append(TDropTableOrViewParams)
TDropTableOrViewParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, None, ),  # 2
    (3, TType.BOOL, 'purge', None, None, ),  # 3
    (4, TType.BOOL, 'is_table', None, None, ),  # 4
    (5, TType.STRING, 'server_name', None, None, ),  # 5
)
all_structs.append(TTruncateParams)
TTruncateParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.BOOL, 'if_exists', None, None, ),  # 2
    (3, TType.BOOL, 'delete_stats', None, True, ),  # 3
)
all_structs.append(TDropFunctionParams)
TDropFunctionParams.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fn_name', [Types.ttypes.TFunctionName, None], None, ),  # 1
    (2, TType.LIST, 'arg_types', (TType.STRUCT, [Types.ttypes.TColumnType, None], False), None, ),  # 2
    (3, TType.BOOL, 'if_exists', None, None, ),  # 3
    (4, TType.STRING, 'signature', None, None, ),  # 4
)
all_structs.append(TTableUsageMetrics)
TTableUsageMetrics.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.I64, 'memory_estimate_bytes', None, None, ),  # 2
    (3, TType.I64, 'num_metadata_operations', None, None, ),  # 3
    (4, TType.I64, 'num_files', None, None, ),  # 4
    (5, TType.I64, 'median_table_loading_ns', None, None, ),  # 5
    (6, TType.I64, 'max_table_loading_ns', None, None, ),  # 6
    (7, TType.I64, 'num_table_loading', None, None, ),  # 7
    (8, TType.I64, 'p75_loading_time_ns', None, None, ),  # 8
    (9, TType.I64, 'p95_loading_time_ns', None, None, ),  # 9
    (10, TType.I64, 'p99_loading_time_ns', None, None, ),  # 10
)
all_structs.append(TGetCatalogUsageResponse)
TGetCatalogUsageResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'large_tables', (TType.STRUCT, [TTableUsageMetrics, None], False), None, ),  # 1
    (2, TType.LIST, 'frequently_accessed_tables', (TType.STRUCT, [TTableUsageMetrics, None], False), None, ),  # 2
    (3, TType.LIST, 'high_file_count_tables', (TType.STRUCT, [TTableUsageMetrics, None], False), None, ),  # 3
    (4, TType.LIST, 'long_metadata_loading_tables', (TType.STRUCT, [TTableUsageMetrics, None], False), None, ),  # 4
)
all_structs.append(TOperationUsageCounter)
TOperationUsageCounter.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'catalog_op_name', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
    (3, TType.I64, 'op_counter', None, None, ),  # 3
)
all_structs.append(TCatalogOpRecord)
TCatalogOpRecord.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'thread_id', None, None, ),  # 1
    (2, TType.STRUCT, 'query_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.STRING, 'client_ip', None, None, ),  # 3
    (4, TType.STRING, 'coordinator_hostname', None, None, ),  # 4
    (5, TType.STRING, 'catalog_op_name', None, None, ),  # 5
    (6, TType.STRING, 'target_name', None, None, ),  # 6
    (7, TType.STRING, 'user', None, None, ),  # 7
    (8, TType.I64, 'start_time_ms', None, None, ),  # 8
    (9, TType.I64, 'finish_time_ms', None, None, ),  # 9
    (10, TType.STRING, 'status', None, None, ),  # 10
    (11, TType.STRING, 'details', None, None, ),  # 11
)
all_structs.append(TGetOperationUsageResponse)
TGetOperationUsageResponse.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'catalog_op_counters', (TType.STRUCT, [TOperationUsageCounter, None], False), None, ),  # 1
    (2, TType.LIST, 'in_flight_catalog_operations', (TType.STRUCT, [TCatalogOpRecord, None], False), None, ),  # 2
    (3, TType.LIST, 'finished_catalog_operations', (TType.STRUCT, [TCatalogOpRecord, None], False), None, ),  # 3
)
all_structs.append(TColumnName)
TColumnName.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.STRING, 'column_name', None, None, ),  # 2
)
all_structs.append(TCommentOnParams)
TCommentOnParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'comment', None, None, ),  # 1
    (2, TType.STRING, 'db', None, None, ),  # 2
    (3, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 3
    (4, TType.STRUCT, 'column_name', [TColumnName, None], None, ),  # 4
)
all_structs.append(TEventProcessorMetrics)
TEventProcessorMetrics.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'status', None, None, ),  # 1
    (2, TType.I64, 'events_received', None, None, ),  # 2
    (3, TType.I64, 'events_skipped', None, None, ),  # 3
    (4, TType.DOUBLE, 'events_fetch_duration_mean', None, None, ),  # 4
    (5, TType.DOUBLE, 'events_fetch_duration_p75', None, None, ),  # 5
    (6, TType.DOUBLE, 'events_fetch_duration_p95', None, None, ),  # 6
    (7, TType.DOUBLE, 'events_fetch_duration_p99', None, None, ),  # 7
    (8, TType.DOUBLE, 'last_events_fetch_duration', None, None, ),  # 8
    (9, TType.DOUBLE, 'events_process_duration_mean', None, None, ),  # 9
    (10, TType.DOUBLE, 'events_process_duration_p75', None, None, ),  # 10
    (11, TType.DOUBLE, 'events_process_duration_p95', None, None, ),  # 11
    (12, TType.DOUBLE, 'events_process_duration_p99', None, None, ),  # 12
    (13, TType.DOUBLE, 'last_events_process_duration', None, None, ),  # 13
    (14, TType.DOUBLE, 'events_received_1min_rate', None, None, ),  # 14
    (15, TType.DOUBLE, 'events_received_5min_rate', None, None, ),  # 15
    (16, TType.DOUBLE, 'events_received_15min_rate', None, None, ),  # 16
    (17, TType.DOUBLE, 'events_skipped_per_poll_mean', None, None, ),  # 17
    (18, TType.I64, 'last_synced_event_id', None, None, ),  # 18
    (19, TType.I64, 'last_synced_event_time', None, None, ),  # 19
    (20, TType.I64, 'latest_event_id', None, None, ),  # 20
    (21, TType.I64, 'latest_event_time', None, None, ),  # 21
)
all_structs.append(TCatalogHmsCacheApiMetrics)
TCatalogHmsCacheApiMetrics.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'api_name', None, None, ),  # 1
    (2, TType.I64, 'api_requests', None, None, ),  # 2
    (3, TType.DOUBLE, 'p99_response_time_ms', None, None, ),  # 3
    (4, TType.DOUBLE, 'p95_response_time_ms', None, None, ),  # 4
    (5, TType.DOUBLE, 'response_time_mean_ms', None, None, ),  # 5
    (6, TType.DOUBLE, 'response_time_max_ms', None, None, ),  # 6
    (7, TType.DOUBLE, 'response_time_min_ms', None, None, ),  # 7
    (8, TType.DOUBLE, 'api_requests_1min_rate', None, None, ),  # 8
    (9, TType.DOUBLE, 'api_requests_5min_rate', None, None, ),  # 9
    (10, TType.DOUBLE, 'api_requests_15min_rate', None, None, ),  # 10
    (11, TType.DOUBLE, 'cache_hit_ratio', None, None, ),  # 11
)
all_structs.append(TCatalogdHmsCacheMetrics)
TCatalogdHmsCacheMetrics.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'api_metrics', (TType.STRUCT, [TCatalogHmsCacheApiMetrics, None], False), None, ),  # 1
    (2, TType.DOUBLE, 'cache_hit_ratio', None, None, ),  # 2
    (3, TType.I64, 'api_requests', None, None, ),  # 3
    (4, TType.DOUBLE, 'api_requests_1min_rate', None, None, ),  # 4
    (5, TType.DOUBLE, 'api_requests_5min_rate', None, None, ),  # 5
    (6, TType.DOUBLE, 'api_requests_15min_rate', None, None, ),  # 6
)
all_structs.append(TGetCatalogServerMetricsResponse)
TGetCatalogServerMetricsResponse.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'catalog_partial_fetch_rpc_queue_len', None, None, ),  # 1
    (2, TType.STRUCT, 'event_metrics', [TEventProcessorMetrics, None], None, ),  # 2
    (3, TType.STRUCT, 'catalogd_hms_cache_metrics', [TCatalogdHmsCacheMetrics, None], None, ),  # 3
    (4, TType.I32, 'catalog_num_file_metadata_loading_threads', None, None, ),  # 4
    (5, TType.I32, 'catalog_num_file_metadata_loading_tasks', None, None, ),  # 5
    (6, TType.I32, 'catalog_num_tables_loading_file_metadata', None, None, ),  # 6
    (7, TType.I32, 'catalog_num_tables_loading_metadata', None, None, ),  # 7
    (8, TType.I32, 'catalog_num_tables_async_loading_metadata', None, None, ),  # 8
    (9, TType.I32, 'catalog_num_tables_waiting_for_async_loading', None, None, ),  # 9
    (10, TType.I32, 'catalog_num_dbs', None, None, ),  # 10
    (11, TType.I32, 'catalog_num_tables', None, None, ),  # 11
    (12, TType.I32, 'catalog_num_functions', None, None, ),  # 12
    (13, TType.I32, 'catalog_num_hms_clients_idle', None, None, ),  # 13
    (14, TType.I32, 'catalog_num_hms_clients_in_use', None, None, ),  # 14
)
all_structs.append(TCopyTestCaseReq)
TCopyTestCaseReq.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'input_path', None, None, ),  # 1
)
all_structs.append(TEventBatchProgressInfo)
TEventBatchProgressInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'num_hms_events', None, None, ),  # 1
    (2, TType.I32, 'num_filtered_events', None, None, ),  # 2
    (3, TType.I32, 'current_event_index', None, None, ),  # 3
    (4, TType.I32, 'current_event_batch_size', None, None, ),  # 4
    (5, TType.I64, 'min_event_id', None, None, ),  # 5
    (6, TType.I64, 'min_event_time_s', None, None, ),  # 6
    (7, TType.I64, 'max_event_id', None, None, ),  # 7
    (8, TType.I64, 'max_event_time_s', None, None, ),  # 8
    (9, TType.I64, 'current_batch_start_time_ms', None, None, ),  # 9
    (10, TType.I64, 'current_event_start_time_ms', None, None, ),  # 10
    (11, TType.I64, 'last_synced_event_id', None, None, ),  # 11
    (12, TType.I64, 'last_synced_event_time_s', None, None, ),  # 12
    (13, TType.I64, 'latest_event_id', None, None, ),  # 13
    (14, TType.I64, 'latest_event_time_s', None, None, ),  # 14
    (15, TType.STRUCT, 'current_event', [hive_metastore.ttypes.NotificationEvent, None], None, ),  # 15
)
all_structs.append(TEventProcessorMetricsSummaryResponse)
TEventProcessorMetricsSummaryResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'summary', None, None, ),  # 1
    (2, TType.STRING, 'error_msg', None, None, ),  # 2
    (3, TType.STRUCT, 'progress', [TEventBatchProgressInfo, None], None, ),  # 3
)
fix_spec(all_structs)
del all_structs
