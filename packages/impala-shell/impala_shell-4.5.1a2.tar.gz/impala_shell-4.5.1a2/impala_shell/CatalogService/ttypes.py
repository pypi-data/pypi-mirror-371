#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:no_utf8strings
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import CatalogObjects.ttypes
import JniCatalog.ttypes
import Types.ttypes
import Status.ttypes
import Results.ttypes
import RuntimeProfile.ttypes
import hive_metastore.ttypes
import SqlConstraints.ttypes

from thrift.transport import TTransport
all_structs = []


class CatalogServiceVersion(object):
    V1 = 0
    V2 = 1

    _VALUES_TO_NAMES = {
        0: "V1",
        1: "V2",
    }

    _NAMES_TO_VALUES = {
        "V1": 0,
        "V2": 1,
    }


class TImpalaTableType(object):
    TABLE = 0
    VIEW = 1
    UNKNOWN = 2
    MATERIALIZED_VIEW = 3

    _VALUES_TO_NAMES = {
        0: "TABLE",
        1: "VIEW",
        2: "UNKNOWN",
        3: "MATERIALIZED_VIEW",
    }

    _NAMES_TO_VALUES = {
        "TABLE": 0,
        "VIEW": 1,
        "UNKNOWN": 2,
        "MATERIALIZED_VIEW": 3,
    }


class CatalogLookupStatus(object):
    OK = 0
    DB_NOT_FOUND = 1
    TABLE_NOT_FOUND = 2
    TABLE_NOT_LOADED = 3
    FUNCTION_NOT_FOUND = 4
    PARTITION_NOT_FOUND = 5
    DATA_SOURCE_NOT_FOUND = 6
    VERSION_MISMATCH = 7

    _VALUES_TO_NAMES = {
        0: "OK",
        1: "DB_NOT_FOUND",
        2: "TABLE_NOT_FOUND",
        3: "TABLE_NOT_LOADED",
        4: "FUNCTION_NOT_FOUND",
        5: "PARTITION_NOT_FOUND",
        6: "DATA_SOURCE_NOT_FOUND",
        7: "VERSION_MISMATCH",
    }

    _NAMES_TO_VALUES = {
        "OK": 0,
        "DB_NOT_FOUND": 1,
        "TABLE_NOT_FOUND": 2,
        "TABLE_NOT_LOADED": 3,
        "FUNCTION_NOT_FOUND": 4,
        "PARTITION_NOT_FOUND": 5,
        "DATA_SOURCE_NOT_FOUND": 6,
        "VERSION_MISMATCH": 7,
    }


class TCatalogServiceRequestHeader(object):
    """
    Attributes:
     - requesting_user
     - redacted_sql_stmt
     - client_ip
     - want_minimal_response
     - query_id
     - coordinator_hostname

    """


    def __init__(self, requesting_user=None, redacted_sql_stmt=None, client_ip=None, want_minimal_response=None, query_id=None, coordinator_hostname=None,):
        self.requesting_user = requesting_user
        self.redacted_sql_stmt = redacted_sql_stmt
        self.client_ip = client_ip
        self.want_minimal_response = want_minimal_response
        self.query_id = query_id
        self.coordinator_hostname = coordinator_hostname

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.requesting_user = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.redacted_sql_stmt = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.client_ip = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.want_minimal_response = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.query_id = Types.ttypes.TUniqueId()
                    self.query_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.coordinator_hostname = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogServiceRequestHeader')
        if self.requesting_user is not None:
            oprot.writeFieldBegin('requesting_user', TType.STRING, 1)
            oprot.writeString(self.requesting_user)
            oprot.writeFieldEnd()
        if self.redacted_sql_stmt is not None:
            oprot.writeFieldBegin('redacted_sql_stmt', TType.STRING, 2)
            oprot.writeString(self.redacted_sql_stmt)
            oprot.writeFieldEnd()
        if self.client_ip is not None:
            oprot.writeFieldBegin('client_ip', TType.STRING, 3)
            oprot.writeString(self.client_ip)
            oprot.writeFieldEnd()
        if self.want_minimal_response is not None:
            oprot.writeFieldBegin('want_minimal_response', TType.BOOL, 4)
            oprot.writeBool(self.want_minimal_response)
            oprot.writeFieldEnd()
        if self.query_id is not None:
            oprot.writeFieldBegin('query_id', TType.STRUCT, 5)
            self.query_id.write(oprot)
            oprot.writeFieldEnd()
        if self.coordinator_hostname is not None:
            oprot.writeFieldBegin('coordinator_hostname', TType.STRING, 6)
            oprot.writeString(self.coordinator_hostname)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogUpdateResult(object):
    """
    Attributes:
     - catalog_service_id
     - version
     - status
     - is_invalidate
     - updated_catalog_objects
     - removed_catalog_objects

    """


    def __init__(self, catalog_service_id=None, version=None, status=None, is_invalidate=None, updated_catalog_objects=None, removed_catalog_objects=None,):
        self.catalog_service_id = catalog_service_id
        self.version = version
        self.status = status
        self.is_invalidate = is_invalidate
        self.updated_catalog_objects = updated_catalog_objects
        self.removed_catalog_objects = removed_catalog_objects

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catalog_service_id = Types.ttypes.TUniqueId()
                    self.catalog_service_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_invalidate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.updated_catalog_objects = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = CatalogObjects.ttypes.TCatalogObject()
                        _elem5.read(iprot)
                        self.updated_catalog_objects.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.removed_catalog_objects = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = CatalogObjects.ttypes.TCatalogObject()
                        _elem11.read(iprot)
                        self.removed_catalog_objects.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogUpdateResult')
        if self.catalog_service_id is not None:
            oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
            self.catalog_service_id.write(oprot)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I64, 2)
            oprot.writeI64(self.version)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 3)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.is_invalidate is not None:
            oprot.writeFieldBegin('is_invalidate', TType.BOOL, 4)
            oprot.writeBool(self.is_invalidate)
            oprot.writeFieldEnd()
        if self.updated_catalog_objects is not None:
            oprot.writeFieldBegin('updated_catalog_objects', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.updated_catalog_objects))
            for iter12 in self.updated_catalog_objects:
                iter12.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.removed_catalog_objects is not None:
            oprot.writeFieldBegin('removed_catalog_objects', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.removed_catalog_objects))
            for iter13 in self.removed_catalog_objects:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_service_id is None:
            raise TProtocolException(message='Required field catalog_service_id is unset!')
        if self.version is None:
            raise TProtocolException(message='Required field version is unset!')
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.is_invalidate is None:
            raise TProtocolException(message='Required field is_invalidate is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDdlQueryOptions(object):
    """
    Attributes:
     - sync_ddl
     - debug_action
     - lock_max_wait_time_s
     - kudu_table_reserve_seconds

    """


    def __init__(self, sync_ddl=None, debug_action=None, lock_max_wait_time_s=None, kudu_table_reserve_seconds=None,):
        self.sync_ddl = sync_ddl
        self.debug_action = debug_action
        self.lock_max_wait_time_s = lock_max_wait_time_s
        self.kudu_table_reserve_seconds = kudu_table_reserve_seconds

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.sync_ddl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.debug_action = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.lock_max_wait_time_s = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.kudu_table_reserve_seconds = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDdlQueryOptions')
        if self.sync_ddl is not None:
            oprot.writeFieldBegin('sync_ddl', TType.BOOL, 1)
            oprot.writeBool(self.sync_ddl)
            oprot.writeFieldEnd()
        if self.debug_action is not None:
            oprot.writeFieldBegin('debug_action', TType.STRING, 2)
            oprot.writeString(self.debug_action)
            oprot.writeFieldEnd()
        if self.lock_max_wait_time_s is not None:
            oprot.writeFieldBegin('lock_max_wait_time_s', TType.I32, 3)
            oprot.writeI32(self.lock_max_wait_time_s)
            oprot.writeFieldEnd()
        if self.kudu_table_reserve_seconds is not None:
            oprot.writeFieldBegin('kudu_table_reserve_seconds', TType.I32, 4)
            oprot.writeI32(self.kudu_table_reserve_seconds)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.sync_ddl is None:
            raise TProtocolException(message='Required field sync_ddl is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDdlExecRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - ddl_type
     - alter_table_params
     - alter_view_params
     - create_db_params
     - create_table_params
     - create_table_like_params
     - create_view_params
     - create_fn_params
     - drop_db_params
     - drop_table_or_view_params
     - truncate_params
     - drop_fn_params
     - compute_stats_params
     - create_data_source_params
     - drop_data_source_params
     - drop_stats_params
     - create_drop_role_params
     - grant_revoke_role_params
     - grant_revoke_priv_params
     - comment_on_params
     - alter_db_params
     - copy_test_case_params
     - query_options

    """


    def __init__(self, protocol_version=1, header=None, ddl_type=None, alter_table_params=None, alter_view_params=None, create_db_params=None, create_table_params=None, create_table_like_params=None, create_view_params=None, create_fn_params=None, drop_db_params=None, drop_table_or_view_params=None, truncate_params=None, drop_fn_params=None, compute_stats_params=None, create_data_source_params=None, drop_data_source_params=None, drop_stats_params=None, create_drop_role_params=None, grant_revoke_role_params=None, grant_revoke_priv_params=None, comment_on_params=None, alter_db_params=None, copy_test_case_params=None, query_options=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.ddl_type = ddl_type
        self.alter_table_params = alter_table_params
        self.alter_view_params = alter_view_params
        self.create_db_params = create_db_params
        self.create_table_params = create_table_params
        self.create_table_like_params = create_table_like_params
        self.create_view_params = create_view_params
        self.create_fn_params = create_fn_params
        self.drop_db_params = drop_db_params
        self.drop_table_or_view_params = drop_table_or_view_params
        self.truncate_params = truncate_params
        self.drop_fn_params = drop_fn_params
        self.compute_stats_params = compute_stats_params
        self.create_data_source_params = create_data_source_params
        self.drop_data_source_params = drop_data_source_params
        self.drop_stats_params = drop_stats_params
        self.create_drop_role_params = create_drop_role_params
        self.grant_revoke_role_params = grant_revoke_role_params
        self.grant_revoke_priv_params = grant_revoke_priv_params
        self.comment_on_params = comment_on_params
        self.alter_db_params = alter_db_params
        self.copy_test_case_params = copy_test_case_params
        self.query_options = query_options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.ddl_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.alter_table_params = JniCatalog.ttypes.TAlterTableParams()
                    self.alter_table_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.alter_view_params = JniCatalog.ttypes.TCreateOrAlterViewParams()
                    self.alter_view_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.create_db_params = JniCatalog.ttypes.TCreateDbParams()
                    self.create_db_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.create_table_params = JniCatalog.ttypes.TCreateTableParams()
                    self.create_table_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.create_table_like_params = JniCatalog.ttypes.TCreateTableLikeParams()
                    self.create_table_like_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.create_view_params = JniCatalog.ttypes.TCreateOrAlterViewParams()
                    self.create_view_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.create_fn_params = JniCatalog.ttypes.TCreateFunctionParams()
                    self.create_fn_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.drop_db_params = JniCatalog.ttypes.TDropDbParams()
                    self.drop_db_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.drop_table_or_view_params = JniCatalog.ttypes.TDropTableOrViewParams()
                    self.drop_table_or_view_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.truncate_params = JniCatalog.ttypes.TTruncateParams()
                    self.truncate_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.drop_fn_params = JniCatalog.ttypes.TDropFunctionParams()
                    self.drop_fn_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRUCT:
                    self.compute_stats_params = JniCatalog.ttypes.TComputeStatsParams()
                    self.compute_stats_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.create_data_source_params = JniCatalog.ttypes.TCreateDataSourceParams()
                    self.create_data_source_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.drop_data_source_params = JniCatalog.ttypes.TDropDataSourceParams()
                    self.drop_data_source_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRUCT:
                    self.drop_stats_params = JniCatalog.ttypes.TDropStatsParams()
                    self.drop_stats_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRUCT:
                    self.create_drop_role_params = JniCatalog.ttypes.TCreateDropRoleParams()
                    self.create_drop_role_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.STRUCT:
                    self.grant_revoke_role_params = JniCatalog.ttypes.TGrantRevokeRoleParams()
                    self.grant_revoke_role_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.STRUCT:
                    self.grant_revoke_priv_params = JniCatalog.ttypes.TGrantRevokePrivParams()
                    self.grant_revoke_priv_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.STRUCT:
                    self.comment_on_params = JniCatalog.ttypes.TCommentOnParams()
                    self.comment_on_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.STRUCT:
                    self.alter_db_params = JniCatalog.ttypes.TAlterDbParams()
                    self.alter_db_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.STRUCT:
                    self.copy_test_case_params = JniCatalog.ttypes.TCopyTestCaseReq()
                    self.copy_test_case_params.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.STRUCT:
                    self.query_options = TDdlQueryOptions()
                    self.query_options.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDdlExecRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 2)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.ddl_type is not None:
            oprot.writeFieldBegin('ddl_type', TType.I32, 3)
            oprot.writeI32(self.ddl_type)
            oprot.writeFieldEnd()
        if self.alter_table_params is not None:
            oprot.writeFieldBegin('alter_table_params', TType.STRUCT, 4)
            self.alter_table_params.write(oprot)
            oprot.writeFieldEnd()
        if self.alter_view_params is not None:
            oprot.writeFieldBegin('alter_view_params', TType.STRUCT, 5)
            self.alter_view_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_db_params is not None:
            oprot.writeFieldBegin('create_db_params', TType.STRUCT, 6)
            self.create_db_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_table_params is not None:
            oprot.writeFieldBegin('create_table_params', TType.STRUCT, 7)
            self.create_table_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_table_like_params is not None:
            oprot.writeFieldBegin('create_table_like_params', TType.STRUCT, 8)
            self.create_table_like_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_view_params is not None:
            oprot.writeFieldBegin('create_view_params', TType.STRUCT, 9)
            self.create_view_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_fn_params is not None:
            oprot.writeFieldBegin('create_fn_params', TType.STRUCT, 10)
            self.create_fn_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_db_params is not None:
            oprot.writeFieldBegin('drop_db_params', TType.STRUCT, 11)
            self.drop_db_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_table_or_view_params is not None:
            oprot.writeFieldBegin('drop_table_or_view_params', TType.STRUCT, 12)
            self.drop_table_or_view_params.write(oprot)
            oprot.writeFieldEnd()
        if self.truncate_params is not None:
            oprot.writeFieldBegin('truncate_params', TType.STRUCT, 13)
            self.truncate_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_fn_params is not None:
            oprot.writeFieldBegin('drop_fn_params', TType.STRUCT, 14)
            self.drop_fn_params.write(oprot)
            oprot.writeFieldEnd()
        if self.compute_stats_params is not None:
            oprot.writeFieldBegin('compute_stats_params', TType.STRUCT, 15)
            self.compute_stats_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_data_source_params is not None:
            oprot.writeFieldBegin('create_data_source_params', TType.STRUCT, 16)
            self.create_data_source_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_data_source_params is not None:
            oprot.writeFieldBegin('drop_data_source_params', TType.STRUCT, 17)
            self.drop_data_source_params.write(oprot)
            oprot.writeFieldEnd()
        if self.drop_stats_params is not None:
            oprot.writeFieldBegin('drop_stats_params', TType.STRUCT, 18)
            self.drop_stats_params.write(oprot)
            oprot.writeFieldEnd()
        if self.create_drop_role_params is not None:
            oprot.writeFieldBegin('create_drop_role_params', TType.STRUCT, 19)
            self.create_drop_role_params.write(oprot)
            oprot.writeFieldEnd()
        if self.grant_revoke_role_params is not None:
            oprot.writeFieldBegin('grant_revoke_role_params', TType.STRUCT, 20)
            self.grant_revoke_role_params.write(oprot)
            oprot.writeFieldEnd()
        if self.grant_revoke_priv_params is not None:
            oprot.writeFieldBegin('grant_revoke_priv_params', TType.STRUCT, 21)
            self.grant_revoke_priv_params.write(oprot)
            oprot.writeFieldEnd()
        if self.comment_on_params is not None:
            oprot.writeFieldBegin('comment_on_params', TType.STRUCT, 22)
            self.comment_on_params.write(oprot)
            oprot.writeFieldEnd()
        if self.alter_db_params is not None:
            oprot.writeFieldBegin('alter_db_params', TType.STRUCT, 23)
            self.alter_db_params.write(oprot)
            oprot.writeFieldEnd()
        if self.copy_test_case_params is not None:
            oprot.writeFieldBegin('copy_test_case_params', TType.STRUCT, 24)
            self.copy_test_case_params.write(oprot)
            oprot.writeFieldEnd()
        if self.query_options is not None:
            oprot.writeFieldBegin('query_options', TType.STRUCT, 25)
            self.query_options.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.ddl_type is None:
            raise TProtocolException(message='Required field ddl_type is unset!')
        if self.query_options is None:
            raise TProtocolException(message='Required field query_options is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDdlExecResponse(object):
    """
    Attributes:
     - result
     - new_table_created
     - result_set
     - table_name
     - table_create_time
     - table_location
     - profile

    """


    def __init__(self, result=None, new_table_created=None, result_set=None, table_name=None, table_create_time=None, table_location=None, profile=None,):
        self.result = result
        self.new_table_created = new_table_created
        self.result_set = result_set
        self.table_name = table_name
        self.table_create_time = table_create_time
        self.table_location = table_location
        self.profile = profile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.result = TCatalogUpdateResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.new_table_created = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.result_set = Results.ttypes.TResultSet()
                    self.result_set.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.table_create_time = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.table_location = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.profile = RuntimeProfile.ttypes.TRuntimeProfileNode()
                    self.profile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDdlExecResponse')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 1)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        if self.new_table_created is not None:
            oprot.writeFieldBegin('new_table_created', TType.BOOL, 2)
            oprot.writeBool(self.new_table_created)
            oprot.writeFieldEnd()
        if self.result_set is not None:
            oprot.writeFieldBegin('result_set', TType.STRUCT, 3)
            self.result_set.write(oprot)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 4)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.table_create_time is not None:
            oprot.writeFieldBegin('table_create_time', TType.I64, 5)
            oprot.writeI64(self.table_create_time)
            oprot.writeFieldEnd()
        if self.table_location is not None:
            oprot.writeFieldBegin('table_location', TType.STRING, 6)
            oprot.writeString(self.table_location)
            oprot.writeFieldEnd()
        if self.profile is not None:
            oprot.writeFieldBegin('profile', TType.STRUCT, 7)
            self.profile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.result is None:
            raise TProtocolException(message='Required field result is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergOperationParam(object):
    """
    Attributes:
     - operation
     - spec_id
     - iceberg_data_files_fb
     - iceberg_delete_files_fb
     - is_overwrite
     - initial_snapshot_id
     - data_files_referenced_by_position_deletes
     - replaced_data_files_without_deletes

    """


    def __init__(self, operation=None, spec_id=None, iceberg_data_files_fb=None, iceberg_delete_files_fb=None, is_overwrite=False, initial_snapshot_id=None, data_files_referenced_by_position_deletes=None, replaced_data_files_without_deletes=None,):
        self.operation = operation
        self.spec_id = spec_id
        self.iceberg_data_files_fb = iceberg_data_files_fb
        self.iceberg_delete_files_fb = iceberg_delete_files_fb
        self.is_overwrite = is_overwrite
        self.initial_snapshot_id = initial_snapshot_id
        self.data_files_referenced_by_position_deletes = data_files_referenced_by_position_deletes
        self.replaced_data_files_without_deletes = replaced_data_files_without_deletes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 5:
                if ftype == TType.I32:
                    self.operation = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.I32:
                    self.spec_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.iceberg_data_files_fb = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = iprot.readBinary()
                        self.iceberg_data_files_fb.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.iceberg_delete_files_fb = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = iprot.readBinary()
                        self.iceberg_delete_files_fb.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_overwrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.initial_snapshot_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.data_files_referenced_by_position_deletes = []
                    (_etype29, _size26) = iprot.readListBegin()
                    for _i30 in range(_size26):
                        _elem31 = iprot.readString()
                        self.data_files_referenced_by_position_deletes.append(_elem31)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.SET:
                    self.replaced_data_files_without_deletes = set()
                    (_etype35, _size32) = iprot.readSetBegin()
                    for _i36 in range(_size32):
                        _elem37 = iprot.readString()
                        self.replaced_data_files_without_deletes.add(_elem37)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergOperationParam')
        if self.spec_id is not None:
            oprot.writeFieldBegin('spec_id', TType.I32, 1)
            oprot.writeI32(self.spec_id)
            oprot.writeFieldEnd()
        if self.iceberg_data_files_fb is not None:
            oprot.writeFieldBegin('iceberg_data_files_fb', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.iceberg_data_files_fb))
            for iter38 in self.iceberg_data_files_fb:
                oprot.writeBinary(iter38)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_overwrite is not None:
            oprot.writeFieldBegin('is_overwrite', TType.BOOL, 3)
            oprot.writeBool(self.is_overwrite)
            oprot.writeFieldEnd()
        if self.initial_snapshot_id is not None:
            oprot.writeFieldBegin('initial_snapshot_id', TType.I64, 4)
            oprot.writeI64(self.initial_snapshot_id)
            oprot.writeFieldEnd()
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.I32, 5)
            oprot.writeI32(self.operation)
            oprot.writeFieldEnd()
        if self.iceberg_delete_files_fb is not None:
            oprot.writeFieldBegin('iceberg_delete_files_fb', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.iceberg_delete_files_fb))
            for iter39 in self.iceberg_delete_files_fb:
                oprot.writeBinary(iter39)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.data_files_referenced_by_position_deletes is not None:
            oprot.writeFieldBegin('data_files_referenced_by_position_deletes', TType.LIST, 7)
            oprot.writeListBegin(TType.STRING, len(self.data_files_referenced_by_position_deletes))
            for iter40 in self.data_files_referenced_by_position_deletes:
                oprot.writeString(iter40)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.replaced_data_files_without_deletes is not None:
            oprot.writeFieldBegin('replaced_data_files_without_deletes', TType.SET, 8)
            oprot.writeSetBegin(TType.STRING, len(self.replaced_data_files_without_deletes))
            for iter41 in self.replaced_data_files_without_deletes:
                oprot.writeString(iter41)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.operation is None:
            raise TProtocolException(message='Required field operation is unset!')
        if self.is_overwrite is None:
            raise TProtocolException(message='Required field is_overwrite is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdatedPartition(object):
    """
    Attributes:
     - files

    """


    def __init__(self, files=None,):
        self.files = files

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.files = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = iprot.readString()
                        self.files.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdatedPartition')
        if self.files is not None:
            oprot.writeFieldBegin('files', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.files))
            for iter48 in self.files:
                oprot.writeString(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.files is None:
            raise TProtocolException(message='Required field files is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateCatalogRequest(object):
    """
    Attributes:
     - protocol_version
     - sync_ddl
     - header
     - target_table
     - db_name
     - updated_partitions
     - is_overwrite
     - transaction_id
     - write_id
     - iceberg_operation
     - debug_action

    """


    def __init__(self, protocol_version=1, sync_ddl=None, header=None, target_table=None, db_name=None, updated_partitions=None, is_overwrite=None, transaction_id=None, write_id=None, iceberg_operation=None, debug_action=None,):
        self.protocol_version = protocol_version
        self.sync_ddl = sync_ddl
        self.header = header
        self.target_table = target_table
        self.db_name = db_name
        self.updated_partitions = updated_partitions
        self.is_overwrite = is_overwrite
        self.transaction_id = transaction_id
        self.write_id = write_id
        self.iceberg_operation = iceberg_operation
        self.debug_action = debug_action

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.sync_ddl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.target_table = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.updated_partitions = {}
                    (_ktype50, _vtype51, _size49) = iprot.readMapBegin()
                    for _i53 in range(_size49):
                        _key54 = iprot.readString()
                        _val55 = TUpdatedPartition()
                        _val55.read(iprot)
                        self.updated_partitions[_key54] = _val55
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.is_overwrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.transaction_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.write_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.iceberg_operation = TIcebergOperationParam()
                    self.iceberg_operation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRING:
                    self.debug_action = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateCatalogRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.sync_ddl is not None:
            oprot.writeFieldBegin('sync_ddl', TType.BOOL, 2)
            oprot.writeBool(self.sync_ddl)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 3)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.target_table is not None:
            oprot.writeFieldBegin('target_table', TType.STRING, 4)
            oprot.writeString(self.target_table)
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 5)
            oprot.writeString(self.db_name)
            oprot.writeFieldEnd()
        if self.updated_partitions is not None:
            oprot.writeFieldBegin('updated_partitions', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.updated_partitions))
            for kiter56, viter57 in self.updated_partitions.items():
                oprot.writeString(kiter56)
                viter57.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.is_overwrite is not None:
            oprot.writeFieldBegin('is_overwrite', TType.BOOL, 7)
            oprot.writeBool(self.is_overwrite)
            oprot.writeFieldEnd()
        if self.transaction_id is not None:
            oprot.writeFieldBegin('transaction_id', TType.I64, 8)
            oprot.writeI64(self.transaction_id)
            oprot.writeFieldEnd()
        if self.write_id is not None:
            oprot.writeFieldBegin('write_id', TType.I64, 9)
            oprot.writeI64(self.write_id)
            oprot.writeFieldEnd()
        if self.iceberg_operation is not None:
            oprot.writeFieldBegin('iceberg_operation', TType.STRUCT, 10)
            self.iceberg_operation.write(oprot)
            oprot.writeFieldEnd()
        if self.debug_action is not None:
            oprot.writeFieldBegin('debug_action', TType.STRING, 11)
            oprot.writeString(self.debug_action)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.sync_ddl is None:
            raise TProtocolException(message='Required field sync_ddl is unset!')
        if self.target_table is None:
            raise TProtocolException(message='Required field target_table is unset!')
        if self.db_name is None:
            raise TProtocolException(message='Required field db_name is unset!')
        if self.updated_partitions is None:
            raise TProtocolException(message='Required field updated_partitions is unset!')
        if self.is_overwrite is None:
            raise TProtocolException(message='Required field is_overwrite is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateCatalogResponse(object):
    """
    Attributes:
     - result
     - profile

    """


    def __init__(self, result=None, profile=None,):
        self.result = result
        self.profile = profile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.result = TCatalogUpdateResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.profile = RuntimeProfile.ttypes.TRuntimeProfileNode()
                    self.profile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateCatalogResponse')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 1)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        if self.profile is not None:
            oprot.writeFieldBegin('profile', TType.STRUCT, 2)
            self.profile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.result is None:
            raise TProtocolException(message='Required field result is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResetMetadataRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - is_refresh
     - table_name
     - partition_spec
     - db_name
     - sync_ddl
     - authorization
     - refresh_updated_hms_partitions
     - debug_action

    """


    def __init__(self, protocol_version=1, header=None, is_refresh=None, table_name=None, partition_spec=None, db_name=None, sync_ddl=None, authorization=None, refresh_updated_hms_partitions=None, debug_action=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.is_refresh = is_refresh
        self.table_name = table_name
        self.partition_spec = partition_spec
        self.db_name = db_name
        self.sync_ddl = sync_ddl
        self.authorization = authorization
        self.refresh_updated_hms_partitions = refresh_updated_hms_partitions
        self.debug_action = debug_action

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.is_refresh = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.partition_spec = []
                    (_etype61, _size58) = iprot.readListBegin()
                    for _i62 in range(_size58):
                        _elem63 = CatalogObjects.ttypes.TPartitionKeyValue()
                        _elem63.read(iprot)
                        self.partition_spec.append(_elem63)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.sync_ddl = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.authorization = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.BOOL:
                    self.refresh_updated_hms_partitions = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.debug_action = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResetMetadataRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 2)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.is_refresh is not None:
            oprot.writeFieldBegin('is_refresh', TType.BOOL, 3)
            oprot.writeBool(self.is_refresh)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 4)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
            for iter64 in self.partition_spec:
                iter64.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 6)
            oprot.writeString(self.db_name)
            oprot.writeFieldEnd()
        if self.sync_ddl is not None:
            oprot.writeFieldBegin('sync_ddl', TType.BOOL, 7)
            oprot.writeBool(self.sync_ddl)
            oprot.writeFieldEnd()
        if self.authorization is not None:
            oprot.writeFieldBegin('authorization', TType.BOOL, 8)
            oprot.writeBool(self.authorization)
            oprot.writeFieldEnd()
        if self.refresh_updated_hms_partitions is not None:
            oprot.writeFieldBegin('refresh_updated_hms_partitions', TType.BOOL, 9)
            oprot.writeBool(self.refresh_updated_hms_partitions)
            oprot.writeFieldEnd()
        if self.debug_action is not None:
            oprot.writeFieldBegin('debug_action', TType.STRING, 10)
            oprot.writeString(self.debug_action)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.is_refresh is None:
            raise TProtocolException(message='Required field is_refresh is unset!')
        if self.sync_ddl is None:
            raise TProtocolException(message='Required field sync_ddl is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResetMetadataResponse(object):
    """
    Attributes:
     - result
     - profile

    """


    def __init__(self, result=None, profile=None,):
        self.result = result
        self.profile = profile

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.result = TCatalogUpdateResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.profile = RuntimeProfile.ttypes.TRuntimeProfileNode()
                    self.profile.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResetMetadataResponse')
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 1)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        if self.profile is not None:
            oprot.writeFieldBegin('profile', TType.STRUCT, 2)
            self.profile.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.result is None:
            raise TProtocolException(message='Required field result is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetFunctionsRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - db_name

    """


    def __init__(self, protocol_version=1, header=None, db_name=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.db_name = db_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetFunctionsRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 2)
            oprot.writeString(self.db_name)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 3)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetFunctionsResponse(object):
    """
    Attributes:
     - status
     - functions

    """


    def __init__(self, status=None, functions=None,):
        self.status = status
        self.functions = functions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.functions = []
                    (_etype68, _size65) = iprot.readListBegin()
                    for _i69 in range(_size65):
                        _elem70 = Types.ttypes.TFunction()
                        _elem70.read(iprot)
                        self.functions.append(_elem70)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetFunctionsResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.functions is not None:
            oprot.writeFieldBegin('functions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.functions))
            for iter71 in self.functions:
                iter71.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogInfoSelector(object):
    """
    Attributes:
     - want_db_names

    """


    def __init__(self, want_db_names=None,):
        self.want_db_names = want_db_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.want_db_names = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogInfoSelector')
        if self.want_db_names is not None:
            oprot.writeFieldBegin('want_db_names', TType.BOOL, 1)
            oprot.writeBool(self.want_db_names)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartialCatalogInfo(object):
    """
    Attributes:
     - db_names

    """


    def __init__(self, db_names=None,):
        self.db_names = db_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.db_names = []
                    (_etype75, _size72) = iprot.readListBegin()
                    for _i76 in range(_size72):
                        _elem77 = iprot.readString()
                        self.db_names.append(_elem77)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartialCatalogInfo')
        if self.db_names is not None:
            oprot.writeFieldBegin('db_names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.db_names))
            for iter78 in self.db_names:
                oprot.writeString(iter78)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableInfoSelector(object):
    """
    Attributes:
     - want_hms_table
     - partition_ids
     - want_partition_names
     - want_partition_metadata
     - want_partition_files
     - want_stats_for_column_names
     - want_partition_stats
     - want_table_constraints
     - valid_write_ids
     - table_id
     - want_stats_for_all_columns
     - want_hms_partition
     - want_iceberg_table

    """


    def __init__(self, want_hms_table=None, partition_ids=None, want_partition_names=None, want_partition_metadata=None, want_partition_files=None, want_stats_for_column_names=None, want_partition_stats=None, want_table_constraints=None, valid_write_ids=None, table_id=-1, want_stats_for_all_columns=None, want_hms_partition=None, want_iceberg_table=None,):
        self.want_hms_table = want_hms_table
        self.partition_ids = partition_ids
        self.want_partition_names = want_partition_names
        self.want_partition_metadata = want_partition_metadata
        self.want_partition_files = want_partition_files
        self.want_stats_for_column_names = want_stats_for_column_names
        self.want_partition_stats = want_partition_stats
        self.want_table_constraints = want_table_constraints
        self.valid_write_ids = valid_write_ids
        self.table_id = table_id
        self.want_stats_for_all_columns = want_stats_for_all_columns
        self.want_hms_partition = want_hms_partition
        self.want_iceberg_table = want_iceberg_table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.want_hms_table = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_ids = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = iprot.readI64()
                        self.partition_ids.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.want_partition_names = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.want_partition_metadata = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.want_partition_files = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.want_stats_for_column_names = []
                    (_etype88, _size85) = iprot.readListBegin()
                    for _i89 in range(_size85):
                        _elem90 = iprot.readString()
                        self.want_stats_for_column_names.append(_elem90)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.want_partition_stats = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.want_table_constraints = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.valid_write_ids = CatalogObjects.ttypes.TValidWriteIdList()
                    self.valid_write_ids.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.table_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.want_stats_for_all_columns = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.want_hms_partition = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.want_iceberg_table = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableInfoSelector')
        if self.want_hms_table is not None:
            oprot.writeFieldBegin('want_hms_table', TType.BOOL, 1)
            oprot.writeBool(self.want_hms_table)
            oprot.writeFieldEnd()
        if self.partition_ids is not None:
            oprot.writeFieldBegin('partition_ids', TType.LIST, 2)
            oprot.writeListBegin(TType.I64, len(self.partition_ids))
            for iter91 in self.partition_ids:
                oprot.writeI64(iter91)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.want_partition_names is not None:
            oprot.writeFieldBegin('want_partition_names', TType.BOOL, 3)
            oprot.writeBool(self.want_partition_names)
            oprot.writeFieldEnd()
        if self.want_partition_metadata is not None:
            oprot.writeFieldBegin('want_partition_metadata', TType.BOOL, 4)
            oprot.writeBool(self.want_partition_metadata)
            oprot.writeFieldEnd()
        if self.want_partition_files is not None:
            oprot.writeFieldBegin('want_partition_files', TType.BOOL, 5)
            oprot.writeBool(self.want_partition_files)
            oprot.writeFieldEnd()
        if self.want_stats_for_column_names is not None:
            oprot.writeFieldBegin('want_stats_for_column_names', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.want_stats_for_column_names))
            for iter92 in self.want_stats_for_column_names:
                oprot.writeString(iter92)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.want_partition_stats is not None:
            oprot.writeFieldBegin('want_partition_stats', TType.BOOL, 7)
            oprot.writeBool(self.want_partition_stats)
            oprot.writeFieldEnd()
        if self.want_table_constraints is not None:
            oprot.writeFieldBegin('want_table_constraints', TType.BOOL, 8)
            oprot.writeBool(self.want_table_constraints)
            oprot.writeFieldEnd()
        if self.valid_write_ids is not None:
            oprot.writeFieldBegin('valid_write_ids', TType.STRUCT, 9)
            self.valid_write_ids.write(oprot)
            oprot.writeFieldEnd()
        if self.table_id is not None:
            oprot.writeFieldBegin('table_id', TType.I64, 10)
            oprot.writeI64(self.table_id)
            oprot.writeFieldEnd()
        if self.want_stats_for_all_columns is not None:
            oprot.writeFieldBegin('want_stats_for_all_columns', TType.BOOL, 11)
            oprot.writeBool(self.want_stats_for_all_columns)
            oprot.writeFieldEnd()
        if self.want_hms_partition is not None:
            oprot.writeFieldBegin('want_hms_partition', TType.BOOL, 12)
            oprot.writeBool(self.want_hms_partition)
            oprot.writeFieldEnd()
        if self.want_iceberg_table is not None:
            oprot.writeFieldBegin('want_iceberg_table', TType.BOOL, 13)
            oprot.writeBool(self.want_iceberg_table)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartialPartitionInfo(object):
    """
    Attributes:
     - id
     - name
     - hms_partition
     - file_descriptors
     - insert_file_descriptors
     - delete_file_descriptors
     - last_compaction_id
     - partition_stats
     - has_incremental_stats
     - is_marked_cached
     - hms_parameters
     - write_id
     - hdfs_storage_descriptor
     - location

    """


    def __init__(self, id=None, name=None, hms_partition=None, file_descriptors=None, insert_file_descriptors=None, delete_file_descriptors=None, last_compaction_id=None, partition_stats=None, has_incremental_stats=None, is_marked_cached=None, hms_parameters=None, write_id=None, hdfs_storage_descriptor=None, location=None,):
        self.id = id
        self.name = name
        self.hms_partition = hms_partition
        self.file_descriptors = file_descriptors
        self.insert_file_descriptors = insert_file_descriptors
        self.delete_file_descriptors = delete_file_descriptors
        self.last_compaction_id = last_compaction_id
        self.partition_stats = partition_stats
        self.has_incremental_stats = has_incremental_stats
        self.is_marked_cached = is_marked_cached
        self.hms_parameters = hms_parameters
        self.write_id = write_id
        self.hdfs_storage_descriptor = hdfs_storage_descriptor
        self.location = location

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.hms_partition = hive_metastore.ttypes.Partition()
                    self.hms_partition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.file_descriptors = []
                    (_etype96, _size93) = iprot.readListBegin()
                    for _i97 in range(_size93):
                        _elem98 = CatalogObjects.ttypes.THdfsFileDesc()
                        _elem98.read(iprot)
                        self.file_descriptors.append(_elem98)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.insert_file_descriptors = []
                    (_etype102, _size99) = iprot.readListBegin()
                    for _i103 in range(_size99):
                        _elem104 = CatalogObjects.ttypes.THdfsFileDesc()
                        _elem104.read(iprot)
                        self.insert_file_descriptors.append(_elem104)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.delete_file_descriptors = []
                    (_etype108, _size105) = iprot.readListBegin()
                    for _i109 in range(_size105):
                        _elem110 = CatalogObjects.ttypes.THdfsFileDesc()
                        _elem110.read(iprot)
                        self.delete_file_descriptors.append(_elem110)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.last_compaction_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.partition_stats = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.has_incremental_stats = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.is_marked_cached = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.MAP:
                    self.hms_parameters = {}
                    (_ktype112, _vtype113, _size111) = iprot.readMapBegin()
                    for _i115 in range(_size111):
                        _key116 = iprot.readString()
                        _val117 = iprot.readString()
                        self.hms_parameters[_key116] = _val117
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.write_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.hdfs_storage_descriptor = CatalogObjects.ttypes.THdfsStorageDescriptor()
                    self.hdfs_storage_descriptor.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.location = CatalogObjects.ttypes.THdfsPartitionLocation()
                    self.location.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartialPartitionInfo')
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 1)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.hms_partition is not None:
            oprot.writeFieldBegin('hms_partition', TType.STRUCT, 3)
            self.hms_partition.write(oprot)
            oprot.writeFieldEnd()
        if self.file_descriptors is not None:
            oprot.writeFieldBegin('file_descriptors', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.file_descriptors))
            for iter118 in self.file_descriptors:
                iter118.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_stats is not None:
            oprot.writeFieldBegin('partition_stats', TType.STRING, 5)
            oprot.writeBinary(self.partition_stats)
            oprot.writeFieldEnd()
        if self.has_incremental_stats is not None:
            oprot.writeFieldBegin('has_incremental_stats', TType.BOOL, 6)
            oprot.writeBool(self.has_incremental_stats)
            oprot.writeFieldEnd()
        if self.is_marked_cached is not None:
            oprot.writeFieldBegin('is_marked_cached', TType.BOOL, 7)
            oprot.writeBool(self.is_marked_cached)
            oprot.writeFieldEnd()
        if self.insert_file_descriptors is not None:
            oprot.writeFieldBegin('insert_file_descriptors', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.insert_file_descriptors))
            for iter119 in self.insert_file_descriptors:
                iter119.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.delete_file_descriptors is not None:
            oprot.writeFieldBegin('delete_file_descriptors', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.delete_file_descriptors))
            for iter120 in self.delete_file_descriptors:
                iter120.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.hms_parameters is not None:
            oprot.writeFieldBegin('hms_parameters', TType.MAP, 10)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.hms_parameters))
            for kiter121, viter122 in self.hms_parameters.items():
                oprot.writeString(kiter121)
                oprot.writeString(viter122)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.write_id is not None:
            oprot.writeFieldBegin('write_id', TType.I64, 11)
            oprot.writeI64(self.write_id)
            oprot.writeFieldEnd()
        if self.hdfs_storage_descriptor is not None:
            oprot.writeFieldBegin('hdfs_storage_descriptor', TType.STRUCT, 12)
            self.hdfs_storage_descriptor.write(oprot)
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRUCT, 13)
            self.location.write(oprot)
            oprot.writeFieldEnd()
        if self.last_compaction_id is not None:
            oprot.writeFieldBegin('last_compaction_id', TType.I64, 14)
            oprot.writeI64(self.last_compaction_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.id is None:
            raise TProtocolException(message='Required field id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartialTableInfo(object):
    """
    Attributes:
     - hms_table
     - partitions
     - column_stats
     - virtual_columns
     - storage_metadata_load_time_ns
     - network_addresses
     - sql_constraints
     - valid_write_ids
     - is_marked_cached
     - partition_prefixes
     - iceberg_table

    """


    def __init__(self, hms_table=None, partitions=None, column_stats=None, virtual_columns=None, storage_metadata_load_time_ns=None, network_addresses=None, sql_constraints=None, valid_write_ids=None, is_marked_cached=None, partition_prefixes=None, iceberg_table=None,):
        self.hms_table = hms_table
        self.partitions = partitions
        self.column_stats = column_stats
        self.virtual_columns = virtual_columns
        self.storage_metadata_load_time_ns = storage_metadata_load_time_ns
        self.network_addresses = network_addresses
        self.sql_constraints = sql_constraints
        self.valid_write_ids = valid_write_ids
        self.is_marked_cached = is_marked_cached
        self.partition_prefixes = partition_prefixes
        self.iceberg_table = iceberg_table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hms_table = hive_metastore.ttypes.Table()
                    self.hms_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partitions = []
                    (_etype126, _size123) = iprot.readListBegin()
                    for _i127 in range(_size123):
                        _elem128 = TPartialPartitionInfo()
                        _elem128.read(iprot)
                        self.partitions.append(_elem128)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.column_stats = []
                    (_etype132, _size129) = iprot.readListBegin()
                    for _i133 in range(_size129):
                        _elem134 = hive_metastore.ttypes.ColumnStatisticsObj()
                        _elem134.read(iprot)
                        self.column_stats.append(_elem134)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.virtual_columns = []
                    (_etype138, _size135) = iprot.readListBegin()
                    for _i139 in range(_size135):
                        _elem140 = CatalogObjects.ttypes.TColumn()
                        _elem140.read(iprot)
                        self.virtual_columns.append(_elem140)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.storage_metadata_load_time_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.network_addresses = []
                    (_etype144, _size141) = iprot.readListBegin()
                    for _i145 in range(_size141):
                        _elem146 = Types.ttypes.TNetworkAddress()
                        _elem146.read(iprot)
                        self.network_addresses.append(_elem146)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.sql_constraints = SqlConstraints.ttypes.TSqlConstraints()
                    self.sql_constraints.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.valid_write_ids = CatalogObjects.ttypes.TValidWriteIdList()
                    self.valid_write_ids.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.is_marked_cached = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.LIST:
                    self.partition_prefixes = []
                    (_etype150, _size147) = iprot.readListBegin()
                    for _i151 in range(_size147):
                        _elem152 = iprot.readString()
                        self.partition_prefixes.append(_elem152)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.iceberg_table = CatalogObjects.ttypes.TIcebergTable()
                    self.iceberg_table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartialTableInfo')
        if self.hms_table is not None:
            oprot.writeFieldBegin('hms_table', TType.STRUCT, 1)
            self.hms_table.write(oprot)
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.partitions))
            for iter153 in self.partitions:
                iter153.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.column_stats is not None:
            oprot.writeFieldBegin('column_stats', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.column_stats))
            for iter154 in self.column_stats:
                iter154.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.virtual_columns is not None:
            oprot.writeFieldBegin('virtual_columns', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.virtual_columns))
            for iter155 in self.virtual_columns:
                iter155.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.storage_metadata_load_time_ns is not None:
            oprot.writeFieldBegin('storage_metadata_load_time_ns', TType.I64, 5)
            oprot.writeI64(self.storage_metadata_load_time_ns)
            oprot.writeFieldEnd()
        if self.network_addresses is not None:
            oprot.writeFieldBegin('network_addresses', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.network_addresses))
            for iter156 in self.network_addresses:
                iter156.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.sql_constraints is not None:
            oprot.writeFieldBegin('sql_constraints', TType.STRUCT, 9)
            self.sql_constraints.write(oprot)
            oprot.writeFieldEnd()
        if self.valid_write_ids is not None:
            oprot.writeFieldBegin('valid_write_ids', TType.STRUCT, 10)
            self.valid_write_ids.write(oprot)
            oprot.writeFieldEnd()
        if self.is_marked_cached is not None:
            oprot.writeFieldBegin('is_marked_cached', TType.BOOL, 11)
            oprot.writeBool(self.is_marked_cached)
            oprot.writeFieldEnd()
        if self.partition_prefixes is not None:
            oprot.writeFieldBegin('partition_prefixes', TType.LIST, 12)
            oprot.writeListBegin(TType.STRING, len(self.partition_prefixes))
            for iter157 in self.partition_prefixes:
                oprot.writeString(iter157)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.iceberg_table is not None:
            oprot.writeFieldBegin('iceberg_table', TType.STRUCT, 13)
            self.iceberg_table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TBriefTableMeta(object):
    """
    Attributes:
     - name
     - msType
     - comment
     - tblType

    """


    def __init__(self, name=None, msType=None, comment=None, tblType=None,):
        self.name = name
        self.msType = msType
        self.comment = comment
        self.tblType = tblType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.msType = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.comment = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.tblType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TBriefTableMeta')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.msType is not None:
            oprot.writeFieldBegin('msType', TType.STRING, 2)
            oprot.writeString(self.msType)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 3)
            oprot.writeString(self.comment)
            oprot.writeFieldEnd()
        if self.tblType is not None:
            oprot.writeFieldBegin('tblType', TType.I32, 4)
            oprot.writeI32(self.tblType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDbInfoSelector(object):
    """
    Attributes:
     - want_hms_database
     - want_brief_meta_of_tables
     - want_function_names

    """


    def __init__(self, want_hms_database=None, want_brief_meta_of_tables=None, want_function_names=None,):
        self.want_hms_database = want_hms_database
        self.want_brief_meta_of_tables = want_brief_meta_of_tables
        self.want_function_names = want_function_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.want_hms_database = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.want_brief_meta_of_tables = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.want_function_names = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDbInfoSelector')
        if self.want_hms_database is not None:
            oprot.writeFieldBegin('want_hms_database', TType.BOOL, 1)
            oprot.writeBool(self.want_hms_database)
            oprot.writeFieldEnd()
        if self.want_brief_meta_of_tables is not None:
            oprot.writeFieldBegin('want_brief_meta_of_tables', TType.BOOL, 2)
            oprot.writeBool(self.want_brief_meta_of_tables)
            oprot.writeFieldEnd()
        if self.want_function_names is not None:
            oprot.writeFieldBegin('want_function_names', TType.BOOL, 3)
            oprot.writeBool(self.want_function_names)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartialDbInfo(object):
    """
    Attributes:
     - hms_database
     - brief_meta_of_tables
     - function_names

    """


    def __init__(self, hms_database=None, brief_meta_of_tables=None, function_names=None,):
        self.hms_database = hms_database
        self.brief_meta_of_tables = brief_meta_of_tables
        self.function_names = function_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hms_database = hive_metastore.ttypes.Database()
                    self.hms_database.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.brief_meta_of_tables = []
                    (_etype161, _size158) = iprot.readListBegin()
                    for _i162 in range(_size158):
                        _elem163 = TBriefTableMeta()
                        _elem163.read(iprot)
                        self.brief_meta_of_tables.append(_elem163)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.function_names = []
                    (_etype167, _size164) = iprot.readListBegin()
                    for _i168 in range(_size164):
                        _elem169 = iprot.readString()
                        self.function_names.append(_elem169)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartialDbInfo')
        if self.hms_database is not None:
            oprot.writeFieldBegin('hms_database', TType.STRUCT, 1)
            self.hms_database.write(oprot)
            oprot.writeFieldEnd()
        if self.brief_meta_of_tables is not None:
            oprot.writeFieldBegin('brief_meta_of_tables', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.brief_meta_of_tables))
            for iter170 in self.brief_meta_of_tables:
                iter170.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.function_names is not None:
            oprot.writeFieldBegin('function_names', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.function_names))
            for iter171 in self.function_names:
                oprot.writeString(iter171)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPartialCatalogObjectRequest(object):
    """
    Attributes:
     - protocol_version
     - object_desc
     - table_info_selector
     - db_info_selector
     - catalog_info_selector

    """


    def __init__(self, protocol_version=1, object_desc=None, table_info_selector=None, db_info_selector=None, catalog_info_selector=None,):
        self.protocol_version = protocol_version
        self.object_desc = object_desc
        self.table_info_selector = table_info_selector
        self.db_info_selector = db_info_selector
        self.catalog_info_selector = catalog_info_selector

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.object_desc = CatalogObjects.ttypes.TCatalogObject()
                    self.object_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.table_info_selector = TTableInfoSelector()
                    self.table_info_selector.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.db_info_selector = TDbInfoSelector()
                    self.db_info_selector.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.catalog_info_selector = TCatalogInfoSelector()
                    self.catalog_info_selector.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPartialCatalogObjectRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.object_desc is not None:
            oprot.writeFieldBegin('object_desc', TType.STRUCT, 2)
            self.object_desc.write(oprot)
            oprot.writeFieldEnd()
        if self.table_info_selector is not None:
            oprot.writeFieldBegin('table_info_selector', TType.STRUCT, 3)
            self.table_info_selector.write(oprot)
            oprot.writeFieldEnd()
        if self.db_info_selector is not None:
            oprot.writeFieldBegin('db_info_selector', TType.STRUCT, 4)
            self.db_info_selector.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_info_selector is not None:
            oprot.writeFieldBegin('catalog_info_selector', TType.STRUCT, 5)
            self.catalog_info_selector.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.object_desc is None:
            raise TProtocolException(message='Required field object_desc is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPartialCatalogObjectResponse(object):
    """
    Attributes:
     - status
     - lookup_status
     - object_version_number
     - table_info
     - db_info
     - catalog_info
     - functions
     - data_srcs
     - object_loaded_time_ms

    """


    def __init__(self, status=None, lookup_status=0, object_version_number=None, table_info=None, db_info=None, catalog_info=None, functions=None, data_srcs=None, object_loaded_time_ms=None,):
        self.status = status
        self.lookup_status = lookup_status
        self.object_version_number = object_version_number
        self.table_info = table_info
        self.db_info = db_info
        self.catalog_info = catalog_info
        self.functions = functions
        self.data_srcs = data_srcs
        self.object_loaded_time_ms = object_loaded_time_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.lookup_status = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.object_version_number = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.table_info = TPartialTableInfo()
                    self.table_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.db_info = TPartialDbInfo()
                    self.db_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.catalog_info = TPartialCatalogInfo()
                    self.catalog_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.functions = []
                    (_etype175, _size172) = iprot.readListBegin()
                    for _i176 in range(_size172):
                        _elem177 = Types.ttypes.TFunction()
                        _elem177.read(iprot)
                        self.functions.append(_elem177)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.data_srcs = []
                    (_etype181, _size178) = iprot.readListBegin()
                    for _i182 in range(_size178):
                        _elem183 = CatalogObjects.ttypes.TDataSource()
                        _elem183.read(iprot)
                        self.data_srcs.append(_elem183)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.object_loaded_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPartialCatalogObjectResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.lookup_status is not None:
            oprot.writeFieldBegin('lookup_status', TType.I32, 2)
            oprot.writeI32(self.lookup_status)
            oprot.writeFieldEnd()
        if self.object_version_number is not None:
            oprot.writeFieldBegin('object_version_number', TType.I64, 3)
            oprot.writeI64(self.object_version_number)
            oprot.writeFieldEnd()
        if self.table_info is not None:
            oprot.writeFieldBegin('table_info', TType.STRUCT, 4)
            self.table_info.write(oprot)
            oprot.writeFieldEnd()
        if self.db_info is not None:
            oprot.writeFieldBegin('db_info', TType.STRUCT, 5)
            self.db_info.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_info is not None:
            oprot.writeFieldBegin('catalog_info', TType.STRUCT, 6)
            self.catalog_info.write(oprot)
            oprot.writeFieldEnd()
        if self.functions is not None:
            oprot.writeFieldBegin('functions', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.functions))
            for iter184 in self.functions:
                iter184.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.data_srcs is not None:
            oprot.writeFieldBegin('data_srcs', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.data_srcs))
            for iter185 in self.data_srcs:
                iter185.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.object_loaded_time_ms is not None:
            oprot.writeFieldBegin('object_loaded_time_ms', TType.I64, 9)
            oprot.writeI64(self.object_loaded_time_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetCatalogObjectRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - object_desc

    """


    def __init__(self, protocol_version=1, header=None, object_desc=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.object_desc = object_desc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.object_desc = CatalogObjects.ttypes.TCatalogObject()
                    self.object_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetCatalogObjectRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.object_desc is not None:
            oprot.writeFieldBegin('object_desc', TType.STRUCT, 2)
            self.object_desc.write(oprot)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 3)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.object_desc is None:
            raise TProtocolException(message='Required field object_desc is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetCatalogObjectResponse(object):
    """
    Attributes:
     - status
     - catalog_object

    """


    def __init__(self, status=None, catalog_object=None,):
        self.status = status
        self.catalog_object = catalog_object

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.catalog_object = CatalogObjects.ttypes.TCatalogObject()
                    self.catalog_object.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetCatalogObjectResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_object is not None:
            oprot.writeFieldBegin('catalog_object', TType.STRUCT, 2)
            self.catalog_object.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.catalog_object is None:
            raise TProtocolException(message='Required field catalog_object is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPartitionStatsRequest(object):
    """
    Attributes:
     - protocol_version
     - table_name
     - valid_write_ids
     - table_id

    """


    def __init__(self, protocol_version=1, table_name=None, valid_write_ids=None, table_id=-1,):
        self.protocol_version = protocol_version
        self.table_name = table_name
        self.valid_write_ids = valid_write_ids
        self.table_id = table_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.valid_write_ids = CatalogObjects.ttypes.TValidWriteIdList()
                    self.valid_write_ids.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.table_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPartitionStatsRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 2)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.valid_write_ids is not None:
            oprot.writeFieldBegin('valid_write_ids', TType.STRUCT, 3)
            self.valid_write_ids.write(oprot)
            oprot.writeFieldEnd()
        if self.table_id is not None:
            oprot.writeFieldBegin('table_id', TType.I64, 4)
            oprot.writeI64(self.table_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetPartitionStatsResponse(object):
    """
    Attributes:
     - status
     - partition_stats

    """


    def __init__(self, status=None, partition_stats=None,):
        self.status = status
        self.partition_stats = partition_stats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.partition_stats = {}
                    (_ktype187, _vtype188, _size186) = iprot.readMapBegin()
                    for _i190 in range(_size186):
                        _key191 = iprot.readString()
                        _val192 = iprot.readBinary()
                        self.partition_stats[_key191] = _val192
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetPartitionStatsResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_stats is not None:
            oprot.writeFieldBegin('partition_stats', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partition_stats))
            for kiter193, viter194 in self.partition_stats.items():
                oprot.writeString(kiter193)
                oprot.writeBinary(viter194)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetNullPartitionNameRequest(object):
    """
    Attributes:
     - protocol_version

    """


    def __init__(self, protocol_version=1,):
        self.protocol_version = protocol_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetNullPartitionNameRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetNullPartitionNameResponse(object):
    """
    Attributes:
     - status
     - partition_value

    """


    def __init__(self, status=None, partition_value=None,):
        self.status = status
        self.partition_value = partition_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.partition_value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetNullPartitionNameResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_value is not None:
            oprot.writeFieldBegin('partition_value', TType.STRING, 2)
            oprot.writeString(self.partition_value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.partition_value is None:
            raise TProtocolException(message='Required field partition_value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetLatestCompactionsRequest(object):
    """
    Attributes:
     - protocol_version
     - db_name
     - table_name
     - non_parition_name
     - partition_names
     - last_compaction_id

    """


    def __init__(self, protocol_version=1, db_name=None, table_name=None, non_parition_name=None, partition_names=None, last_compaction_id=None,):
        self.protocol_version = protocol_version
        self.db_name = db_name
        self.table_name = table_name
        self.non_parition_name = non_parition_name
        self.partition_names = partition_names
        self.last_compaction_id = last_compaction_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.non_parition_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.partition_names = []
                    (_etype198, _size195) = iprot.readListBegin()
                    for _i199 in range(_size195):
                        _elem200 = iprot.readString()
                        self.partition_names.append(_elem200)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.last_compaction_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetLatestCompactionsRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 2)
            oprot.writeString(self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 3)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.non_parition_name is not None:
            oprot.writeFieldBegin('non_parition_name', TType.STRING, 4)
            oprot.writeString(self.non_parition_name)
            oprot.writeFieldEnd()
        if self.partition_names is not None:
            oprot.writeFieldBegin('partition_names', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.partition_names))
            for iter201 in self.partition_names:
                oprot.writeString(iter201)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.last_compaction_id is not None:
            oprot.writeFieldBegin('last_compaction_id', TType.I64, 6)
            oprot.writeI64(self.last_compaction_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.db_name is None:
            raise TProtocolException(message='Required field db_name is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.non_parition_name is None:
            raise TProtocolException(message='Required field non_parition_name is unset!')
        if self.last_compaction_id is None:
            raise TProtocolException(message='Required field last_compaction_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetLatestCompactionsResponse(object):
    """
    Attributes:
     - status
     - partition_to_compaction_id

    """


    def __init__(self, status=None, partition_to_compaction_id=None,):
        self.status = status
        self.partition_to_compaction_id = partition_to_compaction_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.partition_to_compaction_id = {}
                    (_ktype203, _vtype204, _size202) = iprot.readMapBegin()
                    for _i206 in range(_size202):
                        _key207 = iprot.readString()
                        _val208 = iprot.readI64()
                        self.partition_to_compaction_id[_key207] = _val208
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetLatestCompactionsResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.partition_to_compaction_id is not None:
            oprot.writeFieldBegin('partition_to_compaction_id', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.partition_to_compaction_id))
            for kiter209, viter210 in self.partition_to_compaction_id.items():
                oprot.writeString(kiter209)
                oprot.writeI64(viter210)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        if self.partition_to_compaction_id is None:
            raise TProtocolException(message='Required field partition_to_compaction_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPrioritizeLoadRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - object_descs

    """


    def __init__(self, protocol_version=1, header=None, object_descs=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.object_descs = object_descs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.object_descs = []
                    (_etype214, _size211) = iprot.readListBegin()
                    for _i215 in range(_size211):
                        _elem216 = CatalogObjects.ttypes.TCatalogObject()
                        _elem216.read(iprot)
                        self.object_descs.append(_elem216)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPrioritizeLoadRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 2)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.object_descs is not None:
            oprot.writeFieldBegin('object_descs', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.object_descs))
            for iter217 in self.object_descs:
                iter217.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.object_descs is None:
            raise TProtocolException(message='Required field object_descs is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPrioritizeLoadResponse(object):
    """
    Attributes:
     - status

    """


    def __init__(self, status=None,):
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPrioritizeLoadResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableUsage(object):
    """
    Attributes:
     - table_name
     - num_usages

    """


    def __init__(self, table_name=None, num_usages=None,):
        self.table_name = table_name
        self.num_usages = num_usages

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.table_name = CatalogObjects.ttypes.TTableName()
                    self.table_name.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_usages = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableUsage')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRUCT, 1)
            self.table_name.write(oprot)
            oprot.writeFieldEnd()
        if self.num_usages is not None:
            oprot.writeFieldBegin('num_usages', TType.I32, 2)
            oprot.writeI32(self.num_usages)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.num_usages is None:
            raise TProtocolException(message='Required field num_usages is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTableUsageRequest(object):
    """
    Attributes:
     - protocol_version
     - usages

    """


    def __init__(self, protocol_version=1, usages=None,):
        self.protocol_version = protocol_version
        self.usages = usages

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.usages = []
                    (_etype221, _size218) = iprot.readListBegin()
                    for _i222 in range(_size218):
                        _elem223 = TTableUsage()
                        _elem223.read(iprot)
                        self.usages.append(_elem223)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTableUsageRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.usages is not None:
            oprot.writeFieldBegin('usages', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.usages))
            for iter224 in self.usages:
                iter224.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.usages is None:
            raise TProtocolException(message='Required field usages is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUpdateTableUsageResponse(object):
    """
    Attributes:
     - status

    """


    def __init__(self, status=None,):
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUpdateTableUsageResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TEventProcessorCmdParams(object):
    """
    Attributes:
     - action
     - event_id

    """


    def __init__(self, action=None, event_id=None,):
        self.action = action
        self.event_id = event_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.action = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.event_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TEventProcessorCmdParams')
        if self.action is not None:
            oprot.writeFieldBegin('action', TType.STRING, 1)
            oprot.writeString(self.action)
            oprot.writeFieldEnd()
        if self.event_id is not None:
            oprot.writeFieldBegin('event_id', TType.I64, 2)
            oprot.writeI64(self.event_id)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.action is None:
            raise TProtocolException(message='Required field action is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetEventProcessorStatusRequest(object):
    """
    Attributes:
     - protocol_version
     - header
     - params

    """


    def __init__(self, protocol_version=1, header=None, params=None,):
        self.protocol_version = protocol_version
        self.header = header
        self.params = params

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.protocol_version = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.header = TCatalogServiceRequestHeader()
                    self.header.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.params = TEventProcessorCmdParams()
                    self.params.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetEventProcessorStatusRequest')
        if self.protocol_version is not None:
            oprot.writeFieldBegin('protocol_version', TType.I32, 1)
            oprot.writeI32(self.protocol_version)
            oprot.writeFieldEnd()
        if self.header is not None:
            oprot.writeFieldBegin('header', TType.STRUCT, 2)
            self.header.write(oprot)
            oprot.writeFieldEnd()
        if self.params is not None:
            oprot.writeFieldBegin('params', TType.STRUCT, 3)
            self.params.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.protocol_version is None:
            raise TProtocolException(message='Required field protocol_version is unset!')
        if self.params is None:
            raise TProtocolException(message='Required field params is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSetEventProcessorStatusResponse(object):
    """
    Attributes:
     - status
     - info

    """


    def __init__(self, status=None, info=None,):
        self.status = status
        self.info = info

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.info = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSetEventProcessorStatusResponse')
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 1)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRING, 2)
            oprot.writeString(self.info)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.status is None:
            raise TProtocolException(message='Required field status is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TCatalogServiceRequestHeader)
TCatalogServiceRequestHeader.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'requesting_user', None, None, ),  # 1
    (2, TType.STRING, 'redacted_sql_stmt', None, None, ),  # 2
    (3, TType.STRING, 'client_ip', None, None, ),  # 3
    (4, TType.BOOL, 'want_minimal_response', None, None, ),  # 4
    (5, TType.STRUCT, 'query_id', [Types.ttypes.TUniqueId, None], None, ),  # 5
    (6, TType.STRING, 'coordinator_hostname', None, None, ),  # 6
)
all_structs.append(TCatalogUpdateResult)
TCatalogUpdateResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'catalog_service_id', [Types.ttypes.TUniqueId, None], None, ),  # 1
    (2, TType.I64, 'version', None, None, ),  # 2
    (3, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 3
    (4, TType.BOOL, 'is_invalidate', None, None, ),  # 4
    (5, TType.LIST, 'updated_catalog_objects', (TType.STRUCT, [CatalogObjects.ttypes.TCatalogObject, None], False), None, ),  # 5
    (6, TType.LIST, 'removed_catalog_objects', (TType.STRUCT, [CatalogObjects.ttypes.TCatalogObject, None], False), None, ),  # 6
)
all_structs.append(TDdlQueryOptions)
TDdlQueryOptions.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'sync_ddl', None, None, ),  # 1
    (2, TType.STRING, 'debug_action', None, None, ),  # 2
    (3, TType.I32, 'lock_max_wait_time_s', None, None, ),  # 3
    (4, TType.I32, 'kudu_table_reserve_seconds', None, None, ),  # 4
)
all_structs.append(TDdlExecRequest)
TDdlExecRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 2
    (3, TType.I32, 'ddl_type', None, None, ),  # 3
    (4, TType.STRUCT, 'alter_table_params', [JniCatalog.ttypes.TAlterTableParams, None], None, ),  # 4
    (5, TType.STRUCT, 'alter_view_params', [JniCatalog.ttypes.TCreateOrAlterViewParams, None], None, ),  # 5
    (6, TType.STRUCT, 'create_db_params', [JniCatalog.ttypes.TCreateDbParams, None], None, ),  # 6
    (7, TType.STRUCT, 'create_table_params', [JniCatalog.ttypes.TCreateTableParams, None], None, ),  # 7
    (8, TType.STRUCT, 'create_table_like_params', [JniCatalog.ttypes.TCreateTableLikeParams, None], None, ),  # 8
    (9, TType.STRUCT, 'create_view_params', [JniCatalog.ttypes.TCreateOrAlterViewParams, None], None, ),  # 9
    (10, TType.STRUCT, 'create_fn_params', [JniCatalog.ttypes.TCreateFunctionParams, None], None, ),  # 10
    (11, TType.STRUCT, 'drop_db_params', [JniCatalog.ttypes.TDropDbParams, None], None, ),  # 11
    (12, TType.STRUCT, 'drop_table_or_view_params', [JniCatalog.ttypes.TDropTableOrViewParams, None], None, ),  # 12
    (13, TType.STRUCT, 'truncate_params', [JniCatalog.ttypes.TTruncateParams, None], None, ),  # 13
    (14, TType.STRUCT, 'drop_fn_params', [JniCatalog.ttypes.TDropFunctionParams, None], None, ),  # 14
    (15, TType.STRUCT, 'compute_stats_params', [JniCatalog.ttypes.TComputeStatsParams, None], None, ),  # 15
    (16, TType.STRUCT, 'create_data_source_params', [JniCatalog.ttypes.TCreateDataSourceParams, None], None, ),  # 16
    (17, TType.STRUCT, 'drop_data_source_params', [JniCatalog.ttypes.TDropDataSourceParams, None], None, ),  # 17
    (18, TType.STRUCT, 'drop_stats_params', [JniCatalog.ttypes.TDropStatsParams, None], None, ),  # 18
    (19, TType.STRUCT, 'create_drop_role_params', [JniCatalog.ttypes.TCreateDropRoleParams, None], None, ),  # 19
    (20, TType.STRUCT, 'grant_revoke_role_params', [JniCatalog.ttypes.TGrantRevokeRoleParams, None], None, ),  # 20
    (21, TType.STRUCT, 'grant_revoke_priv_params', [JniCatalog.ttypes.TGrantRevokePrivParams, None], None, ),  # 21
    (22, TType.STRUCT, 'comment_on_params', [JniCatalog.ttypes.TCommentOnParams, None], None, ),  # 22
    (23, TType.STRUCT, 'alter_db_params', [JniCatalog.ttypes.TAlterDbParams, None], None, ),  # 23
    (24, TType.STRUCT, 'copy_test_case_params', [JniCatalog.ttypes.TCopyTestCaseReq, None], None, ),  # 24
    (25, TType.STRUCT, 'query_options', [TDdlQueryOptions, None], None, ),  # 25
)
all_structs.append(TDdlExecResponse)
TDdlExecResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'result', [TCatalogUpdateResult, None], None, ),  # 1
    (2, TType.BOOL, 'new_table_created', None, None, ),  # 2
    (3, TType.STRUCT, 'result_set', [Results.ttypes.TResultSet, None], None, ),  # 3
    (4, TType.STRING, 'table_name', None, None, ),  # 4
    (5, TType.I64, 'table_create_time', None, None, ),  # 5
    (6, TType.STRING, 'table_location', None, None, ),  # 6
    (7, TType.STRUCT, 'profile', [RuntimeProfile.ttypes.TRuntimeProfileNode, None], None, ),  # 7
)
all_structs.append(TIcebergOperationParam)
TIcebergOperationParam.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'spec_id', None, None, ),  # 1
    (2, TType.LIST, 'iceberg_data_files_fb', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.BOOL, 'is_overwrite', None, False, ),  # 3
    (4, TType.I64, 'initial_snapshot_id', None, None, ),  # 4
    (5, TType.I32, 'operation', None, None, ),  # 5
    (6, TType.LIST, 'iceberg_delete_files_fb', (TType.STRING, 'BINARY', False), None, ),  # 6
    (7, TType.LIST, 'data_files_referenced_by_position_deletes', (TType.STRING, None, False), None, ),  # 7
    (8, TType.SET, 'replaced_data_files_without_deletes', (TType.STRING, None, False), None, ),  # 8
)
all_structs.append(TUpdatedPartition)
TUpdatedPartition.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'files', (TType.STRING, None, False), None, ),  # 1
)
all_structs.append(TUpdateCatalogRequest)
TUpdateCatalogRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.BOOL, 'sync_ddl', None, None, ),  # 2
    (3, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 3
    (4, TType.STRING, 'target_table', None, None, ),  # 4
    (5, TType.STRING, 'db_name', None, None, ),  # 5
    (6, TType.MAP, 'updated_partitions', (TType.STRING, None, TType.STRUCT, [TUpdatedPartition, None], False), None, ),  # 6
    (7, TType.BOOL, 'is_overwrite', None, None, ),  # 7
    (8, TType.I64, 'transaction_id', None, None, ),  # 8
    (9, TType.I64, 'write_id', None, None, ),  # 9
    (10, TType.STRUCT, 'iceberg_operation', [TIcebergOperationParam, None], None, ),  # 10
    (11, TType.STRING, 'debug_action', None, None, ),  # 11
)
all_structs.append(TUpdateCatalogResponse)
TUpdateCatalogResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'result', [TCatalogUpdateResult, None], None, ),  # 1
    (2, TType.STRUCT, 'profile', [RuntimeProfile.ttypes.TRuntimeProfileNode, None], None, ),  # 2
)
all_structs.append(TResetMetadataRequest)
TResetMetadataRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 2
    (3, TType.BOOL, 'is_refresh', None, None, ),  # 3
    (4, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 4
    (5, TType.LIST, 'partition_spec', (TType.STRUCT, [CatalogObjects.ttypes.TPartitionKeyValue, None], False), None, ),  # 5
    (6, TType.STRING, 'db_name', None, None, ),  # 6
    (7, TType.BOOL, 'sync_ddl', None, None, ),  # 7
    (8, TType.BOOL, 'authorization', None, None, ),  # 8
    (9, TType.BOOL, 'refresh_updated_hms_partitions', None, None, ),  # 9
    (10, TType.STRING, 'debug_action', None, None, ),  # 10
)
all_structs.append(TResetMetadataResponse)
TResetMetadataResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'result', [TCatalogUpdateResult, None], None, ),  # 1
    (2, TType.STRUCT, 'profile', [RuntimeProfile.ttypes.TRuntimeProfileNode, None], None, ),  # 2
)
all_structs.append(TGetFunctionsRequest)
TGetFunctionsRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRING, 'db_name', None, None, ),  # 2
    (3, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 3
)
all_structs.append(TGetFunctionsResponse)
TGetFunctionsResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.LIST, 'functions', (TType.STRUCT, [Types.ttypes.TFunction, None], False), None, ),  # 2
)
all_structs.append(TCatalogInfoSelector)
TCatalogInfoSelector.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'want_db_names', None, None, ),  # 1
)
all_structs.append(TPartialCatalogInfo)
TPartialCatalogInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'db_names', (TType.STRING, None, False), None, ),  # 1
)
all_structs.append(TTableInfoSelector)
TTableInfoSelector.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'want_hms_table', None, None, ),  # 1
    (2, TType.LIST, 'partition_ids', (TType.I64, None, False), None, ),  # 2
    (3, TType.BOOL, 'want_partition_names', None, None, ),  # 3
    (4, TType.BOOL, 'want_partition_metadata', None, None, ),  # 4
    (5, TType.BOOL, 'want_partition_files', None, None, ),  # 5
    (6, TType.LIST, 'want_stats_for_column_names', (TType.STRING, None, False), None, ),  # 6
    (7, TType.BOOL, 'want_partition_stats', None, None, ),  # 7
    (8, TType.BOOL, 'want_table_constraints', None, None, ),  # 8
    (9, TType.STRUCT, 'valid_write_ids', [CatalogObjects.ttypes.TValidWriteIdList, None], None, ),  # 9
    (10, TType.I64, 'table_id', None, -1, ),  # 10
    (11, TType.BOOL, 'want_stats_for_all_columns', None, None, ),  # 11
    (12, TType.BOOL, 'want_hms_partition', None, None, ),  # 12
    (13, TType.BOOL, 'want_iceberg_table', None, None, ),  # 13
)
all_structs.append(TPartialPartitionInfo)
TPartialPartitionInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'id', None, None, ),  # 1
    (2, TType.STRING, 'name', None, None, ),  # 2
    (3, TType.STRUCT, 'hms_partition', [hive_metastore.ttypes.Partition, None], None, ),  # 3
    (4, TType.LIST, 'file_descriptors', (TType.STRUCT, [CatalogObjects.ttypes.THdfsFileDesc, None], False), None, ),  # 4
    (5, TType.STRING, 'partition_stats', 'BINARY', None, ),  # 5
    (6, TType.BOOL, 'has_incremental_stats', None, None, ),  # 6
    (7, TType.BOOL, 'is_marked_cached', None, None, ),  # 7
    (8, TType.LIST, 'insert_file_descriptors', (TType.STRUCT, [CatalogObjects.ttypes.THdfsFileDesc, None], False), None, ),  # 8
    (9, TType.LIST, 'delete_file_descriptors', (TType.STRUCT, [CatalogObjects.ttypes.THdfsFileDesc, None], False), None, ),  # 9
    (10, TType.MAP, 'hms_parameters', (TType.STRING, None, TType.STRING, None, False), None, ),  # 10
    (11, TType.I64, 'write_id', None, None, ),  # 11
    (12, TType.STRUCT, 'hdfs_storage_descriptor', [CatalogObjects.ttypes.THdfsStorageDescriptor, None], None, ),  # 12
    (13, TType.STRUCT, 'location', [CatalogObjects.ttypes.THdfsPartitionLocation, None], None, ),  # 13
    (14, TType.I64, 'last_compaction_id', None, None, ),  # 14
)
all_structs.append(TPartialTableInfo)
TPartialTableInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hms_table', [hive_metastore.ttypes.Table, None], None, ),  # 1
    (2, TType.LIST, 'partitions', (TType.STRUCT, [TPartialPartitionInfo, None], False), None, ),  # 2
    (3, TType.LIST, 'column_stats', (TType.STRUCT, [hive_metastore.ttypes.ColumnStatisticsObj, None], False), None, ),  # 3
    (4, TType.LIST, 'virtual_columns', (TType.STRUCT, [CatalogObjects.ttypes.TColumn, None], False), None, ),  # 4
    (5, TType.I64, 'storage_metadata_load_time_ns', None, None, ),  # 5
    None,  # 6
    None,  # 7
    (8, TType.LIST, 'network_addresses', (TType.STRUCT, [Types.ttypes.TNetworkAddress, None], False), None, ),  # 8
    (9, TType.STRUCT, 'sql_constraints', [SqlConstraints.ttypes.TSqlConstraints, None], None, ),  # 9
    (10, TType.STRUCT, 'valid_write_ids', [CatalogObjects.ttypes.TValidWriteIdList, None], None, ),  # 10
    (11, TType.BOOL, 'is_marked_cached', None, None, ),  # 11
    (12, TType.LIST, 'partition_prefixes', (TType.STRING, None, False), None, ),  # 12
    (13, TType.STRUCT, 'iceberg_table', [CatalogObjects.ttypes.TIcebergTable, None], None, ),  # 13
)
all_structs.append(TBriefTableMeta)
TBriefTableMeta.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', None, None, ),  # 1
    (2, TType.STRING, 'msType', None, None, ),  # 2
    (3, TType.STRING, 'comment', None, None, ),  # 3
    (4, TType.I32, 'tblType', None, None, ),  # 4
)
all_structs.append(TDbInfoSelector)
TDbInfoSelector.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'want_hms_database', None, None, ),  # 1
    (2, TType.BOOL, 'want_brief_meta_of_tables', None, None, ),  # 2
    (3, TType.BOOL, 'want_function_names', None, None, ),  # 3
)
all_structs.append(TPartialDbInfo)
TPartialDbInfo.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'hms_database', [hive_metastore.ttypes.Database, None], None, ),  # 1
    (2, TType.LIST, 'brief_meta_of_tables', (TType.STRUCT, [TBriefTableMeta, None], False), None, ),  # 2
    (3, TType.LIST, 'function_names', (TType.STRING, None, False), None, ),  # 3
)
all_structs.append(TGetPartialCatalogObjectRequest)
TGetPartialCatalogObjectRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'object_desc', [CatalogObjects.ttypes.TCatalogObject, None], None, ),  # 2
    (3, TType.STRUCT, 'table_info_selector', [TTableInfoSelector, None], None, ),  # 3
    (4, TType.STRUCT, 'db_info_selector', [TDbInfoSelector, None], None, ),  # 4
    (5, TType.STRUCT, 'catalog_info_selector', [TCatalogInfoSelector, None], None, ),  # 5
)
all_structs.append(TGetPartialCatalogObjectResponse)
TGetPartialCatalogObjectResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.I32, 'lookup_status', None, 0, ),  # 2
    (3, TType.I64, 'object_version_number', None, None, ),  # 3
    (4, TType.STRUCT, 'table_info', [TPartialTableInfo, None], None, ),  # 4
    (5, TType.STRUCT, 'db_info', [TPartialDbInfo, None], None, ),  # 5
    (6, TType.STRUCT, 'catalog_info', [TPartialCatalogInfo, None], None, ),  # 6
    (7, TType.LIST, 'functions', (TType.STRUCT, [Types.ttypes.TFunction, None], False), None, ),  # 7
    (8, TType.LIST, 'data_srcs', (TType.STRUCT, [CatalogObjects.ttypes.TDataSource, None], False), None, ),  # 8
    (9, TType.I64, 'object_loaded_time_ms', None, None, ),  # 9
)
all_structs.append(TGetCatalogObjectRequest)
TGetCatalogObjectRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'object_desc', [CatalogObjects.ttypes.TCatalogObject, None], None, ),  # 2
    (3, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 3
)
all_structs.append(TGetCatalogObjectResponse)
TGetCatalogObjectResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.STRUCT, 'catalog_object', [CatalogObjects.ttypes.TCatalogObject, None], None, ),  # 2
)
all_structs.append(TGetPartitionStatsRequest)
TGetPartitionStatsRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 2
    (3, TType.STRUCT, 'valid_write_ids', [CatalogObjects.ttypes.TValidWriteIdList, None], None, ),  # 3
    (4, TType.I64, 'table_id', None, -1, ),  # 4
)
all_structs.append(TGetPartitionStatsResponse)
TGetPartitionStatsResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.MAP, 'partition_stats', (TType.STRING, None, TType.STRING, 'BINARY', False), None, ),  # 2
)
all_structs.append(TGetNullPartitionNameRequest)
TGetNullPartitionNameRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
)
all_structs.append(TGetNullPartitionNameResponse)
TGetNullPartitionNameResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.STRING, 'partition_value', None, None, ),  # 2
)
all_structs.append(TGetLatestCompactionsRequest)
TGetLatestCompactionsRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRING, 'db_name', None, None, ),  # 2
    (3, TType.STRING, 'table_name', None, None, ),  # 3
    (4, TType.STRING, 'non_parition_name', None, None, ),  # 4
    (5, TType.LIST, 'partition_names', (TType.STRING, None, False), None, ),  # 5
    (6, TType.I64, 'last_compaction_id', None, None, ),  # 6
)
all_structs.append(TGetLatestCompactionsResponse)
TGetLatestCompactionsResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.MAP, 'partition_to_compaction_id', (TType.STRING, None, TType.I64, None, False), None, ),  # 2
)
all_structs.append(TPrioritizeLoadRequest)
TPrioritizeLoadRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 2
    (3, TType.LIST, 'object_descs', (TType.STRUCT, [CatalogObjects.ttypes.TCatalogObject, None], False), None, ),  # 3
)
all_structs.append(TPrioritizeLoadResponse)
TPrioritizeLoadResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
)
all_structs.append(TTableUsage)
TTableUsage.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'table_name', [CatalogObjects.ttypes.TTableName, None], None, ),  # 1
    (2, TType.I32, 'num_usages', None, None, ),  # 2
)
all_structs.append(TUpdateTableUsageRequest)
TUpdateTableUsageRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.LIST, 'usages', (TType.STRUCT, [TTableUsage, None], False), None, ),  # 2
)
all_structs.append(TUpdateTableUsageResponse)
TUpdateTableUsageResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
)
all_structs.append(TEventProcessorCmdParams)
TEventProcessorCmdParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'action', None, None, ),  # 1
    (2, TType.I64, 'event_id', None, None, ),  # 2
)
all_structs.append(TSetEventProcessorStatusRequest)
TSetEventProcessorStatusRequest.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'protocol_version', None, 1, ),  # 1
    (2, TType.STRUCT, 'header', [TCatalogServiceRequestHeader, None], None, ),  # 2
    (3, TType.STRUCT, 'params', [TEventProcessorCmdParams, None], None, ),  # 3
)
all_structs.append(TSetEventProcessorStatusResponse)
TSetEventProcessorStatusResponse.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 1
    (2, TType.STRING, 'info', None, None, ),  # 2
)
fix_spec(all_structs)
del all_structs
