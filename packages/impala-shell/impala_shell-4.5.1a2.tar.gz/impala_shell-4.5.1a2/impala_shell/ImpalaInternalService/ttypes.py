#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:no_utf8strings
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import Status.ttypes
import ErrorCodes.ttypes
import Types.ttypes
import Exprs.ttypes
import CatalogObjects.ttypes
import Descriptors.ttypes
import PlanNodes.ttypes
import Planner.ttypes
import DataSinks.ttypes
import Results.ttypes
import RuntimeProfile.ttypes
import ImpalaService.ttypes
import Data.ttypes
import Query.ttypes

from thrift.transport import TTransport
all_structs = []


class ImpalaInternalServiceVersion(object):
    V1 = 0

    _VALUES_TO_NAMES = {
        0: "V1",
    }

    _NAMES_TO_VALUES = {
        "V1": 0,
    }


class TDebugOptions(object):
    """
    Attributes:
     - node_id
     - phase
     - action
     - action_param

    """


    def __init__(self, node_id=None, phase=None, action=None, action_param=None,):
        self.node_id = node_id
        self.phase = phase
        self.action = action
        self.action_param = action_param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.phase = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.action = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.action_param = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDebugOptions')
        if self.node_id is not None:
            oprot.writeFieldBegin('node_id', TType.I32, 1)
            oprot.writeI32(self.node_id)
            oprot.writeFieldEnd()
        if self.phase is not None:
            oprot.writeFieldBegin('phase', TType.I32, 2)
            oprot.writeI32(self.phase)
            oprot.writeFieldEnd()
        if self.action is not None:
            oprot.writeFieldBegin('action', TType.I32, 3)
            oprot.writeI32(self.action)
            oprot.writeFieldEnd()
        if self.action_param is not None:
            oprot.writeFieldBegin('action_param', TType.STRING, 4)
            oprot.writeString(self.action_param)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRuntimeFilterAggDesc(object):
    """
    Attributes:
     - krpc_hostname
     - krpc_address
     - num_reporting_hosts

    """


    def __init__(self, krpc_hostname=None, krpc_address=None, num_reporting_hosts=None,):
        self.krpc_hostname = krpc_hostname
        self.krpc_address = krpc_address
        self.num_reporting_hosts = num_reporting_hosts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.krpc_hostname = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.krpc_address = Types.ttypes.TNetworkAddress()
                    self.krpc_address.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.num_reporting_hosts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRuntimeFilterAggDesc')
        if self.krpc_hostname is not None:
            oprot.writeFieldBegin('krpc_hostname', TType.STRING, 1)
            oprot.writeString(self.krpc_hostname)
            oprot.writeFieldEnd()
        if self.krpc_address is not None:
            oprot.writeFieldBegin('krpc_address', TType.STRUCT, 2)
            self.krpc_address.write(oprot)
            oprot.writeFieldEnd()
        if self.num_reporting_hosts is not None:
            oprot.writeFieldBegin('num_reporting_hosts', TType.I32, 3)
            oprot.writeI32(self.num_reporting_hosts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.krpc_hostname is None:
            raise TProtocolException(message='Required field krpc_hostname is unset!')
        if self.krpc_address is None:
            raise TProtocolException(message='Required field krpc_address is unset!')
        if self.num_reporting_hosts is None:
            raise TProtocolException(message='Required field num_reporting_hosts is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRuntimeFilterSource(object):
    """
    Attributes:
     - src_node_id
     - filter_id
     - aggregator_desc

    """


    def __init__(self, src_node_id=None, filter_id=None, aggregator_desc=None,):
        self.src_node_id = src_node_id
        self.filter_id = filter_id
        self.aggregator_desc = aggregator_desc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.src_node_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.filter_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.aggregator_desc = TRuntimeFilterAggDesc()
                    self.aggregator_desc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRuntimeFilterSource')
        if self.src_node_id is not None:
            oprot.writeFieldBegin('src_node_id', TType.I32, 1)
            oprot.writeI32(self.src_node_id)
            oprot.writeFieldEnd()
        if self.filter_id is not None:
            oprot.writeFieldBegin('filter_id', TType.I32, 2)
            oprot.writeI32(self.filter_id)
            oprot.writeFieldEnd()
        if self.aggregator_desc is not None:
            oprot.writeFieldBegin('aggregator_desc', TType.STRUCT, 3)
            self.aggregator_desc.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.src_node_id is None:
            raise TProtocolException(message='Required field src_node_id is unset!')
        if self.filter_id is None:
            raise TProtocolException(message='Required field filter_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPlanFragmentInstanceCtx(object):
    """
    Attributes:
     - fragment_idx
     - fragment_instance_id
     - per_fragment_instance_idx
     - per_exch_num_senders
     - sender_id
     - debug_options
     - filters_produced
     - num_join_build_outputs
     - num_backends

    """


    def __init__(self, fragment_idx=None, fragment_instance_id=None, per_fragment_instance_idx=None, per_exch_num_senders=None, sender_id=None, debug_options=None, filters_produced=None, num_join_build_outputs=None, num_backends=None,):
        self.fragment_idx = fragment_idx
        self.fragment_instance_id = fragment_instance_id
        self.per_fragment_instance_idx = per_fragment_instance_idx
        self.per_exch_num_senders = per_exch_num_senders
        self.sender_id = sender_id
        self.debug_options = debug_options
        self.filters_produced = filters_produced
        self.num_join_build_outputs = num_join_build_outputs
        self.num_backends = num_backends

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.fragment_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.fragment_instance_id = Types.ttypes.TUniqueId()
                    self.fragment_instance_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.per_fragment_instance_idx = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.per_exch_num_senders = {}
                    (_ktype1, _vtype2, _size0) = iprot.readMapBegin()
                    for _i4 in range(_size0):
                        _key5 = iprot.readI32()
                        _val6 = iprot.readI32()
                        self.per_exch_num_senders[_key5] = _val6
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.sender_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.debug_options = TDebugOptions()
                    self.debug_options.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.LIST:
                    self.filters_produced = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = TRuntimeFilterSource()
                        _elem12.read(iprot)
                        self.filters_produced.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.num_join_build_outputs = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.num_backends = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPlanFragmentInstanceCtx')
        if self.fragment_idx is not None:
            oprot.writeFieldBegin('fragment_idx', TType.I32, 1)
            oprot.writeI32(self.fragment_idx)
            oprot.writeFieldEnd()
        if self.fragment_instance_id is not None:
            oprot.writeFieldBegin('fragment_instance_id', TType.STRUCT, 2)
            self.fragment_instance_id.write(oprot)
            oprot.writeFieldEnd()
        if self.per_fragment_instance_idx is not None:
            oprot.writeFieldBegin('per_fragment_instance_idx', TType.I32, 3)
            oprot.writeI32(self.per_fragment_instance_idx)
            oprot.writeFieldEnd()
        if self.per_exch_num_senders is not None:
            oprot.writeFieldBegin('per_exch_num_senders', TType.MAP, 5)
            oprot.writeMapBegin(TType.I32, TType.I32, len(self.per_exch_num_senders))
            for kiter13, viter14 in self.per_exch_num_senders.items():
                oprot.writeI32(kiter13)
                oprot.writeI32(viter14)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.sender_id is not None:
            oprot.writeFieldBegin('sender_id', TType.I32, 6)
            oprot.writeI32(self.sender_id)
            oprot.writeFieldEnd()
        if self.debug_options is not None:
            oprot.writeFieldBegin('debug_options', TType.STRUCT, 7)
            self.debug_options.write(oprot)
            oprot.writeFieldEnd()
        if self.filters_produced is not None:
            oprot.writeFieldBegin('filters_produced', TType.LIST, 8)
            oprot.writeListBegin(TType.STRUCT, len(self.filters_produced))
            for iter15 in self.filters_produced:
                iter15.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.num_join_build_outputs is not None:
            oprot.writeFieldBegin('num_join_build_outputs', TType.I32, 10)
            oprot.writeI32(self.num_join_build_outputs)
            oprot.writeFieldEnd()
        if self.num_backends is not None:
            oprot.writeFieldBegin('num_backends', TType.I32, 11)
            oprot.writeI32(self.num_backends)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.fragment_idx is None:
            raise TProtocolException(message='Required field fragment_idx is unset!')
        if self.fragment_instance_id is None:
            raise TProtocolException(message='Required field fragment_instance_id is unset!')
        if self.per_fragment_instance_idx is None:
            raise TProtocolException(message='Required field per_fragment_instance_idx is unset!')
        if self.per_exch_num_senders is None:
            raise TProtocolException(message='Required field per_exch_num_senders is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExecPlanFragmentInfo(object):
    """
    Attributes:
     - fragments
     - fragment_instance_ctxs

    """


    def __init__(self, fragments=None, fragment_instance_ctxs=None,):
        self.fragments = fragments
        self.fragment_instance_ctxs = fragment_instance_ctxs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.fragments = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = Planner.ttypes.TPlanFragment()
                        _elem21.read(iprot)
                        self.fragments.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fragment_instance_ctxs = []
                    (_etype25, _size22) = iprot.readListBegin()
                    for _i26 in range(_size22):
                        _elem27 = TPlanFragmentInstanceCtx()
                        _elem27.read(iprot)
                        self.fragment_instance_ctxs.append(_elem27)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExecPlanFragmentInfo')
        if self.fragments is not None:
            oprot.writeFieldBegin('fragments', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.fragments))
            for iter28 in self.fragments:
                iter28.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fragment_instance_ctxs is not None:
            oprot.writeFieldBegin('fragment_instance_ctxs', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.fragment_instance_ctxs))
            for iter29 in self.fragment_instance_ctxs:
                iter29.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResolveRequestPoolParams(object):
    """
    Attributes:
     - user
     - requested_pool

    """


    def __init__(self, user=None, requested_pool=None,):
        self.user = user
        self.requested_pool = requested_pool

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.requested_pool = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResolveRequestPoolParams')
        if self.user is not None:
            oprot.writeFieldBegin('user', TType.STRING, 1)
            oprot.writeString(self.user)
            oprot.writeFieldEnd()
        if self.requested_pool is not None:
            oprot.writeFieldBegin('requested_pool', TType.STRING, 2)
            oprot.writeString(self.requested_pool)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.user is None:
            raise TProtocolException(message='Required field user is unset!')
        if self.requested_pool is None:
            raise TProtocolException(message='Required field requested_pool is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResolveRequestPoolResult(object):
    """
    Attributes:
     - resolved_pool
     - has_access
     - status

    """


    def __init__(self, resolved_pool=None, has_access=None, status=None,):
        self.resolved_pool = resolved_pool
        self.has_access = has_access
        self.status = status

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.resolved_pool = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.has_access = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.status = Status.ttypes.TStatus()
                    self.status.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResolveRequestPoolResult')
        if self.resolved_pool is not None:
            oprot.writeFieldBegin('resolved_pool', TType.STRING, 1)
            oprot.writeString(self.resolved_pool)
            oprot.writeFieldEnd()
        if self.has_access is not None:
            oprot.writeFieldBegin('has_access', TType.BOOL, 2)
            oprot.writeBool(self.has_access)
            oprot.writeFieldEnd()
        if self.status is not None:
            oprot.writeFieldBegin('status', TType.STRUCT, 3)
            self.status.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPoolConfigParams(object):
    """
    Attributes:
     - pool

    """


    def __init__(self, pool=None,):
        self.pool = pool

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pool = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPoolConfigParams')
        if self.pool is not None:
            oprot.writeFieldBegin('pool', TType.STRING, 1)
            oprot.writeString(self.pool)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pool is None:
            raise TProtocolException(message='Required field pool is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPoolConfig(object):
    """
    Attributes:
     - max_requests
     - max_queued
     - max_mem_resources
     - queue_timeout_ms
     - default_query_options
     - max_query_mem_limit
     - min_query_mem_limit
     - clamp_mem_limit_query_option
     - max_mt_dop
     - max_query_cpu_core_per_node_limit
     - max_query_cpu_core_coordinator_limit
     - user_query_limits
     - group_query_limits
     - only_coordinators

    """


    def __init__(self, max_requests=None, max_queued=None, max_mem_resources=None, queue_timeout_ms=None, default_query_options=None, max_query_mem_limit=0, min_query_mem_limit=0, clamp_mem_limit_query_option=True, max_mt_dop=-1, max_query_cpu_core_per_node_limit=0, max_query_cpu_core_coordinator_limit=0, user_query_limits=None, group_query_limits=None, only_coordinators=None,):
        self.max_requests = max_requests
        self.max_queued = max_queued
        self.max_mem_resources = max_mem_resources
        self.queue_timeout_ms = queue_timeout_ms
        self.default_query_options = default_query_options
        self.max_query_mem_limit = max_query_mem_limit
        self.min_query_mem_limit = min_query_mem_limit
        self.clamp_mem_limit_query_option = clamp_mem_limit_query_option
        self.max_mt_dop = max_mt_dop
        self.max_query_cpu_core_per_node_limit = max_query_cpu_core_per_node_limit
        self.max_query_cpu_core_coordinator_limit = max_query_cpu_core_coordinator_limit
        self.user_query_limits = user_query_limits
        self.group_query_limits = group_query_limits
        self.only_coordinators = only_coordinators

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.max_requests = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max_queued = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.max_mem_resources = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.queue_timeout_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.default_query_options = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.max_query_mem_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.min_query_mem_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.clamp_mem_limit_query_option = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.max_mt_dop = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I64:
                    self.max_query_cpu_core_per_node_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.max_query_cpu_core_coordinator_limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.MAP:
                    self.user_query_limits = {}
                    (_ktype31, _vtype32, _size30) = iprot.readMapBegin()
                    for _i34 in range(_size30):
                        _key35 = iprot.readString()
                        _val36 = iprot.readI32()
                        self.user_query_limits[_key35] = _val36
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.MAP:
                    self.group_query_limits = {}
                    (_ktype38, _vtype39, _size37) = iprot.readMapBegin()
                    for _i41 in range(_size37):
                        _key42 = iprot.readString()
                        _val43 = iprot.readI32()
                        self.group_query_limits[_key42] = _val43
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.only_coordinators = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPoolConfig')
        if self.max_requests is not None:
            oprot.writeFieldBegin('max_requests', TType.I64, 1)
            oprot.writeI64(self.max_requests)
            oprot.writeFieldEnd()
        if self.max_queued is not None:
            oprot.writeFieldBegin('max_queued', TType.I64, 2)
            oprot.writeI64(self.max_queued)
            oprot.writeFieldEnd()
        if self.max_mem_resources is not None:
            oprot.writeFieldBegin('max_mem_resources', TType.I64, 3)
            oprot.writeI64(self.max_mem_resources)
            oprot.writeFieldEnd()
        if self.queue_timeout_ms is not None:
            oprot.writeFieldBegin('queue_timeout_ms', TType.I64, 4)
            oprot.writeI64(self.queue_timeout_ms)
            oprot.writeFieldEnd()
        if self.default_query_options is not None:
            oprot.writeFieldBegin('default_query_options', TType.STRING, 5)
            oprot.writeString(self.default_query_options)
            oprot.writeFieldEnd()
        if self.max_query_mem_limit is not None:
            oprot.writeFieldBegin('max_query_mem_limit', TType.I64, 6)
            oprot.writeI64(self.max_query_mem_limit)
            oprot.writeFieldEnd()
        if self.min_query_mem_limit is not None:
            oprot.writeFieldBegin('min_query_mem_limit', TType.I64, 7)
            oprot.writeI64(self.min_query_mem_limit)
            oprot.writeFieldEnd()
        if self.clamp_mem_limit_query_option is not None:
            oprot.writeFieldBegin('clamp_mem_limit_query_option', TType.BOOL, 8)
            oprot.writeBool(self.clamp_mem_limit_query_option)
            oprot.writeFieldEnd()
        if self.max_mt_dop is not None:
            oprot.writeFieldBegin('max_mt_dop', TType.I64, 9)
            oprot.writeI64(self.max_mt_dop)
            oprot.writeFieldEnd()
        if self.max_query_cpu_core_per_node_limit is not None:
            oprot.writeFieldBegin('max_query_cpu_core_per_node_limit', TType.I64, 10)
            oprot.writeI64(self.max_query_cpu_core_per_node_limit)
            oprot.writeFieldEnd()
        if self.max_query_cpu_core_coordinator_limit is not None:
            oprot.writeFieldBegin('max_query_cpu_core_coordinator_limit', TType.I64, 11)
            oprot.writeI64(self.max_query_cpu_core_coordinator_limit)
            oprot.writeFieldEnd()
        if self.user_query_limits is not None:
            oprot.writeFieldBegin('user_query_limits', TType.MAP, 12)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.user_query_limits))
            for kiter44, viter45 in self.user_query_limits.items():
                oprot.writeString(kiter44)
                oprot.writeI32(viter45)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.group_query_limits is not None:
            oprot.writeFieldBegin('group_query_limits', TType.MAP, 13)
            oprot.writeMapBegin(TType.STRING, TType.I32, len(self.group_query_limits))
            for kiter46, viter47 in self.group_query_limits.items():
                oprot.writeString(kiter46)
                oprot.writeI32(viter47)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.only_coordinators is not None:
            oprot.writeFieldBegin('only_coordinators', TType.BOOL, 14)
            oprot.writeBool(self.only_coordinators)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.max_requests is None:
            raise TProtocolException(message='Required field max_requests is unset!')
        if self.max_queued is None:
            raise TProtocolException(message='Required field max_queued is unset!')
        if self.max_mem_resources is None:
            raise TProtocolException(message='Required field max_mem_resources is unset!')
        if self.default_query_options is None:
            raise TProtocolException(message='Required field default_query_options is unset!')
        if self.max_query_mem_limit is None:
            raise TProtocolException(message='Required field max_query_mem_limit is unset!')
        if self.min_query_mem_limit is None:
            raise TProtocolException(message='Required field min_query_mem_limit is unset!')
        if self.clamp_mem_limit_query_option is None:
            raise TProtocolException(message='Required field clamp_mem_limit_query_option is unset!')
        if self.max_mt_dop is None:
            raise TProtocolException(message='Required field max_mt_dop is unset!')
        if self.max_query_cpu_core_per_node_limit is None:
            raise TProtocolException(message='Required field max_query_cpu_core_per_node_limit is unset!')
        if self.max_query_cpu_core_coordinator_limit is None:
            raise TProtocolException(message='Required field max_query_cpu_core_coordinator_limit is unset!')
        if self.user_query_limits is None:
            raise TProtocolException(message='Required field user_query_limits is unset!')
        if self.group_query_limits is None:
            raise TProtocolException(message='Required field group_query_limits is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TParseDateStringResult(object):
    """
    Attributes:
     - valid
     - days_since_epoch
     - canonical_date_string

    """


    def __init__(self, valid=None, days_since_epoch=None, canonical_date_string=None,):
        self.valid = valid
        self.days_since_epoch = days_since_epoch
        self.canonical_date_string = canonical_date_string

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.valid = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.days_since_epoch = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.canonical_date_string = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TParseDateStringResult')
        if self.valid is not None:
            oprot.writeFieldBegin('valid', TType.BOOL, 1)
            oprot.writeBool(self.valid)
            oprot.writeFieldEnd()
        if self.days_since_epoch is not None:
            oprot.writeFieldBegin('days_since_epoch', TType.I32, 2)
            oprot.writeI32(self.days_since_epoch)
            oprot.writeFieldEnd()
        if self.canonical_date_string is not None:
            oprot.writeFieldBegin('canonical_date_string', TType.STRING, 3)
            oprot.writeString(self.canonical_date_string)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.valid is None:
            raise TProtocolException(message='Required field valid is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TDebugOptions)
TDebugOptions.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'node_id', None, None, ),  # 1
    (2, TType.I32, 'phase', None, None, ),  # 2
    (3, TType.I32, 'action', None, None, ),  # 3
    (4, TType.STRING, 'action_param', None, None, ),  # 4
)
all_structs.append(TRuntimeFilterAggDesc)
TRuntimeFilterAggDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'krpc_hostname', None, None, ),  # 1
    (2, TType.STRUCT, 'krpc_address', [Types.ttypes.TNetworkAddress, None], None, ),  # 2
    (3, TType.I32, 'num_reporting_hosts', None, None, ),  # 3
)
all_structs.append(TRuntimeFilterSource)
TRuntimeFilterSource.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'src_node_id', None, None, ),  # 1
    (2, TType.I32, 'filter_id', None, None, ),  # 2
    (3, TType.STRUCT, 'aggregator_desc', [TRuntimeFilterAggDesc, None], None, ),  # 3
)
all_structs.append(TPlanFragmentInstanceCtx)
TPlanFragmentInstanceCtx.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'fragment_idx', None, None, ),  # 1
    (2, TType.STRUCT, 'fragment_instance_id', [Types.ttypes.TUniqueId, None], None, ),  # 2
    (3, TType.I32, 'per_fragment_instance_idx', None, None, ),  # 3
    None,  # 4
    (5, TType.MAP, 'per_exch_num_senders', (TType.I32, None, TType.I32, None, False), None, ),  # 5
    (6, TType.I32, 'sender_id', None, None, ),  # 6
    (7, TType.STRUCT, 'debug_options', [TDebugOptions, None], None, ),  # 7
    (8, TType.LIST, 'filters_produced', (TType.STRUCT, [TRuntimeFilterSource, None], False), None, ),  # 8
    None,  # 9
    (10, TType.I32, 'num_join_build_outputs', None, None, ),  # 10
    (11, TType.I32, 'num_backends', None, None, ),  # 11
)
all_structs.append(TExecPlanFragmentInfo)
TExecPlanFragmentInfo.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'fragments', (TType.STRUCT, [Planner.ttypes.TPlanFragment, None], False), None, ),  # 1
    (2, TType.LIST, 'fragment_instance_ctxs', (TType.STRUCT, [TPlanFragmentInstanceCtx, None], False), None, ),  # 2
)
all_structs.append(TResolveRequestPoolParams)
TResolveRequestPoolParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'user', None, None, ),  # 1
    (2, TType.STRING, 'requested_pool', None, None, ),  # 2
)
all_structs.append(TResolveRequestPoolResult)
TResolveRequestPoolResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'resolved_pool', None, None, ),  # 1
    (2, TType.BOOL, 'has_access', None, None, ),  # 2
    (3, TType.STRUCT, 'status', [Status.ttypes.TStatus, None], None, ),  # 3
)
all_structs.append(TPoolConfigParams)
TPoolConfigParams.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pool', None, None, ),  # 1
)
all_structs.append(TPoolConfig)
TPoolConfig.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'max_requests', None, None, ),  # 1
    (2, TType.I64, 'max_queued', None, None, ),  # 2
    (3, TType.I64, 'max_mem_resources', None, None, ),  # 3
    (4, TType.I64, 'queue_timeout_ms', None, None, ),  # 4
    (5, TType.STRING, 'default_query_options', None, None, ),  # 5
    (6, TType.I64, 'max_query_mem_limit', None, 0, ),  # 6
    (7, TType.I64, 'min_query_mem_limit', None, 0, ),  # 7
    (8, TType.BOOL, 'clamp_mem_limit_query_option', None, True, ),  # 8
    (9, TType.I64, 'max_mt_dop', None, -1, ),  # 9
    (10, TType.I64, 'max_query_cpu_core_per_node_limit', None, 0, ),  # 10
    (11, TType.I64, 'max_query_cpu_core_coordinator_limit', None, 0, ),  # 11
    (12, TType.MAP, 'user_query_limits', (TType.STRING, None, TType.I32, None, False), None, ),  # 12
    (13, TType.MAP, 'group_query_limits', (TType.STRING, None, TType.I32, None, False), None, ),  # 13
    (14, TType.BOOL, 'only_coordinators', None, None, ),  # 14
)
all_structs.append(TParseDateStringResult)
TParseDateStringResult.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'valid', None, None, ),  # 1
    (2, TType.I32, 'days_since_epoch', None, None, ),  # 2
    (3, TType.STRING, 'canonical_date_string', None, None, ),  # 3
)
fix_spec(all_structs)
del all_structs
