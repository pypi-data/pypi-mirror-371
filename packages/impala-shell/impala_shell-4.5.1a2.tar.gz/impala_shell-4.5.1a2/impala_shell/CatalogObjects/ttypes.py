#
# Autogenerated by Thrift Compiler (0.16.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:no_utf8strings
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import Data.ttypes
import Exprs.ttypes
import Status.ttypes
import Types.ttypes
import hive_metastore.ttypes
import SqlConstraints.ttypes

from thrift.transport import TTransport
all_structs = []


class TCatalogObjectType(object):
    UNKNOWN = 0
    CATALOG = 1
    DATABASE = 2
    TABLE = 3
    VIEW = 4
    FUNCTION = 5
    DATA_SOURCE = 6
    PRINCIPAL = 7
    PRIVILEGE = 8
    HDFS_CACHE_POOL = 9
    AUTHZ_CACHE_INVALIDATION = 10
    HDFS_PARTITION = 11

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "CATALOG",
        2: "DATABASE",
        3: "TABLE",
        4: "VIEW",
        5: "FUNCTION",
        6: "DATA_SOURCE",
        7: "PRINCIPAL",
        8: "PRIVILEGE",
        9: "HDFS_CACHE_POOL",
        10: "AUTHZ_CACHE_INVALIDATION",
        11: "HDFS_PARTITION",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "CATALOG": 1,
        "DATABASE": 2,
        "TABLE": 3,
        "VIEW": 4,
        "FUNCTION": 5,
        "DATA_SOURCE": 6,
        "PRINCIPAL": 7,
        "PRIVILEGE": 8,
        "HDFS_CACHE_POOL": 9,
        "AUTHZ_CACHE_INVALIDATION": 10,
        "HDFS_PARTITION": 11,
    }


class TTableType(object):
    HDFS_TABLE = 0
    HBASE_TABLE = 1
    VIEW = 2
    DATA_SOURCE_TABLE = 3
    KUDU_TABLE = 4
    ICEBERG_TABLE = 5
    UNLOADED_TABLE = 6
    MATERIALIZED_VIEW = 7
    SYSTEM_TABLE = 8

    _VALUES_TO_NAMES = {
        0: "HDFS_TABLE",
        1: "HBASE_TABLE",
        2: "VIEW",
        3: "DATA_SOURCE_TABLE",
        4: "KUDU_TABLE",
        5: "ICEBERG_TABLE",
        6: "UNLOADED_TABLE",
        7: "MATERIALIZED_VIEW",
        8: "SYSTEM_TABLE",
    }

    _NAMES_TO_VALUES = {
        "HDFS_TABLE": 0,
        "HBASE_TABLE": 1,
        "VIEW": 2,
        "DATA_SOURCE_TABLE": 3,
        "KUDU_TABLE": 4,
        "ICEBERG_TABLE": 5,
        "UNLOADED_TABLE": 6,
        "MATERIALIZED_VIEW": 7,
        "SYSTEM_TABLE": 8,
    }


class THdfsFileFormat(object):
    TEXT = 0
    RC_FILE = 1
    SEQUENCE_FILE = 2
    AVRO = 3
    PARQUET = 4
    KUDU = 5
    ORC = 6
    HUDI_PARQUET = 7
    ICEBERG = 8
    JSON = 9
    JDBC = 10

    _VALUES_TO_NAMES = {
        0: "TEXT",
        1: "RC_FILE",
        2: "SEQUENCE_FILE",
        3: "AVRO",
        4: "PARQUET",
        5: "KUDU",
        6: "ORC",
        7: "HUDI_PARQUET",
        8: "ICEBERG",
        9: "JSON",
        10: "JDBC",
    }

    _NAMES_TO_VALUES = {
        "TEXT": 0,
        "RC_FILE": 1,
        "SEQUENCE_FILE": 2,
        "AVRO": 3,
        "PARQUET": 4,
        "KUDU": 5,
        "ORC": 6,
        "HUDI_PARQUET": 7,
        "ICEBERG": 8,
        "JSON": 9,
        "JDBC": 10,
    }


class TVirtualColumnType(object):
    NONE = 0
    INPUT_FILE_NAME = 1
    FILE_POSITION = 2
    PARTITION_SPEC_ID = 3
    ICEBERG_PARTITION_SERIALIZED = 4
    ICEBERG_DATA_SEQUENCE_NUMBER = 5

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "INPUT_FILE_NAME",
        2: "FILE_POSITION",
        3: "PARTITION_SPEC_ID",
        4: "ICEBERG_PARTITION_SERIALIZED",
        5: "ICEBERG_DATA_SEQUENCE_NUMBER",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "INPUT_FILE_NAME": 1,
        "FILE_POSITION": 2,
        "PARTITION_SPEC_ID": 3,
        "ICEBERG_PARTITION_SERIALIZED": 4,
        "ICEBERG_DATA_SEQUENCE_NUMBER": 5,
    }


class THdfsCompression(object):
    NONE = 0
    DEFAULT = 1
    GZIP = 2
    DEFLATE = 3
    BZIP2 = 4
    SNAPPY = 5
    SNAPPY_BLOCKED = 6
    LZO = 7
    LZ4 = 8
    ZLIB = 9
    ZSTD = 10
    BROTLI = 11
    LZ4_BLOCKED = 12

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "DEFAULT",
        2: "GZIP",
        3: "DEFLATE",
        4: "BZIP2",
        5: "SNAPPY",
        6: "SNAPPY_BLOCKED",
        7: "LZO",
        8: "LZ4",
        9: "ZLIB",
        10: "ZSTD",
        11: "BROTLI",
        12: "LZ4_BLOCKED",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "DEFAULT": 1,
        "GZIP": 2,
        "DEFLATE": 3,
        "BZIP2": 4,
        "SNAPPY": 5,
        "SNAPPY_BLOCKED": 6,
        "LZO": 7,
        "LZ4": 8,
        "ZLIB": 9,
        "ZSTD": 10,
        "BROTLI": 11,
        "LZ4_BLOCKED": 12,
    }


class TIcebergFileFormat(object):
    PARQUET = 0
    ORC = 1
    AVRO = 2

    _VALUES_TO_NAMES = {
        0: "PARQUET",
        1: "ORC",
        2: "AVRO",
    }

    _NAMES_TO_VALUES = {
        "PARQUET": 0,
        "ORC": 1,
        "AVRO": 2,
    }


class TIcebergCatalog(object):
    HADOOP_TABLES = 0
    HADOOP_CATALOG = 1
    HIVE_CATALOG = 2
    CATALOGS = 3

    _VALUES_TO_NAMES = {
        0: "HADOOP_TABLES",
        1: "HADOOP_CATALOG",
        2: "HIVE_CATALOG",
        3: "CATALOGS",
    }

    _NAMES_TO_VALUES = {
        "HADOOP_TABLES": 0,
        "HADOOP_CATALOG": 1,
        "HIVE_CATALOG": 2,
        "CATALOGS": 3,
    }


class TColumnEncoding(object):
    AUTO = 0
    PLAIN = 1
    PREFIX = 2
    GROUP_VARINT = 3
    RLE = 4
    DICTIONARY = 5
    BIT_SHUFFLE = 6

    _VALUES_TO_NAMES = {
        0: "AUTO",
        1: "PLAIN",
        2: "PREFIX",
        3: "GROUP_VARINT",
        4: "RLE",
        5: "DICTIONARY",
        6: "BIT_SHUFFLE",
    }

    _NAMES_TO_VALUES = {
        "AUTO": 0,
        "PLAIN": 1,
        "PREFIX": 2,
        "GROUP_VARINT": 3,
        "RLE": 4,
        "DICTIONARY": 5,
        "BIT_SHUFFLE": 6,
    }


class THdfsSeqCompressionMode(object):
    RECORD = 0
    BLOCK = 1

    _VALUES_TO_NAMES = {
        0: "RECORD",
        1: "BLOCK",
    }

    _NAMES_TO_VALUES = {
        "RECORD": 0,
        "BLOCK": 1,
    }


class TTablePropertyType(object):
    TBL_PROPERTY = 0
    SERDE_PROPERTY = 1

    _VALUES_TO_NAMES = {
        0: "TBL_PROPERTY",
        1: "SERDE_PROPERTY",
    }

    _NAMES_TO_VALUES = {
        "TBL_PROPERTY": 0,
        "SERDE_PROPERTY": 1,
    }


class TAccessLevel(object):
    NONE = 0
    READ_WRITE = 1
    READ_ONLY = 2
    WRITE_ONLY = 3

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "READ_WRITE",
        2: "READ_ONLY",
        3: "WRITE_ONLY",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "READ_WRITE": 1,
        "READ_ONLY": 2,
        "WRITE_ONLY": 3,
    }


class TIcebergPartitionTransformType(object):
    IDENTITY = 0
    HOUR = 1
    DAY = 2
    MONTH = 3
    YEAR = 4
    BUCKET = 5
    TRUNCATE = 6
    VOID = 7

    _VALUES_TO_NAMES = {
        0: "IDENTITY",
        1: "HOUR",
        2: "DAY",
        3: "MONTH",
        4: "YEAR",
        5: "BUCKET",
        6: "TRUNCATE",
        7: "VOID",
    }

    _NAMES_TO_VALUES = {
        "IDENTITY": 0,
        "HOUR": 1,
        "DAY": 2,
        "MONTH": 3,
        "YEAR": 4,
        "BUCKET": 5,
        "TRUNCATE": 6,
        "VOID": 7,
    }


class TBucketType(object):
    NONE = 0
    HASH = 1

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "HASH",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "HASH": 1,
    }


class TSystemTableName(object):
    IMPALA_QUERY_LIVE = 0

    _VALUES_TO_NAMES = {
        0: "IMPALA_QUERY_LIVE",
    }

    _NAMES_TO_VALUES = {
        "IMPALA_QUERY_LIVE": 0,
    }


class TPrincipalType(object):
    ROLE = 0
    USER = 1
    GROUP = 2

    _VALUES_TO_NAMES = {
        0: "ROLE",
        1: "USER",
        2: "GROUP",
    }

    _NAMES_TO_VALUES = {
        "ROLE": 0,
        "USER": 1,
        "GROUP": 2,
    }


class TPrivilegeScope(object):
    SERVER = 0
    URI = 1
    DATABASE = 2
    TABLE = 3
    COLUMN = 4
    STORAGE_TYPE = 5
    STORAGEHANDLER_URI = 6
    USER_DEFINED_FN = 7

    _VALUES_TO_NAMES = {
        0: "SERVER",
        1: "URI",
        2: "DATABASE",
        3: "TABLE",
        4: "COLUMN",
        5: "STORAGE_TYPE",
        6: "STORAGEHANDLER_URI",
        7: "USER_DEFINED_FN",
    }

    _NAMES_TO_VALUES = {
        "SERVER": 0,
        "URI": 1,
        "DATABASE": 2,
        "TABLE": 3,
        "COLUMN": 4,
        "STORAGE_TYPE": 5,
        "STORAGEHANDLER_URI": 6,
        "USER_DEFINED_FN": 7,
    }


class TPrivilegeLevel(object):
    ALL = 0
    INSERT = 1
    SELECT = 2
    REFRESH = 3
    CREATE = 4
    ALTER = 5
    DROP = 6
    OWNER = 7
    RWSTORAGE = 8

    _VALUES_TO_NAMES = {
        0: "ALL",
        1: "INSERT",
        2: "SELECT",
        3: "REFRESH",
        4: "CREATE",
        5: "ALTER",
        6: "DROP",
        7: "OWNER",
        8: "RWSTORAGE",
    }

    _NAMES_TO_VALUES = {
        "ALL": 0,
        "INSERT": 1,
        "SELECT": 2,
        "REFRESH": 3,
        "CREATE": 4,
        "ALTER": 5,
        "DROP": 6,
        "OWNER": 7,
        "RWSTORAGE": 8,
    }


class TCompressionCodec(object):
    """
    Attributes:
     - codec
     - compression_level

    """


    def __init__(self, codec=None, compression_level=None,):
        self.codec = codec
        self.compression_level = compression_level

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.codec = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.compression_level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCompressionCodec')
        if self.codec is not None:
            oprot.writeFieldBegin('codec', TType.I32, 1)
            oprot.writeI32(self.codec)
            oprot.writeFieldEnd()
        if self.compression_level is not None:
            oprot.writeFieldBegin('compression_level', TType.I32, 2)
            oprot.writeI32(self.compression_level)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.codec is None:
            raise TProtocolException(message='Required field codec is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartitionKeyValue(object):
    """
    Attributes:
     - name
     - value

    """


    def __init__(self, name=None, value=None,):
        self.name = name
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartitionKeyValue')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableName(object):
    """
    Attributes:
     - db_name
     - table_name

    """


    def __init__(self, db_name=None, table_name=None,):
        self.db_name = db_name
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableName')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db_name is None:
            raise TProtocolException(message='Required field db_name is unset!')
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableStats(object):
    """
    Attributes:
     - num_rows
     - total_file_bytes

    """


    def __init__(self, num_rows=None, total_file_bytes=None,):
        self.num_rows = num_rows
        self.total_file_bytes = total_file_bytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.num_rows = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.total_file_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableStats')
        if self.num_rows is not None:
            oprot.writeFieldBegin('num_rows', TType.I64, 1)
            oprot.writeI64(self.num_rows)
            oprot.writeFieldEnd()
        if self.total_file_bytes is not None:
            oprot.writeFieldBegin('total_file_bytes', TType.I64, 2)
            oprot.writeI64(self.total_file_bytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_rows is None:
            raise TProtocolException(message='Required field num_rows is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TBucketInfo(object):
    """
    Attributes:
     - bucket_type
     - bucket_columns
     - num_bucket

    """


    def __init__(self, bucket_type=None, bucket_columns=None, num_bucket=None,):
        self.bucket_type = bucket_type
        self.bucket_columns = bucket_columns
        self.num_bucket = num_bucket

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.bucket_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.bucket_columns = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString()
                        self.bucket_columns.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.num_bucket = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TBucketInfo')
        if self.bucket_type is not None:
            oprot.writeFieldBegin('bucket_type', TType.I32, 1)
            oprot.writeI32(self.bucket_type)
            oprot.writeFieldEnd()
        if self.bucket_columns is not None:
            oprot.writeFieldBegin('bucket_columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.bucket_columns))
            for iter6 in self.bucket_columns:
                oprot.writeString(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.num_bucket is not None:
            oprot.writeFieldBegin('num_bucket', TType.I32, 3)
            oprot.writeI32(self.num_bucket)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.bucket_type is None:
            raise TProtocolException(message='Required field bucket_type is unset!')
        if self.num_bucket is None:
            raise TProtocolException(message='Required field num_bucket is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColumnStats(object):
    """
    Attributes:
     - avg_size
     - max_size
     - num_distinct_values
     - num_nulls
     - num_trues
     - num_falses
     - low_value
     - high_value

    """


    def __init__(self, avg_size=None, max_size=None, num_distinct_values=None, num_nulls=None, num_trues=None, num_falses=None, low_value=None, high_value=None,):
        self.avg_size = avg_size
        self.max_size = max_size
        self.num_distinct_values = num_distinct_values
        self.num_nulls = num_nulls
        self.num_trues = num_trues
        self.num_falses = num_falses
        self.low_value = low_value
        self.high_value = high_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.avg_size = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.max_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_distinct_values = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.num_nulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.num_trues = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.num_falses = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.low_value = Data.ttypes.TColumnValue()
                    self.low_value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.high_value = Data.ttypes.TColumnValue()
                    self.high_value.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColumnStats')
        if self.avg_size is not None:
            oprot.writeFieldBegin('avg_size', TType.DOUBLE, 1)
            oprot.writeDouble(self.avg_size)
            oprot.writeFieldEnd()
        if self.max_size is not None:
            oprot.writeFieldBegin('max_size', TType.I64, 2)
            oprot.writeI64(self.max_size)
            oprot.writeFieldEnd()
        if self.num_distinct_values is not None:
            oprot.writeFieldBegin('num_distinct_values', TType.I64, 3)
            oprot.writeI64(self.num_distinct_values)
            oprot.writeFieldEnd()
        if self.num_nulls is not None:
            oprot.writeFieldBegin('num_nulls', TType.I64, 4)
            oprot.writeI64(self.num_nulls)
            oprot.writeFieldEnd()
        if self.num_trues is not None:
            oprot.writeFieldBegin('num_trues', TType.I64, 5)
            oprot.writeI64(self.num_trues)
            oprot.writeFieldEnd()
        if self.num_falses is not None:
            oprot.writeFieldBegin('num_falses', TType.I64, 6)
            oprot.writeI64(self.num_falses)
            oprot.writeFieldEnd()
        if self.low_value is not None:
            oprot.writeFieldBegin('low_value', TType.STRUCT, 7)
            self.low_value.write(oprot)
            oprot.writeFieldEnd()
        if self.high_value is not None:
            oprot.writeFieldBegin('high_value', TType.STRUCT, 8)
            self.high_value.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.avg_size is None:
            raise TProtocolException(message='Required field avg_size is unset!')
        if self.max_size is None:
            raise TProtocolException(message='Required field max_size is unset!')
        if self.num_distinct_values is None:
            raise TProtocolException(message='Required field num_distinct_values is unset!')
        if self.num_nulls is None:
            raise TProtocolException(message='Required field num_nulls is unset!')
        if self.num_trues is None:
            raise TProtocolException(message='Required field num_trues is unset!')
        if self.num_falses is None:
            raise TProtocolException(message='Required field num_falses is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIntermediateColumnStats(object):
    """
    Attributes:
     - intermediate_ndv
     - is_ndv_encoded
     - num_nulls
     - max_width
     - avg_width
     - num_rows
     - num_trues
     - num_falses
     - low_value
     - high_value

    """


    def __init__(self, intermediate_ndv=None, is_ndv_encoded=None, num_nulls=None, max_width=None, avg_width=None, num_rows=None, num_trues=None, num_falses=None, low_value=None, high_value=None,):
        self.intermediate_ndv = intermediate_ndv
        self.is_ndv_encoded = is_ndv_encoded
        self.num_nulls = num_nulls
        self.max_width = max_width
        self.avg_width = avg_width
        self.num_rows = num_rows
        self.num_trues = num_trues
        self.num_falses = num_falses
        self.low_value = low_value
        self.high_value = high_value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.intermediate_ndv = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.is_ndv_encoded = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_nulls = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.max_width = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.avg_width = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.num_rows = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.num_trues = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.num_falses = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.low_value = Data.ttypes.TColumnValue()
                    self.low_value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.high_value = Data.ttypes.TColumnValue()
                    self.high_value.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIntermediateColumnStats')
        if self.intermediate_ndv is not None:
            oprot.writeFieldBegin('intermediate_ndv', TType.STRING, 1)
            oprot.writeBinary(self.intermediate_ndv)
            oprot.writeFieldEnd()
        if self.is_ndv_encoded is not None:
            oprot.writeFieldBegin('is_ndv_encoded', TType.BOOL, 2)
            oprot.writeBool(self.is_ndv_encoded)
            oprot.writeFieldEnd()
        if self.num_nulls is not None:
            oprot.writeFieldBegin('num_nulls', TType.I64, 3)
            oprot.writeI64(self.num_nulls)
            oprot.writeFieldEnd()
        if self.max_width is not None:
            oprot.writeFieldBegin('max_width', TType.I32, 4)
            oprot.writeI32(self.max_width)
            oprot.writeFieldEnd()
        if self.avg_width is not None:
            oprot.writeFieldBegin('avg_width', TType.DOUBLE, 5)
            oprot.writeDouble(self.avg_width)
            oprot.writeFieldEnd()
        if self.num_rows is not None:
            oprot.writeFieldBegin('num_rows', TType.I64, 6)
            oprot.writeI64(self.num_rows)
            oprot.writeFieldEnd()
        if self.num_trues is not None:
            oprot.writeFieldBegin('num_trues', TType.I64, 7)
            oprot.writeI64(self.num_trues)
            oprot.writeFieldEnd()
        if self.num_falses is not None:
            oprot.writeFieldBegin('num_falses', TType.I64, 8)
            oprot.writeI64(self.num_falses)
            oprot.writeFieldEnd()
        if self.low_value is not None:
            oprot.writeFieldBegin('low_value', TType.STRUCT, 9)
            self.low_value.write(oprot)
            oprot.writeFieldEnd()
        if self.high_value is not None:
            oprot.writeFieldBegin('high_value', TType.STRUCT, 10)
            self.high_value.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPartitionStats(object):
    """
    Attributes:
     - stats
     - intermediate_col_stats

    """


    def __init__(self, stats=None, intermediate_col_stats=None,):
        self.stats = stats
        self.intermediate_col_stats = intermediate_col_stats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stats = TTableStats()
                    self.stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.intermediate_col_stats = {}
                    (_ktype8, _vtype9, _size7) = iprot.readMapBegin()
                    for _i11 in range(_size7):
                        _key12 = iprot.readString()
                        _val13 = TIntermediateColumnStats()
                        _val13.read(iprot)
                        self.intermediate_col_stats[_key12] = _val13
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPartitionStats')
        if self.stats is not None:
            oprot.writeFieldBegin('stats', TType.STRUCT, 1)
            self.stats.write(oprot)
            oprot.writeFieldEnd()
        if self.intermediate_col_stats is not None:
            oprot.writeFieldBegin('intermediate_col_stats', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.intermediate_col_stats))
            for kiter14, viter15 in self.intermediate_col_stats.items():
                oprot.writeString(kiter14)
                viter15.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.stats is None:
            raise TProtocolException(message='Required field stats is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColumn(object):
    """
    Attributes:
     - columnName
     - columnType
     - comment
     - col_stats
     - position
     - virtual_column_type
     - is_hidden
     - is_hbase_column
     - column_family
     - column_qualifier
     - is_binary
     - is_kudu_column
     - is_key
     - is_nullable
     - encoding
     - compression
     - default_value
     - block_size
     - kudu_column_name
     - is_primary_key_unique
     - is_auto_incrementing
     - is_iceberg_column
     - iceberg_field_id
     - iceberg_field_map_key_id
     - iceberg_field_map_value_id

    """


    def __init__(self, columnName=None, columnType=None, comment=None, col_stats=None, position=None, virtual_column_type=0, is_hidden=None, is_hbase_column=None, column_family=None, column_qualifier=None, is_binary=None, is_kudu_column=None, is_key=None, is_nullable=None, encoding=None, compression=None, default_value=None, block_size=None, kudu_column_name=None, is_primary_key_unique=None, is_auto_incrementing=None, is_iceberg_column=None, iceberg_field_id=None, iceberg_field_map_key_id=None, iceberg_field_map_value_id=None,):
        self.columnName = columnName
        self.columnType = columnType
        self.comment = comment
        self.col_stats = col_stats
        self.position = position
        self.virtual_column_type = virtual_column_type
        self.is_hidden = is_hidden
        self.is_hbase_column = is_hbase_column
        self.column_family = column_family
        self.column_qualifier = column_qualifier
        self.is_binary = is_binary
        self.is_kudu_column = is_kudu_column
        self.is_key = is_key
        self.is_nullable = is_nullable
        self.encoding = encoding
        self.compression = compression
        self.default_value = default_value
        self.block_size = block_size
        self.kudu_column_name = kudu_column_name
        self.is_primary_key_unique = is_primary_key_unique
        self.is_auto_incrementing = is_auto_incrementing
        self.is_iceberg_column = is_iceberg_column
        self.iceberg_field_id = iceberg_field_id
        self.iceberg_field_map_key_id = iceberg_field_map_key_id
        self.iceberg_field_map_value_id = iceberg_field_map_value_id

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.columnName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.columnType = Types.ttypes.TColumnType()
                    self.columnType.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.comment = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.col_stats = TColumnStats()
                    self.col_stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.position = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.virtual_column_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.is_hidden = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.is_hbase_column = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.column_family = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.column_qualifier = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.is_binary = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.is_kudu_column = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.is_key = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.is_nullable = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I32:
                    self.encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I32:
                    self.compression = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.default_value = Exprs.ttypes.TExpr()
                    self.default_value.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I32:
                    self.block_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRING:
                    self.kudu_column_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.BOOL:
                    self.is_primary_key_unique = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.BOOL:
                    self.is_auto_incrementing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.BOOL:
                    self.is_iceberg_column = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.I32:
                    self.iceberg_field_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.I32:
                    self.iceberg_field_map_key_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.I32:
                    self.iceberg_field_map_value_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColumn')
        if self.columnName is not None:
            oprot.writeFieldBegin('columnName', TType.STRING, 1)
            oprot.writeString(self.columnName)
            oprot.writeFieldEnd()
        if self.columnType is not None:
            oprot.writeFieldBegin('columnType', TType.STRUCT, 2)
            self.columnType.write(oprot)
            oprot.writeFieldEnd()
        if self.comment is not None:
            oprot.writeFieldBegin('comment', TType.STRING, 3)
            oprot.writeString(self.comment)
            oprot.writeFieldEnd()
        if self.col_stats is not None:
            oprot.writeFieldBegin('col_stats', TType.STRUCT, 4)
            self.col_stats.write(oprot)
            oprot.writeFieldEnd()
        if self.position is not None:
            oprot.writeFieldBegin('position', TType.I32, 5)
            oprot.writeI32(self.position)
            oprot.writeFieldEnd()
        if self.virtual_column_type is not None:
            oprot.writeFieldBegin('virtual_column_type', TType.I32, 6)
            oprot.writeI32(self.virtual_column_type)
            oprot.writeFieldEnd()
        if self.is_hidden is not None:
            oprot.writeFieldBegin('is_hidden', TType.BOOL, 7)
            oprot.writeBool(self.is_hidden)
            oprot.writeFieldEnd()
        if self.is_hbase_column is not None:
            oprot.writeFieldBegin('is_hbase_column', TType.BOOL, 8)
            oprot.writeBool(self.is_hbase_column)
            oprot.writeFieldEnd()
        if self.column_family is not None:
            oprot.writeFieldBegin('column_family', TType.STRING, 9)
            oprot.writeString(self.column_family)
            oprot.writeFieldEnd()
        if self.column_qualifier is not None:
            oprot.writeFieldBegin('column_qualifier', TType.STRING, 10)
            oprot.writeString(self.column_qualifier)
            oprot.writeFieldEnd()
        if self.is_binary is not None:
            oprot.writeFieldBegin('is_binary', TType.BOOL, 11)
            oprot.writeBool(self.is_binary)
            oprot.writeFieldEnd()
        if self.is_kudu_column is not None:
            oprot.writeFieldBegin('is_kudu_column', TType.BOOL, 12)
            oprot.writeBool(self.is_kudu_column)
            oprot.writeFieldEnd()
        if self.is_key is not None:
            oprot.writeFieldBegin('is_key', TType.BOOL, 13)
            oprot.writeBool(self.is_key)
            oprot.writeFieldEnd()
        if self.is_nullable is not None:
            oprot.writeFieldBegin('is_nullable', TType.BOOL, 14)
            oprot.writeBool(self.is_nullable)
            oprot.writeFieldEnd()
        if self.encoding is not None:
            oprot.writeFieldBegin('encoding', TType.I32, 15)
            oprot.writeI32(self.encoding)
            oprot.writeFieldEnd()
        if self.compression is not None:
            oprot.writeFieldBegin('compression', TType.I32, 16)
            oprot.writeI32(self.compression)
            oprot.writeFieldEnd()
        if self.default_value is not None:
            oprot.writeFieldBegin('default_value', TType.STRUCT, 17)
            self.default_value.write(oprot)
            oprot.writeFieldEnd()
        if self.block_size is not None:
            oprot.writeFieldBegin('block_size', TType.I32, 18)
            oprot.writeI32(self.block_size)
            oprot.writeFieldEnd()
        if self.kudu_column_name is not None:
            oprot.writeFieldBegin('kudu_column_name', TType.STRING, 19)
            oprot.writeString(self.kudu_column_name)
            oprot.writeFieldEnd()
        if self.is_iceberg_column is not None:
            oprot.writeFieldBegin('is_iceberg_column', TType.BOOL, 20)
            oprot.writeBool(self.is_iceberg_column)
            oprot.writeFieldEnd()
        if self.iceberg_field_id is not None:
            oprot.writeFieldBegin('iceberg_field_id', TType.I32, 21)
            oprot.writeI32(self.iceberg_field_id)
            oprot.writeFieldEnd()
        if self.iceberg_field_map_key_id is not None:
            oprot.writeFieldBegin('iceberg_field_map_key_id', TType.I32, 22)
            oprot.writeI32(self.iceberg_field_map_key_id)
            oprot.writeFieldEnd()
        if self.iceberg_field_map_value_id is not None:
            oprot.writeFieldBegin('iceberg_field_map_value_id', TType.I32, 23)
            oprot.writeI32(self.iceberg_field_map_value_id)
            oprot.writeFieldEnd()
        if self.is_primary_key_unique is not None:
            oprot.writeFieldBegin('is_primary_key_unique', TType.BOOL, 24)
            oprot.writeBool(self.is_primary_key_unique)
            oprot.writeFieldEnd()
        if self.is_auto_incrementing is not None:
            oprot.writeFieldBegin('is_auto_incrementing', TType.BOOL, 25)
            oprot.writeBool(self.is_auto_incrementing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columnName is None:
            raise TProtocolException(message='Required field columnName is unset!')
        if self.columnType is None:
            raise TProtocolException(message='Required field columnType is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsFileDesc(object):
    """
    Attributes:
     - file_desc_data
     - file_metadata

    """


    def __init__(self, file_desc_data=None, file_metadata=None,):
        self.file_desc_data = file_desc_data
        self.file_metadata = file_metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.file_desc_data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.file_metadata = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsFileDesc')
        if self.file_desc_data is not None:
            oprot.writeFieldBegin('file_desc_data', TType.STRING, 1)
            oprot.writeBinary(self.file_desc_data)
            oprot.writeFieldEnd()
        if self.file_metadata is not None:
            oprot.writeFieldBegin('file_metadata', TType.STRING, 2)
            oprot.writeBinary(self.file_metadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.file_desc_data is None:
            raise TProtocolException(message='Required field file_desc_data is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsPartitionLocation(object):
    """
    Attributes:
     - prefix_index
     - suffix

    """


    def __init__(self, prefix_index=-1, suffix=None,):
        self.prefix_index = prefix_index
        self.suffix = suffix

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.prefix_index = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.suffix = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsPartitionLocation')
        if self.prefix_index is not None:
            oprot.writeFieldBegin('prefix_index', TType.I32, 1)
            oprot.writeI32(self.prefix_index)
            oprot.writeFieldEnd()
        if self.suffix is not None:
            oprot.writeFieldBegin('suffix', TType.STRING, 2)
            oprot.writeString(self.suffix)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.prefix_index is None:
            raise TProtocolException(message='Required field prefix_index is unset!')
        if self.suffix is None:
            raise TProtocolException(message='Required field suffix is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsStorageDescriptor(object):
    """
    Attributes:
     - lineDelim
     - fieldDelim
     - collectionDelim
     - mapKeyDelim
     - escapeChar
     - quoteChar
     - fileFormat
     - blockSize

    """


    def __init__(self, lineDelim=None, fieldDelim=None, collectionDelim=None, mapKeyDelim=None, escapeChar=None, quoteChar=None, fileFormat=None, blockSize=None,):
        self.lineDelim = lineDelim
        self.fieldDelim = fieldDelim
        self.collectionDelim = collectionDelim
        self.mapKeyDelim = mapKeyDelim
        self.escapeChar = escapeChar
        self.quoteChar = quoteChar
        self.fileFormat = fileFormat
        self.blockSize = blockSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.lineDelim = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BYTE:
                    self.fieldDelim = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.collectionDelim = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BYTE:
                    self.mapKeyDelim = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BYTE:
                    self.escapeChar = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BYTE:
                    self.quoteChar = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.fileFormat = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.blockSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsStorageDescriptor')
        if self.lineDelim is not None:
            oprot.writeFieldBegin('lineDelim', TType.BYTE, 1)
            oprot.writeByte(self.lineDelim)
            oprot.writeFieldEnd()
        if self.fieldDelim is not None:
            oprot.writeFieldBegin('fieldDelim', TType.BYTE, 2)
            oprot.writeByte(self.fieldDelim)
            oprot.writeFieldEnd()
        if self.collectionDelim is not None:
            oprot.writeFieldBegin('collectionDelim', TType.BYTE, 3)
            oprot.writeByte(self.collectionDelim)
            oprot.writeFieldEnd()
        if self.mapKeyDelim is not None:
            oprot.writeFieldBegin('mapKeyDelim', TType.BYTE, 4)
            oprot.writeByte(self.mapKeyDelim)
            oprot.writeFieldEnd()
        if self.escapeChar is not None:
            oprot.writeFieldBegin('escapeChar', TType.BYTE, 5)
            oprot.writeByte(self.escapeChar)
            oprot.writeFieldEnd()
        if self.quoteChar is not None:
            oprot.writeFieldBegin('quoteChar', TType.BYTE, 6)
            oprot.writeByte(self.quoteChar)
            oprot.writeFieldEnd()
        if self.fileFormat is not None:
            oprot.writeFieldBegin('fileFormat', TType.I32, 7)
            oprot.writeI32(self.fileFormat)
            oprot.writeFieldEnd()
        if self.blockSize is not None:
            oprot.writeFieldBegin('blockSize', TType.I32, 8)
            oprot.writeI32(self.blockSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.lineDelim is None:
            raise TProtocolException(message='Required field lineDelim is unset!')
        if self.fieldDelim is None:
            raise TProtocolException(message='Required field fieldDelim is unset!')
        if self.collectionDelim is None:
            raise TProtocolException(message='Required field collectionDelim is unset!')
        if self.mapKeyDelim is None:
            raise TProtocolException(message='Required field mapKeyDelim is unset!')
        if self.escapeChar is None:
            raise TProtocolException(message='Required field escapeChar is unset!')
        if self.quoteChar is None:
            raise TProtocolException(message='Required field quoteChar is unset!')
        if self.fileFormat is None:
            raise TProtocolException(message='Required field fileFormat is unset!')
        if self.blockSize is None:
            raise TProtocolException(message='Required field blockSize is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsPartition(object):
    """
    Attributes:
     - partitionKeyExprs
     - location
     - id
     - prev_id
     - file_desc
     - insert_file_desc
     - delete_file_desc
     - access_level
     - stats
     - is_marked_cached
     - hms_parameters
     - num_blocks
     - total_file_size_bytes
     - partition_stats
     - has_incremental_stats
     - write_id
     - db_name
     - tbl_name
     - partition_name
     - hdfs_storage_descriptor

    """


    def __init__(self, partitionKeyExprs=None, location=None, id=None, prev_id=-1, file_desc=None, insert_file_desc=None, delete_file_desc=None, access_level=None, stats=None, is_marked_cached=None, hms_parameters=None, num_blocks=None, total_file_size_bytes=None, partition_stats=None, has_incremental_stats=None, write_id=None, db_name=None, tbl_name=None, partition_name=None, hdfs_storage_descriptor=None,):
        self.partitionKeyExprs = partitionKeyExprs
        self.location = location
        self.id = id
        self.prev_id = prev_id
        self.file_desc = file_desc
        self.insert_file_desc = insert_file_desc
        self.delete_file_desc = delete_file_desc
        self.access_level = access_level
        self.stats = stats
        self.is_marked_cached = is_marked_cached
        self.hms_parameters = hms_parameters
        self.num_blocks = num_blocks
        self.total_file_size_bytes = total_file_size_bytes
        self.partition_stats = partition_stats
        self.has_incremental_stats = has_incremental_stats
        self.write_id = write_id
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.partition_name = partition_name
        self.hdfs_storage_descriptor = hdfs_storage_descriptor

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 7:
                if ftype == TType.LIST:
                    self.partitionKeyExprs = []
                    (_etype19, _size16) = iprot.readListBegin()
                    for _i20 in range(_size16):
                        _elem21 = Exprs.ttypes.TExpr()
                        _elem21.read(iprot)
                        self.partitionKeyExprs.append(_elem21)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.location = THdfsPartitionLocation()
                    self.location.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I64:
                    self.id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 26:
                if ftype == TType.I64:
                    self.prev_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.file_desc = []
                    (_etype25, _size22) = iprot.readListBegin()
                    for _i26 in range(_size22):
                        _elem27 = THdfsFileDesc()
                        _elem27.read(iprot)
                        self.file_desc.append(_elem27)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 21:
                if ftype == TType.LIST:
                    self.insert_file_desc = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = THdfsFileDesc()
                        _elem33.read(iprot)
                        self.insert_file_desc.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 22:
                if ftype == TType.LIST:
                    self.delete_file_desc = []
                    (_etype37, _size34) = iprot.readListBegin()
                    for _i38 in range(_size34):
                        _elem39 = THdfsFileDesc()
                        _elem39.read(iprot)
                        self.delete_file_desc.append(_elem39)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.access_level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.stats = TTableStats()
                    self.stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BOOL:
                    self.is_marked_cached = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.MAP:
                    self.hms_parameters = {}
                    (_ktype41, _vtype42, _size40) = iprot.readMapBegin()
                    for _i44 in range(_size40):
                        _key45 = iprot.readString()
                        _val46 = iprot.readString()
                        self.hms_parameters[_key45] = _val46
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I64:
                    self.num_blocks = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I64:
                    self.total_file_size_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRING:
                    self.partition_stats = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.BOOL:
                    self.has_incremental_stats = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.I64:
                    self.write_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 23:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 24:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 25:
                if ftype == TType.STRING:
                    self.partition_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 27:
                if ftype == TType.STRUCT:
                    self.hdfs_storage_descriptor = THdfsStorageDescriptor()
                    self.hdfs_storage_descriptor.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsPartition')
        if self.partitionKeyExprs is not None:
            oprot.writeFieldBegin('partitionKeyExprs', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.partitionKeyExprs))
            for iter47 in self.partitionKeyExprs:
                iter47.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.file_desc is not None:
            oprot.writeFieldBegin('file_desc', TType.LIST, 9)
            oprot.writeListBegin(TType.STRUCT, len(self.file_desc))
            for iter48 in self.file_desc:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.location is not None:
            oprot.writeFieldBegin('location', TType.STRUCT, 10)
            self.location.write(oprot)
            oprot.writeFieldEnd()
        if self.access_level is not None:
            oprot.writeFieldBegin('access_level', TType.I32, 11)
            oprot.writeI32(self.access_level)
            oprot.writeFieldEnd()
        if self.stats is not None:
            oprot.writeFieldBegin('stats', TType.STRUCT, 12)
            self.stats.write(oprot)
            oprot.writeFieldEnd()
        if self.is_marked_cached is not None:
            oprot.writeFieldBegin('is_marked_cached', TType.BOOL, 13)
            oprot.writeBool(self.is_marked_cached)
            oprot.writeFieldEnd()
        if self.id is not None:
            oprot.writeFieldBegin('id', TType.I64, 14)
            oprot.writeI64(self.id)
            oprot.writeFieldEnd()
        if self.hms_parameters is not None:
            oprot.writeFieldBegin('hms_parameters', TType.MAP, 15)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.hms_parameters))
            for kiter49, viter50 in self.hms_parameters.items():
                oprot.writeString(kiter49)
                oprot.writeString(viter50)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.num_blocks is not None:
            oprot.writeFieldBegin('num_blocks', TType.I64, 16)
            oprot.writeI64(self.num_blocks)
            oprot.writeFieldEnd()
        if self.total_file_size_bytes is not None:
            oprot.writeFieldBegin('total_file_size_bytes', TType.I64, 17)
            oprot.writeI64(self.total_file_size_bytes)
            oprot.writeFieldEnd()
        if self.partition_stats is not None:
            oprot.writeFieldBegin('partition_stats', TType.STRING, 18)
            oprot.writeBinary(self.partition_stats)
            oprot.writeFieldEnd()
        if self.has_incremental_stats is not None:
            oprot.writeFieldBegin('has_incremental_stats', TType.BOOL, 19)
            oprot.writeBool(self.has_incremental_stats)
            oprot.writeFieldEnd()
        if self.write_id is not None:
            oprot.writeFieldBegin('write_id', TType.I64, 20)
            oprot.writeI64(self.write_id)
            oprot.writeFieldEnd()
        if self.insert_file_desc is not None:
            oprot.writeFieldBegin('insert_file_desc', TType.LIST, 21)
            oprot.writeListBegin(TType.STRUCT, len(self.insert_file_desc))
            for iter51 in self.insert_file_desc:
                iter51.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.delete_file_desc is not None:
            oprot.writeFieldBegin('delete_file_desc', TType.LIST, 22)
            oprot.writeListBegin(TType.STRUCT, len(self.delete_file_desc))
            for iter52 in self.delete_file_desc:
                iter52.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 23)
            oprot.writeString(self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 24)
            oprot.writeString(self.tbl_name)
            oprot.writeFieldEnd()
        if self.partition_name is not None:
            oprot.writeFieldBegin('partition_name', TType.STRING, 25)
            oprot.writeString(self.partition_name)
            oprot.writeFieldEnd()
        if self.prev_id is not None:
            oprot.writeFieldBegin('prev_id', TType.I64, 26)
            oprot.writeI64(self.prev_id)
            oprot.writeFieldEnd()
        if self.hdfs_storage_descriptor is not None:
            oprot.writeFieldBegin('hdfs_storage_descriptor', TType.STRUCT, 27)
            self.hdfs_storage_descriptor.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TValidWriteIdList(object):
    """
    Attributes:
     - high_watermark
     - min_open_write_id
     - invalid_write_ids
     - aborted_indexes

    """


    def __init__(self, high_watermark=None, min_open_write_id=None, invalid_write_ids=None, aborted_indexes=None,):
        self.high_watermark = high_watermark
        self.min_open_write_id = min_open_write_id
        self.invalid_write_ids = invalid_write_ids
        self.aborted_indexes = aborted_indexes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.high_watermark = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.min_open_write_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.invalid_write_ids = []
                    (_etype56, _size53) = iprot.readListBegin()
                    for _i57 in range(_size53):
                        _elem58 = iprot.readI64()
                        self.invalid_write_ids.append(_elem58)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.aborted_indexes = []
                    (_etype62, _size59) = iprot.readListBegin()
                    for _i63 in range(_size59):
                        _elem64 = iprot.readI32()
                        self.aborted_indexes.append(_elem64)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TValidWriteIdList')
        if self.high_watermark is not None:
            oprot.writeFieldBegin('high_watermark', TType.I64, 1)
            oprot.writeI64(self.high_watermark)
            oprot.writeFieldEnd()
        if self.min_open_write_id is not None:
            oprot.writeFieldBegin('min_open_write_id', TType.I64, 2)
            oprot.writeI64(self.min_open_write_id)
            oprot.writeFieldEnd()
        if self.invalid_write_ids is not None:
            oprot.writeFieldBegin('invalid_write_ids', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.invalid_write_ids))
            for iter65 in self.invalid_write_ids:
                oprot.writeI64(iter65)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.aborted_indexes is not None:
            oprot.writeFieldBegin('aborted_indexes', TType.LIST, 4)
            oprot.writeListBegin(TType.I32, len(self.aborted_indexes))
            for iter66 in self.aborted_indexes:
                oprot.writeI32(iter66)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsTable(object):
    """
    Attributes:
     - hdfsBaseDir
     - colNames
     - nullPartitionKeyValue
     - nullColumnValue
     - avroSchema
     - partitions
     - has_full_partitions
     - has_partition_names
     - prototype_partition
     - partition_prefixes
     - network_addresses
     - sql_constraints
     - is_full_acid
     - valid_write_ids
     - bucket_info
     - dropped_partitions

    """


    def __init__(self, hdfsBaseDir=None, colNames=None, nullPartitionKeyValue=None, nullColumnValue=None, avroSchema=None, partitions=None, has_full_partitions=None, has_partition_names=None, prototype_partition=None, partition_prefixes=None, network_addresses=None, sql_constraints=None, is_full_acid=False, valid_write_ids=None, bucket_info=None, dropped_partitions=None,):
        self.hdfsBaseDir = hdfsBaseDir
        self.colNames = colNames
        self.nullPartitionKeyValue = nullPartitionKeyValue
        self.nullColumnValue = nullColumnValue
        self.avroSchema = avroSchema
        self.partitions = partitions
        self.has_full_partitions = has_full_partitions
        self.has_partition_names = has_partition_names
        self.prototype_partition = prototype_partition
        self.partition_prefixes = partition_prefixes
        self.network_addresses = network_addresses
        self.sql_constraints = sql_constraints
        self.is_full_acid = is_full_acid
        self.valid_write_ids = valid_write_ids
        self.bucket_info = bucket_info
        self.dropped_partitions = dropped_partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hdfsBaseDir = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.colNames = []
                    (_etype70, _size67) = iprot.readListBegin()
                    for _i71 in range(_size67):
                        _elem72 = iprot.readString()
                        self.colNames.append(_elem72)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.nullPartitionKeyValue = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.nullColumnValue = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.avroSchema = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.partitions = {}
                    (_ktype74, _vtype75, _size73) = iprot.readMapBegin()
                    for _i77 in range(_size73):
                        _key78 = iprot.readI64()
                        _val79 = THdfsPartition()
                        _val79.read(iprot)
                        self.partitions[_key78] = _val79
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.has_full_partitions = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.has_partition_names = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.prototype_partition = THdfsPartition()
                    self.prototype_partition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.LIST:
                    self.partition_prefixes = []
                    (_etype83, _size80) = iprot.readListBegin()
                    for _i84 in range(_size80):
                        _elem85 = iprot.readString()
                        self.partition_prefixes.append(_elem85)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.network_addresses = []
                    (_etype89, _size86) = iprot.readListBegin()
                    for _i90 in range(_size86):
                        _elem91 = Types.ttypes.TNetworkAddress()
                        _elem91.read(iprot)
                        self.network_addresses.append(_elem91)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.sql_constraints = SqlConstraints.ttypes.TSqlConstraints()
                    self.sql_constraints.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.is_full_acid = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.valid_write_ids = TValidWriteIdList()
                    self.valid_write_ids.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.STRUCT:
                    self.bucket_info = TBucketInfo()
                    self.bucket_info.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.LIST:
                    self.dropped_partitions = []
                    (_etype95, _size92) = iprot.readListBegin()
                    for _i96 in range(_size92):
                        _elem97 = THdfsPartition()
                        _elem97.read(iprot)
                        self.dropped_partitions.append(_elem97)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsTable')
        if self.hdfsBaseDir is not None:
            oprot.writeFieldBegin('hdfsBaseDir', TType.STRING, 1)
            oprot.writeString(self.hdfsBaseDir)
            oprot.writeFieldEnd()
        if self.colNames is not None:
            oprot.writeFieldBegin('colNames', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.colNames))
            for iter98 in self.colNames:
                oprot.writeString(iter98)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.nullPartitionKeyValue is not None:
            oprot.writeFieldBegin('nullPartitionKeyValue', TType.STRING, 3)
            oprot.writeString(self.nullPartitionKeyValue)
            oprot.writeFieldEnd()
        if self.partitions is not None:
            oprot.writeFieldBegin('partitions', TType.MAP, 4)
            oprot.writeMapBegin(TType.I64, TType.STRUCT, len(self.partitions))
            for kiter99, viter100 in self.partitions.items():
                oprot.writeI64(kiter99)
                viter100.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.nullColumnValue is not None:
            oprot.writeFieldBegin('nullColumnValue', TType.STRING, 5)
            oprot.writeString(self.nullColumnValue)
            oprot.writeFieldEnd()
        if self.avroSchema is not None:
            oprot.writeFieldBegin('avroSchema', TType.STRING, 6)
            oprot.writeString(self.avroSchema)
            oprot.writeFieldEnd()
        if self.network_addresses is not None:
            oprot.writeFieldBegin('network_addresses', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.network_addresses))
            for iter101 in self.network_addresses:
                iter101.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_prefixes is not None:
            oprot.writeFieldBegin('partition_prefixes', TType.LIST, 9)
            oprot.writeListBegin(TType.STRING, len(self.partition_prefixes))
            for iter102 in self.partition_prefixes:
                oprot.writeString(iter102)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.prototype_partition is not None:
            oprot.writeFieldBegin('prototype_partition', TType.STRUCT, 10)
            self.prototype_partition.write(oprot)
            oprot.writeFieldEnd()
        if self.sql_constraints is not None:
            oprot.writeFieldBegin('sql_constraints', TType.STRUCT, 11)
            self.sql_constraints.write(oprot)
            oprot.writeFieldEnd()
        if self.is_full_acid is not None:
            oprot.writeFieldBegin('is_full_acid', TType.BOOL, 12)
            oprot.writeBool(self.is_full_acid)
            oprot.writeFieldEnd()
        if self.valid_write_ids is not None:
            oprot.writeFieldBegin('valid_write_ids', TType.STRUCT, 13)
            self.valid_write_ids.write(oprot)
            oprot.writeFieldEnd()
        if self.has_full_partitions is not None:
            oprot.writeFieldBegin('has_full_partitions', TType.BOOL, 14)
            oprot.writeBool(self.has_full_partitions)
            oprot.writeFieldEnd()
        if self.has_partition_names is not None:
            oprot.writeFieldBegin('has_partition_names', TType.BOOL, 15)
            oprot.writeBool(self.has_partition_names)
            oprot.writeFieldEnd()
        if self.bucket_info is not None:
            oprot.writeFieldBegin('bucket_info', TType.STRUCT, 16)
            self.bucket_info.write(oprot)
            oprot.writeFieldEnd()
        if self.dropped_partitions is not None:
            oprot.writeFieldBegin('dropped_partitions', TType.LIST, 17)
            oprot.writeListBegin(TType.STRUCT, len(self.dropped_partitions))
            for iter103 in self.dropped_partitions:
                iter103.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hdfsBaseDir is None:
            raise TProtocolException(message='Required field hdfsBaseDir is unset!')
        if self.colNames is None:
            raise TProtocolException(message='Required field colNames is unset!')
        if self.nullPartitionKeyValue is None:
            raise TProtocolException(message='Required field nullPartitionKeyValue is unset!')
        if self.nullColumnValue is None:
            raise TProtocolException(message='Required field nullColumnValue is unset!')
        if self.partitions is None:
            raise TProtocolException(message='Required field partitions is unset!')
        if self.prototype_partition is None:
            raise TProtocolException(message='Required field prototype_partition is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THBaseTable(object):
    """
    Attributes:
     - tableName
     - families
     - qualifiers
     - binary_encoded

    """


    def __init__(self, tableName=None, families=None, qualifiers=None, binary_encoded=None,):
        self.tableName = tableName
        self.families = families
        self.qualifiers = qualifiers
        self.binary_encoded = binary_encoded

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.families = []
                    (_etype107, _size104) = iprot.readListBegin()
                    for _i108 in range(_size104):
                        _elem109 = iprot.readString()
                        self.families.append(_elem109)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.qualifiers = []
                    (_etype113, _size110) = iprot.readListBegin()
                    for _i114 in range(_size110):
                        _elem115 = iprot.readString()
                        self.qualifiers.append(_elem115)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.binary_encoded = []
                    (_etype119, _size116) = iprot.readListBegin()
                    for _i120 in range(_size116):
                        _elem121 = iprot.readBool()
                        self.binary_encoded.append(_elem121)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THBaseTable')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName)
            oprot.writeFieldEnd()
        if self.families is not None:
            oprot.writeFieldBegin('families', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.families))
            for iter122 in self.families:
                oprot.writeString(iter122)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.qualifiers is not None:
            oprot.writeFieldBegin('qualifiers', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.qualifiers))
            for iter123 in self.qualifiers:
                oprot.writeString(iter123)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.binary_encoded is not None:
            oprot.writeFieldBegin('binary_encoded', TType.LIST, 4)
            oprot.writeListBegin(TType.BOOL, len(self.binary_encoded))
            for iter124 in self.binary_encoded:
                oprot.writeBool(iter124)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        if self.families is None:
            raise TProtocolException(message='Required field families is unset!')
        if self.qualifiers is None:
            raise TProtocolException(message='Required field qualifiers is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataSource(object):
    """
    Attributes:
     - name
     - hdfs_location
     - class_name
     - api_version

    """


    def __init__(self, name=None, hdfs_location=None, class_name=None, api_version=None,):
        self.name = name
        self.hdfs_location = hdfs_location
        self.class_name = class_name
        self.api_version = api_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.hdfs_location = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.class_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.api_version = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataSource')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name)
            oprot.writeFieldEnd()
        if self.hdfs_location is not None:
            oprot.writeFieldBegin('hdfs_location', TType.STRING, 2)
            oprot.writeString(self.hdfs_location)
            oprot.writeFieldEnd()
        if self.class_name is not None:
            oprot.writeFieldBegin('class_name', TType.STRING, 3)
            oprot.writeString(self.class_name)
            oprot.writeFieldEnd()
        if self.api_version is not None:
            oprot.writeFieldBegin('api_version', TType.STRING, 4)
            oprot.writeString(self.api_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        if self.hdfs_location is None:
            raise TProtocolException(message='Required field hdfs_location is unset!')
        if self.class_name is None:
            raise TProtocolException(message='Required field class_name is unset!')
        if self.api_version is None:
            raise TProtocolException(message='Required field api_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDataSourceTable(object):
    """
    Attributes:
     - data_source
     - init_string

    """


    def __init__(self, data_source=None, init_string=None,):
        self.data_source = data_source
        self.init_string = init_string

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.data_source = TDataSource()
                    self.data_source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.init_string = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDataSourceTable')
        if self.data_source is not None:
            oprot.writeFieldBegin('data_source', TType.STRUCT, 1)
            self.data_source.write(oprot)
            oprot.writeFieldEnd()
        if self.init_string is not None:
            oprot.writeFieldBegin('init_string', TType.STRING, 2)
            oprot.writeString(self.init_string)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.data_source is None:
            raise TProtocolException(message='Required field data_source is unset!')
        if self.init_string is None:
            raise TProtocolException(message='Required field init_string is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduPartitionByHashParam(object):
    """
    Attributes:
     - columns
     - num_partitions

    """


    def __init__(self, columns=None, num_partitions=None,):
        self.columns = columns
        self.num_partitions = num_partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype128, _size125) = iprot.readListBegin()
                    for _i129 in range(_size125):
                        _elem130 = iprot.readString()
                        self.columns.append(_elem130)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.num_partitions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduPartitionByHashParam')
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter131 in self.columns:
                oprot.writeString(iter131)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.num_partitions is not None:
            oprot.writeFieldBegin('num_partitions', TType.I32, 2)
            oprot.writeI32(self.num_partitions)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        if self.num_partitions is None:
            raise TProtocolException(message='Required field num_partitions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRangePartition(object):
    """
    Attributes:
     - lower_bound_values
     - is_lower_bound_inclusive
     - upper_bound_values
     - is_upper_bound_inclusive
     - hash_specs

    """


    def __init__(self, lower_bound_values=None, is_lower_bound_inclusive=None, upper_bound_values=None, is_upper_bound_inclusive=None, hash_specs=None,):
        self.lower_bound_values = lower_bound_values
        self.is_lower_bound_inclusive = is_lower_bound_inclusive
        self.upper_bound_values = upper_bound_values
        self.is_upper_bound_inclusive = is_upper_bound_inclusive
        self.hash_specs = hash_specs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.lower_bound_values = []
                    (_etype135, _size132) = iprot.readListBegin()
                    for _i136 in range(_size132):
                        _elem137 = Exprs.ttypes.TExpr()
                        _elem137.read(iprot)
                        self.lower_bound_values.append(_elem137)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.is_lower_bound_inclusive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.upper_bound_values = []
                    (_etype141, _size138) = iprot.readListBegin()
                    for _i142 in range(_size138):
                        _elem143 = Exprs.ttypes.TExpr()
                        _elem143.read(iprot)
                        self.upper_bound_values.append(_elem143)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.is_upper_bound_inclusive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.hash_specs = []
                    (_etype147, _size144) = iprot.readListBegin()
                    for _i148 in range(_size144):
                        _elem149 = TKuduPartitionParam()
                        _elem149.read(iprot)
                        self.hash_specs.append(_elem149)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRangePartition')
        if self.lower_bound_values is not None:
            oprot.writeFieldBegin('lower_bound_values', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.lower_bound_values))
            for iter150 in self.lower_bound_values:
                iter150.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_lower_bound_inclusive is not None:
            oprot.writeFieldBegin('is_lower_bound_inclusive', TType.BOOL, 2)
            oprot.writeBool(self.is_lower_bound_inclusive)
            oprot.writeFieldEnd()
        if self.upper_bound_values is not None:
            oprot.writeFieldBegin('upper_bound_values', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.upper_bound_values))
            for iter151 in self.upper_bound_values:
                iter151.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_upper_bound_inclusive is not None:
            oprot.writeFieldBegin('is_upper_bound_inclusive', TType.BOOL, 4)
            oprot.writeBool(self.is_upper_bound_inclusive)
            oprot.writeFieldEnd()
        if self.hash_specs is not None:
            oprot.writeFieldBegin('hash_specs', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.hash_specs))
            for iter152 in self.hash_specs:
                iter152.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduPartitionByRangeParam(object):
    """
    Attributes:
     - columns
     - range_partitions

    """


    def __init__(self, columns=None, range_partitions=None,):
        self.columns = columns
        self.range_partitions = range_partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype156, _size153) = iprot.readListBegin()
                    for _i157 in range(_size153):
                        _elem158 = iprot.readString()
                        self.columns.append(_elem158)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range_partitions = []
                    (_etype162, _size159) = iprot.readListBegin()
                    for _i163 in range(_size159):
                        _elem164 = TRangePartition()
                        _elem164.read(iprot)
                        self.range_partitions.append(_elem164)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduPartitionByRangeParam')
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.columns))
            for iter165 in self.columns:
                oprot.writeString(iter165)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range_partitions is not None:
            oprot.writeFieldBegin('range_partitions', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.range_partitions))
            for iter166 in self.range_partitions:
                iter166.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduPartitionParam(object):
    """
    Attributes:
     - by_hash_param
     - by_range_param

    """


    def __init__(self, by_hash_param=None, by_range_param=None,):
        self.by_hash_param = by_hash_param
        self.by_range_param = by_range_param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.by_hash_param = TKuduPartitionByHashParam()
                    self.by_hash_param.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.by_range_param = TKuduPartitionByRangeParam()
                    self.by_range_param.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduPartitionParam')
        if self.by_hash_param is not None:
            oprot.writeFieldBegin('by_hash_param', TType.STRUCT, 1)
            self.by_hash_param.write(oprot)
            oprot.writeFieldEnd()
        if self.by_range_param is not None:
            oprot.writeFieldBegin('by_range_param', TType.STRUCT, 2)
            self.by_range_param.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TKuduTable(object):
    """
    Attributes:
     - table_name
     - master_addresses
     - key_columns
     - partition_by
     - is_primary_key_unique
     - has_auto_incrementing

    """


    def __init__(self, table_name=None, master_addresses=None, key_columns=None, partition_by=None, is_primary_key_unique=None, has_auto_incrementing=None,):
        self.table_name = table_name
        self.master_addresses = master_addresses
        self.key_columns = key_columns
        self.partition_by = partition_by
        self.is_primary_key_unique = is_primary_key_unique
        self.has_auto_incrementing = has_auto_incrementing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.master_addresses = []
                    (_etype170, _size167) = iprot.readListBegin()
                    for _i171 in range(_size167):
                        _elem172 = iprot.readString()
                        self.master_addresses.append(_elem172)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.key_columns = []
                    (_etype176, _size173) = iprot.readListBegin()
                    for _i177 in range(_size173):
                        _elem178 = iprot.readString()
                        self.key_columns.append(_elem178)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.partition_by = []
                    (_etype182, _size179) = iprot.readListBegin()
                    for _i183 in range(_size179):
                        _elem184 = TKuduPartitionParam()
                        _elem184.read(iprot)
                        self.partition_by.append(_elem184)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.is_primary_key_unique = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.has_auto_incrementing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TKuduTable')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 1)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.master_addresses is not None:
            oprot.writeFieldBegin('master_addresses', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.master_addresses))
            for iter185 in self.master_addresses:
                oprot.writeString(iter185)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.key_columns is not None:
            oprot.writeFieldBegin('key_columns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.key_columns))
            for iter186 in self.key_columns:
                oprot.writeString(iter186)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.partition_by is not None:
            oprot.writeFieldBegin('partition_by', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_by))
            for iter187 in self.partition_by:
                iter187.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_primary_key_unique is not None:
            oprot.writeFieldBegin('is_primary_key_unique', TType.BOOL, 5)
            oprot.writeBool(self.is_primary_key_unique)
            oprot.writeFieldEnd()
        if self.has_auto_incrementing is not None:
            oprot.writeFieldBegin('has_auto_incrementing', TType.BOOL, 6)
            oprot.writeBool(self.has_auto_incrementing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        if self.master_addresses is None:
            raise TProtocolException(message='Required field master_addresses is unset!')
        if self.key_columns is None:
            raise TProtocolException(message='Required field key_columns is unset!')
        if self.partition_by is None:
            raise TProtocolException(message='Required field partition_by is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergPartitionTransform(object):
    """
    Attributes:
     - transform_type
     - transform_param

    """


    def __init__(self, transform_type=None, transform_param=None,):
        self.transform_type = transform_type
        self.transform_param = transform_param

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.transform_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.transform_param = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergPartitionTransform')
        if self.transform_type is not None:
            oprot.writeFieldBegin('transform_type', TType.I32, 1)
            oprot.writeI32(self.transform_type)
            oprot.writeFieldEnd()
        if self.transform_param is not None:
            oprot.writeFieldBegin('transform_param', TType.I32, 2)
            oprot.writeI32(self.transform_param)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.transform_type is None:
            raise TProtocolException(message='Required field transform_type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergPartitionField(object):
    """
    Attributes:
     - source_id
     - field_id
     - orig_field_name
     - field_name
     - transform
     - type

    """


    def __init__(self, source_id=None, field_id=None, orig_field_name=None, field_name=None, transform=None, type=None,):
        self.source_id = source_id
        self.field_id = field_id
        self.orig_field_name = orig_field_name
        self.field_name = field_name
        self.transform = transform
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.source_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.field_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.orig_field_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.field_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.transform = TIcebergPartitionTransform()
                    self.transform.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.type = Types.ttypes.TScalarType()
                    self.type.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergPartitionField')
        if self.source_id is not None:
            oprot.writeFieldBegin('source_id', TType.I32, 1)
            oprot.writeI32(self.source_id)
            oprot.writeFieldEnd()
        if self.field_id is not None:
            oprot.writeFieldBegin('field_id', TType.I32, 2)
            oprot.writeI32(self.field_id)
            oprot.writeFieldEnd()
        if self.orig_field_name is not None:
            oprot.writeFieldBegin('orig_field_name', TType.STRING, 3)
            oprot.writeString(self.orig_field_name)
            oprot.writeFieldEnd()
        if self.field_name is not None:
            oprot.writeFieldBegin('field_name', TType.STRING, 4)
            oprot.writeString(self.field_name)
            oprot.writeFieldEnd()
        if self.transform is not None:
            oprot.writeFieldBegin('transform', TType.STRUCT, 5)
            self.transform.write(oprot)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRUCT, 6)
            self.type.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.source_id is None:
            raise TProtocolException(message='Required field source_id is unset!')
        if self.field_id is None:
            raise TProtocolException(message='Required field field_id is unset!')
        if self.orig_field_name is None:
            raise TProtocolException(message='Required field orig_field_name is unset!')
        if self.field_name is None:
            raise TProtocolException(message='Required field field_name is unset!')
        if self.transform is None:
            raise TProtocolException(message='Required field transform is unset!')
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergPartitionSpec(object):
    """
    Attributes:
     - spec_id
     - partition_fields

    """


    def __init__(self, spec_id=None, partition_fields=None,):
        self.spec_id = spec_id
        self.partition_fields = partition_fields

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.spec_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_fields = []
                    (_etype191, _size188) = iprot.readListBegin()
                    for _i192 in range(_size188):
                        _elem193 = TIcebergPartitionField()
                        _elem193.read(iprot)
                        self.partition_fields.append(_elem193)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergPartitionSpec')
        if self.spec_id is not None:
            oprot.writeFieldBegin('spec_id', TType.I32, 1)
            oprot.writeI32(self.spec_id)
            oprot.writeFieldEnd()
        if self.partition_fields is not None:
            oprot.writeFieldBegin('partition_fields', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_fields))
            for iter194 in self.partition_fields:
                iter194.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.spec_id is None:
            raise TProtocolException(message='Required field spec_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergPartitionStats(object):
    """
    Attributes:
     - num_files
     - num_rows
     - file_size_in_bytes

    """


    def __init__(self, num_files=None, num_rows=None, file_size_in_bytes=None,):
        self.num_files = num_files
        self.num_rows = num_rows
        self.file_size_in_bytes = file_size_in_bytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.num_files = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.num_rows = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.file_size_in_bytes = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergPartitionStats')
        if self.num_files is not None:
            oprot.writeFieldBegin('num_files', TType.I64, 1)
            oprot.writeI64(self.num_files)
            oprot.writeFieldEnd()
        if self.num_rows is not None:
            oprot.writeFieldBegin('num_rows', TType.I64, 2)
            oprot.writeI64(self.num_rows)
            oprot.writeFieldEnd()
        if self.file_size_in_bytes is not None:
            oprot.writeFieldBegin('file_size_in_bytes', TType.I64, 3)
            oprot.writeI64(self.file_size_in_bytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.num_files is None:
            raise TProtocolException(message='Required field num_files is unset!')
        if self.num_rows is None:
            raise TProtocolException(message='Required field num_rows is unset!')
        if self.file_size_in_bytes is None:
            raise TProtocolException(message='Required field file_size_in_bytes is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergContentFileStore(object):
    """
    Attributes:
     - path_hash_to_data_file_without_deletes
     - path_hash_to_data_file_with_deletes
     - path_hash_to_position_delete_file
     - path_hash_to_equality_delete_file
     - has_avro
     - has_orc
     - has_parquet

    """


    def __init__(self, path_hash_to_data_file_without_deletes=None, path_hash_to_data_file_with_deletes=None, path_hash_to_position_delete_file=None, path_hash_to_equality_delete_file=None, has_avro=None, has_orc=None, has_parquet=None,):
        self.path_hash_to_data_file_without_deletes = path_hash_to_data_file_without_deletes
        self.path_hash_to_data_file_with_deletes = path_hash_to_data_file_with_deletes
        self.path_hash_to_position_delete_file = path_hash_to_position_delete_file
        self.path_hash_to_equality_delete_file = path_hash_to_equality_delete_file
        self.has_avro = has_avro
        self.has_orc = has_orc
        self.has_parquet = has_parquet

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.path_hash_to_data_file_without_deletes = {}
                    (_ktype196, _vtype197, _size195) = iprot.readMapBegin()
                    for _i199 in range(_size195):
                        _key200 = iprot.readString()
                        _val201 = THdfsFileDesc()
                        _val201.read(iprot)
                        self.path_hash_to_data_file_without_deletes[_key200] = _val201
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.path_hash_to_data_file_with_deletes = {}
                    (_ktype203, _vtype204, _size202) = iprot.readMapBegin()
                    for _i206 in range(_size202):
                        _key207 = iprot.readString()
                        _val208 = THdfsFileDesc()
                        _val208.read(iprot)
                        self.path_hash_to_data_file_with_deletes[_key207] = _val208
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.path_hash_to_position_delete_file = {}
                    (_ktype210, _vtype211, _size209) = iprot.readMapBegin()
                    for _i213 in range(_size209):
                        _key214 = iprot.readString()
                        _val215 = THdfsFileDesc()
                        _val215.read(iprot)
                        self.path_hash_to_position_delete_file[_key214] = _val215
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.path_hash_to_equality_delete_file = {}
                    (_ktype217, _vtype218, _size216) = iprot.readMapBegin()
                    for _i220 in range(_size216):
                        _key221 = iprot.readString()
                        _val222 = THdfsFileDesc()
                        _val222.read(iprot)
                        self.path_hash_to_equality_delete_file[_key221] = _val222
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.has_avro = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.has_orc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.has_parquet = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergContentFileStore')
        if self.path_hash_to_data_file_without_deletes is not None:
            oprot.writeFieldBegin('path_hash_to_data_file_without_deletes', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.path_hash_to_data_file_without_deletes))
            for kiter223, viter224 in self.path_hash_to_data_file_without_deletes.items():
                oprot.writeString(kiter223)
                viter224.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.path_hash_to_data_file_with_deletes is not None:
            oprot.writeFieldBegin('path_hash_to_data_file_with_deletes', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.path_hash_to_data_file_with_deletes))
            for kiter225, viter226 in self.path_hash_to_data_file_with_deletes.items():
                oprot.writeString(kiter225)
                viter226.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.path_hash_to_position_delete_file is not None:
            oprot.writeFieldBegin('path_hash_to_position_delete_file', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.path_hash_to_position_delete_file))
            for kiter227, viter228 in self.path_hash_to_position_delete_file.items():
                oprot.writeString(kiter227)
                viter228.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.path_hash_to_equality_delete_file is not None:
            oprot.writeFieldBegin('path_hash_to_equality_delete_file', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.path_hash_to_equality_delete_file))
            for kiter229, viter230 in self.path_hash_to_equality_delete_file.items():
                oprot.writeString(kiter229)
                viter230.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.has_avro is not None:
            oprot.writeFieldBegin('has_avro', TType.BOOL, 5)
            oprot.writeBool(self.has_avro)
            oprot.writeFieldEnd()
        if self.has_orc is not None:
            oprot.writeFieldBegin('has_orc', TType.BOOL, 6)
            oprot.writeBool(self.has_orc)
            oprot.writeFieldEnd()
        if self.has_parquet is not None:
            oprot.writeFieldBegin('has_parquet', TType.BOOL, 7)
            oprot.writeBool(self.has_parquet)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergDropPartitionRequest(object):
    """
    Attributes:
     - paths
     - is_truncate
     - num_partitions

    """


    def __init__(self, paths=None, is_truncate=None, num_partitions=None,):
        self.paths = paths
        self.is_truncate = is_truncate
        self.num_partitions = num_partitions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.paths = []
                    (_etype234, _size231) = iprot.readListBegin()
                    for _i235 in range(_size231):
                        _elem236 = iprot.readString()
                        self.paths.append(_elem236)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.is_truncate = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.num_partitions = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergDropPartitionRequest')
        if self.paths is not None:
            oprot.writeFieldBegin('paths', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.paths))
            for iter237 in self.paths:
                oprot.writeString(iter237)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.is_truncate is not None:
            oprot.writeFieldBegin('is_truncate', TType.BOOL, 2)
            oprot.writeBool(self.is_truncate)
            oprot.writeFieldEnd()
        if self.num_partitions is not None:
            oprot.writeFieldBegin('num_partitions', TType.I64, 3)
            oprot.writeI64(self.num_partitions)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.paths is None:
            raise TProtocolException(message='Required field paths is unset!')
        if self.is_truncate is None:
            raise TProtocolException(message='Required field is_truncate is unset!')
        if self.num_partitions is None:
            raise TProtocolException(message='Required field num_partitions is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIcebergTable(object):
    """
    Attributes:
     - table_location
     - partition_spec
     - default_partition_spec_id
     - content_files
     - catalog_snapshot_id
     - parquet_compression_codec
     - parquet_row_group_size
     - parquet_plain_page_size
     - parquet_dict_page_size
     - partition_stats

    """


    def __init__(self, table_location=None, partition_spec=None, default_partition_spec_id=None, content_files=None, catalog_snapshot_id=None, parquet_compression_codec=None, parquet_row_group_size=None, parquet_plain_page_size=None, parquet_dict_page_size=None, partition_stats=None,):
        self.table_location = table_location
        self.partition_spec = partition_spec
        self.default_partition_spec_id = default_partition_spec_id
        self.content_files = content_files
        self.catalog_snapshot_id = catalog_snapshot_id
        self.parquet_compression_codec = parquet_compression_codec
        self.parquet_row_group_size = parquet_row_group_size
        self.parquet_plain_page_size = parquet_plain_page_size
        self.parquet_dict_page_size = parquet_dict_page_size
        self.partition_stats = partition_stats

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.table_location = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.partition_spec = []
                    (_etype241, _size238) = iprot.readListBegin()
                    for _i242 in range(_size238):
                        _elem243 = TIcebergPartitionSpec()
                        _elem243.read(iprot)
                        self.partition_spec.append(_elem243)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.default_partition_spec_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.content_files = TIcebergContentFileStore()
                    self.content_files.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.catalog_snapshot_id = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.parquet_compression_codec = TCompressionCodec()
                    self.parquet_compression_codec.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.parquet_row_group_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.parquet_plain_page_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I64:
                    self.parquet_dict_page_size = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.MAP:
                    self.partition_stats = {}
                    (_ktype245, _vtype246, _size244) = iprot.readMapBegin()
                    for _i248 in range(_size244):
                        _key249 = iprot.readString()
                        _val250 = TIcebergPartitionStats()
                        _val250.read(iprot)
                        self.partition_stats[_key249] = _val250
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIcebergTable')
        if self.table_location is not None:
            oprot.writeFieldBegin('table_location', TType.STRING, 1)
            oprot.writeString(self.table_location)
            oprot.writeFieldEnd()
        if self.partition_spec is not None:
            oprot.writeFieldBegin('partition_spec', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.partition_spec))
            for iter251 in self.partition_spec:
                iter251.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.default_partition_spec_id is not None:
            oprot.writeFieldBegin('default_partition_spec_id', TType.I32, 3)
            oprot.writeI32(self.default_partition_spec_id)
            oprot.writeFieldEnd()
        if self.content_files is not None:
            oprot.writeFieldBegin('content_files', TType.STRUCT, 4)
            self.content_files.write(oprot)
            oprot.writeFieldEnd()
        if self.catalog_snapshot_id is not None:
            oprot.writeFieldBegin('catalog_snapshot_id', TType.I64, 5)
            oprot.writeI64(self.catalog_snapshot_id)
            oprot.writeFieldEnd()
        if self.parquet_compression_codec is not None:
            oprot.writeFieldBegin('parquet_compression_codec', TType.STRUCT, 6)
            self.parquet_compression_codec.write(oprot)
            oprot.writeFieldEnd()
        if self.parquet_row_group_size is not None:
            oprot.writeFieldBegin('parquet_row_group_size', TType.I64, 7)
            oprot.writeI64(self.parquet_row_group_size)
            oprot.writeFieldEnd()
        if self.parquet_plain_page_size is not None:
            oprot.writeFieldBegin('parquet_plain_page_size', TType.I64, 8)
            oprot.writeI64(self.parquet_plain_page_size)
            oprot.writeFieldEnd()
        if self.parquet_dict_page_size is not None:
            oprot.writeFieldBegin('parquet_dict_page_size', TType.I64, 9)
            oprot.writeI64(self.parquet_dict_page_size)
            oprot.writeFieldEnd()
        if self.partition_stats is not None:
            oprot.writeFieldBegin('partition_stats', TType.MAP, 10)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.partition_stats))
            for kiter252, viter253 in self.partition_stats.items():
                oprot.writeString(kiter252)
                viter253.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_location is None:
            raise TProtocolException(message='Required field table_location is unset!')
        if self.partition_spec is None:
            raise TProtocolException(message='Required field partition_spec is unset!')
        if self.default_partition_spec_id is None:
            raise TProtocolException(message='Required field default_partition_spec_id is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TSystemTable(object):
    """
    Attributes:
     - table_name

    """


    def __init__(self, table_name=None,):
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.table_name = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TSystemTable')
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.I32, 1)
            oprot.writeI32(self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.table_name is None:
            raise TProtocolException(message='Required field table_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTable(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - load_status
     - access_level
     - columns
     - clustering_columns
     - virtual_columns
     - table_stats
     - table_type
     - hdfs_table
     - hbase_table
     - metastore_table
     - data_source_table
     - kudu_table
     - storage_metadata_load_time_ns
     - iceberg_table
     - tbl_comment
     - system_table

    """


    def __init__(self, db_name=None, tbl_name=None, load_status=None, access_level=None, columns=None, clustering_columns=None, virtual_columns=None, table_stats=None, table_type=None, hdfs_table=None, hbase_table=None, metastore_table=None, data_source_table=None, kudu_table=None, storage_metadata_load_time_ns=None, iceberg_table=None, tbl_comment=None, system_table=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.load_status = load_status
        self.access_level = access_level
        self.columns = columns
        self.clustering_columns = clustering_columns
        self.virtual_columns = virtual_columns
        self.table_stats = table_stats
        self.table_type = table_type
        self.hdfs_table = hdfs_table
        self.hbase_table = hbase_table
        self.metastore_table = metastore_table
        self.data_source_table = data_source_table
        self.kudu_table = kudu_table
        self.storage_metadata_load_time_ns = storage_metadata_load_time_ns
        self.iceberg_table = iceberg_table
        self.tbl_comment = tbl_comment
        self.system_table = system_table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.load_status = Status.ttypes.TStatus()
                    self.load_status.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.access_level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype257, _size254) = iprot.readListBegin()
                    for _i258 in range(_size254):
                        _elem259 = TColumn()
                        _elem259.read(iprot)
                        self.columns.append(_elem259)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.clustering_columns = []
                    (_etype263, _size260) = iprot.readListBegin()
                    for _i264 in range(_size260):
                        _elem265 = TColumn()
                        _elem265.read(iprot)
                        self.clustering_columns.append(_elem265)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.virtual_columns = []
                    (_etype269, _size266) = iprot.readListBegin()
                    for _i270 in range(_size266):
                        _elem271 = TColumn()
                        _elem271.read(iprot)
                        self.virtual_columns.append(_elem271)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.table_stats = TTableStats()
                    self.table_stats.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.table_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.hdfs_table = THdfsTable()
                    self.hdfs_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.hbase_table = THBaseTable()
                    self.hbase_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.metastore_table = hive_metastore.ttypes.Table()
                    self.metastore_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRUCT:
                    self.data_source_table = TDataSourceTable()
                    self.data_source_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRUCT:
                    self.kudu_table = TKuduTable()
                    self.kudu_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I64:
                    self.storage_metadata_load_time_ns = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.STRUCT:
                    self.iceberg_table = TIcebergTable()
                    self.iceberg_table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRING:
                    self.tbl_comment = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.STRUCT:
                    self.system_table = TSystemTable()
                    self.system_table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTable')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name)
            oprot.writeFieldEnd()
        if self.load_status is not None:
            oprot.writeFieldBegin('load_status', TType.STRUCT, 3)
            self.load_status.write(oprot)
            oprot.writeFieldEnd()
        if self.access_level is not None:
            oprot.writeFieldBegin('access_level', TType.I32, 4)
            oprot.writeI32(self.access_level)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter272 in self.columns:
                iter272.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.clustering_columns is not None:
            oprot.writeFieldBegin('clustering_columns', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.clustering_columns))
            for iter273 in self.clustering_columns:
                iter273.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.virtual_columns is not None:
            oprot.writeFieldBegin('virtual_columns', TType.LIST, 7)
            oprot.writeListBegin(TType.STRUCT, len(self.virtual_columns))
            for iter274 in self.virtual_columns:
                iter274.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.table_stats is not None:
            oprot.writeFieldBegin('table_stats', TType.STRUCT, 8)
            self.table_stats.write(oprot)
            oprot.writeFieldEnd()
        if self.table_type is not None:
            oprot.writeFieldBegin('table_type', TType.I32, 9)
            oprot.writeI32(self.table_type)
            oprot.writeFieldEnd()
        if self.hdfs_table is not None:
            oprot.writeFieldBegin('hdfs_table', TType.STRUCT, 10)
            self.hdfs_table.write(oprot)
            oprot.writeFieldEnd()
        if self.hbase_table is not None:
            oprot.writeFieldBegin('hbase_table', TType.STRUCT, 11)
            self.hbase_table.write(oprot)
            oprot.writeFieldEnd()
        if self.metastore_table is not None:
            oprot.writeFieldBegin('metastore_table', TType.STRUCT, 12)
            self.metastore_table.write(oprot)
            oprot.writeFieldEnd()
        if self.data_source_table is not None:
            oprot.writeFieldBegin('data_source_table', TType.STRUCT, 13)
            self.data_source_table.write(oprot)
            oprot.writeFieldEnd()
        if self.kudu_table is not None:
            oprot.writeFieldBegin('kudu_table', TType.STRUCT, 14)
            self.kudu_table.write(oprot)
            oprot.writeFieldEnd()
        if self.storage_metadata_load_time_ns is not None:
            oprot.writeFieldBegin('storage_metadata_load_time_ns', TType.I64, 16)
            oprot.writeI64(self.storage_metadata_load_time_ns)
            oprot.writeFieldEnd()
        if self.iceberg_table is not None:
            oprot.writeFieldBegin('iceberg_table', TType.STRUCT, 17)
            self.iceberg_table.write(oprot)
            oprot.writeFieldEnd()
        if self.tbl_comment is not None:
            oprot.writeFieldBegin('tbl_comment', TType.STRING, 18)
            oprot.writeString(self.tbl_comment)
            oprot.writeFieldEnd()
        if self.system_table is not None:
            oprot.writeFieldBegin('system_table', TType.STRUCT, 19)
            self.system_table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db_name is None:
            raise TProtocolException(message='Required field db_name is unset!')
        if self.tbl_name is None:
            raise TProtocolException(message='Required field tbl_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDatabase(object):
    """
    Attributes:
     - db_name
     - metastore_db

    """


    def __init__(self, db_name=None, metastore_db=None,):
        self.db_name = db_name
        self.metastore_db = metastore_db

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metastore_db = hive_metastore.ttypes.Database()
                    self.metastore_db.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDatabase')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name)
            oprot.writeFieldEnd()
        if self.metastore_db is not None:
            oprot.writeFieldBegin('metastore_db', TType.STRUCT, 2)
            self.metastore_db.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.db_name is None:
            raise TProtocolException(message='Required field db_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPrincipal(object):
    """
    Attributes:
     - principal_name
     - principal_id
     - principal_type
     - grant_groups

    """


    def __init__(self, principal_name=None, principal_id=None, principal_type=None, grant_groups=None,):
        self.principal_name = principal_name
        self.principal_id = principal_id
        self.principal_type = principal_type
        self.grant_groups = grant_groups

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.principal_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.grant_groups = []
                    (_etype278, _size275) = iprot.readListBegin()
                    for _i279 in range(_size275):
                        _elem280 = iprot.readString()
                        self.grant_groups.append(_elem280)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPrincipal')
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 1)
            oprot.writeString(self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_id is not None:
            oprot.writeFieldBegin('principal_id', TType.I32, 2)
            oprot.writeI32(self.principal_id)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 3)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.grant_groups is not None:
            oprot.writeFieldBegin('grant_groups', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.grant_groups))
            for iter281 in self.grant_groups:
                oprot.writeString(iter281)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.principal_name is None:
            raise TProtocolException(message='Required field principal_name is unset!')
        if self.principal_id is None:
            raise TProtocolException(message='Required field principal_id is unset!')
        if self.principal_type is None:
            raise TProtocolException(message='Required field principal_type is unset!')
        if self.grant_groups is None:
            raise TProtocolException(message='Required field grant_groups is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPrivilege(object):
    """
    Attributes:
     - privilege_level
     - scope
     - has_grant_opt
     - principal_id
     - principal_type
     - server_name
     - db_name
     - table_name
     - uri
     - create_time_ms
     - column_name
     - storage_type
     - storage_url
     - fn_name

    """


    def __init__(self, privilege_level=None, scope=None, has_grant_opt=None, principal_id=None, principal_type=None, server_name=None, db_name=None, table_name=None, uri=None, create_time_ms=None, column_name=None, storage_type=None, storage_url=None, fn_name=None,):
        self.privilege_level = privilege_level
        self.scope = scope
        self.has_grant_opt = has_grant_opt
        self.principal_id = principal_id
        self.principal_type = principal_type
        self.server_name = server_name
        self.db_name = db_name
        self.table_name = table_name
        self.uri = uri
        self.create_time_ms = create_time_ms
        self.column_name = column_name
        self.storage_type = storage_type
        self.storage_url = storage_url
        self.fn_name = fn_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 2:
                if ftype == TType.I32:
                    self.privilege_level = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.scope = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.has_grant_opt = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.principal_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.server_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRING:
                    self.uri = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I64:
                    self.create_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRING:
                    self.column_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.STRING:
                    self.storage_type = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.STRING:
                    self.storage_url = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.fn_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPrivilege')
        if self.privilege_level is not None:
            oprot.writeFieldBegin('privilege_level', TType.I32, 2)
            oprot.writeI32(self.privilege_level)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.I32, 3)
            oprot.writeI32(self.scope)
            oprot.writeFieldEnd()
        if self.has_grant_opt is not None:
            oprot.writeFieldBegin('has_grant_opt', TType.BOOL, 4)
            oprot.writeBool(self.has_grant_opt)
            oprot.writeFieldEnd()
        if self.principal_id is not None:
            oprot.writeFieldBegin('principal_id', TType.I32, 5)
            oprot.writeI32(self.principal_id)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 6)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.server_name is not None:
            oprot.writeFieldBegin('server_name', TType.STRING, 7)
            oprot.writeString(self.server_name)
            oprot.writeFieldEnd()
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 8)
            oprot.writeString(self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 9)
            oprot.writeString(self.table_name)
            oprot.writeFieldEnd()
        if self.uri is not None:
            oprot.writeFieldBegin('uri', TType.STRING, 10)
            oprot.writeString(self.uri)
            oprot.writeFieldEnd()
        if self.create_time_ms is not None:
            oprot.writeFieldBegin('create_time_ms', TType.I64, 11)
            oprot.writeI64(self.create_time_ms)
            oprot.writeFieldEnd()
        if self.column_name is not None:
            oprot.writeFieldBegin('column_name', TType.STRING, 12)
            oprot.writeString(self.column_name)
            oprot.writeFieldEnd()
        if self.storage_type is not None:
            oprot.writeFieldBegin('storage_type', TType.STRING, 13)
            oprot.writeString(self.storage_type)
            oprot.writeFieldEnd()
        if self.storage_url is not None:
            oprot.writeFieldBegin('storage_url', TType.STRING, 14)
            oprot.writeString(self.storage_url)
            oprot.writeFieldEnd()
        if self.fn_name is not None:
            oprot.writeFieldBegin('fn_name', TType.STRING, 15)
            oprot.writeString(self.fn_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.privilege_level is None:
            raise TProtocolException(message='Required field privilege_level is unset!')
        if self.scope is None:
            raise TProtocolException(message='Required field scope is unset!')
        if self.has_grant_opt is None:
            raise TProtocolException(message='Required field has_grant_opt is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THdfsCachePool(object):
    """
    Attributes:
     - pool_name

    """


    def __init__(self, pool_name=None,):
        self.pool_name = pool_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pool_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THdfsCachePool')
        if self.pool_name is not None:
            oprot.writeFieldBegin('pool_name', TType.STRING, 1)
            oprot.writeString(self.pool_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.pool_name is None:
            raise TProtocolException(message='Required field pool_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthzCacheInvalidation(object):
    """
    Attributes:
     - marker_name

    """


    def __init__(self, marker_name=None,):
        self.marker_name = marker_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.marker_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthzCacheInvalidation')
        if self.marker_name is not None:
            oprot.writeFieldBegin('marker_name', TType.STRING, 1)
            oprot.writeString(self.marker_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.marker_name is None:
            raise TProtocolException(message='Required field marker_name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalog(object):
    """
    Attributes:
     - catalog_service_id
     - last_reset_catalog_version

    """


    def __init__(self, catalog_service_id=None, last_reset_catalog_version=None,):
        self.catalog_service_id = catalog_service_id
        self.last_reset_catalog_version = last_reset_catalog_version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.catalog_service_id = Types.ttypes.TUniqueId()
                    self.catalog_service_id.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.last_reset_catalog_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalog')
        if self.catalog_service_id is not None:
            oprot.writeFieldBegin('catalog_service_id', TType.STRUCT, 1)
            self.catalog_service_id.write(oprot)
            oprot.writeFieldEnd()
        if self.last_reset_catalog_version is not None:
            oprot.writeFieldBegin('last_reset_catalog_version', TType.I64, 2)
            oprot.writeI64(self.last_reset_catalog_version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.catalog_service_id is None:
            raise TProtocolException(message='Required field catalog_service_id is unset!')
        if self.last_reset_catalog_version is None:
            raise TProtocolException(message='Required field last_reset_catalog_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCatalogObject(object):
    """
    Attributes:
     - type
     - catalog_version
     - catalog
     - db
     - table
     - fn
     - data_source
     - principal
     - privilege
     - cache_pool
     - authz_cache_invalidation
     - hdfs_partition
     - last_modified_time_ms

    """


    def __init__(self, type=None, catalog_version=None, catalog=None, db=None, table=None, fn=None, data_source=None, principal=None, privilege=None, cache_pool=None, authz_cache_invalidation=None, hdfs_partition=None, last_modified_time_ms=None,):
        self.type = type
        self.catalog_version = catalog_version
        self.catalog = catalog
        self.db = db
        self.table = table
        self.fn = fn
        self.data_source = data_source
        self.principal = principal
        self.privilege = privilege
        self.cache_pool = cache_pool
        self.authz_cache_invalidation = authz_cache_invalidation
        self.hdfs_partition = hdfs_partition
        self.last_modified_time_ms = last_modified_time_ms

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.catalog_version = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.catalog = TCatalog()
                    self.catalog.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.db = TDatabase()
                    self.db.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.table = TTable()
                    self.table.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.fn = Types.ttypes.TFunction()
                    self.fn.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.data_source = TDataSource()
                    self.data_source.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.principal = TPrincipal()
                    self.principal.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.privilege = TPrivilege()
                    self.privilege.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.cache_pool = THdfsCachePool()
                    self.cache_pool.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.authz_cache_invalidation = TAuthzCacheInvalidation()
                    self.authz_cache_invalidation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.STRUCT:
                    self.hdfs_partition = THdfsPartition()
                    self.hdfs_partition.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I64:
                    self.last_modified_time_ms = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCatalogObject')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.catalog_version is not None:
            oprot.writeFieldBegin('catalog_version', TType.I64, 2)
            oprot.writeI64(self.catalog_version)
            oprot.writeFieldEnd()
        if self.catalog is not None:
            oprot.writeFieldBegin('catalog', TType.STRUCT, 3)
            self.catalog.write(oprot)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRUCT, 4)
            self.db.write(oprot)
            oprot.writeFieldEnd()
        if self.table is not None:
            oprot.writeFieldBegin('table', TType.STRUCT, 5)
            self.table.write(oprot)
            oprot.writeFieldEnd()
        if self.fn is not None:
            oprot.writeFieldBegin('fn', TType.STRUCT, 6)
            self.fn.write(oprot)
            oprot.writeFieldEnd()
        if self.data_source is not None:
            oprot.writeFieldBegin('data_source', TType.STRUCT, 7)
            self.data_source.write(oprot)
            oprot.writeFieldEnd()
        if self.principal is not None:
            oprot.writeFieldBegin('principal', TType.STRUCT, 8)
            self.principal.write(oprot)
            oprot.writeFieldEnd()
        if self.privilege is not None:
            oprot.writeFieldBegin('privilege', TType.STRUCT, 9)
            self.privilege.write(oprot)
            oprot.writeFieldEnd()
        if self.cache_pool is not None:
            oprot.writeFieldBegin('cache_pool', TType.STRUCT, 10)
            self.cache_pool.write(oprot)
            oprot.writeFieldEnd()
        if self.authz_cache_invalidation is not None:
            oprot.writeFieldBegin('authz_cache_invalidation', TType.STRUCT, 11)
            self.authz_cache_invalidation.write(oprot)
            oprot.writeFieldEnd()
        if self.hdfs_partition is not None:
            oprot.writeFieldBegin('hdfs_partition', TType.STRUCT, 12)
            self.hdfs_partition.write(oprot)
            oprot.writeFieldEnd()
        if self.last_modified_time_ms is not None:
            oprot.writeFieldBegin('last_modified_time_ms', TType.I64, 13)
            oprot.writeI64(self.last_modified_time_ms)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.type is None:
            raise TProtocolException(message='Required field type is unset!')
        if self.catalog_version is None:
            raise TProtocolException(message='Required field catalog_version is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TCompressionCodec)
TCompressionCodec.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'codec', None, None, ),  # 1
    (2, TType.I32, 'compression_level', None, None, ),  # 2
)
all_structs.append(TPartitionKeyValue)
TPartitionKeyValue.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', None, None, ),  # 1
    (2, TType.STRING, 'value', None, None, ),  # 2
)
all_structs.append(TTableName)
TTableName.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', None, None, ),  # 1
    (2, TType.STRING, 'table_name', None, None, ),  # 2
)
all_structs.append(TTableStats)
TTableStats.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'num_rows', None, None, ),  # 1
    (2, TType.I64, 'total_file_bytes', None, None, ),  # 2
)
all_structs.append(TBucketInfo)
TBucketInfo.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'bucket_type', None, None, ),  # 1
    (2, TType.LIST, 'bucket_columns', (TType.STRING, None, False), None, ),  # 2
    (3, TType.I32, 'num_bucket', None, None, ),  # 3
)
all_structs.append(TColumnStats)
TColumnStats.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'avg_size', None, None, ),  # 1
    (2, TType.I64, 'max_size', None, None, ),  # 2
    (3, TType.I64, 'num_distinct_values', None, None, ),  # 3
    (4, TType.I64, 'num_nulls', None, None, ),  # 4
    (5, TType.I64, 'num_trues', None, None, ),  # 5
    (6, TType.I64, 'num_falses', None, None, ),  # 6
    (7, TType.STRUCT, 'low_value', [Data.ttypes.TColumnValue, None], None, ),  # 7
    (8, TType.STRUCT, 'high_value', [Data.ttypes.TColumnValue, None], None, ),  # 8
)
all_structs.append(TIntermediateColumnStats)
TIntermediateColumnStats.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'intermediate_ndv', 'BINARY', None, ),  # 1
    (2, TType.BOOL, 'is_ndv_encoded', None, None, ),  # 2
    (3, TType.I64, 'num_nulls', None, None, ),  # 3
    (4, TType.I32, 'max_width', None, None, ),  # 4
    (5, TType.DOUBLE, 'avg_width', None, None, ),  # 5
    (6, TType.I64, 'num_rows', None, None, ),  # 6
    (7, TType.I64, 'num_trues', None, None, ),  # 7
    (8, TType.I64, 'num_falses', None, None, ),  # 8
    (9, TType.STRUCT, 'low_value', [Data.ttypes.TColumnValue, None], None, ),  # 9
    (10, TType.STRUCT, 'high_value', [Data.ttypes.TColumnValue, None], None, ),  # 10
)
all_structs.append(TPartitionStats)
TPartitionStats.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'stats', [TTableStats, None], None, ),  # 1
    (2, TType.MAP, 'intermediate_col_stats', (TType.STRING, None, TType.STRUCT, [TIntermediateColumnStats, None], False), None, ),  # 2
)
all_structs.append(TColumn)
TColumn.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'columnName', None, None, ),  # 1
    (2, TType.STRUCT, 'columnType', [Types.ttypes.TColumnType, None], None, ),  # 2
    (3, TType.STRING, 'comment', None, None, ),  # 3
    (4, TType.STRUCT, 'col_stats', [TColumnStats, None], None, ),  # 4
    (5, TType.I32, 'position', None, None, ),  # 5
    (6, TType.I32, 'virtual_column_type', None, 0, ),  # 6
    (7, TType.BOOL, 'is_hidden', None, None, ),  # 7
    (8, TType.BOOL, 'is_hbase_column', None, None, ),  # 8
    (9, TType.STRING, 'column_family', None, None, ),  # 9
    (10, TType.STRING, 'column_qualifier', None, None, ),  # 10
    (11, TType.BOOL, 'is_binary', None, None, ),  # 11
    (12, TType.BOOL, 'is_kudu_column', None, None, ),  # 12
    (13, TType.BOOL, 'is_key', None, None, ),  # 13
    (14, TType.BOOL, 'is_nullable', None, None, ),  # 14
    (15, TType.I32, 'encoding', None, None, ),  # 15
    (16, TType.I32, 'compression', None, None, ),  # 16
    (17, TType.STRUCT, 'default_value', [Exprs.ttypes.TExpr, None], None, ),  # 17
    (18, TType.I32, 'block_size', None, None, ),  # 18
    (19, TType.STRING, 'kudu_column_name', None, None, ),  # 19
    (20, TType.BOOL, 'is_iceberg_column', None, None, ),  # 20
    (21, TType.I32, 'iceberg_field_id', None, None, ),  # 21
    (22, TType.I32, 'iceberg_field_map_key_id', None, None, ),  # 22
    (23, TType.I32, 'iceberg_field_map_value_id', None, None, ),  # 23
    (24, TType.BOOL, 'is_primary_key_unique', None, None, ),  # 24
    (25, TType.BOOL, 'is_auto_incrementing', None, None, ),  # 25
)
all_structs.append(THdfsFileDesc)
THdfsFileDesc.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'file_desc_data', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'file_metadata', 'BINARY', None, ),  # 2
)
all_structs.append(THdfsPartitionLocation)
THdfsPartitionLocation.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'prefix_index', None, -1, ),  # 1
    (2, TType.STRING, 'suffix', None, None, ),  # 2
)
all_structs.append(THdfsStorageDescriptor)
THdfsStorageDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'lineDelim', None, None, ),  # 1
    (2, TType.BYTE, 'fieldDelim', None, None, ),  # 2
    (3, TType.BYTE, 'collectionDelim', None, None, ),  # 3
    (4, TType.BYTE, 'mapKeyDelim', None, None, ),  # 4
    (5, TType.BYTE, 'escapeChar', None, None, ),  # 5
    (6, TType.BYTE, 'quoteChar', None, None, ),  # 6
    (7, TType.I32, 'fileFormat', None, None, ),  # 7
    (8, TType.I32, 'blockSize', None, None, ),  # 8
)
all_structs.append(THdfsPartition)
THdfsPartition.thrift_spec = (
    None,  # 0
    None,  # 1
    None,  # 2
    None,  # 3
    None,  # 4
    None,  # 5
    None,  # 6
    (7, TType.LIST, 'partitionKeyExprs', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 7
    None,  # 8
    (9, TType.LIST, 'file_desc', (TType.STRUCT, [THdfsFileDesc, None], False), None, ),  # 9
    (10, TType.STRUCT, 'location', [THdfsPartitionLocation, None], None, ),  # 10
    (11, TType.I32, 'access_level', None, None, ),  # 11
    (12, TType.STRUCT, 'stats', [TTableStats, None], None, ),  # 12
    (13, TType.BOOL, 'is_marked_cached', None, None, ),  # 13
    (14, TType.I64, 'id', None, None, ),  # 14
    (15, TType.MAP, 'hms_parameters', (TType.STRING, None, TType.STRING, None, False), None, ),  # 15
    (16, TType.I64, 'num_blocks', None, None, ),  # 16
    (17, TType.I64, 'total_file_size_bytes', None, None, ),  # 17
    (18, TType.STRING, 'partition_stats', 'BINARY', None, ),  # 18
    (19, TType.BOOL, 'has_incremental_stats', None, None, ),  # 19
    (20, TType.I64, 'write_id', None, None, ),  # 20
    (21, TType.LIST, 'insert_file_desc', (TType.STRUCT, [THdfsFileDesc, None], False), None, ),  # 21
    (22, TType.LIST, 'delete_file_desc', (TType.STRUCT, [THdfsFileDesc, None], False), None, ),  # 22
    (23, TType.STRING, 'db_name', None, None, ),  # 23
    (24, TType.STRING, 'tbl_name', None, None, ),  # 24
    (25, TType.STRING, 'partition_name', None, None, ),  # 25
    (26, TType.I64, 'prev_id', None, -1, ),  # 26
    (27, TType.STRUCT, 'hdfs_storage_descriptor', [THdfsStorageDescriptor, None], None, ),  # 27
)
all_structs.append(TValidWriteIdList)
TValidWriteIdList.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'high_watermark', None, None, ),  # 1
    (2, TType.I64, 'min_open_write_id', None, None, ),  # 2
    (3, TType.LIST, 'invalid_write_ids', (TType.I64, None, False), None, ),  # 3
    (4, TType.LIST, 'aborted_indexes', (TType.I32, None, False), None, ),  # 4
)
all_structs.append(THdfsTable)
THdfsTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hdfsBaseDir', None, None, ),  # 1
    (2, TType.LIST, 'colNames', (TType.STRING, None, False), None, ),  # 2
    (3, TType.STRING, 'nullPartitionKeyValue', None, None, ),  # 3
    (4, TType.MAP, 'partitions', (TType.I64, None, TType.STRUCT, [THdfsPartition, None], False), None, ),  # 4
    (5, TType.STRING, 'nullColumnValue', None, None, ),  # 5
    (6, TType.STRING, 'avroSchema', None, None, ),  # 6
    (7, TType.LIST, 'network_addresses', (TType.STRUCT, [Types.ttypes.TNetworkAddress, None], False), None, ),  # 7
    None,  # 8
    (9, TType.LIST, 'partition_prefixes', (TType.STRING, None, False), None, ),  # 9
    (10, TType.STRUCT, 'prototype_partition', [THdfsPartition, None], None, ),  # 10
    (11, TType.STRUCT, 'sql_constraints', [SqlConstraints.ttypes.TSqlConstraints, None], None, ),  # 11
    (12, TType.BOOL, 'is_full_acid', None, False, ),  # 12
    (13, TType.STRUCT, 'valid_write_ids', [TValidWriteIdList, None], None, ),  # 13
    (14, TType.BOOL, 'has_full_partitions', None, None, ),  # 14
    (15, TType.BOOL, 'has_partition_names', None, None, ),  # 15
    (16, TType.STRUCT, 'bucket_info', [TBucketInfo, None], None, ),  # 16
    (17, TType.LIST, 'dropped_partitions', (TType.STRUCT, [THdfsPartition, None], False), None, ),  # 17
)
all_structs.append(THBaseTable)
THBaseTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', None, None, ),  # 1
    (2, TType.LIST, 'families', (TType.STRING, None, False), None, ),  # 2
    (3, TType.LIST, 'qualifiers', (TType.STRING, None, False), None, ),  # 3
    (4, TType.LIST, 'binary_encoded', (TType.BOOL, None, False), None, ),  # 4
)
all_structs.append(TDataSource)
TDataSource.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', None, None, ),  # 1
    (2, TType.STRING, 'hdfs_location', None, None, ),  # 2
    (3, TType.STRING, 'class_name', None, None, ),  # 3
    (4, TType.STRING, 'api_version', None, None, ),  # 4
)
all_structs.append(TDataSourceTable)
TDataSourceTable.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'data_source', [TDataSource, None], None, ),  # 1
    (2, TType.STRING, 'init_string', None, None, ),  # 2
)
all_structs.append(TKuduPartitionByHashParam)
TKuduPartitionByHashParam.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRING, None, False), None, ),  # 1
    (2, TType.I32, 'num_partitions', None, None, ),  # 2
)
all_structs.append(TRangePartition)
TRangePartition.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'lower_bound_values', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 1
    (2, TType.BOOL, 'is_lower_bound_inclusive', None, None, ),  # 2
    (3, TType.LIST, 'upper_bound_values', (TType.STRUCT, [Exprs.ttypes.TExpr, None], False), None, ),  # 3
    (4, TType.BOOL, 'is_upper_bound_inclusive', None, None, ),  # 4
    (5, TType.LIST, 'hash_specs', (TType.STRUCT, [TKuduPartitionParam, None], False), None, ),  # 5
)
all_structs.append(TKuduPartitionByRangeParam)
TKuduPartitionByRangeParam.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns', (TType.STRING, None, False), None, ),  # 1
    (2, TType.LIST, 'range_partitions', (TType.STRUCT, [TRangePartition, None], False), None, ),  # 2
)
all_structs.append(TKuduPartitionParam)
TKuduPartitionParam.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'by_hash_param', [TKuduPartitionByHashParam, None], None, ),  # 1
    (2, TType.STRUCT, 'by_range_param', [TKuduPartitionByRangeParam, None], None, ),  # 2
)
all_structs.append(TKuduTable)
TKuduTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table_name', None, None, ),  # 1
    (2, TType.LIST, 'master_addresses', (TType.STRING, None, False), None, ),  # 2
    (3, TType.LIST, 'key_columns', (TType.STRING, None, False), None, ),  # 3
    (4, TType.LIST, 'partition_by', (TType.STRUCT, [TKuduPartitionParam, None], False), None, ),  # 4
    (5, TType.BOOL, 'is_primary_key_unique', None, None, ),  # 5
    (6, TType.BOOL, 'has_auto_incrementing', None, None, ),  # 6
)
all_structs.append(TIcebergPartitionTransform)
TIcebergPartitionTransform.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'transform_type', None, None, ),  # 1
    (2, TType.I32, 'transform_param', None, None, ),  # 2
)
all_structs.append(TIcebergPartitionField)
TIcebergPartitionField.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'source_id', None, None, ),  # 1
    (2, TType.I32, 'field_id', None, None, ),  # 2
    (3, TType.STRING, 'orig_field_name', None, None, ),  # 3
    (4, TType.STRING, 'field_name', None, None, ),  # 4
    (5, TType.STRUCT, 'transform', [TIcebergPartitionTransform, None], None, ),  # 5
    (6, TType.STRUCT, 'type', [Types.ttypes.TScalarType, None], None, ),  # 6
)
all_structs.append(TIcebergPartitionSpec)
TIcebergPartitionSpec.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'spec_id', None, None, ),  # 1
    (2, TType.LIST, 'partition_fields', (TType.STRUCT, [TIcebergPartitionField, None], False), None, ),  # 2
)
all_structs.append(TIcebergPartitionStats)
TIcebergPartitionStats.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'num_files', None, None, ),  # 1
    (2, TType.I64, 'num_rows', None, None, ),  # 2
    (3, TType.I64, 'file_size_in_bytes', None, None, ),  # 3
)
all_structs.append(TIcebergContentFileStore)
TIcebergContentFileStore.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'path_hash_to_data_file_without_deletes', (TType.STRING, None, TType.STRUCT, [THdfsFileDesc, None], False), None, ),  # 1
    (2, TType.MAP, 'path_hash_to_data_file_with_deletes', (TType.STRING, None, TType.STRUCT, [THdfsFileDesc, None], False), None, ),  # 2
    (3, TType.MAP, 'path_hash_to_position_delete_file', (TType.STRING, None, TType.STRUCT, [THdfsFileDesc, None], False), None, ),  # 3
    (4, TType.MAP, 'path_hash_to_equality_delete_file', (TType.STRING, None, TType.STRUCT, [THdfsFileDesc, None], False), None, ),  # 4
    (5, TType.BOOL, 'has_avro', None, None, ),  # 5
    (6, TType.BOOL, 'has_orc', None, None, ),  # 6
    (7, TType.BOOL, 'has_parquet', None, None, ),  # 7
)
all_structs.append(TIcebergDropPartitionRequest)
TIcebergDropPartitionRequest.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'paths', (TType.STRING, None, False), None, ),  # 1
    (2, TType.BOOL, 'is_truncate', None, None, ),  # 2
    (3, TType.I64, 'num_partitions', None, None, ),  # 3
)
all_structs.append(TIcebergTable)
TIcebergTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'table_location', None, None, ),  # 1
    (2, TType.LIST, 'partition_spec', (TType.STRUCT, [TIcebergPartitionSpec, None], False), None, ),  # 2
    (3, TType.I32, 'default_partition_spec_id', None, None, ),  # 3
    (4, TType.STRUCT, 'content_files', [TIcebergContentFileStore, None], None, ),  # 4
    (5, TType.I64, 'catalog_snapshot_id', None, None, ),  # 5
    (6, TType.STRUCT, 'parquet_compression_codec', [TCompressionCodec, None], None, ),  # 6
    (7, TType.I64, 'parquet_row_group_size', None, None, ),  # 7
    (8, TType.I64, 'parquet_plain_page_size', None, None, ),  # 8
    (9, TType.I64, 'parquet_dict_page_size', None, None, ),  # 9
    (10, TType.MAP, 'partition_stats', (TType.STRING, None, TType.STRUCT, [TIcebergPartitionStats, None], False), None, ),  # 10
)
all_structs.append(TSystemTable)
TSystemTable.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'table_name', None, None, ),  # 1
)
all_structs.append(TTable)
TTable.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', None, None, ),  # 1
    (2, TType.STRING, 'tbl_name', None, None, ),  # 2
    (3, TType.STRUCT, 'load_status', [Status.ttypes.TStatus, None], None, ),  # 3
    (4, TType.I32, 'access_level', None, None, ),  # 4
    (5, TType.LIST, 'columns', (TType.STRUCT, [TColumn, None], False), None, ),  # 5
    (6, TType.LIST, 'clustering_columns', (TType.STRUCT, [TColumn, None], False), None, ),  # 6
    (7, TType.LIST, 'virtual_columns', (TType.STRUCT, [TColumn, None], False), None, ),  # 7
    (8, TType.STRUCT, 'table_stats', [TTableStats, None], None, ),  # 8
    (9, TType.I32, 'table_type', None, None, ),  # 9
    (10, TType.STRUCT, 'hdfs_table', [THdfsTable, None], None, ),  # 10
    (11, TType.STRUCT, 'hbase_table', [THBaseTable, None], None, ),  # 11
    (12, TType.STRUCT, 'metastore_table', [hive_metastore.ttypes.Table, None], None, ),  # 12
    (13, TType.STRUCT, 'data_source_table', [TDataSourceTable, None], None, ),  # 13
    (14, TType.STRUCT, 'kudu_table', [TKuduTable, None], None, ),  # 14
    None,  # 15
    (16, TType.I64, 'storage_metadata_load_time_ns', None, None, ),  # 16
    (17, TType.STRUCT, 'iceberg_table', [TIcebergTable, None], None, ),  # 17
    (18, TType.STRING, 'tbl_comment', None, None, ),  # 18
    (19, TType.STRUCT, 'system_table', [TSystemTable, None], None, ),  # 19
)
all_structs.append(TDatabase)
TDatabase.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'db_name', None, None, ),  # 1
    (2, TType.STRUCT, 'metastore_db', [hive_metastore.ttypes.Database, None], None, ),  # 2
)
all_structs.append(TPrincipal)
TPrincipal.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'principal_name', None, None, ),  # 1
    (2, TType.I32, 'principal_id', None, None, ),  # 2
    (3, TType.I32, 'principal_type', None, None, ),  # 3
    (4, TType.LIST, 'grant_groups', (TType.STRING, None, False), None, ),  # 4
)
all_structs.append(TPrivilege)
TPrivilege.thrift_spec = (
    None,  # 0
    None,  # 1
    (2, TType.I32, 'privilege_level', None, None, ),  # 2
    (3, TType.I32, 'scope', None, None, ),  # 3
    (4, TType.BOOL, 'has_grant_opt', None, None, ),  # 4
    (5, TType.I32, 'principal_id', None, None, ),  # 5
    (6, TType.I32, 'principal_type', None, None, ),  # 6
    (7, TType.STRING, 'server_name', None, None, ),  # 7
    (8, TType.STRING, 'db_name', None, None, ),  # 8
    (9, TType.STRING, 'table_name', None, None, ),  # 9
    (10, TType.STRING, 'uri', None, None, ),  # 10
    (11, TType.I64, 'create_time_ms', None, None, ),  # 11
    (12, TType.STRING, 'column_name', None, None, ),  # 12
    (13, TType.STRING, 'storage_type', None, None, ),  # 13
    (14, TType.STRING, 'storage_url', None, None, ),  # 14
    (15, TType.STRING, 'fn_name', None, None, ),  # 15
)
all_structs.append(THdfsCachePool)
THdfsCachePool.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'pool_name', None, None, ),  # 1
)
all_structs.append(TAuthzCacheInvalidation)
TAuthzCacheInvalidation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'marker_name', None, None, ),  # 1
)
all_structs.append(TCatalog)
TCatalog.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'catalog_service_id', [Types.ttypes.TUniqueId, None], None, ),  # 1
    (2, TType.I64, 'last_reset_catalog_version', None, None, ),  # 2
)
all_structs.append(TCatalogObject)
TCatalogObject.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'type', None, None, ),  # 1
    (2, TType.I64, 'catalog_version', None, None, ),  # 2
    (3, TType.STRUCT, 'catalog', [TCatalog, None], None, ),  # 3
    (4, TType.STRUCT, 'db', [TDatabase, None], None, ),  # 4
    (5, TType.STRUCT, 'table', [TTable, None], None, ),  # 5
    (6, TType.STRUCT, 'fn', [Types.ttypes.TFunction, None], None, ),  # 6
    (7, TType.STRUCT, 'data_source', [TDataSource, None], None, ),  # 7
    (8, TType.STRUCT, 'principal', [TPrincipal, None], None, ),  # 8
    (9, TType.STRUCT, 'privilege', [TPrivilege, None], None, ),  # 9
    (10, TType.STRUCT, 'cache_pool', [THdfsCachePool, None], None, ),  # 10
    (11, TType.STRUCT, 'authz_cache_invalidation', [TAuthzCacheInvalidation, None], None, ),  # 11
    (12, TType.STRUCT, 'hdfs_partition', [THdfsPartition, None], None, ),  # 12
    (13, TType.I64, 'last_modified_time_ms', None, None, ),  # 13
)
fix_spec(all_structs)
del all_structs
