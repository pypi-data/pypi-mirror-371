#!/usr/bin/env python
# -*- coding:utf-8 -*-
from collections.abc import Callable
from functools import wraps
from typing import Union, Any

from ._hooks_handler import _build, _run
from ..generic import T

_ExceptionTypes = Union[type[Exception], tuple[type[Exception]], None]


def capture(exception: _ExceptionTypes = BaseException, post: Callable = None) -> T:
    """
    Catch exceptions to decorated functions, including exceptions generated by other decorators.

    callback functions can and only support communication via the chain keyword parameter. example: callback() is ok,
    callback(chain=None) is ok, callback(chain=None, other=None) is ok(other arg will not be assigned), callback(other, chain=None) will happend exception

    :param post while callback function when happen exception
    :param exception: The base type exception to the exception that needs to be caught. After capture,
                    the exception will be "eaten" directly, and exception outside this range will be thrown.
    """

    def _inner(func):
        @wraps(func)
        def _wrapper(*args, **kwargs):
            return __do_capture(func, args, kwargs, exception, post)

        return _wrapper

    return _inner


def __do_capture(func: Callable, args: tuple, kwargs: dict, exception: _ExceptionTypes = BaseException,
                 post: Callable = None) -> Any:
    post_argument_map = _build(func, args, kwargs, post)
    try:
        return func(*args, **kwargs)
    except BaseException as e:
        if issubclass(type(exception), list):
            e_type = type(e)
            for e_ in exception:
                if not issubclass(e_type, e_):
                    raise
        else:
            if not issubclass(type(e), exception):
                raise
    finally:
        _run(post_argument_map)


__all__ = []
